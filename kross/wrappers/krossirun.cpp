//This is file has been generated by xmltokross, you should not edit this file but the files used to generate it.

#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <kross/core/manager.h>
#include <kross/core/wrapperinterface.h>
#include <interfaces/irun.h>

class KrossKDevelopIRun : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	public:
		KrossKDevelopIRun(KDevelop::IRun* obj, QObject* parent=0) : QObject(parent), wrapped(obj)		{ setObjectName("KDevelop::IRun"); }
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE KDevelop::IRun operator=(const KDevelop::IRun& x0) { return wrapped->operator=(x0); }
		Q_SCRIPTABLE KUrl executable() const { return wrapped->executable(); }
		Q_SCRIPTABLE void setExecutable(const QString& x0) { wrapped->setExecutable(x0); }
		Q_SCRIPTABLE KUrl workingDirectory() const { return wrapped->workingDirectory(); }
		Q_SCRIPTABLE void setWorkingDirectory(const QString& x0) { wrapped->setWorkingDirectory(x0); }
		Q_SCRIPTABLE QString environmentKey() const { return wrapped->environmentKey(); }
		Q_SCRIPTABLE void setEnvironmentKey(const QString& x0) { wrapped->setEnvironmentKey(x0); }
		Q_SCRIPTABLE QStringList arguments() const { return wrapped->arguments(); }
		Q_SCRIPTABLE void addArgument(const QString& x0) { wrapped->addArgument(x0); }
		Q_SCRIPTABLE void setArguments(const QStringList& x0) { wrapped->setArguments(x0); }
		Q_SCRIPTABLE void clearArguments() { wrapped->clearArguments(); }
		Q_SCRIPTABLE QString instrumentor() const { return wrapped->instrumentor(); }
		Q_SCRIPTABLE void setInstrumentor(const QString& x0) { wrapped->setInstrumentor(x0); }
		Q_SCRIPTABLE QStringList instrumentorArguments() const { return wrapped->instrumentorArguments(); }
		Q_SCRIPTABLE void addInstrumentorArgument(const QString& x0) { wrapped->addInstrumentorArgument(x0); }
		Q_SCRIPTABLE void setInstrumentorArguments(const QStringList& x0) { wrapped->setInstrumentorArguments(x0); }
		Q_SCRIPTABLE void clearInstrumentorArguments() { wrapped->clearInstrumentorArguments(); }
		Q_SCRIPTABLE void setCompilationDependencies(const QList< KDevelop::ProjectBaseItem* >& x0) { wrapped->setCompilationDependencies(x0); }
		Q_SCRIPTABLE void clearCompilationDependencies() { wrapped->clearCompilationDependencies(); }
		Q_SCRIPTABLE QList< KDevelop::ProjectBaseItem* > compilationDependencies() const { return wrapped->compilationDependencies(); }
	private:
		KDevelop::IRun* wrapped;
};

bool krossirun_registerHandler(const QByteArray& name, Kross::MetaTypeHandler::FunctionPtr* handler)
{ Kross::Manager::self().registerMetaTypeHandler(name, handler); return false; }

namespace Handlers
{
QVariant _kDevelopIRunHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::IRun* t=static_cast<KDevelop::IRun*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::IRun*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopIRun(t, 0));
}
bool b_KDevelopIRun=krossirun_registerHandler("KDevelop::IRun*", _kDevelopIRunHandler);
QVariant kDevelopIRunHandler(KDevelop::IRun* type){ return _kDevelopIRunHandler(type); }
QVariant kDevelopIRunHandler(const KDevelop::IRun* type) { return _kDevelopIRunHandler((void*) type); }

}
#include "krossirun.moc"
