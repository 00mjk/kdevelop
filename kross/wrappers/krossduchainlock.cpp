//This is file has been generated by xmltokross, you should not edit this file but the files used to generate it.

#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <kross/core/manager.h>
#include <kross/core/wrapperinterface.h>
#include <language/duchain/duchainlock.h>

class KrossKDevelopDUChainLock : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	public:
		KrossKDevelopDUChainLock(KDevelop::DUChainLock* obj, QObject* parent=0) : QObject(parent), wrapped(obj) {}
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE bool lockForRead(unsigned int x0) { return wrapped->lockForRead(x0); }
		Q_SCRIPTABLE bool lockForRead() { return wrapped->lockForRead(); }
		Q_SCRIPTABLE void releaseReadLock() { wrapped->releaseReadLock(); }
		Q_SCRIPTABLE bool currentThreadHasReadLock() { return wrapped->currentThreadHasReadLock(); }
		Q_SCRIPTABLE bool lockForWrite(int x0=0) { return wrapped->lockForWrite(x0); }
		Q_SCRIPTABLE void releaseWriteLock() { wrapped->releaseWriteLock(); }
		Q_SCRIPTABLE bool currentThreadHasWriteLock() { return wrapped->currentThreadHasWriteLock(); }
	private:
		KDevelop::DUChainLock* wrapped;
};

class KrossKDevelopDUChainReadLocker : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	public:
		KrossKDevelopDUChainReadLocker(KDevelop::DUChainReadLocker* obj, QObject* parent=0) : QObject(parent), wrapped(obj) {}
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE bool lock() { return wrapped->lock(); }
		Q_SCRIPTABLE void unlock() { wrapped->unlock(); }
		Q_SCRIPTABLE bool locked() const { return wrapped->locked(); }
	private:
		KDevelop::DUChainReadLocker* wrapped;
};

class KrossKDevelopDUChainWriteLocker : public QObject, public Kross::WrapperInterface
{
	Q_OBJECT
	public:
		KrossKDevelopDUChainWriteLocker(KDevelop::DUChainWriteLocker* obj, QObject* parent=0) : QObject(parent), wrapped(obj) {}
		void* wrappedObject() const { return wrapped; }

		Q_SCRIPTABLE bool lock() { return wrapped->lock(); }
		Q_SCRIPTABLE void unlock() { wrapped->unlock(); }
		Q_SCRIPTABLE bool locked() const { return wrapped->locked(); }
	private:
		KDevelop::DUChainWriteLocker* wrapped;
};

bool krossduchainlock_registerHandler(const QByteArray& name, Kross::MetaTypeHandler::FunctionPtr* handler)
{ Kross::Manager::self().registerMetaTypeHandler(name, handler); return false; }

namespace Handlers
{
QVariant _kDevelopDUChainLockHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::DUChainLock* t=static_cast<KDevelop::DUChainLock*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::DUChainLock*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopDUChainLock(t, 0));
}
bool b_KDevelopDUChainLock=krossduchainlock_registerHandler("KDevelop::DUChainLock*", _kDevelopDUChainLockHandler);

QVariant _kDevelopDUChainReadLockerHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::DUChainReadLocker* t=static_cast<KDevelop::DUChainReadLocker*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::DUChainReadLocker*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopDUChainReadLocker(t, 0));
}
bool b_KDevelopDUChainReadLocker=krossduchainlock_registerHandler("KDevelop::DUChainReadLocker*", _kDevelopDUChainReadLockerHandler);

QVariant _kDevelopDUChainWriteLockerHandler(void* type)
{
	if(!type) return QVariant();
	KDevelop::DUChainWriteLocker* t=static_cast<KDevelop::DUChainWriteLocker*>(type);
	Q_ASSERT(dynamic_cast<KDevelop::DUChainWriteLocker*>(t));
	return qVariantFromValue((QObject*) new KrossKDevelopDUChainWriteLocker(t, 0));
}
bool b_KDevelopDUChainWriteLocker=krossduchainlock_registerHandler("KDevelop::DUChainWriteLocker*", _kDevelopDUChainWriteLockerHandler);

}
#include "krossduchainlock.moc"
