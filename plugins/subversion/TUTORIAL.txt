The code length of subversion plugin seems to be very long, but it's just because
there are many kind of actions in subversion. If we separate and investigate
one action, the architecture is simple.

We will take "svn blame(annotate)" operation as an example, in sequencial way.

1. User invoked action via menubar or context-menu.

Associated slot is called and execution is redirected into
KDevSubversionPart::annotate( const KUrl &path_or_url ). Here,
dialogbox is invoked to fetch options from user. Then
SubversionCore::spawnBlameThread() is called. spawnXXXXXThread() functions
are call-and-forget functions. The caller doesn't need to connect any
signals to display results or notification. These are done via "KDevSubversionView".

2. Inside SubversionCore::spawnBlameThread()

Here SvnKJobBase and SvnBlameJob is created. SvnKJobBase is KJob. Unlike the
name suggests, SvnBlameJob is SubversionThread (QThread). KJob is parent
of QThread, and SubversionCore is parent of KJob. Also we associate KJob
and QThread each other via SvnKJob::setSvnThread().
Before starting the job, jobFinished() signal is connected to core.
When SvnKJobBase::start() called, its associated SubversionThread is called.

3. At the constructor of SubversionThread.

--- memory pool
After setting some properties you will see svn_pool_create(). This allocates
new memory pool.
What is memory pool? In point of user, it consolidates each individual memory
allocation/deletion into one operation. Without memory pool, you should delete
memory 35 times to delete 35 different string. What is worse, you should keep
track of 35 char* pointer. But if we allocate these into one pool, you need
just delete one pool with svn_pool_destroy().

--- setting up callback funtions and batons.
When SVN API wants to let you know something, each callback funtions are called.
For example, when notification message is available, it calls function specified
by svn_client_ctx_t::notify_func2. These callbacks have its own argument, so
client can receive information via arguments.
There are other memer named "baton". It is void* pointer passed with callback.

--- setting up authentication providers.
There we again install callbacks and its baton.

4. At the constructor of SvnBlameJob

Here we store some optional data, such as url, revision etc.

5. At the SvnBlameJob::run()

This is nothing but to call svn_client_blame() and prepare its arguments.

One thing to note is lifecyle of allocated memory pool. In case of blame,
memory is freed after run() returns, but other operations such as diff/info
memory is freed within the destructor of class. This is because in the slot
connected to finished() signal, we should use these variables.

6. At the svn_client_blame() and its callback funtions.

This is SVN C-API. It contacts repository and fetches data.

If id/pwd is not cached on disk, svn_client_*() functions invokes callback
functions specified by authentication providers (which were described earler).
Remember that at the contructor of SubversionThread, we specified
SubversionThread::displayLoginDialog(). At the return time of this callback.
svn_client_*() expect valid id/pwd as argument of svn_auth_cred_simple_t**.
And similar thing happens when you use https server and server is not a
trusted one. In that case, svn api invoke SSL trust callback funtions.

Now it is our reponsibility to invoke dialog box and receive user input.
Note that We can't use any QWidget in QThread. QWidgets can be used only
in main thread. Thus, we define some sets of events. We also define custom
event handler in SubversionThread and SubversionCore. When thread needs
any GUI action, it sends event to SubversionCore (which resides in main thread)
and enters event loop. Code path blocks at QThread::exec().
During SubverionThread waits inside its own event loop, SubversionCore
invokes modal dialog box, receives user input, and send event back to
SubversionThread. Then QThread::exec() returns and code flow continues.

For each fetched line, svn_client_blame() calls receiver callback function
specified as its argument. In our case, we specified SvnBlameJob::blameReceiver().
The information is contained in the argument of this callback.
We simply define new structure and append it to QList. Then at the slot
connected to finished(), the caller can finally use blame results.

7. Thread finished with signal finished()

When KDevSubversionView was constructed, it connected SubversionCore's
blameFetched() signal into its printBlame() slot. Thus results are printed
at KDevSubversionView's GUI.

-- case when the action was invoked via IBasicVersionControl interfaces.

In this case, subversion plugin doesn't print result. Subversion plugin just
provides information via QVariant SvnKJobBase::fetchResults(). This method
converts blame result into VcsAnnotation class.

======= Development tip =======

The important file you should see to write subversion plugin is <svn_client.h>
It contains full description for each operation and its arguments.

If you don't understand some concepts in subversion itself, consult subversion
book (use keyword "subversion book" at google).

Library requirement: requires svn library 1.3 or higher currently.

