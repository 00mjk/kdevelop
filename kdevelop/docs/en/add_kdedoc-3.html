<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>The KDE 2 Developer's Guide: Using KDE I/O Slaves</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="add_kdedoc-4.html">Next</A>
 <A HREF="add_kdedoc-2.html">Previous</A>
 <A HREF="add_kdedoc.html#toc3">Table of Contents</A>
</P>
<H3><A NAME="s3">3. Using KDE I/O Slaves</A></H3>

<P>Kurt Granroth 
<A HREF="mailto:granroth@kde.org">&lt;granroth@kde.org&gt;</A><P>v0.1, 15, June 1999
<P><EM>This HOWTO describes how the KDE I/O slaves (ioslaves) work.  It is
intended for both ioslave implementers as well as users.  In this
document, I will attempt to describe both how ioslaves work as well
as how to use them.</EM>
<P>
<P>
<H3><A NAME="ss3.1">3.1 Introduction</A>
</H3>

<H4>What Are I/O Slaves?</H4>

<P>The K Desktop Environment (KDE) I/O slaves (ioslaves) are a series of
small programs that have intimate knowledge on working with a very
specific protocol.  For instance, the HTTP ioslave (<CODE>kio_http</CODE>)
knows all about sending and receiving data to and from a web server.  It
knows all about SSL, encoding, and what all of the different header fields
mean.  It knows this so that KDE developers won't have to -- if they want
a web page, they merely have to use <CODE>kio_http</CODE> for it and it will
take care of everything for them.
<P>The ioslaves are based on the KIO library (<CODE>libkio</CODE>).  This library
implements a method of asynchronous communication between
applications as well as provides a "protocol registry" of sorts.
This has many advantages.  Two of the major ones are:
<P>
<UL>
<LI>The client does not need to know anything about the ioslave that
it is calling.  It merely specifies the protocol and <CODE>cdx/libkio/</CODE> will
automatically determine the proper ioslave to use.
        </LI>
<LI>All communication is done asynchronously.  All <CODE>libkio</CODE> calls will
return immediately.  Whenever events occur, <CODE>libkio</CODE> will send
signals altering the client to that fact.  This means that the
client does not have to engage in any "busy waiting."</LI>
</UL>
<P>Here is a fully working snippet of code to download a web page:
<!--
KIOJob
-->
<!--
sigData()
-->
<P>
<PRE>
 KIOJob *job = new KIOJob;
 connect(job, SIGNAL(sigData(int, const char*, int)),
         this, SIGNAL(slotData(int, const char*, int)));
 job->get("http://www.kde.org/news_dyn.html");
 
</PRE>
<P>That's it!  When the ioslave is done getting the KDE news page, it
will call your application's slotData() function with the page.
<P>
<H4>Copyright</H4>

<P>Copyright (c) 1999 Kurt Granroth, All rights reserved.  This is free
documentware; you can redistribute it and/or modify it under the
terms of version 2 or later of the
<A HREF="http://www.gnu.org/copyleft/gpl.html">GNU General Public  License</A><P>
<H3><A NAME="ss3.2">3.2 Setting Up IOSlaves</A>
 </H3>

<P>Using the KDE ioslaves is very easy once the framework is in place.
This section will describe getting the "back-end" stuff setup.
<P>
<H4>The KIO Library </H4>

<P>The first part that needs to be installed is the KDE IO library
(<CODE>libkio</CODE>).  This library is part of the KDE 2.x <CODE>kdelibs</CODE>
package.  It
will be installed by default on all KDE 2.x systems when 2.x is
finally released.  In the meantime, you will need to get it through
either CVSUP or the snapshots.  See www.kde.org (or a later appendix
when I get around to it later) for details on that.
<P><CODE>libkio</CODE> depends on the KDE UI library (<CODE>libkdeui</CODE>), the KDE
Core library (<CODE>libkdecore</CODE>), and Qt (<CODE>libqt</CODE>).  These are
the "standard" KDE libraries so there shouldn't be any problems, there.
<P>
<H4>The IOSlaves </H4>

<P>There are ioslaves for <CODE>http</CODE>, <CODE>file</CODE>, <CODE>gzip</CODE>,
<CODE>tar</CODE>, <CODE>file</CODE>, <CODE>smb</CODE>, <CODE>pop3</CODE>, and
<CODE>imap4</CODE> as of the time of this writing.  They are all found in the
<CODE>kdebase</CODE> package under <CODE>kioslaves</CODE>.  Again, these are
available only from the KDE development CVS so you'll need to use CVSUP or
the snapshots to retrieve them.
<P>
<H3><A NAME="ss3.3">3.3 Using ioslaves in your Application</A>
 </H3>

<P>Now that you have the backend stuff all setup, you can start setting
up your application to use them.  This requires adding the <CODE>libkio</CODE>
library to your linking and including the proper header files.
<P>
<H4>Modifying your Makefile </H4>

<P>If you are using the standard KDE automake/autoconf system for your
application, then you are in luck!  Adding another library is
trivial:
<P>
<UL>
<LI>Edit Makefile.am</LI>
<LI>Change the line &lt;yourapp&gt;_LDADD to look something like:

<PRE>
     myapp_LDADD = $(LIB_KIO)
   
</PRE>
</LI>
</UL>
<P>That's it!  If you are not using the KDE setup, then just make sure
that you are including the following in your link stage:
<P>
<PRE>
    -lkio -lkdeui -lkdecore -lqt
 
</PRE>
<P>
<H4>Adding the Proper Headers </H4>

<P>This is also simple:
<P>
<PRE>
   #include &lt;kio_job.h>
 
</PRE>
<P>Will take care of everything.
<P>
<H3><A NAME="ss3.4">3.4 Using IOSlaves via KIOJob</A>
 </H3>

<P>Now that your application is all prepped for using ioslaves, you can
actually start using them!
<P>The only class you need to deal with at a client level is the KIOJob
class.  You will use it to "call" the ioslaves and it will send you
signals when it received events from them.
<P>The basic procedure is something like this:
<P>
<UL>
<LI>Create a KIOJob instance</LI>
<LI>Connect all of the signals (events) that you are interested in to
some local slots (callbacks).</LI>
<LI>Send the actual request</LI>
<LI>Process the resulting response in your slots.</LI>
</UL>
<P>
<H4>Typical Example </H4>

<P>An example looks like so:
<!--
sigData()
-->
<!--
sigError()
-->
<!--
sigDataEnd()
-->
<!--
sigFinished()
-->
<P>
<PRE>
 KIOJob *job = new KIOJob;
 connect(job, SIGNAL(sigData(int, const char*, int)),
         this, SLOT(slotData(int, const char*, int)));
 connect(job, SIGNAL(sigError(int, int, const char*)),
         this, SLOT(slotError(int, int, const char*)));
 connect(job, SIGNAL(sigDataEnd(int)),
         this, SLOT(slotDataEnd(int)));
 connect(job, SIGNAL(sigFinished(int)),
         this, SLOT(slotFinished(int)));
 job->get("http://www.pobox.com/~kurt_granroth/index.html");
 
</PRE>
<P>This will get the web page at the above URL.  When the ioslave is done
receiving the page, it will send it to you with your <CODE>slotData()</CODE>
function.  If there was an error, then you receive it in
<CODE>slotError()</CODE>.  If the page was large, then it will be sent in
chunks.  You know that you are done receiving data when
<CODE>slotDataEnd()</CODE> is called.  The <CODE>slotFinished()</CODE> function is
called when the ioslave is completely done.
<P>
<H3><A NAME="ss3.5">3.5 KIOJob Calls</A>
 </H3>

<P>There are numerous operations that you can do with KIOJob.  Some of them
are: <CODE>put</CODE>, <CODE>get</CODE>, <CODE>mkdir</CODE>, <CODE>copy</CODE>,
<CODE>move</CODE>, <CODE>del</CODE>, <CODE>unmount</CODE>, and <CODE>mount</CODE>.  I will
refer only to <CODE>put()</CODE> and <CODE>get()</CODE> in this HOWTO.  The others
follow similar patterns.
<P>
<H4>get(const char* url) </H4>

<P>This is probably the most common operation.  It tells the ioslave to
"get" the resource described in the URL.  This may be a web page, a
POP3 message, or a local file -- it all depends on your URL.
<P>This operation is not very interactive.  You tell the ioslave what
you want and it gets it for you.  Period.
<P>Specifically, it will send back your data with the <CODE>sigData(int id,
char char* data, int length)</CODE> signal.
<P>Parameters:
<P>const char *url - The URL of the resource that you wish to get
<P>
<H4>put(const char* url, int mode, bool overwrite, bool resume, int size) </H4>

<P>This operation will start the process of "putting" or sending data to
the location specified in the URL.  This is used, for instance, to
send files to a remote FTP server or do do a PUT or POST request with
HTTP.  It is not quite a straight-forward as a <CODE>get()</CODE> operation.
<P>The basic procedure looks like:
<P>
<UL>
<LI>Connect <CODE>sigReady(int)</CODE> to a local slot (e.g., <CODE>slotReady(int)</CODE>)</LI>
<LI>Send a <CODE>KIOJob::put(..)</CODE> request</LI>
<LI>When <CODE>slotReady(..)</CODE> is called, you know that the ioslave is ready
to relay your data to its final destination.</LI>
<LI>Send all of your data using the <CODE>KIOJob::data(const char*, int)</CODE>
operation.  When you are done, notify the ioslave of this by
sending a <CODE>KIOJob::dataEnd()</CODE></LI>
</UL>
<P>Some sample code looks like so:
<P>
<PRE>
 KIOJob *job;
 char *data = "My message";
 Client::Client()
 {
        job = new KIOJob;
        connect(job, SIGNAL(sigReady(int)), this, SLOT(slotReady(int)));
        connect(job, SIGNAL(sigData(int, const char*, int)),
                this, SLOT(slotData(int, const char*, int)));
        connect(job, SIGNAL(sigDataEnd(int)),
                this, SLOT(slotDataEnd(int)));
        job->put("http://server.com/cgi-bin/post.cgi", -1, true, false, strlen(data));
 }

 void Client::sigReady(int id)
 {
    job->data(data, strlen(data));
        job->dataEnd();
 }
 
</PRE>
<P>Parameters:
<P>const char* url - The end location for your data
int mode        - Special permissions for your data.  This should be set
to -1 if there are no special permissions
bool overwrite  - Instructs the ioslave to overwrite anything that
may already be there.
bool resume     - Instructs the ioslave to resume a previously aborted
transaction.
int size        - This is the size of the data that you will be sending
<P>
<P>Beyond that, everything else is identical to the 'get' method.
<P>
<H4>data(void *data, int size) </H4>

<P>This is used to send data to an ioslave.  It is used in conjunction with
the <CODE>KIOJob::put(..)</CODE> operation.  It is almost always called from
your object's <CODE>slotReady()</CODE> slot as you must wait for the
<CODE>sigReady(int)</CODE> signal before sending any data.  If your data is
greater than 2048 bytes, then you must break it up into many chunks and
send each chunk individually.
<P>Parameters:
<P>void *data - Your data that needs to go to the ioslave.  This should be no
more than 2048 bytes.
int size   - The size of this data
<P>
<H4>dataEnd() </H4>

<P>This is used along with <CODE>KIOJob::data(..)</CODE> and
<CODE>KIOJob::put(..)</CODE>.  It signals the ioslave that you are done
sending it data.  If you do not send this signal, then the ioslave will
essentially hang.  You do not need to use this if you are using
<CODE>KIOJob::get(..)</CODE>.
<P>Parameters:
<P>None
<P>
<H3><A NAME="ss3.6">3.6 KIOJob Signals</A>
 </H3>

<P>All communication from the ioslaves come through KIOJob in the form of
signals.  There are quite a few of them (see <CODE>kio_job.h</CODE> for a complete
listing), but I'll only discuss the "essential" ones.
<P>
<H4>sigError(int id, int errid, const char* text) </H4>

<P>This signal is emitted whenever an error occurs.  You should always connect a
slot to this signal unless you really don't care if there is an error or not.
<P>Parameters:
<P>int id           - The job id
int errid        - The error code.  This corresponds to the list of errors
defined in kio_interface.h
const char* text - A textual description of the error
<P>
<H4>sigReady(int id) </H4>

<P>
<!--
sigReady()
-->

This signal occurs when the ioslave is ready to accept data.  If you are
using only <CODE>get(..)</CODE> methods, then you should not have to connect to this
signal.  If you are using a <CODE>put(..)</CODE> method, then you must connect to this
signal and begin sending data from there.
<P>Parameters:
<P>int id - The job id
<P>
<H4>sigData(int id, const char *data, int size) </H4>

<P>
<!--
sigData()
-->

This signal happens whenever the ioslave is sending you data.  This is
typically the data that it just downloaded.  It will never be more than 2048
bytes, so plan on having it called several times.  You are responsible for
collecting all of the data.  You will know that the ioslave is done sending
you data when you get the <CODE>sigDataEnd(int)</CODE> signal.
<P>Parameters:
<P>int id           - The job id
const char *data - The data that the ioslave just downloaded
int size         - The size of this data chunk
<P>
<H4>sigDataEnd(int id) </H4>

<P>
<!--
sigDataEnd()
-->

This signal is sent to signify that the ioslave is done sending you data.
You should use this signal as an assurance that you can use the data as
<CODE>sigData(..)</CODE> will never again be called.
<P>Parameters:
<P>int id - The job id
<P>
<H4>sigFinished(int id) </H4>

<P>
<!--
sigFinished()
-->

This signal indicates the the ioslave is completely done.
<P>Parameters:
<P>int id - The job id
<P>
<P>
<P>
<P ALIGN="RIGHT">

<A HREF="add_kdedoc-4.html">Next</A>
 <A HREF="add_kdedoc-2.html">Previous</A>
 <A HREF="add_kdedoc.html#toc3">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
