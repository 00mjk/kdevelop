<!doctype linuxdoc system>
<article>
<title>The KDevelop Programming Handbook
<author>Ralf Nolden &lt;<tt/Ralf.Nolden@post.rwth-aachen.de/&gt;, The KDevelop Team
<date>Version 2.0 , Mon May 3 17:02:49 CEST 1999

<abstract>
The User Guide to Programming with the KDevelop IDE, Version 1.0.
</abstract>

<toc>

<sect>Introduction
<p>
As Unix Systems are becoming more and more popular to even beginners working with computer machines due to its advantages in regards of
stability and functionality, most are somehow disappointed, because those applications don't have a consistant look and each one
behaves different from another. With KDE, developers have an almost perfect way to create first-class applications for Unix desktop
systems to get a wider user community by the mere quality their applications have to offer. Therefore, KDE becomes more and more
popular as a base for programming design, and developers want to take advantage of the possibilities that the system has to offer.


<sect1>What you should know already
<p>
For making the best use of this programming handbook, we assume that you already know how to program applications with the C++
programming language. You don't have to know anything about GUI programming, although having a basic knowledge will make things easier
to understand. Also, you should have made yourself comfortable with KDevelop by reading the <em/The User Manual to KDevelop/,
describing all commands and available functions that are provided by the IDE.

<sect1>About this Handbook
<p>
This handbook has been written to give developers an introduction into KDE application development with special regards to the KDevelop
Integrated Development Environment. The reader will learn how to create his own application, what the framework automatically generated
by the KAppWizard already offers and how it runs. By the following chapters, the user is introduced into certain aspects of GUI
application design by a tutorial application, which we called <em/KScribble/.

<bf/In the next chapter/

we'll take a look at the Qt and KDE libraries, showing basic concepts and why things are the way they are.
Also, we will discuss how to create the tutorial applications provided with the Qt toolkit by using KDevelop, so beginners can already
see first results with a few steps, and thereby will learn how to make use of some of KDevelop's best features.

<bf/In the following chapters/ you will learn:
<itemize>
<item>how to create an application with the KAppWizard,
<item>what the project skelleton already provides,
<item>what the code already created means,
<item>how to create your own views,
<item>how to extend your application's functionality by dialog, menubars and toolbars
<item>how to make your application user friendly by providing help functions and
<item>how to write SGML online documentation.
</itemize>


<sect1>Additional Information
<p>
Additional information about Qt/KDE programming is available by various sources:

<itemize>
<item><em/Programming with Qt/ by Matthias Kalle Dalheimer, published by O'Reilly (see <htmlurl url="http://www.oreilly.com"
name="http://www.oreilly.com">, covering almost all aspects of the Qt GUI toolkit and contains examples as well.
<item><em/The User Manual to KDevelop/, provided with the KDevelop IDE,
<item><em/Online-Reference/ to the Qt-library, provided with your copy of the Qt toolkit in HTML and available as Postscript on
<htmlurl url="http://www.troll.no" name="http://www.troll.no">
<item>On the internet, see
<itemize>
<item>the Troll Tech website at <htmlurl url="http://www.troll.no" name="http://www.troll.no">,
<item>the KDE website at <htmlurl url="http://www.kde.org" name="http://www.kde.org">,
<item>the KDE developer website at <htmlurl url="http://developer.kde.org" name="http://developer.kde.org">
<item>the KDevelop homepage at <htmlurl url="http://www.cs.uni-potsdam.de/~smeier/kdevelop/index.html"
name="http://www.cs.uni-potsdam.de/~smeier/kdevelop/index.html">
</itemize>
</itemize>

Addtionally, you should look for help on the various mailinglists, whose adresses are available on the mentioned websites, and on the
usenet newsgroups dedicated to users of KDE and Unix Systems.

For KDevelop itself, you should send requests to our mailinglist at <htmlurl url="mailto:kdevelop@fara3.cs.uni-potsdam.de"
name="kdevelop@fara3.cs.uni-potsdam.de">. Mind that the KDevelop team is dedicated to provide the means to enable you to program
applications and therefore is not intended as a technical support team in cases where the applications you're developing don't work due
to implementation errors. By this, we ask all users to take advantage of the mailinglist in any case you're running into problems with
the use of the IDE itself, reporting bugs and questions about features as well as giving comments about what can be improved.

<sect>The KDE and Qt Libraries
<p>
The norwegian company Troll Tech (<htmlurl url="http://www.troll.no" name="http://www.troll.no">) provides a so-called GUI-toolkit,
named Qt. Thereby, GUI means "<bf/G/raphical <bf/U/ser <bf/I/nterface", and therefore, Qt-based applications represent themselves with
buttons, windows etc, allowing user input by visualizing the functions an application provides. Such a toolkit is needed for developing
graphical applications that run on the X-Window interface on Unix Systems; although other toolkits can be used, Qt offers some
technical advantages that make application design very easy. Plus- it offers portablity to Windows Systems, which can be a criteria for
developers who want to provide their applications on both systems.

The KDE Team (<htmlurl url="http://www.kde.org" name="http://www.kde.org">) joined together with the goal to make using Unix
Systems more friendly, and decided to use the Qt toolkit as a base for their development for a window manager system on X-Window, plus
a variety of tools included with the KDE packages. After KDE was out, a lot of developers turned their eyes towards the new environment
and what it has to offer them. The KDE libraries are providing essential methods and classes that make all applications designed with
them look similar and consistent, so the user has the great advantage that he only has to get accustomed with an application's specific
usage, not with handling dialogs or buttons. Also, KDE programs include themselves into the desktop and are able to interact with the
window manager via drag'n drop, session management etc.

The next sections describe, what the C++ libraries of Qt and KDE have to offer in regards of application design and creation,
specifically on X-Window, as well as giving an introduction into the Qt library technics by examples that are explained in detail.

<sect1>The Qt GUI Toolkit
<p>
Application design with the Qt toolkit offers the following advantages to the developer:

<itemize>
<item>A complete set of classes and methods ready to use,
<item>A good solution towards user interaction by virtual methods and the signal/slot mechanism,
<item>A set of predefined GUI-elements, called "widgets", that can be used easily for creating the visible elements
<item>Additional completely pre-defined dialogs that only have to be called for standard functions
</itemize>

Therefore knowing the Qt classes is very essential, even if you only want to program KDE-applications. Mind that almost all KDE-classes
and widgets are based on the Qt library, so we suggest having a look at how a Qt-based application looks like first; then we'll switch
to the difference for creating a KDE applications.

<sect2>The first Qt Application
<p>
As usual, programs in C++ contain the <tt/main()/ function. With this, your application starts executing. Now, how does a program
make itself visible ? For an example, we'll have a look at the first tutorial included with the Qt Online Reference Documentation:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &hello );
hello.show();
return a.exec();
}
</code></tscreen>

This application merely paints a window containing a button with "Hello world" as its text. As for all Qt-Applications, you first have
to create an instance of the class <tt/QApplication/, which is the element <tt/a/ here. You also see that the parameters that can be
passed to the program by commandline are given to the QApplication object. During the execution process, the application can check for
the commandline options and provide methods to interpret them as well as executing the resulting actions, such as loading a file or
whatever.

Next, the program creates an instance of the class <tt/QPushButton/ called <tt/hello/. This represents the button later. The
constructor of <tt/hello/ gets a string as a parameter, which is the contents of the widget which is visible as the button's
text.

Then the program calls the <tt/resize()/ method on the <tt/hello/ button. This changes the default size a widget (which is in this
case the QPushButton) has when created to the length of 100 pixels and the heigth of 30 pixels. Finally, the <tt/setMainWidget()/
method is called for <tt/a/ and the <tt/show()/ method for <tt/hello/. The <tt/QApplication/ is finally executed by <tt/a.exec()/,
enters the main event loop and waits until it has to return an integer value to the overlaying Operating System signaling that the
application is exited.

<sect2>The Reference Documentation for Qt
<p>
Now, let's have a quick look at the reference documentation of the Qt library. To do this, start KDevelop and select "Qt-library" from
the "Help"-menu in the menubar. The documentation browser opens and shows you the start page of the Qt reference. This will be your
first place to get information about Qt, it's classes and the available functions they provide. Also, the above program is the first
that is included in the tutorials section. To get to the classes we want to have a look, <tt/QApplication/ and <tt/QPushButton/, select
"Alphabetical Class List" and search for the classes. Follow either of them to have a look at.

For <tt/QApplication/, you will see the constructor and all other methods that this class provides. If you follow a link, you will get
more information about the usage and meaning of the methods, which is very useful when you sometimes can't detect the correct use or
want to have an example. This also counts for the KDE library documentation, which uses a similar documentation type; therefore this is
almost all you have to know about using the class-references with the documentation browser.

<sect2>Interpretation of the Sample
<p>
Starting with <tt/QApplication/, you will find all the methods used in our first example:

<itemize>
<item>the constructor <tt/QApplication()/,
<item>the <tt/setMainWidget()/ method and
<item>the <tt/exec()/ method.
</itemize>

The interpretation of these methods is very simple:

<enum>
<item>first create an instance of the class <tt/QApplication/ with the constructor,
<item>create a widget,
<item>set the widget as the main widget for <tt/a/,
<item>execute the <tt/a/ instance of <tt/QApplication/.
</enum>

The second object of our program is the pushbutton, an instance of the class <tt/QPushButton/. From the two constructors given to
create an instance, we used the second: this accepts a text, which is the label contents of the button; here, it is the string "Hello
world!". Then we called the <tt/resize()/ method to change the size of the button according to it's contents- the button has to be
larger to make the string completely visible.

But what about the <tt/show()/ method ?  Now, you see that like most other widgets, <tt/QPushButton/ is based on a single-inheritance-
here, the documentation says, <em/Inherits/ <tt/QButton/.  Follow the link to the <tt/QButton/ class. This shows you a lot of other
functions that are inherited by QPushButton, which we'll use later to explain the signal/slot mechanism. Anyway, the <tt/show()/ method
is not listed, therfore, it must be a method that is provided by inheritance as well. The class that <tt/QButton/ inherits, is
<tt/QWidget/. Just follow the link again, and you will see a whole bunch of methods that the <tt/QWidget/ class provides; including the
<tt/show()/ method. Now we understand what was done in the sample with the button:

<enum>
<item>create an instance of <tt/QPushButton/, use the second constructor to set the button's text,
<item>resize the widget to it's contents,
<item>set the widget as the main widget of the <tt/QApplication/ instance <tt/a/,
<item>show the widget on the screen by calling <tt/show()/, an inherited method from <tt/QWidget/.
</enum>

Mind that the button is shown even before the <tt/main()/ function reaches the <tt/exec()/ method call; this behavoir can be used to
create "splash-screens" for applications that may take some time to load and thereby signal the user that the program he started is
loading.

After calling the <tt/exec()/ method, the application is visible to the user, showing a window with the button showing "Hello world!".
Now, GUI programs behave somewhat differently than procedural applications. The main thing here is that the application enters a
so-called "main event loop". This means that the program has to wait for user actions and then react to it, also that for a Qt
application, the program has to be in the main event loop to start the event handling. The next section tells you in short what this
means to the programmer and what Qt offers to process user events.

(For already advanced users: The button has no parent declared in the constructor, therefore it is a top-level widget alone and runs in
a local event loop which doesn't need to wait for the main event loop, see the<tt/QWidget/ class documentation)


<sect2>User Interaction
<p>
After reading the last sections, you should already know:
<itemize>
<item>What the Qt-libary provides in terms of GUI applications,
<item>how a program using Qt is created and
<item>where and how to find information about classes that you want to use with the documentation browser
</itemize>

Now we'll turn to give the application "life" by processing user events. Generally, the user has two ways to interact with a program:
the mouse and the keyboard. For both ways, a graphical user interface has to provide methods that detect actions and methods that do
something as a reaction to these actions.

Basically, the user can only interact with objects that are visible. Therefore, the base class that provides user interaction is
<tt/QWidget/. Now, all events that are produced by the user are created as a <tt/QEvent/ and then processed by the virtual member
function

<tt/QWidget::event(QEvent*)/,

which then decides which event has been executed and how to react (the main event handler). Therefore, the <tt/event()/ function passes
the event to so-called event filters, that determine what happened and do something with the event. If no filter signs responsible for
the event, the specialized event handlers are called. Thereby we can decide between:

<bf/a) Keyboard events --TAB and Shift-TAB keys:/

changes the keyboard input focus from the current widget to the next widget in the focus order. The focus can be set to widgets by
calling <tt/setFocusPolicy()/ and process the following event handlers:

<itemize>
<item><tt/virtual void focusInEvent ( QFocusEvent * )/
<item><tt/virtual void focusOutEvent ( QFocusEvent * )/
</itemize>

<bf/b) all other keyboard input:/
<itemize>
<item><tt/virtual void keyPressEvent ( QKeyEvent * )/
<item><tt/virtual void keyReleaseEvent ( QKeyEvent * )/
</itemize>

<bf/c) mouse movements:/
<itemize>
<item><tt/virtual void mouseMoveEvent ( QMouseEvent * )/
<item><tt/virtual void enterEvent ( QEvent * )/
<item><tt/virtual void leaveEvent ( QEvent * )/
</itemize>

<bf/d) mouse button actions:/
<itemize>
<item><tt/virtual void mousePressEvent ( QMouseEvent * )/
<item><tt/virtual void mouseReleaseEvent ( QMouseEvent * )/
<item><tt/virtual void mouseDoubleClickEvent ( QMouseEvent * )/
</itemize>

<bf/e) window events containing the widget:/
<itemize>
<item><tt/virtual void moveEvent ( QMoveEvent * )/
<item><tt/virtual void resizeEvent ( QResizeEvent * )/
<item><tt/virtual void closeEvent ( QCloseEvent * )/
</itemize>

Note that all event functions are virtual and protected, therfore, you can reimplement them in your own widget classes for receiving a
certain behavoir. <tt/QWidget/ also contains some other virtual methods that can be useful in your programs; anyway, it is sufficent to
know about <tt/QWidget/ very well generally.


<sect2>Object Interaction by Signals and Slots
<p>
Now we're coming to the most obvious advantages of the Qt toolkit: the signal/slot mechanism. This offers a very handy and useful
solution to object interaction, which usually is solved by <tt/callback/ functions for X-Window toolkits. As this communication
requires a strict programming and sometimes makes user interface creation very difficult (as refered by the Qt documentation and
explained in <em/Programming with Qt/ by K.Dahlheimer), Troll Tech invented a new system where objects can emit signals that can be
connected to methods declared as slots. For the C++ part of the programmer, he only has to know some things about this mechanism:

<enum>
<item>the classdeclaration of a class using signals/slots has to contain the <tt/Q_OBJECT/ macro at the beginning (without the
semicolon); and have to be derived from the <tt/QObject/ class,
<item>a signal can be emitted by the keyword <tt/emit/, e.g. <tt/emit signal(parameters);/ from within any member function
of a class that allows signals/slots,
<item>all signals used by the classes that are not inherited have to be added to the classdeclaration by a <tt/signals:/ section,
<item>all methods that can be connected with a signal are declared in sections with the additional keyword <tt/slot/, e.g.
<tt/<bf/public/ slots:/ within the classdeclaration,
<item>the meta-object compiler <tt/moc/ has to run over the header file to expand the macros and to produce the implementation (which
is not needed to know.). The output files of <tt/moc/ are compiled as well by the C++ compiler.
</enum>

Another way to use signals without deriving from <tt/QQbject/ is to use the <tt/QSignal/ class- see the reference documentation for
more information and example usage. In the following, we assume you're deriving from <tt/QObject/.


This way, your class is able to send signals anywhere and to provide slots that signals can connect to. By using the signals, you don't
have to care about who's receiving it- just you have to emit the signal and whatever slot wants to connect to it can react to the
emission. Also the slots can be used as normal methods during implementation.

Now, to connect a signal to a slot, you have to use the <tt/connect()/ methods that are provided by <tt/QObject/ or, where available,
special methods that objects provide to set the connection for a certain signal.

<sect3>Sample Usage
<p>
To explain the way how to set up object-interaction, we'll take our first example again and extend it by a simple connection:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &hello );

connect(&hello, SIGNAL( clicked() ), &a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

You see, the only addition to give the button more interaction is to use a <tt/connect()/ method:
<tt/connect(&hello, SIGNAL( clicked() ), &a, SLOT( quit() );/ is all you have to add. What is the meaning now ? The class declaration
of <tt/QObject/ says about the <tt/connect()/ method:

<tt/bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )/

This means, you have to specify a QObject instance pointer that is the sender of the signal, meaning that it can emit this signal as
first parameter; then you have to specify the signal that will be connected. The last two parameters are the receiver object that
provides a slot, followed by the member function which actually <em/is/ the slot that will be executed on signal emission. What is
important to know is that your signal and your slot have to have the same parameters, independent from the usage of the actual
parameters.

By using signals and slots, your program's objects can interact with each other easily without explicitely depending on the existance
of the receiver object. You will learn more about using this mechanism for productive usage later in this handbook while working with
the tutorial application <em/KScribble/.


<sect1>What KDE provides
<p>
<sect2>The KDE 1.1 libraries
<p>
For the time of this writing and due to the fact that KDevelop uses KDE 1.1, I'm refering to the state of the KDE libraries at that
release. The main KDE libraries you'll be using for creating your own KDE applications are:

<itemize>
<item>the KDE-Core library, containing all classes that are non-visible elements and provide functionality your application may use.
<item>the KDE-UI library, containing user interface elements like menubars, toolbars and the like,
<item>the KFile library, containing the file selection dialogs,
</itemize>

Additionally, for specific solutions KDE offers the following libraries:

<itemize>
<item>the KHTMLW library, offering a complete HTML-interpreting widget that is used by various programs like KDEHelp, KFM, KDevelop,
<item>the KAb library, the KAddressBook. Provides Adressbook access for e.g. email applications
<item>the KSpell library, offering widgets and functionality to integrate the use of ISpell, the common spellchecker, in applications
like editors; used for the KEdit application.
</itemize>

Our view should now turn to what changes are required to make a KDE application out of a Qt application.

<sect2>Example KDE Application
<p>
In the following, you will see that writing a KDE application is not much more difficult than a Qt application. For the use of KDE's
features, you just have to use some other classes, and you're almost done. As an example, we'll discuss the changed version of the Qt
example from above:

<tscreen><code>
#include <kapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setTopWidget( &hello );

connect(&hello, SIGNAL( clicked() ), &a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

You see that first we have changed from <tt/QApplication/ to <tt/KApplication/. Further, we had to change the previously used
<tt/setMainWidget()/ method to <tt/setTopWidget/, which <tt/KApplication/ uses to set the main widget. That's it ! Your first KDE
application is ready- you only have to tell the compiler the KDE include path and the linker to link in the KDE-Core library with
-lkdecore.

As you now know what at least the main() function provides generally and how an application gets visible and allows user and object
interaction, we'll go on with the next chapter, where our first application is made with KDevelop- there you can also test everything
which was mentionend before and see the effects.

What you should have looked into additionally until now is the reference documentation for Qt, especially the <tt/QApplication/,
<tt/QWidget/ and <tt/QObject/ class and the KDE-Core library documentation for the <tt/KApplication/ class.


<sect>Creating new Applications with KAppWizard<label id="Creating new Applications with KAppWizard">
<p>
The KAppWizard, or also called the KDE Application Wizard, is intended to let you start working on new projects with KDevelop.
Therefore, all your projects are first created by the wizard; then you can start building them and extend the already provided source
skelleton. KAppWizard also allows to choose between several project types according to your project's goals:

<itemize>
<item>Normal KDE Application: includes sourcecode for a comlete framestructure of a standard KDE application with support for the
Document-View-Controller model, a menubar, toolbar and statusbar as well as a set of standard documentation based on SGML, KDE-links
and application icons. This is the application type usually needed for a new KDE project.
<item>Mini KDE Application: contains the same general structure as the Normal KDE Application type but with the difference that the
application's code only provides a widget as a window.
<item>Normal Qt Application: works like the normal KDE application by it's code with the difference that the project is based on the Qt
library only and doesn't contain KDE support. This is intended for projects that have to be portable to Windows platforms or that don't
want to require KDE libraries by the end-user.
<item>C++ Application: Is based on the C++ compiler only and runs in a console, therefore doesn't require X-Window.
<item>Custom project: creates an empty project without any sourcecode. This is intended for already existing projects to port to
KDevelop or for projects where you want to start from scratch.
</itemize>

In this chapter we'll see how the KAppWizard can be invoked and what has to be done to generate a KDE application project. This will
also be the initial step of our tutorial, where you will create your first version of <em/KScribble/. For all other project types the
steps are usually the same, just you may not have certain options available.

<sect1>Invoking KAppWizard and Project Generation
<p>
<sect2>Starting KAppWizard and the First Page
<p>
To start with your first KDE application, open KDevelop. Then select "New" from the "Project"-menu. The KAppWizard starts, and you see
a tree on the first page, containing the project types. When a type is selected, you see a preview how it will look like after the
initial build process. Choose the KDE subtree, Normal type. Then press the "Next" button on the bottom of the first wizard page. This
will switch to the next page, where you have to set the general project options.

<sect2>The Generate Settings Page
<p>
For our first version of <em/KScribble/, enter <tt/KScribble/ as "Projectname". Then select the directory you want to have your project
build in; the default is your home directory. You can enter the path manually or you can as well press the button on the right to
select the directory by a dialog.

Next, you have to enter the Versionnumber. For the first version, set this to <tt/0.1/. It is usual to number new applications that are
in development for the first release lower than 1, and as the initial version will only contain the standard framework, we'll name this
the 0.1 version. During the following chapters, we'll increase this value along with the facilities that <em/KScribble/ will get by our
implementation.

Finally, add your name to the "Author" field and your email adress. We'll leave all other options untouched- they are needed for our
project.

To give you some information about the options, you can press the right mouse button over the options, and you will get a quickhelp
window that describes the option's purpose.

These are:
<itemize>
<item><bf/generate sources and headers:/  generates the application sourcecode
<item><bf/GNU-Standard-Files:/  adds a copy of the GNU-General Public License to the project as well as some standard files for user
infromation when distributing the package.
<item><bf/User-Documentation:/ the user handbook in SGML, already prepared for your project.
<item><bf/API-Documentation:/ creates an initial HTML documentation set for the <bf/A/pplication <bf/P/rogramming <bf/I/nterface.
<item><bf/lsm-File:/ the Linux Software Map, used by distribution sites and contains short information about the project's purpose and
requirements.
<item><bf/.kdelnk-File: / a KDE link that will install your application in the "Applications" tree of the KDE-Panel.
<item><bf/Program-Icon: / an Icon that represents your project and can be used to create a link on the desktop.
<item><bf/Mini-Icon: / a Mini-version of the program icon that represents your application besides it's name in the KDE-Panel and is
shown in your application's dialogs and main-window in the left upper corner.
</itemize>

Now we'll switch to the next page by pressing the "Next" button again to set the template for the header files of your project.


<sect2>The Header and Source Templates
<p>
The header template page allows you to automatically include a preface for your header files, containing the filename, the construction
date, the year of the copyright, also your name and your email adress. You don't have to change those uppercase parts yourself, as
KAppWizard does this automatically and stores the template for this project, so it can be used later again for creating new files.

The second part of the default header template contains a license information. By default, your project is set under the GNU General
Public License, which is also included in the package. This license is used for your souce code's protection against any person that
just copies your sources for his own purpose. The General Public License offers you this license for free and thereby protects your
rights as the author, and is common for distributing free software. To get more information about the license, you should read the
COPYING file in the base directory of your new project later.

Anyway, you may want to choose another license or another header template you're already using for your projects. Therefore you can
either edit the given default template directly. To do this, you're given the template in an editing window. To clear the default page,
select "New", to use another template, select "Load...", which lets you choose the template file.

When you're done, go to the next page by entering "Next". This is the template page for your source files and is generally the same as
the header template page. The only difference is that this template is used for your implementation files.

<sect2>Creating the Project
<p>

Now that you've set all options for <em/KScribble/, select "Next" and press the "Generate" button on the bottom of the wizard window.
If the button is not available, you haven't set all options correctly. To correct any errors, step back in the Wizard with "Back".

Then you'll see what KAppWizard does- he copies all templates to your project directory and creates the new project. After KAppWizard
is finished, the "Cancel" button changes to an "Exit" button to leave the wizard.

After this last step, you're finished with creating a new project. KDevelop then loads it and the treeviews let you browse through the
project's files and classes.

In the next section, we'll discuss how to build and run your first version of <em/KScribble/ and how the sourcecode is organized, so
you have an idea where we are and where we're going to extend the features of <em/KScribble/ in the following chapters.

<sect1>The Application Skeletton
<p>
<sect1>Additional Contents of KDevelop Projects
<p>
<sect>Creating Views
<p>
<sect1>Using Library Views and Dialogs
<p>
<sect1>Qt Views
<p>
<sect1>KDE Views
<p>
<sect1>Creating your own Views
<p>
<sect>Configuring Menubars and Toolbars
<p>
<sect1>How does it work ?
<p>
<sect1>Adding a new menu
<p>
<sect1>Integrating Toolbar buttons
<p>
<sect1>Configuring Statusbars
<p>
<sect>The Dialogeditor: Where your Dialogs are Build
<p>
<sect1>What the Dialogeditor provides
<p>
<sect1>Constructing a new Dialog
<p>
<sect1>Setting Widget Properties
<p>
<sect1>Integrating the Dialog
<p>
<sect>Printing
<p>
<sect1>The Qt Print Dialog
<p>
<sect1>The QPainter Class
<p>
<sect>Help Functions
<p>
<sect1>Extending the Statusbar Help
<p>
<sect1>Adding Quickhelp
<p>
<sect1>The "What's This ? Button"
<p>

<sect>Extending the Documentation with SGML
<p>
<sect1>Why SGML ?
<p>
<sect1>What the Documentation already contains
<p>
<sect1>Adding new Pages
<p>
<sect1>How to call Help in Dialogs
<p>

<sect>Class Documentation with KDoc
<p>
<sect1>How to use KDevelop's Documentation features
<p>
<sect1>Adding Class and Member Documentation
<p>
<sect1>Special Tags
<p>
<sect>Finding Errors
<p>
<sect1>Debugging Macros provided by Qt
<p>
<sect1>KDE Macros
<p>

<sect>Copyright
<p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

</article>







