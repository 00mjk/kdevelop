<!doctype linuxdoc system>
<article>
<title>The KDevelop Programming Handbook
<author>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">, The KDevelop Team

<date>Version 2.0 , Mon May 3 17:02:49 CEST 1999

<abstract>
The User Guide to C++ Application Design for the K Desktop Environment (KDE) with the KDevelop IDE, Version 1.0. This handbook itself is part of the
KDevelop Integrated Development Environment and is therefore also licensed under the GNU General Public License; see <ref
id="Copyright" name="Copyright"> for more information.

</abstract>

<toc>

<sect>Introduction
<p>
As Unix Systems are becoming more and more popular to even beginners working with computer machines due to its advantages in regards of
stability and functionality, most are somehow disappointed, because those applications don't have a consistant look and each one
behaves different from another. With KDE, developers have an almost perfect way to create first-class applications for Unix desktop
systems to get a wider user community by the mere quality their applications have to offer. Therefore, KDE becomes more and more
popular as a base for programming design, and developers want to take advantage of the possibilities that the system has to offer.


<sect1>What you should know already
<p>
For making the best use of this programming handbook, we assume that you already know about the C++ programming language; if not, you
should make yourself familiar with that first. Information about C++ is available through various sources either in printed form at
your local bookstore or by tutorials found on the internet. Knowledge about the design of Graphical User Interfaces is not required, as
this handbook tries to cover the application design for KDE programs, which also includes an introduction into the Qt toolkit as well
as the KDE libraries and the design of User Interfaces. Also, you should have made yourself comfortable with KDevelop by reading
<em/The User Manual to KDevelop/, which conains a descriptive review of the functionality provided by the IDE.

<sect1>About this Handbook
<p>
This handbook has been written to give developers an introduction into KDE application development with special regards to the KDevelop
Integrated Development Environment. The reader will learn how to create his own application, what the framework automatically generated
by the KAppWizard already offers and how it runs. By the following chapters, the user is introduced into certain aspects of GUI
application design by a tutorial application, <em/KScribble/.

<bf/In the next chapter/

we'll take a look at the Qt and KDE libraries, showing basic concepts and why things are the way they are.
Also, we will discuss how to create the tutorial applications provided with the Qt toolkit by using KDevelop, so beginners can already
see first results with a few steps, and thereby will learn how to make use of some of KDevelop's best features.

<bf/In the following chapters/ you will learn:
<itemize>
<item>how to create an application with the KAppWizard,
<item>what the project skelleton already provides,
<item>what the code already created means,
<item>how to create your own views,
<item>how to extend your application's functionality by dialog, menubars and toolbars
<item>how to make your application user friendly by providing help functions and
<item>how to write SGML online documentation.
</itemize>


<sect1>Additional Information
<p>
Additional information about Qt/KDE programming is available by various sources:

<itemize>
<item><em/Programming with Qt/ by Matthias Kalle Dalheimer, published by O'Reilly (see <htmlurl url="http://www.oreilly.com"
name="http://www.oreilly.com">, covering almost all aspects of the Qt GUI toolkit and contains examples as well.
<item><em/The User Manual to KDevelop/, provided with the KDevelop IDE,
<item><em/Online-Reference/ to the Qt-library, provided with your copy of the Qt toolkit in HTML and available as Postscript on
<htmlurl url="http://www.troll.no" name="http://www.troll.no">
<item>On the internet, see
<itemize>
<item>the Troll Tech website at <htmlurl url="http://www.troll.no" name="http://www.troll.no">,
<item>the KDE website at <htmlurl url="http://www.kde.org" name="http://www.kde.org">,
<item>the KDE developer website at <htmlurl url="http://developer.kde.org" name="http://developer.kde.org">
<item>the KDevelop homepage at <htmlurl url="http://www.cs.uni-potsdam.de/~smeier/kdevelop/index.html"
name="http://www.cs.uni-potsdam.de/~smeier/kdevelop/index.html">
</itemize>
</itemize>

Addtionally, you should look for help by subscribing to the various mailinglists, whose adresses are available on the mentioned
websites, and on the usenet newsgroups dedicated to users of KDE and Unix Systems as well as about the C and C++ programming language.

For obtaining help about the KDevelop IDE, you should send requests to our mailinglist at <htmlurl
url="mailto:kdevelop@fara3.cs.uni-potsdam.de" name="kdevelop@fara3.cs.uni-potsdam.de">. Mind that the KDevelop team is dedicated to
provide the means to enable you to program applications and therefore is not intended as a technical support team in cases where the
applications you're developing don't work due to implementation errors or misconfigurations of your Operating Sytem. By this, we ask
all users to take advantage of the mailinglist in any case you're running into problems with the use of the IDE itself, as well as for
bug reports and suggestions for improving the functionality of the development environment.

<sect>The KDE and Qt Libraries
<p>
The norwegian company Troll Tech (<htmlurl url="http://www.troll.no" name="http://www.troll.no">) provides a so-called GUI-toolkit,
named Qt. Thereby, GUI means "<bf/G/raphical <bf/U/ser <bf/I/nterface", and therefore, Qt-based applications represent themselves with
buttons, windows etc, allowing user input by visualizing the functions an application provides. Such a toolkit is needed for developing
graphical applications that run on the X-Window interface on Unix Systems, because X does not contain a pre-defined user interface
itself. Although other toolkits are also available to create User Interfaces, Qt offers some technical advantages that make application
design very easy. Additionally, the Qt toolkit is also available for Microsoft Windows systems, which allows developers to povide their
applications for both platforms.

The KDE Team (<htmlurl url="http://www.kde.org" name="http://www.kde.org">) joined together with the goal to make using Unix
Systems more friendly, and decided to use the Qt toolkit for the development of a window manager on X-Window, plus a variety of tools
included with the KDE packages. The K Desktop Environment therefore contains the window manager <em/kdm/, the file manager <em/kfm/ and
the launch panel <em/kpanel/ as the main components plus a variety of first-class utilities and applications. After KDE was out, a lot
of developers turned their eyes towards the new environment and what it has to offer them. The KDE libraries are providing essential
methods and classes that make all applications designed with them look similar and consistent, so the user has the great advantage that
he only has to get accustomed with an application's specific usage, not with handling dialogs or buttons. Also, KDE programs integrate
themselves into the desktop and are able to interact with the window manager via drag'n drop, offer session management and many more,
if all features offered by the KDE libraries are used.

Both, the Qt toolkit and the KDE libraries, are implemented in the C++ programming language; therefore applications that make use of
these libraries are also mostly written in C++. In the following chapter, we'll make a short trip through the libraries to see what
already is provided and how Qt and KDE applications are created in general.

<sect1>The Qt GUI Toolkit
<p>
As said, the Qt library is a toolkit that offers graphical elements that are used for creating GUI applications and are needed for
X-Window programming. Additionally, the tookit offers:

<itemize>
<item>A complete set of classes and methods ready to use even for non-graphical programming issues,
<item>A good solution towards user interaction by virtual methods and the signal/slot mechanism,
<item>A set of predefined GUI-elements, called "widgets", that can be used easily for creating the visible elements
<item>Additional completely pre-defined dialogs that are often used in applications such as progress and file dialogs.
</itemize>

Therefore knowing the Qt classes is very essential, even if you only want to program KDE-applications. To have an impression on the
basic concept how GUI-applications are constructed and compiled, we'll first have a look at a sample Qt-only program; then we'll extend
it to a KDE program.

<sect2>The first Qt Application
<p>
As usual, programs in C++ have to contain a <tt/main()/ function, which is the starting point for application execution. As we want
them to be graphically visible in windows and offering user interaction, we first have to know, how it can show itself to the user. For
an example, we'll have a look at the first tutorial included with the Qt Online Reference Documentation and explain the basic
execution steps; also why and how the application widow appears:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</code></tscreen>

This application merely paints a window containing a button with "Hello world" as its text. As for all Qt-Applications, you first have
to create an instance of the class <tt/QApplication/, represented by <tt/a/.

Next, the program creates an instance of the class <tt/QPushButton/ called <tt/hello/,  this will be the button. The constructor of
<tt/hello/ gets a string as a parameter, which is the contents of the widget visible as the button's text.

Then the <tt/resize()/ method is called on the <tt/hello/ button. This changes the default size a widget (which is in this
case the QPushButton) has when created to the length of 100 pixels and the heigth of 30 pixels. Finally, the <tt/setMainWidget()/
method is called for <tt/a/ and the <tt/show()/ method for <tt/hello/. The <tt/QApplication/ is finally executed by <tt/a.exec()/,
enters the main event loop and waits until it has to return an integer value to the overlaying Operating System signaling that the
application is exited.

<sect2>The Reference Documentation for Qt
<p>
Now, let's have a quick look at the reference documentation of the Qt library. To do this, start KDevelop and select "Qt-library" from
the "Help"-menu in the menubar. The documentation browser opens and shows you the start page of the Qt reference. This will be your
first place to get information about Qt, it's classes and the available functions they provide. Also, the above program is the first
that is included in the tutorials section. To get to the classes we want to have a look at, <tt/QApplication/ and <tt/QPushButton/,
select "Alphabetical Class List" and search for the according names. Follow either of them to have a look at the class documentation.

For <tt/QApplication/, you will see the constructor and all other methods that this class provides. If you follow a link, you will get
more information about the usage and meaning of the methods, which is very useful when you sometimes can't detect the correct use or
want to have an example. This also counts for the KDE library documentation, which uses a similar documentation type; therefore this is
almost all you have to know about using the class-references with the documentation browser.

<sect2>Interpretation of the Sample
<p>
Starting with <tt/QApplication/, you will find all the methods used in our first example:

<itemize>
<item>the constructor <tt/QApplication()/,
<item>the <tt/setMainWidget()/ method and
<item>the <tt/exec()/ method.
</itemize>

The interpretation why we use these methods is very simple:

<enum>
<item>first create an instance of the class <tt/QApplication/ with the constructor, so we can make use of the GUI elements provided by
Qt,
<item>create a widget which will be the contents of our program window,
<item>set the widget as the main widget for <tt/a/,
<item>execute the <tt/a/ instance of <tt/QApplication/.
</enum>

The second object of our program is the pushbutton, an instance of the class <tt/QPushButton/. From the two constructors given to
create an instance, we used the second: this accepts a text, which is the label contents of the button; here, it is the string "Hello
world!". Then we called the <tt/resize()/ method to change the size of the button according to it's contents- the button has to be
larger to make the string completely visible.

But what about the <tt/show()/ method ?  Now, you see that like most other widgets, <tt/QPushButton/ is based on a single-inheritance-
here, the documentation says, <em/Inherits/ <tt/QButton/.  Follow the link to the <tt/QButton/ class. This shows you a lot of other
functions that are inherited by QPushButton, which we'll use later to explain the signal/slot mechanism. Anyway, the <tt/show()/ method
is not listed, therefore, it must be a method that is provided by inheritance as well. The class that <tt/QButton/ inherits, is
<tt/QWidget/. Just follow the link again, and you will see a whole bunch of methods that the <tt/QWidget/ class provides; including the
<tt/show()/ method. Now we understand what was done in the sample with the button:

<enum>
<item>create an instance of <tt/QPushButton/, use the second constructor to set the button's text,
<item>resize the widget to it's contents,
<item>set the widget as the main widget of the <tt/QApplication/ instance <tt/a/,
<item>tell the widget to display itself on the screen by calling <tt/show()/, an inherited method from <tt/QWidget/.
</enum>

After calling the <tt/exec()/ method, the application is visible to the user, showing a window with the button showing "Hello world!".
Now, GUI programs behave somewhat differently than procedural applications. The main thing here is that the application enters a
so-called "main event loop". This means that the program has to wait for user actions and then react to it, also that for a Qt
application, the program has to be in the main event loop to start the event handling. The next section tells you in short what this
means to the programmer and what Qt offers to process user events.

(For already advanced users: The button has no parent declared in the constructor, therefore it is a top-level widget alone and runs in
a local event loop which doesn't need to wait for the main event loop, see the<tt/QWidget/ class documentation)

<bf/Summary:/

A Qt application always has to have one instance of the class <tt/QApplication/. This provides that we can create windows that are the
graphical representation of programs to the user and allow interaction. The window contents itself is called a "Main Widget", meaning
that all graphical elements are based on the class <tt/QWidget/ and can be any type of widget that fits the needs of the application to
communicate with the user. Therefore, all user elements somehow have to inherit <tt/QWidget/ to be visible.

<sect2>User Interaction
<p>
After reading the last sections, you should already know:
<itemize>
<item>What the Qt-libary provides in terms of GUI applications,
<item>how a program using Qt is created and
<item>where and how to find information about classes that you want to use with the documentation browser
</itemize>

Now we'll turn to give the application "life" by processing user events. Generally, the user has two ways to interact with a program:
the mouse and the keyboard. For both ways, a graphical user interface has to provide methods that detect actions and methods that do
something as a reaction to these actions.

The Window system therefore sends all interaction events to the according application. The QApplication then sends them to the active
window as a <tt/QEvent/ and the widgets themselves have to decide what to do with them. A widget receives the event and processes
<tt/QWidget::event(QEvent*)/, which then decides which event has been executed and how to react; event() is therefore the main event
handler. Then, the <tt/event()/ function passes the event to so-called event filters, that determine what happened and what to do with
the event. If no filter signs responsible for the event, the specialized event handlers are called. Thereby we can decide between:

<bf/a) Keyboard events --TAB and Shift-TAB keys:/

changes the keyboard input focus from the current widget to the next widget in the focus order. The focus can be set to widgets by
calling <tt/setFocusPolicy()/ and process the following event handlers:

<itemize>
<item><tt/virtual void focusInEvent ( QFocusEvent * )/
<item><tt/virtual void focusOutEvent ( QFocusEvent * )/
</itemize>

<bf/b) all other keyboard input:/
<itemize>
<item><tt/virtual void keyPressEvent ( QKeyEvent * )/
<item><tt/virtual void keyReleaseEvent ( QKeyEvent * )/
</itemize>

<bf/c) mouse movements:/
<itemize>
<item><tt/virtual void mouseMoveEvent ( QMouseEvent * )/
<item><tt/virtual void enterEvent ( QEvent * )/
<item><tt/virtual void leaveEvent ( QEvent * )/
</itemize>

<bf/d) mouse button actions:/
<itemize>
<item><tt/virtual void mousePressEvent ( QMouseEvent * )/
<item><tt/virtual void mouseReleaseEvent ( QMouseEvent * )/
<item><tt/virtual void mouseDoubleClickEvent ( QMouseEvent * )/
</itemize>

<bf/e) window events containing the widget:/
<itemize>
<item><tt/virtual void moveEvent ( QMoveEvent * )/
<item><tt/virtual void resizeEvent ( QResizeEvent * )/
<item><tt/virtual void closeEvent ( QCloseEvent * )/
</itemize>


Note that all event functions are virtual and protected; therefore you can reimplement the events that you need in your own
widgets and specify how your widget has to react. <tt/QWidget/ also contains some other virtual methods that can be useful in your
programs; anyway, it is sufficent to know about <tt/QWidget/ very well generally.

<sect2>Object Interaction by Signals and Slots
<p>
Now we're coming to the most obvious advantages of the Qt toolkit: the signal/slot mechanism. This offers a very handy and useful
solution to object interaction, which usually is solved by <tt/callback/ functions for X-Window toolkits. As this communication
requires a strict programming and sometimes makes user interface creation very difficult (as refered by the Qt documentation and
explained in <em/Programming with Qt/ by K.Dahlheimer), Troll Tech invented a new system where objects can emit signals that can be
connected to methods declared as slots. For the C++ part of the programmer, he only has to know some things about this mechanism:

<enum>
<item>the classdeclaration of a class using signals/slots has to contain the <tt/Q_OBJECT/ macro at the beginning (without the
semicolon); and have to be derived from the <tt/QObject/ class,
<item>a signal can be emitted by the keyword <tt/emit/, e.g. <tt/emit signal(parameters);/ from within any member function
of a class that allows signals/slots,
<item>all signals used by the classes that are not inherited have to be added to the classdeclaration by a <tt/signals:/ section,
<item>all methods that can be connected with a signal are declared in sections with the additional keyword <tt/slot/, e.g.
<tt/<bf/public/ slots:/ within the classdeclaration,
<item>the meta-object compiler <tt/moc/ has to run over the header file to expand the macros and to produce the implementation (which
is not needed to know.). The output files of <tt/moc/ are compiled as well by the C++ compiler.
</enum>

Another way to use signals without deriving from <tt/QQbject/ is to use the <tt/QSignal/ class- see the reference documentation for
more information and example usage. In the following, we assume you're deriving from <tt/QObject/.


This way, your class is able to send signals anywhere and to provide slots that signals can connect to. By using the signals, you don't
have to care about who's receiving it- just you have to emit the signal and whatever slot wants to connect to it can react to the
emission. Also the slots can be used as normal methods during implementation.

Now, to connect a signal to a slot, you have to use the <tt/connect()/ methods that are provided by <tt/QObject/ or, where available,
special methods that objects provide to set the connection for a certain signal.

<sect3>Sample Usage
<p>
To explain the way how to set up object-interaction, we'll take our first example again and extend it by a simple connection:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

You see, the only addition to give the button more interaction is to use a <tt/connect()/ method:
<tt/connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );/ is all you have to add. What is the meaning now ? The class
declaration of <tt/QObject/ says about the <tt/connect()/ method:

<tt/bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )/

This means, you have to specify a QObject instance pointer that is the sender of the signal, meaning that it can emit this signal as
first parameter; then you have to specify the signal that you want to connect to. The last two parameters are the receiver object that
provides a slot, followed by the member function which actually <em/is/ the slot that will be executed on signal emission.

By using signals and slots, your program's objects can interact with each other easily without explicitely depending on the existance
of the receiver object. You will learn more about using this mechanism for productive usage later in this handbook while working with
the tutorial application <em/KScribble/.


<sect1>What KDE provides
<p>
<sect2>The KDE 1.1.x libraries
<p>
For the time of this writing and due to the fact that KDevelop uses KDE 1.1, I'm refering to the state of the KDE libraries at that
release. The main KDE libraries you'll be using for creating your own KDE applications are:

<itemize>
<item>the KDE-Core library, containing all classes that are non-visible elements and provide functionality your application may use.
<item>the KDE-UI library, containing user interface elements like menubars, toolbars and the like,
<item>the KFile library, containing the file selection dialogs,
</itemize>

Additionally, for specific solutions KDE offers the following libraries:

<itemize>
<item>the KHTMLW library, offering a complete HTML-interpreting widget that is used by various programs like KDEHelp, KFM, KDevelop,
<item>the KFM library, allowing to use the KDE file manager from within your application.
<item>the KAb library, the KAddressBook. Provides Adressbook access for e.g. email applications
<item>the KSpell library, offering widgets and functionality to integrate the use of ISpell, the common spellchecker, in applications
like editors; used for the KEdit application.
</itemize>

Next, we'll have a look at what is needed to turn our first Qt application into a KDE one.

<sect2>Example KDE Application
<p>
In the following, you will see that writing a KDE application is not much more difficult than a Qt application. For the use of KDE's
features, you just have to use some other classes, and you're almost done. As an example, we'll discuss the changed version of the Qt
example from above:

<tscreen><code>
#include <kapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

You see that first we have changed from <tt/QApplication/ to <tt/KApplication/. Further, we had to change the previously used
<tt/setMainWidget()/ method to <tt/setTopWidget/, which <tt/KApplication/ uses to set the main widget. That's it ! Your first KDE
application is ready- you only have to tell the compiler the KDE include path and the linker to link in the KDE-Core library with
-lkdecore.

As you now know what at least the main() function provides generally and how an application gets visible and allows user and object
interaction, we'll go on with the next chapter, where our first application is made with KDevelop- there you can also test everything
which was mentionend before and see the effects.

What you should have looked into additionally until now is the reference documentation for Qt, especially the <tt/QApplication/,
<tt/QWidget/ and <tt/QObject/ class and the KDE-Core library documentation for the <tt/KApplication/ class.


<sect>Creating new Applications<label id="Creating new Applications">
<p>
The KAppWizard, or also called the KDE Application Wizard, is intended to let you start working on new projects with KDevelop.
Therefore, all your projects are first created by the wizard; then you can start building them and extend the already provided source
skelleton. KAppWizard also allows to choose between several project types according to your project's goals:

<itemize>
<item>Normal KDE Application: includes sourcecode for a comlete framestructure of a standard KDE application with support for the
Document-View-Controller model, a menubar, toolbar and statusbar as well as a set of standard documentation based on SGML, KDE-links
and application icons. This is the application type usually needed for a new KDE project.
<item>Mini KDE Application: contains the same general structure as the Normal KDE Application type but with the difference that the
application's code only provides a widget as a window.
<item>Normal Qt Application: works like the normal KDE application by it's code with the difference that the project is based on the Qt
library only and doesn't contain KDE support. This is intended for projects that have to be portable to Windows platforms or that don't
want to require KDE libraries by the end-user.
<item>C++ Application: Is based on the C++ compiler only and runs in a console, therefore doesn't require X-Window.
<item>Custom project: creates an empty project without any sourcecode. This is intended for already existing projects to port to
KDevelop or for projects where you want to start from scratch. Mind that you have to take care for makefiles and configure scripts all
by yourself.
</itemize>

In this chapter we'll see how the KAppWizard can be invoked and what has to be done to generate a KDE application project. This will
also be the initial step of our tutorial, where you will create your first version of <em/KScribble/. For all other project types the
steps are usually the same, just you may not have certain options available.

<sect1>Invoking KAppWizard and Project Generation
<p>
<sect2>Starting KAppWizard and the First Page
<p>
To start with your first KDE application, open KDevelop. Then select "New..." from the "Project"-menu. The KAppWizard starts, and you
see a tree on the first page, containing the project types. When a type is selected, you see a preview how it will look like after the
initial build process. Choose the KDE subtree, Normal type. Then press the "Next" button on the bottom of the first wizard page. This
will switch to the next page, where you have to set the general project options.

<sect2>The Generate Settings Page
<p>
For our first version of <em/KScribble/, enter <tt/KScribble/ as "Projectname". Then select the directory you want to have your project
build in; the default is your home directory. You can enter the path manually or you can as well press the button on the right to
select the directory by a dialog.

Next, you have to enter the Versionnumber. For the first version, set this to <tt/0.1/. It is usual to number new applications that are
in development for the first release lower than 1, and as the initial version will only contain the standard framework, we'll name this
the 0.1 version. During the following chapters, we'll increase this value along with the facilities that <em/KScribble/ will get by our
implementation.

Finally, add your name to the "Author" field and your email adress. We'll leave all other options untouched- they are needed for our
project.

To give you some information about the options, you can press the right mouse button over the options, and you will get a quickhelp
window that describes the option's purpose.

These are:
<itemize>
<item><bf/generate sources and headers:/  generates the application sourcecode
<item><bf/GNU-Standard-Files:/  adds a copy of the GNU-General Public License to the project as well as some standard files for user
infromation when distributing the package.
<item><bf/User-Documentation:/ the user handbook in SGML, already prepared for your project.
<item><bf/API-Documentation:/ creates an initial HTML documentation set for the <bf/A/pplication <bf/P/rogramming <bf/I/nterface.
<item><bf/lsm-File:/ the Linux Software Map, used by distribution sites and contains short information about the project's purpose and
requirements.
<item><bf/.kdelnk-File: / a KDE link that will install your application in the "Applications" tree of the KDE-Panel.
<item><bf/Program-Icon: / an Icon that represents your project and can be used to create a link on the desktop.
<item><bf/Mini-Icon: / a Mini-version of the program icon that represents your application besides it's name in the KDE-Panel and is
shown in your application's dialogs and main-window in the left upper corner.
</itemize>

Now we'll switch to the next page by pressing the "Next" button again to set the template for the header files of your project.


<sect2>The Header and Source Templates
<p>
The header template page allows you to automatically include a preface for your header files, containing the filename, the construction
date, the year of the copyright, also your name and your email adress. You don't have to change those uppercase parts yourself, as
KAppWizard does this automatically and stores the template for this project, so it can be used later again for creating new files.

The second part of the default header template contains a license information. By default, your project is set under the GNU General
Public License, which is also included in the package. This license is used for your souce code's protection against any person that
just copies your sources for his own purpose. The General Public License offers you this license for free and thereby protects your
rights as the author, and is common for distributing free software. To get more information about the license, you should read the
COPYING file in the base directory of your new project later.

Anyway, you may want to choose another license or another header template you're already using for your projects. Therefore you can
either edit the given default template directly. To do this, you're given the template in an editing window. To clear the default page,
select "New", to use another template, select "Load...", which lets you choose the template file.

When you're done, go to the next page by entering "Next". This is the template page for your source files and is generally the same as
the header template page. The only difference is that this template is used for your implementation files.

<sect2>Creating the Project
<p>

Now that you've set all options for <em/KScribble/, select "Next" and press the "Generate" button on the bottom of the wizard window.
If the button is not available, you haven't set all options correctly. To correct any errors, step back in the Wizard with "Back".

Then you'll see what KAppWizard does- he copies all templates to your project directory and creates the new project. After KAppWizard
is finished, the "Cancel" button changes to an "Exit" button to leave the wizard.

After this last step, you're finished with creating a new project. KDevelop then loads it and the treeviews let you browse through the
project's files and classes.


In the next section, we'll discuss how to build and run your first version of <em/KScribble/ and how the sourcecode is organized, so
you have an idea where we are and where we're going to extend the features of <em/KScribble/ in the following chapters.

<sect1>The First Build
<p>
After our project is generated, we'll first make a trip through the sourcode to get a general understanding how the application frame
works. This won't only help to get started but we'll know where to change what in later steps.

When opening the LFV (Logical File Viewer) page on the tree-view, you see some folders that already sort the project files relevant to
the developer. The first two folders are "Header" and "Sources". The Header-folder therefore logically contains all header files of the
project, the Sources-folder all sourcecodes. All other folders are of no interest right now, so we'll turn back here later to see what
they contain.

The two folders then contain the following files:

<bf/Headers:/
<itemize>
<item><bf/kscribble.h :/ contains the class declaration for the class <bf/KScribbleApp/.
<item><bf/kscribbledoc.h :/ contains the class declaration for the class <bf/KScribbleDoc/.
<item><bf/kscribbleview.h :/ contains the class declaration for the class <bf/KScribbleView/.
<item><bf/resource.h :/ contains a macro collection for the menu-ID's
</itemize>

<bf/Sources:/
<itemize>
<item><bf/kscribble.cpp :/ contains the implementation of the class <bf/KScribbleApp/.
<item><bf/kscrbbledoc.cpp :/ contains the implementation of the class <bf/KScribbleDoc/.
<item><bf/kscrbbleview.cpp :/ contains the implementation of the class <bf/KScribbleView/.
<item><bf/main.cpp :/ contains the <bf/main()/ function implementation.
</itemize>

Before diving into the sources, we'll let KDevelop build and run our new application. To do this, select "Make" from the "Build"-menu
or hit the according button on the toolbar. The output window opens from the bottom of KDevelop and lets you see what <tt/make/ does by
the messages it gives us:

<tscreen><code>
1   Making all in docs
2   make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
3   Making all in en
4   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
5   make[2]: Nothing to be done for `all'.
6   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
7   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
8   make[2]: Nothing to be done for `all-am'.
9   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
10  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
11  make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble'
12  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.cpp
13  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.cpp
14  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c 		
    kscribble.cpp
15  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    main.cpp
16  /usr/bin/moc ./kscribble.h -o kscribble.moc.cpp
17  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribble.moc.cpp 		
18  /usr/bin/moc ./kscribbledoc.h -o kscribbledoc.moc.cpp
19  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.moc.cpp
20  /usr/bin/moc ./kscribbleview.h -o kscribbleview.moc.cpp
21  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.moc.cpp

22  /bin/sh ../libtool --silent --mode=link g++  -O0 -g -Wall   -o kscribble -L/opt/kde/lib  -L/usr/X11R6/lib -rpath /opt/kde/lib
    -rpath /usr/X11R6/lib kscribbleview.o kscribbledoc.o kscribble.o main.o kscribble.moc.o kscribbledoc.moc.o kscribbleview.moc.o
    -lkfile -lkfm -lkdeui -lkdecore -lqt -lXext -lX11

23  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble'
</code></tscreen>
<p>
As you see, we've put linenumbers in front of each line, which won't appear in your output; it just makes it easier to describe what
happened during the build now. First of all, <tt/make/ works recursively. That means, it starts from the directory it is invoked in and
then goes into the subdirectories first, returns and processes the next directory. Finally, the directory it was started is processed
and <tt/make/ finishes. Therefore, <tt/make/ starts with the main project directory containing the sources first. In line 1 and 2, you
see how the <tt/make/ process goes into the <tt/docs/ directory, then into the <tt/en/ subdirectory. As there isn't anything to do, it
leaves these directories until it returns to the sourcedirectory <tt/kscribble/ in line 11. Then, the real work starts: <tt/make/
invokes the compiler, here <tt/g++/ to compile the sourcefile <tt/kscribbleview.cpp/. The macro <tt/-DHAVE_CONFIG_H/ says that the file
<tt/config.h/ should be used. This is a file containing macros for the specific platform and application and is located in the main
project directory. The following <tt/-I/ commands add the include path where <tt/g++/ can find the includes it needs. These are the
current directory, the main project directory (by <tt/-I../) and the include path for the KDE, Qt and X11 library header files. The
directories for these include files were determined by the <tt/configure/ script and set in the Makefiles, therefore, the compiler
knows where these are located. Finally, <tt/-O0/ sets the optimization to zero (no optimization), <tt/-g/ enables debugging, <tt/-Wall/
sets the compiler warnings to <tt/all/ and <tt/-c/ tells the compiler to produce an object file, so only compile the file.

This is done for the other sourcefiles of our project as well in lines 13-15. Obviously, our sources are compiled, but instead of
linking the object files of the sources to the final binary, we see some other commands. In line 16, you see that the program "moc" is
called to process the headerfile  <tt/kscribble.h/, with it's output in <tt/kscribble.moc.cpp/. Then, in line 17, this source file is
compiled as well. The same happens with the other project header files until line 21. Now, as the Qt toolkit contains the signal/slot
mechanism, but still stays a C++ implementation, you're using certain keywords that are not originally C++ language, such as the
<tt/signals:/ and <tt/slots:/ declaration in your classes. This gives you the ability to easy allow object communication for all class
objects that inherit the class <tt/QObject/, so you can avoid the usual callback pointer functions. Therefore, the application needs
the sources that implement this functionality, and that is why <tt/moc/ is called. <tt/Moc/ is the Meta Object Compiler of the Qt
toolkit and expands the macro <tt/Q_OBJECT/ of your class declaration and builds the implementation for signals and slots mechanisms by
parsing the header file and producing a source output that has to be included in the binary. As KDevelop projects use <tt/automoc/ to
determine, which header file needs to be processed, you don't have to take care for any call on <tt/moc/ and the C++ compiler on the
moc output files. Just remember the rules that make a class use the signals and slots- inheritance from <tt/QObject/ or any class that
inherits <tt/QObject/ itself, inclusion of the <tt/Q_OBJECT/ macro and the declarations for signals and slots.

Finally, your binary is build by the compiler. The Output binary is called <tt/kscribble/, the linker includes the path for the KDE and
X11 libraries and links the sources against the libraries <tt/kfile, kfm, kdeui, kdecore, qt, Xext/ and <tt/X11/. Then you're done and
make exits.

<sect1>The Source Skeletton
<p>

To gain a concept of how a KDE application works, we'll first have a very close look at the source skeletton already provided by the
Application Wizard. As we already saw, we're having a set of source and header files that build the initial code for the application
and make it ready-to-run. Therefore, the easiest way to explain the code is to follow the implementation line by line as it is
processed during executing the program until it enters the main event loop and is ready to accept user input. Then, we'll have a look
at the fuctionality that enables user interaction and how certain things work. This is probably the best way to explain the framework
and, as it is similar to almost all KDE applications, will enable you to read source codes from other projects as well; additionally,
you will know where to change what part of the code to make your applications behave the way they are designed for.

<sect2>The <tt/main()/ Function<label id="The main() Function">
<p>
As the application begins its execution with entering the <tt/main()/ function, this will be the start for our code exmination. The
<tt/main()/ function of <em/KScribble/ is implemented in the file <tt/main.cpp/ and can also be found using the Class Browser by
selecting the "Globals" folder, subfolder "Functions":

<tscreen><code>
1  #include "kscribble.h"
2
3  int main(int argc, char* argv[]) {
4    KApplication app(argc,argv,"KScribble");
5
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
10   else
11   {
12      KScribbleApp* kscribble = new KScribbleApp;
13      kscribble->show();
14      if(argc > 1){
15        kscribble->openFile(argv[1]);
16      }
17    }
18    return app.exec();
19  }
</code></tscreen>

Now, what happens first is the usual creation of a <tt/KApplication/ object, which gets our application name <em/KScribble/ as a third
parameter. When creating a new <tt/KApplication/, a new <tt/KConfig/ instance is created as well which is connected to a configuration
file in $HOME/.kde/share/config/appname + rc which stores all information we want to use when starting application windows. The name we
passed the constructor of <tt/app/ will be used as the window title later.

Despite of the example code for turning the first Qt application into a KDE one, the following code is somewhat different. After the
<tt/KApplication/ object is present, we're testing if the application is started by the session management of <tt/kdm/ or manuall by
the user. This can be found out when calling <tt/isRestored()/ on the <tt/app/ object, which returns <tt/true/ for session management
and <tt/false/ for a normal start.

As session management is a main feature of KDE applications and widely used by the framework but a lot more to explain, we'll follow
the <tt/else{}/ section first; then we'll come back and explain the session functionality in a later step.

<sect2>User Application Start
<p>
The <tt/else{}/ section now creates an instance of the class <tt/KScribbleApp/ in line 12. This object is called to show itself in line
13 as usual; line 14 determines if a commandline argument has been passed and, as this is usually the name of a file, calls the
<tt/kscribble/ object to open it with <tt/openFile()/.

Note that we didn't call the method <tt/setTopWidget(kscribble)/ for our application- this is already done by the class that <tt/KScribbleApp/
inherits. Now we'll have a look at our <tt/KScribbleApp/ object- what is it and what does it provide already ?  The only thing we know
until now is that it has to be a Widget to represent the user interface in the main window. Let's turn to the class implementation of
<tt/KScribbleApp/, which can be found in the file <tt/kscribble.cpp/ or by a click on the class icon in the Class Browser. As the
instance is created by the constructor.
First of all, we see that it inherits the class <tt/KTMainWindow/, which is a part of the <tt/kdeui/ library. This class itself
inherits <tt/QWidget/, so, as usual, we have a normal widget as the top-level window. <tt/KTMainWindow/ contains a lot of functionality
that the class <tt/KScribbleApp/ makes use of. It provides a menubar, toolbar, statusbar and session management support. The only thing
we have to do when subclassing <tt/KTMainWindow/ is to create all the objects we need and create another widget that is managed by our
<tt/KTMainWindow/ instance as the main view in the center of the window; usually this is the place where the user works like a
text-editing view.

<sect3>The Constructor
<p>
Let's have a look at the code for the constructor and see how the instance is created:

<tscreen><code>
1   KScribbleApp::KScribbleApp()
2   {
3     config=kapp->getConfig();
4	
5
6     ///////////////////////////////////////////////////////////////////
7     // call inits to invoke all other construction parts
8     initMenuBar();
9     initToolBar();
10    initStatusBar();
11    initKeyAccel();
12    initDocument();
13    initView();
14
15    readOptions();
16
17    ///////////////////////////////////////////////////////////////////
18    // disable menu and toolbar items at startup
19    disableCommand(ID_FILE_SAVE);
20    disableCommand(ID_FILE_SAVE_AS);
21    disableCommand(ID_FILE_PRINT);
22
23    disableCommand(ID_EDIT_CUT);
24    disableCommand(ID_EDIT_COPY);
25    disableCommand(ID_EDIT_PASTE);
26  }
</code></tscreen>

We see that our config instance of <tt/KConfig/ now points to the applications configuration, so we can operate
with the configuration file entries later.

Then, all parts of the application that are needed are created by their according member functions that are specific to our main
window:

<itemize>
<item><bf/initMenuBar():/  constructs the menubar,
<item><bf/initToolBar():/  constructs the toolbar,
<item><bf/initStatusBar():/ creates the statusbar,
<item><bf/initKeyAccel():/  sets all keyboard accelerators for our application by the global and application specific keyboard
configuration
<item><bf/initDocument():/ creates the document object for the application window
<item><bf/initView():/      creates the main widget for our view within the main window
<item><bf/readOptions():/  reads all application specific settings from the configuration file and initializes the rest of the
application such as the recent file list, the bar positions and the window size.
</itemize>

Finally, we disable some commands that the user can do, because they should not be available in the current application state.
As we now have a general overview how the application window is created, we will look into the details of how the user elements are
constructed by following the above methods.

<sect3>The Menubar
<p>
As shown above, the menubar of <em/KScribble/ is created by the method <tt/initMenuBar()/. There, we create a set of
<tt/QPopupMenu/s that pop up if the user selected a menuentry. Then, we insert them into the menubar and connect to the entries.

First, we create our <tt/recent_file_menu/, which will contain the names of the last 5 opened files. We have to do this first, because
this menu is inserted into the <tt/file_menu/. Then we add the connection directly- we just retrieve the signal that is emitted by the
menuentry with its entry number and call the <tt/slotFileOpenRecent( int )/, which then calls the right file from the recent file list
to be opened.

Then we create our "File"-menu. This will be the menu that will be visible in the menubar. The standard actions are then inserted into
the popupmenu one by one- first the commands for creating a new file, open a file, close a file etc., finally "E&amp;xit" to close the
application. All menuentries have to be created in the order as they appear later, so we have to keep an eye on which we want to have
at what place. As an example, we look at the following entries:

<tscreen><verb>
file_menu->insertItem(Icon("fileopen.xpm"), i18n("&amp;Open..."), ID_FILE_OPEN );
file_menu->insertItem(i18n("Open &amp;recent"), recent_files_menu, ID_FILE_OPEN_RECENT );
</verb></tscreen>

The first one inserts the "Open..." entry. As we want to have it with an icon, we use the <tt/insertItem()/ method with the icon's
name. To understand the icon loading process, we need to know what or where <tt/Icon()/ is declared- in fact, it is a macro provided by
the class <tt/KApplication/:

<tscreen><verb>
#define Icon(x) kapp->getIconLoader()->loadIcon(x)
</verb></tscreen>
Additionally, it uses the following macro internally to get access to the application object:
<tscreen><verb>
#define kapp KApplication::getKApplication()
</verb></tscreen>

This means that the <tt/KApplication/ object already contains an Icon loader instance- we only have to get access to it; then it will
load the according icon. As our icons are all from the KDE libraries, we don't have to take care for anything else- they are installed
on the sytem automatically, therefore we also don't have to include them into our application package to use them.

After the icon parameter (which is optional), we insert the menuentry name by <tt/i18n("&amp;Open...")/.  There, we have to watch two
things: first, the entry is inserted with the <tt/i18n()/ method. Like the <tt/Icon()/ entry, it is a macro defined in <tt/kapp.h/ as
well and calls the <tt/KLocale/ object of <tt/KApplication/ to translate the entry to the currently used language:

<tscreen><verb>
#define i18n(X) KApplication::getKApplication()->getLocale()->translate(X)
</verb></tscreen>

Hereby, it should be mentioned that one could think "I don't want to use macros"- you can do that in most cases. But here it is
immanent to use <tt/i18n()/ because for internationalization the according language files have to be build. As this build process
depends on the <tt/i18n/ string, you have to use the macro.

As you might have already guessed, the ampersand within menuentries is later interpreted as a line under the following letter in the
menuentry. This allows fast access to the menu command via the keyboard when the user presses the <tt/Alt/-key in conjuction with the
underlined letter.

Finally, we're giving the menuentry an ID, which is an integer value by which we can find the entry later. To keep
an overview over the used values, these are defined by macros and are collected in the file <tt/resource.h/ within your project. For
consistancy, these macros are all uppercase and begin with ID_, then the menu name followed by the entry. This makes it very easy to
remember the sense of each entry anywhere within the code, so you don't have to turn to the menubar implementation again to look up the
entries.

The second example entry shows another variant of the <tt/insertItem()/ method. Here, we add  the recent_files_menu popupmenu as a
menuitem. This means, that the entry shows itself with the given string "Open recent", followed by a right arrow. On selection, the
recent file popupmenu appears and the user can choose the last file.

Last but not least there are a lot of other ways to insert menuitems- the framework keeps this as simple as possible. More information
can be obtained in the Qt documentation about the <tt/QMenuData/ class.

Now, after we created the popupmenus <tt/file_menu, edit_menu/ and <tt/view_menu/, we have to include a "Help"-menu as well. We could
do this like the others as well, but the <tt/KApplication/ class offers a nice and quick method to cover this:

<tscreen><verb>
help_menu = kapp->getHelpMenu(true, i18n("KScribble\n" VERSION ));
</verb></tscreen>

This is all we have to do to get a help menu that contains an entry for the help contents with the F1 keyboard shortcut, an aboutbox
for the application and an aboutbox for the KDE (which can be disalbed by calling <tt/getHelpMenu(false,...);/).  The contents for our
applications aboutbox is set with the <tt/i18n()/ string again- VERSION takes the macro that is defined for the project version number
in the file <tt/config.h/, so we don't have to change this every time manually when we want to give out a new release. Feel free to add
any information about your application here, e.g. your name, email adress, copyright and the like.

Now we only have to insert the popups into the menubar. As <tt/KTMainWindow/ already constructs a menubar for us, we just insert them
by calling <tt/menuBar()->insertItem();/.

What is left to do is to connect the menuentries with the methods they will execute. Therefore, we connect each popup menu by its
signal <tt/activated( int )/ to a method <tt/commandCallback( int )/, which contains a <tt/switch/ statement that calls the according
methods for the menu entries. Additionally, we connect the popups by their signal <tt/highlighted( int )/ to provide statusbar help on
each entry. Whenever the user moves his mouse or keyboard focus to an entry, the statusbar then shows the according help message.

After we finished with the menubar, we can continue with the toolbar in the following section. Mind that an instance of a
<tt/KTMainWindow/ can only have one menubar visible at a time; therefore if you want to construct several menubars, you have to create
them seperately with instances of <tt/KMenuBar/ and set one of them by the according methods of <tt/KTMainWindow/ as the current
menubar. See the class documentation of <tt/KMenuBar/ for more detailed information about how to extend the features, also see <ref
id="Configuring Menubars and Toolbars" name="Configuring Menubars and Toolbars">.

<sect3>The Toolbar
<p>
The creation of toolbars now is even simpler than that of menubars. As <tt/KTMainWindow/ already provides toolbars, which are created
by the first insertion, you are free to create several ones. Just add the buttons for the functions you want to provide:

<tscreen><verb>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</verb></tscreen>

This adds a left-aligned button with the icon "filenew.xpm" with the according ID to the toolbar. The third parameter decides if the
button should be enabled or not; by default we set this to <tt/true/, because our <tt/disableCommand()/ methods at the end of the
constructor do this for us automatically for both menu and toolbar entries. Finally, the last parameter is uses as a so-called
"QuickTip"- when the user moves the mouse pointer over the button so that it gets highlighted, a small window appears that contains a
short help message, whose contents can be set here.

Finally, all toolbar buttons are connected to our <tt/commandCallback()/ method again by their signal <tt/clicked()/. On the signal
<tt/pressed()/, we let the user receive the according help message in the statusbar.

<bf/Additional Information:/

As toolbars are created using the class <tt/KToolBar/, you should have a look at the according documentation. With <tt/KTooBar/, a lot
of things needed in a toolbar can be realized such as delayed popups if your button wants to pop up a menu when the button keeps being
pressed or even widgets like combos. Also, by default, the toolbar fills the complete width of the window, which makes it look nice for
using a single bar. When using more than one, you should also think about setting the bar size to end at the most right button, so
other bars can be displayed in the same row below the menubar. We will discuss certain techniques about designing and extending
toolbars in section <ref id="Configuring Menubars and Toolbars" name="Configuring Menubars and Toolbars">.

<sect3>The Statusbar
<p>
The statusbar is, as well as the other bars, already provided by the <tt/KTMainWindow/ instance, so we just have to insert our items as
we want to. By default, the framework contains only one entry that displays statusbar help. For a lot of applications this may not
last; then you would add the entries you need for displaying e.g. coordinates and the like.

Also, an application can only have one statusbar at a time like a menubar. If you want to construct several ones, you should create
them seperately and set the current bar by the according method of <tt/KTMainWindow/.  The statusbar also offers to insert widgets,
which can be used to produce nich habbits for displaying progressbars like KDevelop does. Refer to the class documentation of
<tt/KStatusBar/.

<sect3>Keyboard Accelerators
<p>
With reaching the method <tt/initKeyAccel()/, we already constructed the standard items of an application main window- the menubar,
toolbar and statusbar. Indeed, we didn't set any keyboard accelerators by which advanced users that only want to work with the keyboard
have a quick access to certain commands that are used most often during work with our program. To do this, we could have inserted the
accelerator keys by the insertion of the menuitems for example, but KDE offers a good solution to construct and maintain keyboard
accelerators. A lot of users want to have them configurable on one hand and on the other standard accelerators should be the same over
all applications. Therefore, the KDE controll center offers configuring standard keyboard accelerators globally by using the
<tt/KAccel/ class. Additonally, the KDE libaries contain a widget that lets users configure application specific keyboard shortcuts
easily. As the application framework only uses menuitems that have standard actions such as "New" or "Exit", these are set by the
method <tt/initKeyAccel()/. Standard actions just have to be connected, for your application specific keyboard values, you have to
insert them first by specifying the keyboard accelerator name and then connect them. As our accelerators are all present in the
menubar, we have to change the accelerators for the popup entries. Finally we call <tt/readSettings()/, which reads the current
settings from the root window of KDE containing the configuration of standard accelerators, then the settings for accelerators
specified in the application's config file. When we're going further into our example project, we will also talk about how to configure
our application specific accelerators by a configuration dialog, see <ref id="Configuring Menubars and Toolbars" name="Configuring
Menubars and Toolbars"> for that part of the development process.

<sect3>The Document-View Model
<p>
The next two member function calls, <tt/initDocument()/ and <tt/initView()/, are finally building the part that the application
windows are supposed to provide to the user: an interface to work with data that the application is supposed to manipulate; and that is
also the reason why the application framework contains three classes, an <tt/*App/, <tt/*View/ and <tt/*Doc/ class. To understand, why
this structure is helpful, we'll look a bit aside the actual code and introduce some theory, then we'll switch to the program again to
see how the KDevelop frameworks support such a model.

Basically, all what has been explained about the framework is that we need an application instance that contains a main window. This
window is responsible to provide the basic interface for the user- it contains the menubar, toolbars and statusbar and the event
controlling for user interaction. Also, it contains an area, that is described as a "view". Now, the purpose of a view is generally, to
display the data that the user can manipulate, e.g. a part of a text file. Although the textfile is probably larger than the view is
able to display on the screen, it offers the user to go to the part that he wants to see (therefore it is a view), and there the user
can as well change the data of the file contents. To give the programmer a better way to separate parts of the application by code, the
Document-View Model has been invented. Although not a standard, it provides a structure how an application should work:

<itemize>
<item> The application contains a controller object,
<item> a View object that displays the data the user works with
<item> and a Document object that actually contains the data to manipulate.
</itemize>

Back to the example of working with a textfile- there, this model would work the way that the Document would read the file contents and
provides methods to change the data as well as to save the file again. The view then processes the events that the user produces by the
keyboard and the mouse and uses the document object's methods to manipulate the document data.

Finally, the controller object is responsible for user interaction by providing the document and the view objects as well as the
interfaces to send commands like opening and saving. Additonally, certain methods of the view object can be provided by commands that
can be accessed via keyboard accelerators or the mouse on menubars and toolbars.

This Document-View model has some advantages- it separates the program's code more object-oriented and by this offers more flexibility
in general, e.g. the same document object could be displayed by two views at the same time; either by a new view in a new window or by
tiling the current one that then contains two view object that build the acutal window view region.

Now, if you're coming from MS-Windows systems you may have some experience with that- the MFC already provide a document model that is
ready to use. For KDE and Qt applications, things are a bit different. Qt is a powerful toolkit as it provides the most needed classes,
widgets etc. But there wasn't any intention to take care of the document-view model, and as KDE is inheriting Qt, there weren't any
tendencies to introduce such a model either. This somehow has its reason in the fact that usually X-applications don't work with an MDI
(Multiple Document Interface).  Each main window is responsible for it's data and that reduces the need of a document model to the fact
that methods to work on documents are always implied into widgets. The only exception from this currently is the <em/KOffice/ project
that is intended to provide a complete office suite of applications like a word processor, a spreadsheet etc. Technically, this is
realized by two changes two the normal usage of Qt and KDE:

<itemize>
<item>KOffice uses KOM and the free MICO implementation of CORBA for object communication,
<item>the KOffice applications use a document-view model to allow all applications to work with any KOffice data objects
</itemize>

But as currently KDevelop aims on the use of the current libraries of KDE 1.1.x and Qt 1.4x, we can't use this model by default- this
will come in further releases for KDE 2, which will (hopefully) contain two new major changes in relation to the current situation:

<enum>
<item>an MDI interface for KTMainWindow that allows child windows within the mainwindow,
<item>the KOM libraries that provide a document model
</enum>

Therefore, the current way for application developers can be to either implement all needed document methods within their view or to
try to reproduce a document model by themselves. KDevelop therefore contains such a reproduction by providing the needed classes and
the basic methods that are generally used for a Document-View model with the application frameworks for Qt and KDE.

Back to the code, you now can imagine the purpose of the two methods we mentioned at the beginning of this section: the
<tt/initDocument()/ and <tt/initView()/ functions. The <tt/initDocument()/ constructs the document object that represents the
application window data and initializes the basic attributes like setting the modification bit that indicates if the data currently
used has been changed by the user. Then, the <tt/initView()/ method constructs the <tt/*View/ widget, connects it to the document and
calls the <tt/setView()/ method of <tt/KTMainWindow/ to tell the <tt/*App/ window to use the <tt/*View/ widget as it's center view.

For the developer, it is important to know that during the development process he has to:

<itemize>
<item>reimplement the virtual methods for mouse and keyboard events provided by <tt/QWidget/ in the <tt/*View/ object to provide the
means to manipulate data,
<item>reimplement the <tt/paintEvent()/ of <tt/QWidget/ in the <tt/*View/ object to repaint() the view after changes,
<item>complete the implementation for printing the document via the printing method of the <tt/*View/ object,
<item>add the serialization for the <tt/*Doc/ object to provide file loading and saving,
<item>add the document data structure implementation to the <tt/*Doc/ object that is representing the document data logically in the
memory.
<item>add any methods that have to be accessible by the user via accelerator keys and menus/toolbars.
</itemize>

During the development of our sample application <em/KScribble/, we'll go further into this development process and complete the
application framework according to our program's special needs.

<sect3>Application Configuration
<p>
Now, after we created all instances of the <tt/KTMainWindow/ instance of our application to create the first window, we have to
initialize certain values that influence the look of the program. For this, we call <tt/readOptions()/, which gets all values and calls
the methods needed to set the according attributes. The KDE-Core library contains the class <tt/KConfig/ that provides a good
possiblity to store values in configuration files as well as to read them in again. Also, as each <tt/KApplication/ instance creates
it's resource file already, we only have to access this file and create our values. As <tt/KConfig/ provides us the file object, we
have to use the class <tt/KConfigBase/ to read and write all entries. As writing is very easy to do with <tt/writeEntry()/ methods,
reading depends on the attribute type which we want to initalize. Generally, an entry in the configuration file contains a value name
and a value. Values that belong together in some context can be collected in groups, therefore we have to set the group name before we
access the value afterwards; the group has to be set only once for reading a set of attributes that are in the same group.

Let's have a look at what we want to read in:
<tscreen><code>
1   void KScribbleApp::readOptions()
2   {
3
4      config->setGroup("General Options");
5
6      // bar status settings
7      bool bViewToolbar = config->readBoolEntry("Show Toolbar", true);
8      view_menu->setItemChecked(ID_VIEW_TOOLBAR, bViewToolbar);
9      if(!bViewToolbar)
10       enableToolBar(KToolBar::Hide);
11
12     bool bViewStatusbar = config->readBoolEntry("Show Statusbar", true);
13     view_menu->setItemChecked(ID_VIEW_STATUSBAR, bViewStatusbar);
14     if(!bViewStatusbar)
15       enableStatusBar(KStatusBar::Hide);
16
17     // bar position settings
18     KMenuBar::menuPosition menu_bar_pos;
19     menu_bar_pos=(KMenuBar::menuPosition)config->readNumEntry("MenuBar Position", KMenuBar::Top);
20
21     KToolBar::BarPosition tool_bar_pos;
22     tool_bar_pos=(KToolBar::BarPosition)config->readNumEntry("ToolBar Position", KToolBar::Top);
23
24     menuBar()->setMenuBarPos(menu_bar_pos);
25     toolBar()->setBarPos(tool_bar_pos);
26
27     // initialize the recent file list
28     recent_files.setAutoDelete(TRUE);
29     config->readListEntry("Recent Files",recent_files);
30
31     uint i;
32     for ( i =0 ; i < recent_files.count(); i++){
33       recent_files_menu->insertItem(recent_files.at(i));
34     }
35
36     QSize size=config->readSizeEntry("Geometry");
37     if(!size.isEmpty())
38       resize(size);
39   }
</code></tscreen>

As we have seen in one of the above code parts, the first action our constructor does was:

<tscreen><verb>
config=kapp->getConfig();
</verb></tscreen>

which sets the <tt/KConfig/ pointer <tt/config/ to the application configuration. Therefore, we don't have to care for the location of
the configuration file. Indeed, the file is, according to the KDE File System Standard (KDE FSS), located in
<tt>&dollar;HOME/.kde/share/config/</tt>; we will have a closer look about the KDE FSS in a later step when we're setting installation
locations for project files. As the config file is placed in the user's home directory, each user has it's own appearance of his
application except for values that are located in a system wide configuration file that can optionally be created and installed by the
programmer in the KDE directory. But, although this could help in some cases, we should avoid any dependecy of our application towards
the existing of file entries. Therefore, all read methods provided by <tt/KConfigBase/ allow to add a default value to be used when the
entry doesn't exist. Another thing important to a programmer is that the configuration file is stored in plain text, and this is for
some reasons as well as you have to watch some criterias:
<itemize>
<item>the user is able change the configuration file by a plain text editor
<item>if the user wants to chage values by hand, the entries should be very transparent to determine their purpose
<item>for entries that have to be saved, but are critical in terms of security like passwords, you have to look for a proper solution
to ensure the security.
</itemize>
Now that we know the basics, we're going to analyze the code. As said, we only have to use our config pointer
to access the values. First, in line 4, we set the current goup to "General Options". This indicates that the values used are somewhat
general attributes for the application. Then we read the values for the toolbar and statusbar- these have to be saved when the
application closes to restore their status again when the user restarts the program. As the bars can only be on or off, we use a
boolean value, therefore, our method is <tt/readBoolEntry()/. The process is identical for both bars, so we only have a look at the
lines 7-10 to watch what's happening for the toolbar. First, we read the value into the temporary variable <tt/bViewToolbar/ at line 7.
The value name in the file is "Show Toolbar" and, if the value is not present (which would be the case the first time the application
starts), the default value is set to <tt/true/. Next, we set the checkmark for the menuentry for en-/disabling the toolbar by this
value: we call <tt/setItemChecked()/ on the view menu, enty <tt/ID_VIEW_TOOLBAR/ with our attribute. Finally, we set the toolbar to use
the value. By default, the toolbar is visible, therefore, we only have to do something if <tt/bViewToolbar/ is <tt/false/. With
<tt/enableToolBar()/ (line 10) we're setting the bar to hide itself if it is disabled.

Next, we have to read the bar positions. As the user might have changed the bar position by dragging a bar with the mouse to
another view area, these have to be saved as well and their status restored. Looking at the classes <tt/KToolBar/ and <tt/KMenuBar/,
we see that the bar positions can be:
<tscreen><verb>
enum BarPosition {Top, Left, Bottom, Right, Floating, Flat}
</verb></tscreen>
As this value has been written in a numeric value, we have to read it with <tt/readNumEntry()/ and convert it to a position value. With
<tt/setMenuBarPos()/ and <tt/setBarPos()/ we tell the bars where to show up.

Now you probably have noticed that our "File" menu contains an menu for recently used files. The filenames are stored in a list of
strings, which has to be saved on application closing and now has to be read in to restore the menu. First, we initialize the list
with the entries stored by using the <tt/readListEntry()/. Then, in a <tt/for-/loop, we create a menu entry for each list item.

Finally, we only have to take care for the geometry of our window. We read in the appearance by a <tt/QSize/ variable containing an x
and y value for width and heigth of the window. As the window is initialized by <tt/KTMainWindow/, we don't have to take care for a
default value and only will use <tt/resize()/ if the entry is not empty.

What is left to explain on application construction is that we initially have to disable available user commands that shouldn't be
available if some instances don't match the needed criteria. These are file saving and operations that are using the clipboard. During
the application's lifetime, we have to take care of these several times, but which is quite easy. The framework only gives us two
methods to enable/disable menubar and toolbar items with one method call at the same time.

<sect3>Executing
<p>
During the past section, we have only monitored what happens during the constructor call of our <tt/KScribbleApp/ instance providing us
the main window. After returning to the <tt/main()/ function, we have to call <tt/show()/ to display the window. What is different from
any <tt/KApplication/ or <tt/QApplication/ here is that when we're using <tt/KTMainWindow/ as the instance for our main widget, we
don't have to set it with <tt/setMainWidget()/. This is done by <tt/KTMainWindow/ itself and we don't have to take care of that.

The only thing left then is to interpret the commandline. We get the commandline option and ask, if <tt/int argc/ is > 1, which
indicates that the user called our application with <tt/kscribble filename_to_open/. Our window is then asked to open the file by it's
name and calls <tt/openDocumentFile()/ with the filename.

The last line of the <tt/main()/ function does the known job: it executes the application instance and the program enters the event
loop.

Now, in section <ref id="The main() Function" name="The main() Function">, we started to separate the execution process by
<tt/if( app.isRestored() )/ and described the usual invocation process. The following now gives an introduction to session
management and how our application makes use of this.

<sect2>Invocation by Session Management
<p>
As we said, the <tt/main()/ function tests, if the application is invoked by the session manager. The session manager is responsible to
save the current status of all open application windows on the user's desktop and has to resore them when the user logs in the next
time, which means that the application is not started by the user but automatically invoked. The part of the code which is executed
was:
<tscreen><verb>
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
</verb></tscreen>

In <ref id="The main() Function" name="The main() Function">, we stated that we test the invocation by asking
<tt/app.isRestored()/. Then line 8 gets executed. It looks like a simple statement, but in fact this will result in a complex execution
process which we want to follow in this section.

RESTORE() itself is a macro provided by <tt/KTMainWindow/. It expands to the following code:

<tscreen><verb>
if (app.isRestored()){
  int n = 1;
  while (KTMainWindow::canBeRestored(n)){
    (new KScribbleApp)->restore(n);
    n++;
  }
}
</verb></tscreen>

This will restore all application windows of the class <tt/KScribbleApp/ by creating the instances and calling <tt/restore()/ to the
new window. It is important to realize that if your application uses several different widgets that inherit <tt/KTMainWindow/, you have
to expand the macro and determine the type of the top widgets by using <tt/KTMainWindow::classNameOfToplevel(n)/ instead of the class
<tt/KScribbleApp/.
The <tt/restore()/ method then reads the part of the session file that contains the information about the window. As <tt/KTMainWindow/
stores all of this for us, we don't have to care for anything else. Only information that belong to our specific instance of
<tt/KScribbleApp/ has to be found then. Usually this would be a temporary file that we created to store the document or other
initialization that we might need. To get to this restoration information, we only have to overwrite two virtual methods of
<tt/KTMainWindow/, <tt/saveProperties()/ and <tt/readProperties()/. The information we have to save on session end is if the currently
opended document is modified or not and the filename. If the file is modified, we will get a temporary filename to save it to. On
session beginning, this information now is used to restore the document contents:

<tscreen><verb>
void KScribbleApp::readProperties(KConfig*)
{
  QString filename = config->readEntry("filename","");
  bool modified = config->readBoolEntry("modified",false);
  if( modified ){
    bool b_canRecover;
    QString tempname = kapp->checkRecoverFile(filename,b_canRecover);

    if(b_canRecover){
      doc->openDocument(tempname);
      doc->setModified();
      QFileInfo info(filename);
      doc->pathName(info.absFilePath());
      doc->title(info.fileName());
      QFile::remove(tempname);
    }
  }
  else if(!filename.isEmpty()){
  doc->openDocument(filename);
  }
  setCaption(kapp->appName()+": "+doc->getTitle());
}		
</verb></tscreen>
Here, the line <tt/kapp->checkRecoverFile()/ seems a bit strange, as <tt/b_canRecover/ is not initialized. This is done by the method
which sets it to <tt/true/, if there is a recover file. As we only saved a document in a recover file if it was modified, we set the
modified bit directly to indicate that the information hasn't been saved to the belonging file. Also we have to take care that the
recover file has another filename than the original file which was opened. Therefore, we have to reset the filename and path to the old
filename. Finally, we have the information we wanted to recover and we can delete the temporary file by the session manager.

<bf/Summary:/

During this chapter, you got to know how the application starts either by normal user invocation or by the session manager. We went
through the code to learn how the parts of the visual interface of the application are constructed as well as how to initialize
attributes by configuration file entries. Now you can execute the framework application to test these functions and see how the
program window reacts.

<sect1>Additional Contents of KDevelop Projects
<p>
Besides the sourcecode provided, KDevelop projects contain a lot of other additional parts that are of interest to the developer. These
are:
<itemize>
<item>a program icon
<item>a program mini-icon
<item>a .kdelnk file
<item>a sample SGML-documentation file
<item>a set of API-documentation generated from the framework source
</itemize>

Except the API-documentation, these elements of the project will be installed together with the application binary. As the project
framework has to be as open as possible, you have to adapt these parts towards your project goals. These are first to edit the icons
provided. This will give your application a unique identifyer by which the user can determine your application visually in window
manager menus. The .kdelnk file then is a file that installs your application into <tt/kpanel/ in the <tt/Applications/ menu. This has
to be edited by setting the installation path which will be discussed later in this handbook. Finally, the documentation that you will
provide to the user is written in SGML. This makes it very easy to create several different output from the same source. By default,
KDevelop offers to create a set of HTML files from this source, for KDE-projects this will automatically use the <tt/ksgml2html/
program to add a consistent KDE look and feel to the documentation. In a later section, we will see how the SGML source is edited and
what we have to watch for installation on the end-user.

Finally, the API (Application Programming Interface) documentation allows you and other developers to quickly get into the code and use
the classes without having to guess what purpose each class is for. We will learn how to extend the API documentation in a later step,
for now it lasts to know that the documentation is generated by the <tt/KDoc/ program, which processes the header files and creates the
HTML output, therefore all documentation is placed in the headers.

<sect>Application View Design
<p>
When developing an application with a graphical user interface, the main work takes place in providing a so-called "view" for the
application. A view generally is a widget that displays the data of a document and provides methods to manipulate the document
contents. This can be done by the user via the events he emits by the keyboard or the mouse; more complex operations are often
processed by toolbars and menubars which interact with the view and the document. The statusbar then provides information about the
document, view or application status. As an example, we look at how an editor is constructed and where we can find which part.

An editor generally is supposed to provide an interface to view and/or change the contents of a text document for the user. If you
start <em/KEdit/, you see the visual interface as the following:

<itemize>
<item>The menubar: providing complex operations as well as opening, saving and closing files and exiting the application.
<item>The toolbar: offers icons which allow quicker access for most needed functions,
<item>The statusbar: displays the status of the cursor position by the current row and column,
<item>The view in the center of the window, displaying a document and offering a cursor connected to the keyboard and the mouse
to operate on the data.
</itemize>

Now it's easy to understand, that a view is the most unique part of the application and the design of the view decides about the
usablity and acceptability of an application. This means that one of the first steps in development is to determine the purpose of the
application and what kind of view design would match best to allow any user to work with the application with a minimum of work
learning how to handle the user interface.

For some purposes like text editing and displaying HTML files, views are provided by the Qt and KDE libraries; we will discuss certain
aspects of these high-level widgets in the next section. But for most applications new widgets have to be designed and implemented. It
is that what makes a prgrammer also a designer and where his abilities on creativity are asked. Nevertheless, you should watch for
intuitivity first. Remember that a lot of users won't accept an application that isn't

<itemize>
<item>graphically nice,
<item>offering a lot of features,
<item>easy to handle,
<item>fast to learn how to use it.
</itemize>
Needless to say that stability is a mayor design goal. Nobody can prevent bugs, but a minimum can be reached at least by clever design
goals and wide use of object-oriented design. C++ makes programming a joy if you know how to exploit it's capabilities- inheritance,
information hiding and reusablitity of already existing code.

When creating a KDE or Qt project, you always have to have a view that inherits <tt/QWidget/, either by direct inheriance or because
the library widget you want to use inherits <tt/QWidget/. Therefore, the Application Wizard already constructed a view that is an
instance of a class <tt/&lt;yourapp&gt;View/, which inherits <tt/QWidget/ already. The application creates your view in the method
<tt/initView()/, where an instance is created and connected to the main widget as it's view with <tt/KTMainWidget::setView()/.

This chapter therefore describes how to use library widgets for creating views of KDE or Qt applications that are generated with
KDevelop, then we're looking at the libraries and what kind of views are already offered. Finally, we will extend the already provided
view class of <em/KScribble/, <tt/KScribbleView/ in section <ref id="Creating your own Views" name="Creating your own Views">.

<sect1>Using Library Views
<p>
When your application design has been set up, you first should look for already existing code that will make your life a lot easier. A
part of this search is to look for a widget that can be used as a view or at least as a part of it; either directly or by inheritance.
The KDE and Qt libraries already contain a set of widgets that can be used for this purpose. To use them, you have two options:

<enum>
<item> remove the new view class and create an instance of a library widget; then set this as the view,
<item> change the inheritance of the provided view class to the class of the library widget to use.
</enum>

In either way, it is important to know that if the application framework is currently not linked against the library that contains the
widget, the linker will fail. After you decided to use a certain widget, look for the library to link to; then open
"Project"->"Options" from the KDevelop menubar. Switch to the "Linker Options" page and look for the checkmarks indicating the
libraries that are currently used. If the library of your view widget is already checked, you can leave the project options untouched
and start doing the necessary changes due to your choice. If not, and the linker options offer to add the library by a checkbox,
check it and press "OK" to leave the project options dialog again. In any other case, add the library in the edit line below with the
<tt/-l/ option. For libraries that your application has to search for before preparing the Makefiles by the <tt/configure/ script on
the end-user machine, add the according search macro to the <tt/configure.in/ file located at the root directory of your project and
add the macro to the edit line. Mind that you have to run "Build"->"Autoconf and automake" and "Build"->"Configure" before the
Makefiles contain the correct expansion for the library macro.

Also, if the include files for the library to add are not in the current include path (which can be seen by the <tt/-I/ options in the
output window on "Make"), you have to add the path to the Project Options dialog -"Compiler Options" page with the <tt/-I/
option or the according automake macro at the edit line for "Additional Options".

<sect2>Qt Views
<p>
Looking at the first page of the Qt online documentation, you will find a link to "Widget Screenshots" where you can have a look at
how the widgets Qt contains look like. These are ready to use and can be combined together to form complex widgets to create
application views or dialogs. In the following, we'll discuss some of these which are very usable for creating application views, but
keep in mind that the KDE libraries sometimes contain other widgets for the same purpose; those will be reviewed in the next section.

Here are a set of hints for what purpose you could use which Qt component:
<enum>
<item>if your view area isn't big enough to display all your data, the user must be enabled to scroll over the document with bars on
the left and bootom of the view. For this, Qt provides the class <tt/QScrollView/, which offers a scrollable child area. As explained,
you could inherit your own widget from <tt/QScrollView/ or use an instance to manage your document's view widget.
<item>to create a ScrollView yourself, inherit the View widget from <tt/QWidget/ and add vertical and horizontal <tt/QScrollBar/s.
(this is done by KDE`s KHTMLView widget).
<item>for text processing, use <tt/QMultiLineEdit/. This class provides a complete text editor widget that is already capable to cut,
copy and paste text and is managed by a scrollview.
<item>use <tt/QTableView/ to display data that is arranged in a table. As <tt/QTableView/ is managed by scrollbars as well, it offers a
good solution for table calculation applications.
<item>to display two different widgets or two widget instances at the same time, use <tt/QSplitter/. This allows to tile views by
horizontal or vertical deviders. Netscape's Mail window is a good example how this would look like- the main view is separated by a
splitter vertically, the right window then is devided again horizontally.
<item><tt/QListView/ displays information in a list and tree. This is useful for creating file trees or any other hierarchical
information you want to interact with.
</enum>

You see that Qt alone offers a whole set of widgets which are ready to use so you don't have to invent new solutions if these match
your needs. The sideeffect when using standard widgets is that users already know how to handle them and only have to concentrate on
the displayed data.

<sect2>KDE Views
<p>
The KDE libraries were invented to make designing applications for the K Desktop Environment easier and capable of more functionality
than what Qt alone is offering. To see what's available, we have a look at the documentation tree in KDevelop. You see that the KDE
libraries start with <tt/kdecore/, which is a base for all KDE applications. Then,<tt/kdeui/ offers user interface elements. This is
where we will find some useful things first. For creating new applications, the <tt/kdeui/ library offers:

<enum>
<item><tt/KTabListBox/: offers a multi-column listbox where the user can change the rows with drag'n drop.
<item><tt/KTreeList/: inherited from <tt/QTableView/, offering a collapsable tree. This could be used instead of <tt/QListView/.
<item><tt/KEdit/: the base classes for the <em/KEdit/ application offered with KDE. This could be used instead of <tt/QMultiLineEdit/.
<item><tt/KPanner/ and <tt/KNewPanner/: manage two child widgets like <tt/QSplitter/.
</enum>

The <tt/khtmlw/ library on the other hand offers a complete HTML-interpreting widget that is ready to use. It is scrollable already,
so you don't even have to take care for that. A possible use could be to integrate it as a preview widget for an HTML editor; used by
applications such as KFM, KDEHelp and KDevelop to display HTML files.

Now that you have a general overview of what is already provided, you may notice that for a lot of purposes already existing widgets
can be used or combined together. KMail is an example as well as KDevelop itself makes use of library view components to display data.
But for applications such as drawing programs or syntax-coloring editors, those can only be the beginning. In those cases, you often
have to derive your view from an existing view or from <tt/QWidget/ to display your data and allow manipulation. As our example
application <em/KScribble/, will be a small drawing program, we don't have any choice: we as well have to use <tt/QWidget/; therefore
we can leave our framework untouched and start extending the implementation of the class <tt/KScribbleView/ until it is capable of
offering user input. During the next section, we will do that by overwriting virtual methods provided by <tt/QWidget/ for user event
handling; then we will connect certain functions to the toolbar and menubar and connect these to our widget.

<sect1>Creating your own Views<label id="Creating your own Views">
<p>

<sect>Configuring Menubars and Toolbars<label id="Configuring Menubars and Toolbars">
<p>
<sect1>How does it work ?
<p>
<sect1>Adding a new menu
<p>
<sect1>Integrating Toolbar buttons
<p>
<sect1>Configuring Statusbars
<p>
<sect1>Keyboard Accelerator Configuration
<p>

<sect>The Dialogeditor: Where your Dialogs are Build
<p>
<sect1>What the Dialogeditor provides
<p>
<sect1>Qt and KDE Widgets
<p>
Currently provided widgets are:

<bf/QT-Widgets:/
<itemize>
<item><bf/QWidget/ - a widget that can be specified by yourself and can contain other widgets as well. This allows creating a widget
hirarchy within your dialog.
<item><bf/QLabel/ - a label that represents text information on the widget. Use QLabel e.g. in front of lineedits to signal what the
purpose of the lineedit is or which varialbe e.g. a combo box allows to set.
<item><bf/QPushButton/ - a button that allows to e.g. call another dialog like QFileDialog for selecting a filename.
<item><bf/QCheckBox/ - a checkbox for e.g. enableing/disableing options. QCheckBox is widely used for configuration dialogs.
<item><bf/QLCDNumber/ - displays numbers in LCD style. Often used for clocks.
<item><bf/QRadioButton/ - like QCheckBox often used to let the user set any options. QRadioButton specializes the options setting when more
of them depend on each other, e.g. you have three radiobuttons, but ony want the user to choose one of three offered options.
<item><bf/QComboBox/ - a combo box lets the user set a value by selecting it from a drop-down menu or by inserting the value, if the
box is write enabled.
<item><bf/QListBox/ - provides a single-column list of items that can be scrolled.
<item><bf/QListView/ - creates a multi-column list view that can be used to display e.g. file trees etc. in tree and table view.
<item><bf/QMultiLineEdit/ - offers a multi-line editor.
<item><bf/QProgressBar/ - displays the progress of an action that takes a longer time to be finished.
<item><bf/QSpinBox/ - allows choosing numeric values by up- and down buttons or insertion if write enabled.
<item><bf/QSlider/ - sets a value in a program-defined range by a slider.
<item><bf/QScrollBar/ - indicates the range of a value and sets the current value by a slider as well as up- and down buttons; often
used for widgets whose contents is larger than the acutally visible view area. By using the scrollbar, the visible area can be changed
to another part of the widgets' contents.
<item><bf/QGroupBox/ - provides a groupbox frame with title to indicate that child widgets within the box belong together.
</itemize>

<bf/KDE-Widgets:/
<itemize>
<item><bf/KColorButton/ - a pushbutton displaying a selected color. On a button press, the KDE Color dialog is shown where the user can
select another color. Often used for drawing applications or in any case where color values can be set.
<item><bf/KCombo/ - similar to <tt/QComboBox/. Lets the user choose a value by a drop-down listbox.
<item><bf/KDatePicker/ - a complete widget to get a date value by the user.
<item><bf/KDateTable/ - a calendar table to select a date of a month. Used by <tt/KDatePicker/ to build the datepicker dialog.
<item><bf/KKeyButton/ - a button to select a key value. If the button is selected, it gets activated. Pressing a keyboard button will
change the key value for the button which can be used to configure keybindings.
<item><bf/KLed/ - and LED (Light Emitting Diode) widget to display a certain state.
<item><bf/KLedLamp/ - and LED lamp that also supports click actions
<item><bf/KProgress/ - similar to <tt/QProgressBar/, <tt/KProgress/ supports certain other values.
<item><bf/KRestrictedLine/ - a <tt/QLineEdit/ that only accepts certain user input. This can be used to restrict access to certain data
by password dialogs.
<item><bf/KSeparator/ - a separator widget to be used in all cases where KDE applications require a separator to provide a unique look.
Often used in dialogs to separate logical parts where <tt/QGroupBox/ doesn't fit.
<item><bf/KTreeList/ - a collapsable list view to display trees similar to <tt/QListView/.
</itemize>

<sect1>Properties of Qt supported Widgets
<p>

The following chapter gives a complete overview over the currently supported widgets of the Qt toolkit. To achieve a better
understanding of the properties, these are separated to their inheritance. As all of them inherit <tt/QWidget/, this class is described
first. All QWidget properties are available for all other widgets as well, so these are not listed for them again. For widget groups
that inherit an abstract subclass of QWidget as their baseclass, the baseclasses' properties are listed first (though this class does
not provide a widget in the dialogeditor itself). Then the widget properities for the available widget of the group contains the
properties that are specific to it. For a better understanding the inheritance tree of the available widgets is listed below:

<itemize>
<item><ref id="QWidget" name="QWidget">
	<itemize>
		<item><ref id="QButton" name="QButton"> (abstract)
			<itemize>
			<item><ref id="QCheckBox" name="QCheckBox">
			<item><ref id="QPushButton" name="QPushButton">
			<item><ref id="QRadioButton" name="QRadioButton">
			</itemize>
		<item><ref id="QComboBox" name="QComboBox">
		<item><ref id="QFrame" name="QFrame"> (abstract for now)
			<itemize>
			<item><ref id="QGroupBox" name="QGroupBox">
			<item><ref id="QLCDNumber" name="QLCDNumber">
			<item><ref id="QLabel" name="QLabel">
			<item><ref id="QProgressBar" name="QProgressBar">
			<item><ref id="QScrollView" name="QScrollView"> (abstract for now)
				<itemize>
				<item><ref id="QListView" name="QListView">
				</itemize>
			<item><ref id="QSpinBox" name="QSpinBox">
			<item><ref id="QTableView" name="QTableView"> (abstract)
				<itemize>
				<item><ref id="QListBox" name="QListBox">
				<item><ref id="QMultiLineEdit" name="QMultiLineEdit">
				</itemize>
			</itemize>
		<item><ref id="QLineEdit" name="QLineEdit">
		<item><ref id="QScrollBar" name="QScrollBar">
		<item><ref id="QSlider" name="QSlider">
	</itemize>
</itemize>

<sect2>QWidget Properties <label id="QWidget">
<p>
QWidget is the base class for almost all widgets in Qt and KDE. Therefore widgets that inherit QWidget will allow to use the same
settings in most cases.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/BgColor:/ Background color of the widget
  <item><bf/BgMode:/ Background mode of the widget
  <item><bf/BgPalColor:/ Color pallette for the background
  <item><bf/BgPixmap:/ filename for a background pixmap
  <item><bf/Cursor:/ Cusor over the widget
  <item><bf/Font:/ Font for the widget
  <item><bf/MaskBitmap:/ filename for a masking bitmap.
  </itemize>
<item><bf/C++ Code:/
  <itemize>
  <item><bf/AcceptsDrops:/ if set to true, the widget item will accept drops by drag'n drop mechanisms
  <item><bf/Connections:/ connects the item's signals to slots
  <item><bf/FocusProxy:/ the item that gives its focus to this widget.
  <item><bf/HasFocus:/ sets if the item has the focus by default. Mind that only one item per dialog can have this value as true
  <item><bf/ResizeToParent:/ resizes the widget to it's parent size (not visible in editing mode)
  <item><bf/VarName:/ Variable name of the item. Chage this to names that describe the item's purpose.
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/IsEnabled:/ sets if the widget will accept user events
  <item><bf/IsHidden:/ sets the item to be visible(false) or hidden(true)
  <item><bf/Name:/ sets the name of the widget. Mind that the name is different from the VarName in C++ Code.
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/Height:/ height of the item
  <item><bf/IsFixedSize:/
  <item><bf/MaxHeight:/ maximum value for Height
  <item><bf/MaxWidth:/ maximum value for Width
  <item><bf/MinHeight:/ minimum value for Height
  <item><bf/MinWidth:/ minimum value for Width
  <item><bf/SizeIncX:/ pixel steps for resize actions for X position
  <item><bf/SizeIncY:/ pixel steps for resize actions for Y position
  <item><bf/Width:/ width of the item
  <item><bf/X:/ position horizontal, counted from the left corner
  <item><bf/Y:/ position vertical, counted up to down
  </itemize>
</itemize>


<sect2>QButton inherited widgets <label id="QButton">
<p>
<tt/QButton/ is an abstract widget class that provides properties common to buttons.

Inherits <ref id="QWidget" name="QWidget">

Inherited by <ref id="QCheckBox" name="QCheckBox">, <ref id="QPushButton" name="QPushButton"> and <ref id="QRadioButton"
name="QRadioButton"> inherit <tt/QButton/.


<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/setPixmap:/ sets the pixmap filename to use
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/setText:/ the text on labels, buttons and boxes, also pre-set text for lineedits.
  <item><bf/setAutoRepeat:/ if enabled, the clicked() signal is emitted at regular intervals while the button is down. No effect on
  toogle buttons.
  <item><bf/setAutoResize:/ Enables auto-resizing if TRUE. When auto-resize is enabled, the button will resizes itself
  whenever the contents changes.
  </itemize>
</itemize>
<p>

<sect3>QCheckBox Properities <label id="QCheckBox">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ defines is the checkbox is set checked on construction
  </itemize>
</itemize>
<p>

<sect3>QPushButton Properties <label id="QPushButton">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isAutoDefault: (setAutoDefault)/ the auto-default button becomes the default push button if it receives the keyboard input focus.
  <item><bf/isDefault: (setDefault)/ there can be only one default button and it is only allowed to use in a dialog (see <tt/QDialog/). The
  default button emits <tt/clicked()/ if the user presses the Enter key.
  <item><bf/isMenuButton: (setIsMenuButton)/ tells the button to draw
  a menu indication triangle if enabled. The menu has to be inserted separately.
  <item><bf/isToggleButton::(setToggleButton)/ makes a push button a toggle button, so the button has a similar state as check
  boxes.
  <item><bf/isToggledOn: (setOn)/ (public slot) switches a toggle button on.
  </itemize>
</itemize>
<p>

<sect3>QRadioButton Properties <label id="QRadioButton">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ defines is the radiobutton is set checked on construction
  </itemize>
</itemize>
<p>

<sect2>QComboBox Properties <label id="QComboBox">
<p>
Inherits <ref id="QWidget" name="QWidget">

( no additional properties for now)
<p>


<sect2>QFrame inherited widgets <label id="QFrame">
<p>
Inherits <ref id="QWidget" name="QWidget">

For now only used as an abstract class.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): sets the margin, which is the distance from the innermost pixel of the frame and the outermost pixel of the
  contents.
  </itemize>
</itemize>
<p>

<sect3>QGroupBox Properties <label id="QGroupBox">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Title: (setTitle)/ sets the groupbox title that is displayed in the box frame.
  </itemize>
</itemize>
<p>

<sect3>QLCDNumber Properties  <label id="QLCDNumber">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/NumDigits:(setNumDigits)/ sets the number of digits displayed in QLCDNumber
  <item><bf/Value: (display)/ (public slot) sets the initial value for QLCDNumber
  </itemize>
</itemize>
<p>


<sect3>QLabel Properties  <label id="QLabel">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): sets the margin, which is for QLabel the distance from the frame to the first letter of the label text,
  depending on the alignment of the label.
  </itemize>
<item><bf/C++ Code: /
  <itemize>
  <item><bf/Buddy: (setBuddy)/ sets the buddy widget of the label.
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Text: (setText)/ sets the label text.
  <item><bf/isAutoResize: (setAutoResize)/ if TRUE, the label will resize itself if the contents changes. The top left corner is not
  moved.
  </itemize>
</itemize>
<p>


<sect3>QProgressBar Properties  <label id="QProgressBar">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/TotalSteps: (setTotalSteps)/ (public slot) sets the total steps of the progressbar. During the iteration of your action to
  display the progress, you have to call setProgress(int) to advance the progress step displayed to (int).
  </itemize>
</itemize>
<p>
			
<sect3>QScrollView <label id="QScrollView">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

Inherited by <ref id="QListBox" name="QListBox">
(abstract for now)

Provides a scrollable widget that manages the display of a childwidget by a vertical and horizontal scrollbar.

<sect4>QListView<label id="QListView">
<p>
Inherits <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> and <ref id="QListView" name="QListView">

Provides a list view to display hierarchical data either in a table or a tree. Manages itself by scrollbars throug <ref
id="QScrollView" name="QScrollView">.

<itemize>
<item><bf/Appearance:/
	<itemize>
	<item><bf/ListViewFont:/ (setFont()) Sets the font of the ListView items
	<item><bf/ListViewPalette:/ (setPalette()) Sets the palette of the list view items
	<item><bf/TreeStepSize:/ (setTreeStepSize(int)) Offset of pixels of a child item to its parent item
	<item><bf/hScrollBarMode:/ Scrollbar mode provided by <ref id="QScrollView" name="QScrollView"> for the horizontal scrollbar
	<item><bf/isAllColumnsShowFocus:/ (setAllColumnsShowFocus(bool)) displays focus on all columns of an item.
	<item><bf/isMultiSelection:/ enables multiselection of list items
	<item><bf/isRootDecorated:/ enabeles the + and - decoration to open and close trees
	<item><bf/vScrollBarMode:/Scrollbar mode provided by <ref id="QScrollView" name="QScrollView"> for the vertical scrollbar
	</itemize>
<item><bf/General:/
	<itemize>
	<item><bf/Entries:/ lets you insert a list of entries that are pre-set as QListViewItems.
	<item><bf/isAutoUpdate:/
	</itemize>
</itemize>

<sect3>QSpinBox Properties <label id="QSpinBox">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/MaxValue:/
  <item><bf/MinValue:/
  <item><bf/Prefix:/
  <item><bf/Suffix:/
  <item><bf/Value:/
  <item><bf/isWrapping:/
  </itemize>
</itemize>
<p>

<sect3>QTableView inherited widgets <label id="QTableView">
<p>
Inherits <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

Inherited by <ref id="QListBox" name="QListBox"> and <ref id="QMultiLineEdit" name="QMultiLineEdit">
<p>

<sect4>QListBox Properties <label id="QListBox">
<p>
Inherits <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

<itemize>

<item><bf/General:/
  <itemize>
  <item><bf/isAutoBottomScrollBar: (setAutoBottomScrollBar)/
  <item><bf/isAutoScroll: (setAutoScroll)/
  <item><bf/isAutoScrollBar: (setAutoScrollBar)/
  <item><bf/isAutoUpdate: (setAutoUpdate)/
  <item><bf/isBottomScrollBar: (setBottomScrollBar)/
  <item><bf/isDragSelect: (setDragSelect)/
  <item><bf/isSmoothScrolling: (setSmoothScrolling)/
  </itemize>

<item><bf/Geometry:/

<itemize>
<item><bf/setFixedVisibleLines:/ sets a fixed height for the widget so that the given number of textlines are displayed using the
current font.
</itemize>

</itemize>
<p>

<sect4>QMultiLineEdit Properties <label id="QMultiLineEdit">
<p>
Inherits <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

<itemize>

<item><bf/General:/

<itemize>
<item><bf/Text: (setText) / (public slot) sets the text of the widget.
<item><bf/isAutoUpdate: (setAutoUpdate)/ used to avoid flicker during large changes; the view is not updated if disabled.
<item><bf/isOverWriteMode: (setOverwriteMode) /(public slot) sets overwrite enabled or disabled.
<item><bf/isReadOnly: (setReadOnly)/ (public slot) sets the widget text to read only; disables text input.
<item><bf/isTextSelected: (selectAll)/(public slot) marks the whole text selected
</itemize>

<item><bf/Geometry:/

<itemize>
<item><bf/setFixedVisibleLines:/ sets a fixed height for the widget so that the given number of textlines are displayed using the
current font.
</itemize>

</itemize>
<p>


<sect2>QLineEdit Properties <label id="QLineEdit">
<p>
Inherits <ref id="QWidget" name="QWidget">

<itemize>

<item><bf/General:/

<itemize>
<item><bf/CursorPosition: (setCursorPosition)/ sets the default cursor position.
<item><bf/MaxLength: (setMaxLength) / sets the maximum string length
<item><bf/Text: (setText) / (public slot) sets the contents displayed on construction
<item><bf/hasFrame: (setFrame) / draws the lineedit witin a two-pixel frame if enabled.
<item><bf/isTextSelected: (selectAll) / (public slot) sets the text to be selected.
</itemize>

</itemize>
<p>

<sect2>QScrollBar Properties <label id="QScrollBar">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <tt/QRangeControl/.

<itemize>

<item><bf/General:/

<itemize>
<item><bf/MaxValue:/ sets the maximum slider value; used in constructor (optional)
<item><bf/MinValue:/ sets the minimum slider value; used in constructor (optional)
<item><bf/Orientation: (setOrientation)/ sets the orientation of the scrollbar to horizontal or vertical.
<item><bf/Value: / sets the initial value of the scrollbar in the constructor (optional)
<item><bf/isTracking: (setTracking)/ if enabled, the scrollbar emits <tt/valueChanged()/ whenever the bar is dragged; otherwise only on
mouse release.
</itemize>

</itemize>
<p>

<sect2>QSlider Properties <label id="QSlider">
<p>
Inherits <ref id="QWidget" name="QWidget"> and <tt/QRangeControl/.

<itemize>

<item><bf/General:/

<itemize>
<item><bf/MaxValue:/ sets the maximum slider value; used in constructor (optional)
<item><bf/MinValue:/ sets the minimum slider value; used in constructor (optional)
<item><bf/Orientation: (setOrientation)/ sets the orientation of the slider to horizontal or vertical.
<item><bf/Value: (setValue)/ (public slot) uses <tt/QRangeControl::setValue()/ to set the value.
<item><bf/isTracking:(setTracking)/ if enabled, the slider emits <tt/valueChanged()/ whenever the slider is dragged; otherwise only on
mouse release.
</itemize>

</itemize>
<p>

<sect1>Properties of KDE supported Widgets
<p>

<itemize>
<item><ref id="QWidget" name="QWidget">
	<itemize>
	<item><ref id="QButton" name="QButton"> (abstract)
		<itemize>
		<item><ref id="QPushButton" name="QPushButton">
  		<itemize>
  		<item><ref id="KColorButton" name="KColorButton">
  		<item><ref id="KKeyButton" name="KKeyButton">
  		</itemize>		
		</itemize>
	<item><ref id="QComboBox" name="QComboBox">
		<itemize>
		<item><ref id="KCombo" name="KCombo">
		</itemize>
	<item><ref id="QFrame" name="QFrame"> (abstract for now)
 		<itemize>
 		<item><ref id="KDatePicker" name="KDatePicker">
 		<item><ref id="KLedLamp" name="KLedLamp">
 		<item><ref id="KProgress" name="KProgress">
 		<item><ref id="KSeparator" name="KSeparator">
 		<item><ref id="QTableView" name="QTableView"> (abstract)
 			<itemize>
 			<item><ref id="KDateTable" name="KDateTable">
 			<item><ref id="KTreeList" name="KTreeList">
 			</itemize>
 		</itemize>
 	<item><ref id="QLineEdit" name="QLineEdit">
 		<itemize>
 		<item><ref id="KRestrictedLine" name="KRestrictedLine">
 		</itemize>
	</itemize>
	<item><ref id="KLed" name="KLed">
</itemize>

<sect2>KColorButton<label id="KColorButton">
<p>

Inherits <ref id="QPushButton" name="QPushButton">

<itemize>
<item>General
	<itemize>
	<item>DisplayedColor (setColor()) the displayed color on the button
	</itemize>
</itemize>

<sect2>KKeyButton<label id="KKeyButton">
<p>

<sect2>KCombo<label id="KCombo">
<p>

Inherits: <ref id="QComboBox" name="QComboBox">


<itemize>
<item>General
	<itemize>
	<item>Entries
	<item>Text
	<item>isAutoResize
	</itemize>
</itemize>

<sect2>KDatePicker<label id="KDatePicker">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item>FontSize
	</itemize>
</itemize>
	
<sect2>KLedLamp<label id="KLedLamp">
<p>

<sect2>KProgress<label id="KProgress">
<p>

<sect2>KSeparator<label id="KSeparator">
<p>
<itemize>
<item>General
	<itemize>
	<item>Orientation
	</itemize>
</itemize>

<sect2>KDateTable<label id="KDateTable">
<p>

<sect2>KTreeList<label id="KTreeList">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item>TreeListBgColor
	<item>TreeListPalette
	<item>isBottomScrollbar
	<item>isScrollBar
	<item>isShowItemText
	<item>isSmoothScrolling
	<item>isTreeDrawing
	</itemize>
<item>General
	<itemize>
	<item>Entries
	<item>isAutoUpdate
	</itemize>
</itemize>



<sect2>KRestrictedLine<label id="KRestrictedLine">
<p>
<sect2>KLed<label id="KLed">
<p>

Inherits <ref id="QWidget" name="QWidget">

<itemize>
<item>Appearance
	<itemize>
	<item>LedColor: (setColor()) sets the displayed LED color
	</itemize>
</itemize>
	
	
<sect1>Constructing a new Dialog
<p>
<sect1>Setting Widget Properties
<p>
<sect1>Integrating the Dialog
<p>

<sect>Printing Support
<p>
<sect1>The Qt Print Dialog
<p>
<sect1>The QPainter Class
<p>

<sect>Help Functions
<p>

<sect1>Extending the Statusbar Help
<p>

<sect1>Adding Quickhelp
<p>

<sect1>The "What's This ? Button"
<p>

<sect>Extending the Documentation with SGML
<p>
<sect1>Why SGML ?
<p>
<sect1>What the Documentation already contains
<p>
<sect1>Adding new Pages
<p>
<sect1>How to call Help in Dialogs
<p>

<sect>Class Documentation with KDoc
<p>
<sect1>How to use KDevelop's Documentation features
<p>
<sect1>Adding Class and Member Documentation
<p>
<sect1>Special Tags
<p>

<sect>Internationalization
<p>
<sect1>What is i18n ?
<p>
<sect1>Translation Team Contacts
<p>
<sect1>How KDE supports Internationalization
<p>
<sect1>Enableing Internationalization Support
<p>
<sect1>Adding a Language to your Project
<p>
<sect1>Translations with KTranslator
<p>


<sect>Finding Errors
<p>
<sect1>Debugging Macros provided by Qt
<p>
<sect1>KDE Macros
<p>

<sect>Copyright<label id="Copyright">
<p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

</article>






























