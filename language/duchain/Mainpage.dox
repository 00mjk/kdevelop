/*!
 * @mainpage Definition-Use Chain and Type System
 *
 * Overview | @ref duchain-design "Design" | \ref Implementing "Implementing"
 *
 * The definition-use chain and type system provide a language-neutral
 * representation of source code structure, used to provide language-based
 * features to all implemented languages in a generic manner.
 *
 * An introduction to the duchain can be found in the \ref duchain-design document.
 *
 * Details about how to provide a duchain and type system for your favourite
 * language can be found here: \ref Implementing
 *
 * @licenses
 * @lgpl
 *
 * For questions and discussons about editor either contact the author
 * or the <a href="mailto:kdevelop-devel@kdevelop.org">kdevelop-devel@kdevelop.org</a>
 * mailing list.
 */

/**
 * \page Implementing Implementing Definition-Use Chains for a specific language
 *
 * \ref index "Overview" | @ref duchain-design "Design" | Implementing
 *
 * \section create Creating the Definition-Use Chain
 *
 * To create a definition-use chain for a programming language, you need the following:
 * \li a parser for the language,
 * \li a context builder,
 * \li a type builder,
 * \li a declaration builder,
 * \li and a use builder.
 *
 * Once you have everything up to the declaration builder, your language's classes, functions etc.
 * will automatically appear in the class browser, and be able to perform limited refactoring.
 *
 * Once you have the use builder, you will automatically have full support for context browsing.
 *
 * Code completion support requires further work specific to your language, see \ref cc
 *
 * \subsection parser Parser
 * Parsers in kdevelop can be created in any way as long as they produce an AST (abstract
 * syntax tree).  Most supported languages have parsers generated by kdevelop-pg-qt.
 * This is a LL parser generator, and allows you to specify a grammar which then creates
 * a parser and an AST for you.  The parser will also need a lexer, common solutions are to
 * use flex to create one for you, or to create one by hand.
 *
 * \subsection context Context Builder
 * By subclassing KDevelop::AbstractContextBuilder, you will have everything you need to
 * keep track of contexts as you iterate the AST.  When a new context is encountered, such
 * as a new block (eg. between {} brackets), create a new context with KDevelop::AbstractContextBuilder::openContext(),
 * and close it with KDevelop::AbstractContextBuilder::closeContext().
 *
 * Some languages do not need a context to be created for each block, for example languages
 * where declarations are visible after the block in which they were defined (eg. php).
 *
 * \subsection type Type Builder
 * By subclassing KDevelop::AbstractTypeBuilder, you can create types when one is encountered
 * through openType().  Again, you need to closeType() when the type is exited.  Complex
 * types are built up this way by creating the type at each node, ie. with int[], first an
 * array type is opened, then an integral type representing an integer is opened and closed, then
 * when the array type is closed, you can retrieve the lastType() and set that as the type which
 * is being made into an array.
 *
 * \subsection declaration Declaration Builder
 * By subclassing KDevelop::AbstractDeclarationBuilder, you can create declarations when they are
 * encountered in your AST.  Usually you will assign the lastType() or currentType() to them
 * within closeDeclaration().
 *
 * \subsection use Use Builder
 * By subclassing KDevelop::AbstractUseBuilder, you can create uses when they are encountered
 * in your AST, and they will be automatically registered with the current context.
 *
 * \section cc Implementing Code Completion
 *
 * To provide code completion for your language, you will need to implement the following:
 * \todo complete this section
 */

// DOXYGEN_PROJECT_NAME=Definition-Use Chain and Type System
