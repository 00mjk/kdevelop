/*  This file is part of KDevelop
    Copyright 2012 Miha Čančula <miha@noughmad.eu>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#ifndef KDEVELOP_TEMPLATECLASSGENERATOR_H
#define KDEVELOP_TEMPLATECLASSGENERATOR_H

#include "classgenerator.h"

namespace KDevelop
{

class SourceFileTemplate;

/**
 * Generates new classes from templates
 * 
 * @section TemplateStructure Template Archive Structure
 * 
 * Class templates in KDevPlatform are archive files.
 * The archive must contain at least one .desktop file with the template's description. 
 * If multiple such files are present, the one with the same base name as the archive itself will be used. 
 * 
 * The description file must contain a [General] section with the following keys:
 * @li @c Name - The user-visible name of this template
 * @li @c Comment - A short user-visible comment
 * @li @c Category - The category of this template. It can be nested, in which case levels are separated
 * with forward slashes. The top-level category is usually the language. 
 * @li @c Files - List of files generated by this template. These are not actual file names, but names 
 * of config groups describing those files. 
 * @li @c OptionsFile (optional) - If the template uses custom configuration options, specify a path to
 * the options file here. @ref CustomOptions
 * 
 * For each file name in the @c Files array, TemplateClassGenerator expects a section with the same name. 
 * this section should contain three keys:
 * @li @c Name - User-visible name for this file. This will be show the the user in the dialog and can be translated. 
 * @li @c File - The input file name in the template archive. The template for this file will be read from here. 
 * @li @c OutputFile - The suggested output file name. This will be renderer as a template, so it can contain variables.
 * 
 * An example template description is below. It shows all features described above. 
 * 
 * @code
 * [General]
 * Name=Example
 * Comment=Example description for a C++ Class
 * Category=C++
 * Options=options.kcfg
 * Files=Header,Implementation
 * 
 * [Header]
 * Name=Header
 * File=class.h
 * OutputFile={{ name }}.h
 * 
 * [Implementation]
 * Name=Implementation
 * File=class.cpp
 * OutputFile={{ name }}.cpp
 * @endcode
 * 
 * @section CustomOptions
 * 
 * Templates can expose additional configurations options. 
 * This is done through a file with the same syntax and .kcfg files used by KConfig XT. 
 * The name of this file is specified with the @c OptionsFile key in the [General] section of the description file. 
 * 
 * @note
 * The options are not parsed by TemplateClassGenerator. 
 * Instead, hasCustomOptions() returns true if the template specifies a custom options file, 
 * and customOptions() returns the full text of that file. 
 * The parsing is done by TemplateOptionsPage. 
 * 
 * The file can (and should) provide a type, name, label and default value for each configuration option. 
 * So far, only variables with types String, Int and Bool are recognized. 
 * Label is the user-visible string that will be shown next to the input field. 
 * The default value will be rendered as a template, so it can contain variables. 
 * 
 * After the user configures the options, they will be available to the template as context variables. 
 * The variable name will match the option name, and its value will be the one set by the user.
 * 
 * An example options.kcfg file is included below. 
 * 
 * @code
 * <?xml version="1.0" encoding="UTF-8"?>
 * <kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
 *      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 *      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
 *      http://www.kde.org/standards/kcfg/1.0/kcfg.xsd">
 *  <kcfgfile arg="true"/>
 *  <group name="Private Class">
 *    <entry name="private_class_name" type="String">
 *      <label>Private class name</label>
 *      <default>{{ name }}Private</default>
 *    </entry>
 *    <entry name="private_member_name" type="String">
 *      <label>Private member name</label>
 *      <default>d</default>
 *    </entry>
 *  </group>
 * </kcfg>
 * @endcode
 * 
 * In this example, if the class name is Example, the default value for the private class name will be ExamplePrivate. 
 * After the user accepts the option values, the template will access them through the @c private_class_name 
 * and @c private_member_name variables. 
 * 
 * For more information regarding the XML file format, refer to the KConfig XT documentation. 
 * 
 * @section Variables Variables Passed to Templates
 * 
 * TemplateClassGenerator makes use of the ClassDescription returned by ClassGenerator::description(). 
 * From this description, it constructs the following variables:
 * @li @c description (ClassDescription) - the class description
 * @li @c name (QString) - the class name, same as @c description.name
 * @li @c identifier (QString) - the full class identifier, composed of namespaces and name
 * @li @c members (VariableDescriptionList) - data members, same as @c description.members
 * @li @c functions (FunctionDescriptionList) - function members, same as @c description.methods
 * @li @c base_classes (InheritanceDescriptionList) - directly inherited classes, same as @c description.baseClasses
 * @li @c license (QString) - the license for this class, including author copyright, without comment characters or indentation. It is recommended to use the "lines_prepend" filters from library "kdev_filters" to format it.
 * 
 * For each output file, TemplateClassGenerator add two variables named @c output_file_x 
 * and @c output_file_x_absolute, where @c x is replaced
 * with the file name specified in the template description file. The file name is lowercase and cleaned by replacing
 * all non-alphanumerical characters with underscores. For example, if the file is named "Public Header" in 
 * the description file, the variable will be @c output_file_public_heder. 
 * 
 * As their name suggests, @c output_file_x contains the relative path from baseUrl() to the URL of the 
 * x's output location, while @c output_file_x_absolute contains x's absolute output URL. 
 * Both are avaliable to templates as strings. 
 * 
 * If the templates uses custom options, these options are added to the template variables. Their names match the
 * names specified in the options file, and their values to the values entered by the user. 
 * 
 * Subclasses can override templateVariables() and insert additional variables. 
 * 
 **/
class KDEVPLATFORMLANGUAGE_EXPORT TemplateClassGenerator : public ClassGenerator
{
public:
    /**
     * Creates a new generator.
     * 
     * You should call setTemplateDescription() before any other template-related functions.
     *
     * @param baseUrl the folder where new files will be created
     **/
    TemplateClassGenerator(const KUrl& baseUrl);
    ~TemplateClassGenerator();

    /**
     * @brief Selects the template to be used
     * 
     * This function must be called before using any other functions.
     *
     * The passed @p templateDescription should be an absolute path to a template description (.desktop) file.
     * TemplateClassGenerator will attempt to find a template archive with a matching name.
     *
     * @param templateDescription the template description file
     **/
    void setTemplateDescription(const QString& templateDescription);

    virtual DocumentChangeSet generate();
    virtual QHash<QString,QString> fileLabels();
    virtual QHash< QString, KUrl > fileUrlsFromBase (const KUrl& baseUrl, bool toLower = true);
    /**
     * @brief Default variables that will be passed to templates
     * 
     * These are populated from description(). Subclasses can override this function
     * to provide additional variables, but should always call the base implementation, like this
     * 
     * @code
     * MyGenerator::templateVariables()
     * {
     *     QVariantHash variables = TemplateClassGenerator::templateVariables();
     *     variables["my_variable"] = "SomeString";
     *     return variables;
     * }
     * @endcode
     *
     **/
    virtual QVariantHash templateVariables();

    SourceFileTemplate* sourceFileTemplate();

    /**
     * Adds variables @p variables to the context passed to all template files.
     *
     * The variable values must be of a type registered with Grantlee::registerMetaType()
     *
     * @param variables additional variables to be passed to all templates
     **/
    void addVariables(const QVariantHash& variables);

    /**
     * Convenience function to render a string @p text as a Grantlee template
     *
     **/
    QString renderString(const QString& text);

private:
    class TemplateClassGeneratorPrivate* const d;
};

}

#endif // KDEVELOP_TEMPLATECLASSGENERATOR_H
