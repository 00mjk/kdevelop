<chapter label="9" role="chapter" id="ch09">
<title>Constructing A Responsive User Interface</title>
<para><emphasis>by David Sweet</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In this chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch09lev1sec1">The Importance of Responsiveness</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch09lev1sec2">Speeding Up Window Updates</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch09lev1sec3">Performing Long Jobs</link></emphasis></para></listitem>
</itemizedlist></highlights>
<para>All <indexterm><primary>responsiveness</primary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary></indexterm>too often, you have probably used GUI applications that fail to repaint their windows, leaving an empty, or partially empty frame on the screen, or you have used an application that begins a task and ignores you until it is done&mdash;not knowing if you preferred to abort the task rather than wait. In general, many applications&mdash;even popular, regularly used applications&mdash;at times provide no feedback or do not respond to user input. In this chapter you learn how to avoid writing code that behaves so poorly.</para>
<para>The methods presented in this chapter are not the only relevant ones. In particular, multithreading is continually gaining popularity as a way of separating GUI code from <quote>back-end</quote> work code. Qt is not currently thread-safe (thus, neither is KDE), but there are ways around this problem. Multithreading is beyond the scope of this book, but useful discussion of the subject exists in the <literal>qt-interest</literal> mailing-list archive at <ulink url="http://www.troll.no/qt-interest/">http://www.troll.no/qt-interest/</ulink>.<indexterm><primary>responsiveness</primary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary></indexterm></para>
<section id="ch09lev1sec1">
<title>The Importance of Responsiveness</title>
<para>Your<indexterm><primary>responsiveness</primary><secondary>importance of</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>importance of</tertiary></indexterm> application's interface needs to be constructed so that the user</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Knows the current state of the application</para></listitem>
<listitem><para>Knows whether a command given to the application has been received</para></listitem>
<listitem><para>Knows that the application is working on a task and not simply <quote>hung</quote></para></listitem>
<listitem><para>Can always control the flow of the program</para></listitem>
</itemizedlist>
<para>It is generally simpler to think linearly about the functions your applications need to perform. Many of you may be intimately familiar with this style of programming from writing command-line interface programs. When writing for a GUI, of course, things are different. Your application needs to always be aware of the user interface&mdash;even while it is performing other tasks. Essentially, your application needs to perform rudimentary multitasking to keep the UI alive while still doing useful work.</para>
<para>To get a feel for the importance of a responsive UI, let's look at some common problems GUI application programmers come across (but don't always solve!).<indexterm><primary>responsiveness</primary><secondary>importance of</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>importance of</tertiary></indexterm></para>
<para>Some windows can take a long time to repaint. During the repainting, the application gives no CPU cycles to the UI, and the user has to wait for the window to be completely updated before any mouse clicks or key presses are processed. Slow updates at best make the UI seem sluggish and at worst make the application unusable. Imagine if an automobile responded in a similar way: You turn the steering wheel and after a half-second or so, the wheels respond. This car would be quite difficult to control!</para>
<para>A similar problem occurs when your application must perform long jobs, such as connecting to another computer, searching a database, or filtering an image. It is tempting to write a method that performs the entire task and then returns, perhaps updating the display with the results of the computation, but the user will not be able to interact with your application, so the following problems occur:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The user cannot cancel the long job.</para></listitem>
<listitem><para>The application's windows will not get repainted. (They may need to be repainted if, for example, another window is dragged over them.)</para></listitem>
<listitem><para>The user cannot take advantage of other features of your application that might logically still be usable while the long job progresses.</para></listitem></itemizedlist>
<para>Of course, while performing a long task, you should also let the user know that the task is progressing so that the user knows the application is working as expected. You should periodically update a window with a progress bar or something similar.<indexterm><primary>responsiveness</primary><secondary>importance of</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>importance of</tertiary></indexterm></para>
</section>
<section id="ch09lev1sec2">
<title>Speeding Up Window Updates</title>
<para>Next,<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary></indexterm><indexterm><primary>double-buffering</primary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary></indexterm> you examine a technique for speeding up window draws that makes use of <literal>QPixmap</literal>, an offscreen buffer in which you can draw with <literal>QPainter</literal>. The speed increase comes from realizing that many window redraws are invoked from outside the application and not in response to a need to change the contents of the window.</para>
<para>The technique works like this: You draw your window contents to an offscreen buffer, a <literal>QPixmap</literal>, and then use a bit-block transfer (or <quote>bitblt</quote>, pronounced <quote>bit blit</quote>) to copy the buffer to the screen. Whenever you need to update the window, but its contents have not changed, you just bitblt the buffer to the screen again. The bit-block transfer operation is much quicker than redrawing the window contents from scratch, and on most PCs and many workstations, it is made even quicker by specialized hardware designed to perform the task (that is, 2D video accelerators). This technique is called <emphasis>double-buffering</emphasis>.</para>
<para>Let's take a look at this technique in action. <link linkend="ch09list01">Listings 9.1</link> and <link linkend="ch09list02">9.2</link> present a widget call <literal>KQuickDraw</literal>, which demonstrates double-buffering.<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>example of</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>example of</secondary></indexterm></para>
<example role="codelisting" label="9.1" id="ch09list01">
<title>kquickdraw.h: Class Declaration for <literal>KQuickDraw</literal>, a Widget That Demonstrates Double-buffering<indexterm><primary>KQuickDraw widget</primary><secondary>kquickdraw.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>kquickdraw.h class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KQuickDraw</tertiary></indexterm><indexterm><primary>kquickdraw.h class declaration (KQuickDraw widget)</primary></indexterm><indexterm><primary>widgets</primary><seealso>names of specific widgets</seealso></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KQUICKDRAW_H__
 2: #define __KQUICKDRAW_H__
 3:
 4:
 5: #include &lt;qwidget.h>
 6:
 7: class QPixmap;
 8:
 9: const int NEllipses=1000;
10:
11: /**
12:  * KQuickDraw
13:  * Quickly redraw a window.
14:  **/
15:
16: class KQuickDraw : public QWidget
17: {
18:  public:
19:   KQuickDraw (QWidget *parent, const char *name=0);
20:
21:  protected:
22:   /**
23:    * Repaint the window using a bit-block transfer from the
24:    *  off-screen buffer (a QPixmap). Re-create the pixmap first,
25:    *  if necessary.
26:    **/
27:   void paintEvent (QPaintEvent *);
28:
29:   void resizeEvent (QResizeEvent *);
30:
31:  private:
32:   QPixmap *qpixmap;
33:   bool bneedrecreate;
34:   double x[NEllipses], y[NEllipses];
35:
36: };
37:
38: #endif<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>example of</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>example of</secondary></indexterm><indexterm><primary>KQuickDraw widget</primary><secondary>kquickdraw.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>kquickdraw.h class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KQuickDraw</tertiary></indexterm><indexterm><primary>kquickdraw.h class declaration (KQuickDraw widget)</primary></indexterm>
</programlisting>
</example>
<para><literal>KQuickDraw</literal> displays 1,000 randomly placed ellipses in its content area using a double-buffer method. A flag, <literal>bneedrecreate</literal>, is set to <literal>true</literal> whenever the window contents need to be re-created. In this program, the window contents need to be re-created (or simply created) when the program first starts and whenever the window is resized. When the window is restored after being minimized, when another window stops obscuring this window, or at other times when paint events are generated, you simply copy (bitblt) the contents of the <literal>QPixmap</literal> to the screen.</para>
<example role="codelisting" label="9.2" id="ch09list02">
<title>kquickdraw.cpp: Class Definition for <literal>KQuickDraw</literal><indexterm><primary>KQuickDraw widget</primary><secondary>kquickdraw.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>kquickdraw.cpp class definition</tertiary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KQuickDraw</tertiary></indexterm><indexterm><primary>kquickdraw.cpp class definition (KQuickDraw widget)</primary></indexterm><indexterm><primary>classses</primary><seealso>names of specific classes</seealso></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qpainter.h>
 2: #include &lt;qpixmap.h>
 3:
 4: #include &lt;kapp.h>
 5:
 6: #include "kquickdraw.h"
 7:
 8:
 9: KQuickDraw::KQuickDraw (QWidget *parent, const char *name=0) :
10:   QWidget (parent, name)
11: {
12:   bneedrecreate=true;
13:   qpixmap=0;
14:
15:   for (int i=0; i&lt;NEllipses; i++)
16:     {
17:       x[i]=(kapp->random()%100)/100.;
18:       y[i]=(kapp->random()%100)/100.;
19:     }
20:
21:   setBackgroundMode (NoBackground);
22:       
23: }
24: <indexterm><primary>KQuickDraw widget</primary><secondary>kquickdraw.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>kquickdraw.cpp class definition</tertiary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KQuickDraw</tertiary></indexterm><indexterm><primary>kquickdraw.cpp class definition (KQuickDraw widget)</primary></indexterm>
25: void
26: KQuickDraw::paintEvent (QPaintEvent *)
27: {
28:
29:   if (bneedrecreate)
30:     {
31:     if (qpixmap!=0)
32:   delete qpixmap;
33:     qpixmap = new QPixmap (width(), height());
34:
35:     QPainter qpainter;
36:     qpainter.begin (qpixmap, this);
37:     qpainter.fillRect (qpixmap->rect(), white);
38:     qpainter.setBrush (blue);
39:     int w = width()/10;
40:     int h = height()/10;
41:     for (int i=0; i&lt;NEllipses; i++)
42:   qpainter.drawEllipse (x[i]*width(), y[i]*height(), w, h);
43:
44:     bneedrecreate=false;
45:     }
46:
47:   bitBlt (this, 0, 0, qpixmap);
48:
49: }
50:
51: void
52: KQuickDraw::resizeEvent (QResizeEvent *)
53: {
54:   bneedrecreate = true;
55: }<indexterm><primary>KQuickDraw widget</primary><secondary>kquickdraw.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>kquickdraw.cpp class definition</tertiary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KQuickDraw</tertiary></indexterm><indexterm><primary>kquickdraw.cpp class definition (KQuickDraw widget)</primary></indexterm>
</programlisting>
</example>
<para>Let's look at <indexterm><primary>paintEvent() method</primary></indexterm><indexterm><primary>methods</primary><secondary>paintEvent()</secondary></indexterm><literal>paintEvent()</literal>; this is where the double-buffering is implemented. Line 29 tests to see whether the pixmap contents need to be re-created and carries out the task if necessary.<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>example of</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>example of</secondary></indexterm></para>
<para>Here you have used a <literal>QPainter</literal> differently than before. Line 36 calls <literal>painter.begin()</literal> with two arguments. The first is the <literal>QPixmap</literal> on which you wish to draw, and the second is a pointer to the <literal>KQuickDraw</literal> widget. Using this form of the <literal>begin()</literal> method tells the object <literal>painter</literal> to use the default properties of the window when drawing on the pixmap. These default properties are</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The current pen color</para></listitem>
<listitem><para>The background color</para></listitem>
<listitem><para>The default font</para></listitem></itemizedlist>
<para>Previously, when you have used <literal>QPainter</literal>, you have not called the <literal>begin()</literal> method at all. Instead, you passed a pointer to the current window to the <literal>QPainter</literal> constructor, and the <literal>begin()</literal> method was called automatically.</para>
<para>Finally, the offscreen pixmap is copied to the screen with the Qt function <literal>bitBlt()</literal> in line 47.</para>
<para>The <literal>main()</literal> function in <link linkend="ch09list03">Listing 9.3</link> can be used to try out this widget. You can see it running in <link linkend="ch09fig01">Figure 9.1</link></para>
<example role="codelisting" label="9.3" id="ch09list03">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Testing <literal>KQuickDraw</literal><indexterm><primary>KQuickDraw widget</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KQuickDraw</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KQuickDraw</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kquickdraw.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "kquickdrawtest");
 9:   KQuickDraw *kquickdraw = new KQuickDraw (0);
10:
11:   kapplication.setMainWidget (kquickdraw);
12:
13:   kquickdraw->show();
14:   return kapplication.exec();
15: }<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>example of</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>example of</secondary></indexterm><indexterm><primary>KQuickDraw widget</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KQuickDraw widget</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KQuickDraw</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KQuickDraw</tertiary></indexterm>
</programlisting>
</example>
<figure label="9.1" id="ch09fig01">
<title><literal>kquickdraw</literal> updates its window quickly by storing its window contents in an offscreen buffer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/09fig01.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<section id="ch09lev2sec1">
<title>Experimenting with KQuickDraw</title>
<para>To<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>advantages</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>advantages</secondary></indexterm> get an idea of the difference double-buffering makes, comment out line 29 in <link linkend="ch09list02">Listing 9.2</link>.</para>
<para>This will force <literal>KQuickDraw</literal> to re-create the pixmap every time the <literal>paintEvent()</literal> method is called. Now turn on opaque moving in KWin using the KDE Control Center. This property is listed under Windows, Properties and is called Display Content in Moving Windows. (Note: while you're at it, turn on Display Content in Resizing Windows, too; you'll use that in a minute.)</para>
<para>Now, start KQuickDraw and maximize the window. Then find another window&mdash;a <literal>konsole</literal>, for example&mdash;and drag it around. Notice how the slow update gives a <quote>ghosting</quote> effect so that a partial second copy of the <literal>konsole</literal> window is visible during the move operation. (If you don't see this&mdash;well, then your computer is too fast! Try the experiment again with <literal>NEllipses</literal> set to 5000 or 10000. Just don't get the impression that you'll never need double-buffering. First, your users' computers might not be as fast as yours. Second, when you create applications, you may find that you are drawing things that take much longer than drawing ellipses.)</para>
<para>Remove the comment from line 29 and try the experiment again. Is it better this time?<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>advantages</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>advantages</secondary></indexterm></para>
</section>
<section id="ch09lev2sec2">
<title>Flicker-free Updates</title>
<para>A <indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>screen flicker</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>screen flicker</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>screen flicker</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>screen flicker</secondary></indexterm><indexterm><primary>screen flicker</primary></indexterm><indexterm><primary>flicker effect</primary></indexterm>second advantage exists to using double-buffering. That is, you can avoid some of the <quote>flicker</quote> that occurs when you draw multiple objects on a window. This flicker occurs because the scene the user sees may change rapidly as new objects are added to the window.</para>
<para>Double-buffering won't help with the other major source of flicker, however. Whenever the <literal>QWidget::update()</literal> method is called, it clears the window, by default, to the background color. So the user sees this sequence:</para>
<orderedlist numeration="arabic" continuation="restarts" spacing="compact">
<listitem><para>Window contents</para></listitem>
<listitem><para>Blank window</para></listitem>
<listitem><para>Window contents</para></listitem></orderedlist>
<para>You almost couldn't <emphasis>design</emphasis> a flicker effect any better. If you are using double-buffering, you are going to overwrite the entire window in one operation (the <literal>bitblt()</literal>), so there is no need to clear the window first. You can prevent Qt from clearing the window by calling</para>
<informalexample>
<programlisting linenumbering="unnumbered">
setBackgroundMode (NoBackground);
</programlisting>
</informalexample>
<para>as shown in line 21.<indexterm><primary>responsiveness</primary><secondary>Window updates, double-buffering</secondary><tertiary>screen flicker</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>Window updates, double-buffering</tertiary></indexterm><indexterm><primary>Window updates</primary><secondary>double-buffering</secondary><tertiary>screen flicker</tertiary></indexterm><indexterm><primary>double-buffering</primary><secondary>screen flicker</secondary></indexterm><indexterm><primary>speeding up Window updates (double-buffering)</primary><secondary>screen flicker</secondary></indexterm><indexterm><primary>screen flicker</primary></indexterm><indexterm><primary>flicker effect</primary></indexterm></para>
</section>
</section>
<section id="ch09lev1sec3">
<title>Performing Long Jobs</title>
<para>When <indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary></indexterm><indexterm><primary>tuning performance</primary><see>optimizing performance</see></indexterm><indexterm><primary>tasks</primary><see>jobs</see></indexterm>performing long jobs, you want to</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Let the user know that the application is working and the job is progressing.</para></listitem>
<listitem><para>Let the user access application functions that are still available.</para></listitem>
</itemizedlist>
<para>To make either of these possible, you need to first work to keep the UI alive. This entails chopping our long job into small pieces and reentering the event loop after computing each small piece. The preferred way of accomplishing this is by responding to <literal>QTimer</literal> events.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary></indexterm></para>
<section id="ch09lev2sec3">
<title>Using QTimer to Perform Long Jobs</title>
<para>The<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm> <literal>QTimer</literal> class emits a signal every <literal>msec</literal> milliseconds in response to events it posts in the event queue. If you do all the work required for a long job in response to <literal>QTimer</literal> signals (that is, do our work in a slot connected to the <literal>QTimer::timeout()</literal> signal), this gives other events in the event queue, such as paint events, mouse press events, and so on, a chance to be processed. It is the processing of these events that will keep the UI alive.</para>
<para>An unacceptable alternative to this is to do all the work in a single method at once. The problem with this is that while the work is being performed, no events would be processed, and so the application's UI would <quote>hang</quote>. The window would not update, mouse clicks would be ignored, and so on.</para>
<para>The code presented in <link linkend="ch09list04">Listings 9.4</link> and <link linkend="ch09list05">9.5</link> show a widget called <literal>KlongJob,</literal> which demonstrates how to use <literal>QTimer</literal> to perform a long job. <literal>KLongJob</literal> flips a coin one million times, counts the number of times the coin comes up heads, and computes the percentage deviation from the ideal <quote>50% heads</quote>. That is, the coin is expected to come up heads about half the time, but you know that it'll always be a little different than 50 percent until you've flipped the coin an infinite number of times. This calculation is ideal for this demonstration because it takes a long time but requires very little code.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm></para>
<example role="codelisting" label="9.4" id="ch09list04">
<title>klongjob.h: Class Definition for <literal>KLongJob</literal>, a Main Widget That Demonstrates How to Use <literal>QTimer</literal> to Perform a Long Job<indexterm><primary>KLongJob widget (long job example)</primary><secondary>klongjob.h class declaration (original version)</secondary></indexterm><indexterm><primary>listings</primary><secondary>KLongJob widget (long job example)</secondary><tertiary>klongjob.h class declaration (original version)</tertiary></indexterm><indexterm><primary>klongjob.h class declaration (KLongJob widget)</primary><secondary>original version</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KLongJob example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KLONGJOB_H__
 2: #define __KLONGJOB_H__
 3:
 4: #include &lt;ktmainwindow.h>
 5:
 6: class QTimer;
 7: class QLabel;
 8: class QPopupMenu;
 9:
10: /**
11:  * KLongJob
12:  * Handle a long job while keeping the UI alive.
13:  **/
14:
15: class KLongJob : public KTMainWindow
16: {
17:  Q_OBJECT
18:
19:  public:
20:   KLongJob (const char *name=0);
21:
22:  private:
23:   int count, total;
24:   int idstart, idstop;
25:   QTimer *qtimer;
26:   QLabel *qlabel;
27:   QPopupMenu *file;
28:
29:  private slots:
30:
31:    void slotStartComputation ();
32:    void slotStopComputation ();
33:
34:   /**
35:    * Do some of the calculation.
36:    **/
37:   void slotComputeSome ();
38:
39: };
40:
41: #endif<indexterm><primary>KLongJob widget (long job example)</primary><secondary>klongjob.h class declaration (original version)</secondary></indexterm><indexterm><primary>listings</primary><secondary>KLongJob widget (long job example)</secondary><tertiary>klongjob.h class declaration (original version)</tertiary></indexterm><indexterm><primary>klongjob.h class declaration (KLongJob widget)</primary><secondary>original version</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KLongJob example</tertiary></indexterm>
</programlisting>
</example>
<para><literal>KLongJob</literal> is derived from <literal>KTMainWindow</literal> so that you can add a user interface to the program. You will see when you execute <literal>KLongJob</literal> how the user interface keeps working, even while the long calculation is being performed.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm></para>
<example role="codelisting" label="9.5" id="ch09list05">
<title>klongjob.cpp: Class Declaration for <literal>KLongJob</literal></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qtimer.h>
 2:
 3: #include &lt;kapp.h>
 4: #include &lt;kaction.h>
 5: #include &lt;kstdaction.h>
 6:
 7: #include "klongjob.moc"
 8:
 9: KLongJob::KLongJob (const char *name=0) :
10:   KTMainWindow (name)
11: {
12:   start = 
13:     new KAction ("&amp;Start", 0,  this, SLOT(slotStartComputation()), 
14:          actionCollection(), "start");
15:   stop =
16:     new KAction ("Sto&amp;p", 0,  this, SLOT(slotStopComputation()), 
17:          actionCollection(), "stop");
18:   KStdAction::quit (kapp, SLOT (closeAllWindows()),
19:             actionCollection());
20:   stop->setEnabled (false);
21:
22:   createGUI();
23:
24:   qlabel = new QLabel (this);
25:   qlabel->setAlignment (QLabel::AlignCenter);
26:   setView (qlabel);
27:
28:   qtimer = new QTimer (this);
29:   connect ( qtimer, SIGNAL (timeout()),
30:        this, SLOT (slotComputeSome()) );
31:
32: }
33:
34: void
35: KLongJob::slotStartComputation ()
36: {
37:   start->setEnabled (false);
38:   stop->setEnabled (true);
39:
40:   qtimer->start (0);
41:
42:   count=total=0;
43: }
44:
45: void
46: KLongJob::slotStopComputation ()
47: {
48:   start->setEnabled (true);
49:   stop->setEnabled (false);
50:
51:   qtimer->stop();
52: }
53:
54: void
55: KLongJob::slotComputeSome()
56: {
57:   const int NumberOfFlips = 10;
58:   double deviation;
59:   int i;
60:
61:   for (i=0; i&lt;NumberOfFlips; i++)
62:     if (kapp->random()%2==1)
63:       count++;
64:   total+=NumberOfFlips;
65:
66:   if (!(total%5000))
67:     {
68:       deviation = (count - total/2.)/(double)total;
69:       QString qstring;
70:       qstring.sprintf ("Total flips: %10d\nDeviation from 50%% heads: %10.5f",
71:                total, deviation);
72:       qlabel->setText (qstring);
73:     }
74:
75:   if (total>=1000000)
76:     slotStopComputation();
77: }
</programlisting>
</example>
<para>In the <literal>KLongJob</literal> constructor, shown in <link linkend="ch09list05">Listing 9.5</link>, you create a <literal>QTimer</literal> and connect its timeout signal to our slot <literal>slotComputeSome()</literal> (lines 28&ndash;30). The slot performs some of the computation every time the <literal>QTimer</literal> times out.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm></para>
<para>The File menu entry, Start, is connected to the slot <literal>slotStartComputation()</literal> <indexterm><primary>startComputation() method</primary></indexterm><indexterm><primary>methods</primary><secondary>startComputation()</secondary></indexterm>(lines 12&ndash;14). In this slot you begin the computation by calling</para>
<informalexample>
<programlisting linenumbering="unnumbered">
qtimer->start(0)
</programlisting>
</informalexample>
<para>This statement starts the <literal>QTimer</literal> with a timeout of <literal>0</literal> milliseconds. Using a value of zero here means that the <literal>timeout()</literal> signal will be emitted as soon as all events in the queue have been processed. In other words, a timeout event is appended to the event queue and processed in turn by Qt. If nothing is happening with our UI&mdash;that is, no events are being posted&mdash;when <literal>slotcomputeSome()</literal> exits, it is reentered right away with little time lost.</para>
<para>The slot <literal>slotcomputeSome()</literal> executes 10 coin flips (more precisely, it chooses randomly between 0 and 1 10 times) in lines 61&ndash;63. The classwide variables, <literal>total</literal> and <literal>count,</literal> are used to save the state of the computation between calls to <literal>slotcomputeSome()</literal>. After every 5,000 flips (50 calls to <literal>slotcomputeSome())</literal> the display is updated. I chose not to update the display after every call to <literal>slotcomputeSome()</literal> because updates are slow and can add a lot of time to the computation. It is important to update the display often enough to keep the user informed that things are proceeding as planned, but not so often as to add significant time to the task being performed.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm></para>
<para>It is important to realize that the user would never see the progress indicator you have created&mdash;the <quote>Total flips</quote> and <quote>Deviation from 50% heads</quote> messages&mdash;if you didn't return to the event queue to allow the paint events to be processed. (Whenever you change the text of a <literal>QLabel</literal>, it sends itself a paint event.)</para>
<para>Finally, after flipping the coin one million times, line 76 calls <literal>stopComputation()</literal>.<indexterm><primary>stopComputation() method</primary></indexterm><indexterm><primary>methods</primary><secondary>stopComputation()</secondary></indexterm> In this method, you call</para>
<informalexample>
<programlisting linenumbering="unnumbered">
qtimer->stop()
</programlisting>
</informalexample>
<para>which stops <literal>qtimer</literal> from posting any more timeout events.</para>
<para>You should give <literal>KLongJob</literal> a try. Start the computation by choosing File, Start, and notice that you can resize the window, drag other windows over it, and even close the window while the computation is being performed.</para>
<para>The following <literal>main()</literal> function in <link linkend="ch09list06">Listing 9.6</link> can be used to create an execute <literal>KLongJob</literal>. You will also need to place the file klongjobui.rc (available on this book's Web site) in the directory $KDEDIR/share/klongjob. You can see a screen shot of <literal>KLongJob</literal> in <link linkend="ch09fig02">Figure 9.2</link>.</para>
<example role="codelisting" label="9.6" id="ch09list06">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Testing <literal>KLongJob</literal><indexterm><primary>KLongJob widget (long job example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KLongJob widget (long job example)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KLongJob widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KLongJob widget</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "klongjob.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "klongjobtest");
 9:   KLongJob *klongjob = new KLongJob (0);
10:
11:   kapplication.setMainWidget (klongjob);
12:
13:   klongjob->show();
14:   return kapplication.exec();
15: }<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>QTimer class</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>QTimer class</tertiary></indexterm><indexterm><primary>QTimer class</primary></indexterm><indexterm><primary>KLongJob widget (long job example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KLongJob widget (long job example)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KLongJob widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KLongJob widget</tertiary></indexterm>
</programlisting>
</example>
</section>
<section id="ch09lev2sec4">
<title>Enabling/Disabling Application Functions</title>
<para>While<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>application functions, enabling/disabling</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>functions</primary><secondary>enabling/disabling</secondary></indexterm><indexterm><primary>enabling</primary><secondary>application functions</secondary></indexterm><indexterm><primary>disabling</primary><secondary>application functinos</secondary></indexterm> trying out <literal>Klongjob</literal> you may have noticed that the Start menu entry is grayed out when the program is flipping the coin (see line 37).</para>
<para>It is important to disable the UI controls that give the user access to the long job if it does not make sense to start the job again. An electronic mail client, for example, should disable its Check for New Mail buttons and menu entries while it is checking for new mail (but keep the rest of its UI alive so that the user can read messages), but a Web browser does not need to disable any hyperlinks while it is attempting to connect to a remote site to download a page. If the user clicks another hyperlink while waiting, a browser, generally, cancels the pending request and starts fulfilling the new one.</para>
<figure label="9.2" id="ch09fig02">
<title><literal>Klongjob</literal> performs a long calculation while still allowing user interaction.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/09fig02.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>On line 38, in the method <literal>startComputation()</literal>, you have enabled the File menu entry Stop. This enables the user to cancel the long job.</para>
<para>This is an important function to offer the user. The user may have accidentally chosen to start the job or simply decided the results weren't worth waiting for. In any event, the user should decide what the CPU cycles are being spent on.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>application functions, enabling/disabling</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>application functions, enabling/disabling</tertiary></indexterm><indexterm><primary>functions</primary><secondary>enabling/disabling</secondary></indexterm><indexterm><primary>enabling</primary><secondary>application functions</secondary></indexterm><indexterm><primary>disabling</primary><secondary>application functinos</secondary></indexterm></para>
</section>
<section id="ch09lev2sec5">
<title>Speed Issues</title>
<para>Clearly, <indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>speed issues</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>speed issues</tertiary></indexterm>performing a long computational task in the way just presented takes longer than performing it all in one method without checking the event queue, but the extra time should be considered well spent for the various reasons given previously.</para>
<para>When deciding how much work to do in the <indexterm><primary>computeSome() method</primary></indexterm><indexterm><primary>methods</primary><secondary>computeSome()</secondary></indexterm><literal>computeSome()</literal> method, consider two competing factors:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Efficiency</para></listitem>
<listitem><para>Smoothness of user interaction</para></listitem></itemizedlist>
<para>Efficiency requires more work to be done in each call to <literal>computeSome()</literal>, which means that a higher percentage of the overall time is spent working on the job, and thus, overall time is decreased. Smoothness of user interaction requires less time to be spent working on the job, and thus, overall time is increased. You set the amount of work small enough so that user interaction did not suffer noticeably.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>speed issues</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>speed issues</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>speed issues</tertiary></indexterm></para>
</section>
<section id="ch09lev2sec6">
<title>An Alternative to <literal>QTimer</literal></title>
<para>There<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>processEvents() method</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>processEvents() method</primary></indexterm><indexterm><primary>methods</primary><secondary>processEvents()</secondary></indexterm> is another way to process events while performing a long job. A method in the class <literal>QApplication</literal> (from which <literal>KApplication</literal> is derived), called <literal>processEvents()</literal>, processes all the pending events and then returns.</para>
<para>Using this method, write the code for the long job in one big loop and call <literal>processEvents()</literal> occasionally. See <link linkend="ch09list07">Listing 9.7</link> for a second version of <literal>klongjob,</literal> which uses <literal>processEvents()</literal>.</para>
<example role="codelisting" label="9.7" id="ch09list07">
<title>Modified Version of <literal>KlongJob</literal>, Which Uses <literal>QApplication::processEvents()</literal></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;kaction.h>
 3: #include &lt;kstdaction.h>
 4:
 5: #include "klongjob.moc"
 6:
 7: KLongJob::KLongJob (const char *name=0) :
 8:   KTMainWindow (name)
 9: {
10:   start = 
11:     new KAction ("&amp;Start", 0,  this, SLOT(slotCompute()),
12:          actionCollection(), "start");
13:   stop =
14:     new KAction ("Sto&amp;p", 0,  this, SLOT(slotStopComputation()),
15:          actionCollection(), "stop");
16:
17:   KStdAction::quit (kapp, SLOT(closeAllWindows()),
18:             actionCollection());
19:
20:   createGUI();
21:
22:   stop->setEnabled (false);
23:
24:   qlabel = new QLabel (this);
25:   qlabel->setAlignment (QLabel::AlignCenter);
26:   setView (qlabel);
27: }
28:
29: void
30: KLongJob::slotStopComputation()
31: {
32:   bcontinuecomputation=false;
33: }
34:
35: void
36: KLongJob::slotCompute()
37: {
38:   double deviation;
39:   int i;
40:   count=total=0;
41:
42:   bcontinuecomputation=true;
43:
44:   start->setEnabled (false);
45:   stop->setEnabled (true);
46:
47:   kapp->processEvents();
48:
49:   for (i=0; i&lt;1000000 &amp;&amp;bcontinuecomputation; i++)
50:     {
51:       if (kapp->random()%2==1)
52:     count++;
53:       total++;
54:
55:       if (!(total%100))
56:     kapp->processEvents();
57:
58:
59:       if (!(total%5000))
60:     {
61:       deviation = (count - total/2.)/(double)total;
62:       QString qstring;
63:       qstring.
64:         sprintf ("Total flips: %10d\nDeviation from 50%% heads: %10.5f",
65:              total, deviation);
66:       qlabel->setText (qstring);
67:     }
68:     }
69:
70:   start->setEnabled (true);
71:   stop->setEnabled (false);
72:
73: }
</programlisting>
</example>
<para>This version of <literal>KLongJob</literal> looks essentially the same to the user as the previous version, but the programming style is quite different. The slot <literal>slotCompute()</literal> does all the work in one loop.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>processEvents() method</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>processEvents() method</primary></indexterm><indexterm><primary>methods</primary><secondary>processEvents()</secondary></indexterm></para>
<para>Every so often (after flipping the coin 100 times) in <literal>slotCompute()</literal>, you call (line 56)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
     kapp->processEvents();</programlisting>
</informalexample>
<para>which allows the paint event that is generated by <literal>qlabel</literal> when you change its text (line 66) to be processed, as well as any user input or other events that have been posted.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>processEvents() method</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>processEvents() method</primary></indexterm><indexterm><primary>methods</primary><secondary>processEvents()</secondary></indexterm></para>
<para>I don't recommend using <literal>processEvents()</literal> for long jobs, although you will find it used this way occasionally. The problem with it is that some events can't properly be processed if they need to eventually return control to the method that called <literal>processEvents()</literal>. As an example, run <literal>klongjob</literal>, choose File, Start, and then press Ctrl+Q before the calculation finishes. You should get this message</para>
<informalexample>
<programlisting linenumbering="unnumbered">
Segmentation fault (core dumped)
</programlisting>
</informalexample>
<para>(or something similar). This has happened because your request to terminate the program&mdash;which included deleting the current instance of <literal>KLongJob</literal>&mdash;was processed, and then an attempt to return control to the method <literal>slotCompute()</literal>, <emphasis>part of the deleted instance of</emphasis> <emphasis><literal>KLongJob</literal></emphasis>, was made. This problem could be circumvented, but the possibility still exists that, in a more complex program, you could run into other, similar problems. A safer and more elegant design uses the <literal>QTimer</literal> method described previously.</para>
<para>You can use the <literal>main()</literal> function given in <link linkend="ch09list06">Listing 9.6</link> to try this program. Its UI looks the same as <link linkend="ch09fig02">Figure 9.2</link>.<indexterm><primary>responsiveness</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>responsiveness</secondary><tertiary>long jobs, optimizing performance of</tertiary></indexterm><indexterm><primary>long jobs, optimizing performance of</primary><secondary>processEvents() method</secondary></indexterm><indexterm><primary>jobs</primary><secondary>long jobs, optimizing performance of</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>optimizing performance</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>performance optimization</primary><secondary>long jobs</secondary><tertiary>processEvents() method</tertiary></indexterm><indexterm><primary>processEvents() method</primary></indexterm><indexterm><primary>methods</primary><secondary>processEvents()</secondary></indexterm></para>
</section>
</section>
<section id="ch09lev1sec4">
<title>Summary</title>
<para>Constructing a responsive user interface is not all that difficult if you know the techniques. It is important to remember, when writing a GUI application, that your code needs to divide its time between performing work and interacting with the user. One should not be sacrificed for the other. In particular, it is important to stop thinking in a linear way when coding a long task&mdash;the rest of your application cannot wait for the long task. You should ask yourself the following questions:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Where is a good place to stop working on the long job and return control to the event loop?</para></listitem>
<listitem><para>How long should the long job continue before returning control to the event loop?</para></listitem>
<listitem><para>What information do I need to save so that I can pick up where I left off when control is returned from the event loop to the method carrying out the long job?</para></listitem></itemizedlist>
<para>Answering these questions will help you effectively use <literal>QTimer</literal> to perform long jobs.</para>
<para>You can speed up window updates by using the double-buffer technique. This can keep you from having to unnecessarily re-create your window's contents. This technique can also help reduce flicker by updating the entire window at once rather than drawing multiple objects on the window.</para>
</section>
<section id="ch09lev1sec5">
<title>Exercises</title>
<para>See <link linkend="ap-c">Appendix C, <quote>Answers,</quote></link> for the exercise answers.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch09que01">
<para><link linkend="ch09ans01">What if the process of creating your window contents is a long job? Combine the <literal>QTimer</literal> method for long jobs with double-buffering to efficiently paint a complex scene without hanging the GUI. Your program's GUI should still respond to input while the application is painting the window. (You can easily check this by attempting to close the window while the program is painting.) See <link linkend="ap-c">Appendix C, <quote>Answers,</quote></link> for the exercise answers.</link></para>
</question></qandaentry></qandaset>
</section>
</chapter>
