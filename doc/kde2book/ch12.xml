<chapter label="12" role="chapter" id="ch12">
	<title>Creating and Using Components (KParts)</title>
	<para>
		<emphasis>by David Faure</emphasis>
	</para>
	<highlights>
		<itemizedlist mark="bullet" spacing="compact">
			<title>In this chapter</title>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec1">The Difference Between Components and Widgets</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec2">The KDE Component Framework</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec3">Describing User Interface in XML</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec4">Read-Only and Read/Write Parts</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec5">Creating a Part</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec6">Making a Part Available Using Shared Libraries</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec7">Creating a KParts Application</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec8">Embedding More Than One Part in the Same Window</link>
					</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">
						<link linkend="ch12lev1sec9">Creating a KParts Plug-in</link>
					</emphasis>
				</para>
			</listitem>
		</itemizedlist>
	</highlights>
	<para>The <indexterm>
			<primary>components</primary>
			<see>parts</see>
		</indexterm>
		<indexterm>
			<primary>parts</primary>
		</indexterm>
		<indexterm>
			<primary>KParts</primary>
		</indexterm>main idea behind components is reusability. Often, an application wants to use a functionality that another application provides. Of course, the way to do that is simply to create a shared library that both applications use. But without a standard framework for this, it means both applications are very much coupled to the library's API and will need to be changed if the applications decide to use another library instead. Furthermore, integrating the shared functionality has to be done manually by every application.</para>
	<para>A framework for components enables an application to use a component it never heard of&mdash;and wasn't specifically adapted for&mdash;because both the application and the component comply to the framework and know what to expect from each other. An existing component can be replaced with a new implementation of the same functionality, without changing a single line of code in the application, because the interface remains the same.</para>
	<para>The framework presented here concerns elaborate graphical components, such as an image viewer, a text editor, a mail composer, and so on. Simpler graphical components are usually widgets; I refine this distinction in the next section. Nongraphical components, such as a parser or a string manipulation class, are usually libraries with a specific Application Programming Interface (API).</para>
	<para>Similar frameworks for graphical components exist for a different environment, such as IBM and Apple's OpenDoc, Microsoft's OLE, Gnome's Bonobo, and KDE's previous OpenParts.<indexterm>
			<primary>parts</primary>
		</indexterm>
		<indexterm>
			<primary>KParts</primary>
		</indexterm>
	</para>
	<section id="ch12lev1sec1">
		<title>The Difference Between Components and Widgets</title>
		<para>A KDE <indexterm>
				<primary>parts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>widgets</primary>
				<secondary>compared to parts</secondary>
			</indexterm>component is called a part, and it encapsulates three things: a widget, the functionality that comes with it, and the user interface for this functionality.</para>
		<para>The usual example is a text editor component. Its widget is a multiline text widget; its functionality might include Search And Replace, Copy, Cut, Paste, Undo, Redo, Spell Checking. To make it possible for the user to access this functionality, the component also provides the user interface for it: menu items and toolbar buttons.</para>
		<para>An application using this component will get the widget embedded into a parent widget it provides, as well as the component's user interface merged into its own menubar and toolbars. This is like embedding a MS Excel document into MS Word, an example everybody knows, or when embedding a KSpread document into KWord, an example that will hopefully become very well known as well.</para>
		<para>Another example of very useful component is an image viewer. When using KDE's file manager (Konqueror), clicking an image file opens the image viewer component from KDE's image viewer (KView) and shows it inside Konqueror's window. The part provides actions for zoom in, zoom out, rotate, reset to original size, and orientation.<indexterm>
				<primary>parts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>widgets</primary>
				<secondary>compared to parts</secondary>
			</indexterm>
		</para>
		<note role="normal">
			<para>Note that KOffice parts are a bit different because they don't embed as a full window, but as a frame into the parent's view, which can be moved, resized, and even rotated&mdash;a functionality only KOffice has. This and the document/view architecture of KOffice applications mean that the framework for KOffice parts, although based on KParts, is much more elaborate and out of topic here.</para>
		</note>
		<para>So, when do you use a part and when do you use a widget?</para>
		<para>Use a widget when all the functionality is in the widget itself and doesn't need additional user interface (menu items or toolbar buttons). A button is a widget, a multiline edit is a widget, but a text editor with all the functionality previously mentioned is a part. As you can see there is no problem choosing which one to use.<indexterm>
				<primary>parts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>compared to widgets</secondary>
			</indexterm>
			<indexterm>
				<primary>widgets</primary>
				<secondary>compared to parts</secondary>
			</indexterm>
		</para>
	</section>
	<section id="ch12lev1sec2">
		<title>The KDE Component Framework</title>
		<para>KParts is<indexterm>
				<primary>parts</primary>
				<secondary>framework</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>framework</secondary>
			</indexterm> the framework for KDE parts, based on standard KDE/Qt objects, such as QWidget and <literal>KTMainWindow</literal>. It defines a very simple set of classes: <literal>part</literal>, <literal>plugin</literal>, <literal>mainwindow</literal>, and <literal>part</literal>
			<literal>manager</literal>.</para>
		<itemizedlist mark="none" spacing="compact">
			<listitem>
				<para>A part, <indexterm>
						<primary>part class</primary>
					</indexterm>
					<indexterm>
						<primary>classes</primary>
						<secondary>part</secondary>
					</indexterm>as previously described, is the name for a KDE component. To define a new part, you need to provide the widget, of course, but also the actions that give access to the part's functionality and an XML file that describes the layout of those actions in the user interface.</para>
			</listitem>
			<listitem>
				<para>A plugin <indexterm>
						<primary>plugin class</primary>
					</indexterm>
					<indexterm>
						<primary>classes</primary>
						<secondary>plugin</secondary>
					</indexterm>is a small piece of functionality that is not implemented by an embedded widget, but that defines some actions to be merged in the application's user interface, such as the calculator plugin for KSpread. It can be graphical, however, like a dialog box or a separate window popping up, or it can be an application-specific plugin and act on the application itself&mdash;a spell checker for a word processor, for example.<indexterm>
						<primary>parts</primary>
						<secondary>framework</secondary>
					</indexterm>
					<indexterm>
						<primary>KParts</primary>
						<secondary>framework</secondary>
					</indexterm>
				</para>
			</listitem>
			<listitem>
				<para>A KParts mainwindow <indexterm>
						<primary>mainwindow class</primary>
					</indexterm>
					<indexterm>
						<primary>classes</primary>
						<secondary>mainwindow</secondary>
					</indexterm>is a special <literal>KTMainWindow</literal> whose user interface is described in XML and with actions so that it is able to embed parts. The reason it has to use XML is because merging user interfaces is implemented by merging XML documents.</para>
			</listitem>
			<listitem>
				<para>A part manager <indexterm>
						<primary>part manager class</primary>
					</indexterm>
					<indexterm>
						<primary>classes</primary>
						<secondary>part manager</secondary>
					</indexterm>is a more abstract object whose task is to handle the activation and the deactivation of the parts. Of course, this is useful only for mainwindows that embed more than one part, such as KOffice documents (where the main document is also a part), or Konqueror (where each view is a part). KWrite, which embeds only its own part, doesn't need a part manager.<indexterm>
						<primary>parts</primary>
						<secondary>framework</secondary>
					</indexterm>
					<indexterm>
						<primary>KParts</primary>
						<secondary>framework</secondary>
					</indexterm>
				</para>
			</listitem>
		</itemizedlist>
		<para>In the following sections, you create a part for a simple text editor, a main window able to embed an existing PostScript-viewer part, a part manager to embed more than one part, and even a plug-in; thus, you will know everything about KParts.<indexterm>
				<primary>parts</primary>
				<secondary>framework</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>framework</secondary>
			</indexterm>
		</para>
	</section>
	<section id="ch12lev1sec3">
		<title>Describing User Interface in XML</title>
		<para>The <indexterm>
				<primary>parts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>XML files</primary>
				<secondary>user interfaces</secondary>
			</indexterm>XML file used by a part or a mainwindow provides only the layout of the actions in the user interface. The actions themselves are still implemented in the code, with slots, as usual.</para>
		<para>More precisely, the XML file describes the layout of the menus and submenus in the menubar (only one menubar is always present) and the menu items within those menus, as well as the toolbars and the toolbar buttons. The menubar, menus, and toolbars are containers; menu items and toolbar buttons are the actions.</para>
		<para>A sample XML file for a mainwindow looks like the one shown in <link linkend="ch12list01">Listing 12.1</link>.<indexterm>
				<primary>parts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>XML files</primary>
				<secondary>user interfaces</secondary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.1" id="ch12list01">
			<title>Excerpt of konqueror.rc: A User Interface Described in XML</title>
			<programlisting linenumbering="unnumbered">
&lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
&lt;kpartgui name="Konqueror" version="1">
  &lt;MenuBar>
   &lt;Menu name="file">&lt;Text>&amp;amp;File&lt;/Text>
    &lt;Action name="find"/>
    &lt;Separator/>
    &lt;Action name="print"/>
    &lt;Separator/>
    &lt;Action name="close"/>
   &lt;/Menu>
   &lt;Menu name="edit">&lt;Text>&amp;amp;Edit&lt;/Text>
    &lt;Action name="cut"/>
    &lt;Action name="copy"/>
    &lt;Action name="paste"/>
    &lt;Action name="trash"/>
    &lt;Action name="del"/>
    &lt;Separator/>
    &lt;Merge/>
    &lt;Separator/>
   &lt;/Menu>
   &lt;Merge/>
  &lt;/MenuBar>
  &lt;ToolBar fullWidth="true" name="mainToolBar">&lt;Text>Main&lt;/Text>
   &lt;Action name="cut"/>
   &lt;Action name="copy"/>
   &lt;Action name="paste"/>
   &lt;Action name="print"/>
   &lt;Separator/>
   &lt;Merge/>
   &lt;Separator/>
   &lt;Action name="animated_logo"/>
  &lt;/ToolBar>
  &lt;ToolBar name="locationToolBar">&lt;Text>Location&lt;/Text>
   &lt;Action name="toolbar_url_combo"/>
  &lt;/ToolBar>
&lt;/kpartgui><indexterm>
					<primary>parts</primary>
					<secondary>XML files</secondary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>XML files</secondary>
				</indexterm>
				<indexterm>
					<primary>XML files</primary>
					<secondary>user interfaces</secondary>
				</indexterm>
			</programlisting>
		</example>
		<para>The <literal>DOCTYPE</literal>
			<indexterm>
				<primary>DOCTYPE tag (XML)</primary>
			</indexterm>
			<indexterm>
				<primary>XML tags</primary>
				<secondary>DOCTYPE</secondary>
			</indexterm>
			<indexterm>
				<primary>tags (XML)</primary>
				<secondary>DOCTYPE</secondary>
			</indexterm>tag contains the name of the main element, which should be set to <literal>kpartgui</literal>. The top-level elements are <literal>MenuBar</literal> and <literal>ToolBar</literal>, as expected. In the <literal>MenuBar</literal>, the menus are described. Note that they have a name, used for merging later on, and a text, which is displayed in the user interface, possibly translated. Because this is XML, <literal>&amp;</literal> has to be encoded as <literal>&amp;amp;</literal>. Inside a <literal>Menu</literal> tag, the actions, some separators, and possibly submenus are laid out. The action names are very important because they are used to match the actions created in the code.<indexterm>
				<primary>parts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>XML files</primary>
				<secondary>user interfaces</secondary>
			</indexterm>
		</para>
		<para>The toolbars are then described. Note that the main toolbar has to be called mainToolBar because its settings can be different. KToolBar takes care of adding text under icons for this particular toolbar, if the user wants them. Actions are laid out in the toolbars the usual way. The text for a toolbar is used where the name of the toolbar is to be displayed to the user, possibly translated, such as the toolbar editor.</para>
		<para>Another important tag is the <indexterm>
				<primary>Merge tag (XML)</primary>
			</indexterm>
			<indexterm>
				<primary>XML tags</primary>
				<secondary>Merge</secondary>
			</indexterm>
			<indexterm>
				<primary>tags (XML)</primary>
				<secondary>Merge</secondary>
			</indexterm>
			<literal>Merge</literal> tag. This tag tells the framework where the actions of the active part&mdash;and the plug-ins&mdash;should be merged in a given container. As you can see, this XML file inserts the part's actions before a separator in the Edit menu, whereas it doesn't specify a position for items in the File menu. This means that if the part defines actions for the File menu, they will be appended to the File menu of the mainwindow.<indexterm>
				<primary>parts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>XML files</primary>
				<secondary>user interfaces</secondary>
			</indexterm>
		</para>
		<para>The merging happens when a part simply uses the same menu name or toolbar name as the mainwindow.</para>
		<para>If a <literal>Merge</literal> tag is specified as a child of the <literal>MenuBar</literal> tag, the merging happens at that position; otherwise, it takes place on the right of the existing menus. The toolbar allows merging of the part's actions as well, based on the same principle.</para>
		<para>The <literal>Merge</literal> tag can also appear in a part's XML. It will be used for merging plug-ins or for more advanced uses; the merging engine can merge any number of <quote>inputs</quote> and it is possible to define specific inputs, such as the one Konqueror defines for its View menu.</para>
		<para>Another advanced use of the <literal>Merge</literal> tag is to set a name attribute for it. For instance, if another XML file wants to embed a part and any other parts or plug-ins at different positions in a given menu, it can use two merge tags:<indexterm>
				<primary>Merge tag (XML)</primary>
			</indexterm>
			<indexterm>
				<primary>XML tags</primary>
				<secondary>Merge</secondary>
			</indexterm>
			<indexterm>
				<primary>tags (XML)</primary>
				<secondary>Merge</secondary>
			</indexterm>
		</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
&lt;Merge name="MyPart"/>
.
.
.
&lt;Merge />
</programlisting>
		</informalexample>
		<para>Using the name attribute for the <literal>Merge</literal> tag allows you to control at which position each XML fragment is merged, but it is usually unnecessary.<indexterm>
				<primary>parts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>XML files</secondary>
			</indexterm>
			<indexterm>
				<primary>XML files</primary>
				<secondary>user interfaces</secondary>
			</indexterm>
		</para>
	</section>
	<section id="ch12lev1sec4">
		<title>Read-Only and Read/Write Parts</title>
		<para>The framework defines different kinds of parts. The generic class is <literal>Part</literal> and is the one that provides the basic functionality for a part: widget, XML, and actions.</para>
		<section id="ch12lev2sec1">
			<title>Read-Only Parts</title>
			<para>The <indexterm>
					<primary>parts</primary>
					<secondary>read-only parts</secondary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>read-only parts</secondary>
				</indexterm>
				<indexterm>
					<primary>read-only parts</primary>
				</indexterm>
				<indexterm>
					<primary>ReadOnlyPart class</primary>
				</indexterm>
				<indexterm>
					<primary>classes</primary>
					<secondary>ReadOnlyPart</secondary>
				</indexterm>class <literal>ReadOnlyPart</literal> provides a common framework for all parts that implement any kind of viewer. A text viewer, an image viewer, a PostScript viewer, and a Web browser are all viewers. What they have in common is that they all act on a URL, and in a read-only way. It has always been a design decision in KDE to provide network transparency wherever possible, which is why most KDE applications use URLs, not only filenames. The framework defines methods for opening a URL, closing a URL, and above all provides network transparency&mdash;by downloading the file, if remote, and emitting signals (started, progression, completed). The part itself has to provide only <literal>openFile()</literal>, which opens a local file.</para>
			<para>This common framework for read-only parts enables applications to embed all viewers the same way and to better control those parts. For instance, when Konqueror uses a read-only part to display a file, it can make it open the file using <literal>openURL()</literal> and get all the progress information from the part. All this is not available in the generic <literal>Part</literal> class.<indexterm>
					<primary>parts</primary>
					<secondary>read-only parts</secondary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>read-only parts</secondary>
				</indexterm>
				<indexterm>
					<primary>read-only parts</primary>
				</indexterm>
				<indexterm>
					<primary>ReadOnlyPart class</primary>
				</indexterm>
				<indexterm>
					<primary>classes</primary>
					<secondary>ReadOnlyPart</secondary>
				</indexterm>
			</para>
		</section>
		<section id="ch12lev2sec2">
			<title>Read-Write Parts</title>
			<para>Another kind of part is the <literal>ReadWritePart</literal>, which is an extension of the read-only one, to which it obviously adds the possibility to modify and save the document. This is the one used by a text editor part such as KWrite's, as well as all KOffice parts.</para>
			<para>For read/write parts, the framework provides the other half of the network transparency&mdash; re-uploading the document when saving, for remote files. A read/write part must also know how to act read-only, in case it is used as a read-only part. This is what happens when embedding KWrite or KOffice into Konqueror to view a text file, without being allowed to edit the file. More generally, any editor can be and must know how to be a viewer, as well.<indexterm>
					<primary>parts</primary>
					<secondary>read/write parts</secondary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>read/write parts</secondary>
				</indexterm>
				<indexterm>
					<primary>read/write parts</primary>
				</indexterm>
				<indexterm>
					<primary>ReadWritePart class</primary>
				</indexterm>
				<indexterm>
					<primary>classes</primary>
					<secondary>ReadWritePart</secondary>
				</indexterm>
			</para>
		</section>
	</section>
	<section id="ch12lev1sec5">
		<title>Creating a Part</title>
		<para>In <indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
			</indexterm>this section, you create a very simple part for a text editor. If you have closely followed the previous section, you know that the part should inherit <literal>KParts::ReadWritePart</literal>.</para>
		<para>At this point, it is a very good idea to read kparts/part.h, directly or preferably after running kdoc on it (see <link linkend="ch15">Chapter 15, <quote>Creating Documentation,</quote>
			</link> for information about kdoc). This tells you that a read/write part implementation has to provide the methods <literal>openFile()</literal> and <literal>saveFile()</literal>.<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
			</indexterm>
		</para>
		<para>The task of <literal>openFile()<indexterm>
					<primary>openFile() function</primary>
				</indexterm>
				<indexterm>
					<primary>functions</primary>
					<secondary>openFile()</secondary>
				</indexterm>
			</literal> is obviously to open a local file, which the framework has previously downloaded for us in case the URL that the user wants to open is a remote one. In this case, the file you open is a temporary local file.</para>
		<para>In <literal>saveFile()</literal>, <indexterm>
				<primary>saveFile() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>saveFile()</secondary>
			</indexterm>the part saves to the local file, and in case it's a temporary file, the framework takes care of uploading the new file.</para>
		<para>You can now sketch the header file for your part, which is called <literal>NotepadPart</literal> (see <link linkend="ch12list02">Listing 12.2</link>).<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>notepad_part.h header</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.h header file</primary>
			</indexterm>
			<indexterm>
				<primary>listings</primary>
				<secondary>NotepadPart part</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.2" id="ch12list02">
			<title>notepad_part.h: Header of the NotepadPart Class<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.h header</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: #ifndef __notepad_h__
 2: #define __notepad_h__
 3:
 4: #include &lt;kparts/part.h>
 5:
 6: class QMultiLineEdit;
 7:
 8: class NotepadPart : public KParts::ReadWritePart
 9: {
10:   Q_OBJECT
11: public:
12:   NotepadPart( QWidget * parent, const char * name = 0L );
13:   virtual ~NotepadPart() {}
14:
15:   virtual void setReadWrite( bool rw );
16:
17: protected:
18:   virtual bool openFile();
19:   virtual bool saveFile();
20:
21: protected slots:
22:   void slotSelectAll();
23:
24: protected:
25:   QMultiLineEdit * m_edit;
26:   KInstance *m_instance;
27: };
28:
29: #endif<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.h header</tertiary>
				</indexterm>
			</programlisting>
		</example>
		<para>The parent passed to the constructor is both the parent of the widget and the parent of the part itself, so that both get destroyed if the parent is destroyed. Note that having the same parent is not mandatory. If they have different parents, the framework deletes the widget if the part is destroyed and deletes the part if the widget is destroyed.<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>notepad_part.h header</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.h header file</primary>
			</indexterm>
		</para>
		<para>The class members are a <literal>QMultiLineEdit</literal> (the multiline widget from Qt), and a <literal>KInstance</literal>. An instance enables access to global KDE objects, which can be different from the ones of the application. The application's configuration file and the one of any other instance is different, as well as the search paths for <literal>locate()</literal>, and so on. In KParts, this is used to locate the XML file describing the part, which is usually installed into share/apps/instancename/.</para>
		<para>In addition, you define a slot, <literal>slotSelectAll()</literal>, to be connected to the action your part provides.</para>
		<para>The corresponding XML file for the part <literal>NotepadPart</literal> is listed in <link linkend="ch12list03">Listing 12.3</link> and defines its GUI by an action named <literal>selectall</literal>, to be inserted into the menu Edit in the menubar. Note that the text for the Edit menu is specified, which is mandatory even if mainwindows usually specify it, because it has to work even if a mainwindow doesn't have an Edit menu on its own. So the rule is simple: always provide a text for all menus.<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>notepad_part.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>notepad_part.h header</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.h header file</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.3" id="ch12list03">
			<title>notepadpart.rc: XML Description of the Notepad Part's User Interface<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.rc XML description</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="unnumbered">
&lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
&lt;kpartgui name="NotepadPart" version="1">
&lt;MenuBar>
 &lt;Menu name="Edit">&lt;Text>&amp;amp;Edit&lt;/Text>
  &lt;Action name="selectall"/>
 &lt;/Menu>
&lt;/MenuBar>
&lt;StatusBar/>
&lt;/kpartgui><indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.rc XML description</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_part.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_part.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart part</primary>
					<secondary>notepad_part.h header</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_part.h header file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>An important task in the definition of a part is its constructor. It must at least define the instance, the widget, the actions, and the XML File. The constructor for this example could be as shown in <link linkend="ch12list04">Listing 12.4</link>.<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>constructor</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>constructor</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>constructor</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.cpp part 1 file</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.4" id="ch12list04">
			<title>notepad_part.cpp part 1: Constructor<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 1 constructor</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: NotepadPart::NotepadPart( QWidget * parent, const char * name )
 2:  : KParts::ReadWritePart( parent, name )
 3: {
 4:   KInstance * instance = new KInstance( "notepadpart" );
 5:   setInstance( instance );
 6:
 7:   m_edit = new QMultiLineEdit( parent, "multilineedit" );
 8:   m_edit->setFocus();
 9:   setWidget( m_edit );
10:
11:   (void)new KAction( i18n( "Select All" ), 0, this,
12:         SLOT( slotSelectAll() ), actionCollection(), "selectall" );
13:   setXMLFile( "notepadpart.rc" );
14:
15:   setReadWrite( true );
16: }<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 1 constructor</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>constructor</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>constructor</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart part</primary>
					<secondary>constructor</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_part.cpp part 1 file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>After calling the parent constructor with parent and name, you create an instance, named <literal>notepadpart</literal>, and declare it to the framework using <literal>setInstance()</literal>. This is a temporary solution; you'll see later how to use a library-factory's instance. Then you create the multiline edit widget, give it the focus, and declare it as well, using <literal>setWidget()</literal>.</para>
		<para>The next step is to create the actions that your part provides. The <quote>selectall</quote> action is given a translated label, is connected to <literal>slotSelectAll()</literal>, and is created as a child of the action collection that the framework provides. This is important, because it's the only way to make it find the action later on, when parsing the XML file. This is why you don't even need to store the action in a variable, unless you want to be able to enable or disable it later.</para>
		<para>You also need to give the framework the name of the XML file describing the part's GUI. As mentioned previously, it is usually installed into share/apps/instancename/, and in this case, you simply pass the filename with no path. It is also possible, but not recommended, to install the XML file anywhere else and provide a full path in <literal>setXMLFile()</literal>.</para>
		<para>Finally, the part is set to read/write mode. Read/write parts feature the <literal>setReadWrite()</literal> call<indexterm>
				<primary>setReadWrite() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>setReadWrite()</secondary>
			</indexterm>, which enables you to set the read/write mode on or off. Most parts should reimplement this method to enable or disable anything that modifies the part, KActions as well as any direct modification provided by the widget itself. The reimplementation of <literal>setReadWrite()</literal> for the Notepad Part is shown in <link linkend="ch12list05">Listing 12.5</link>.<indexterm>
				<primary>setReadWrite() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>setReadWrite()</secondary>
			</indexterm>
			<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>setReadWrite() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>setReadWrite() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>setReadWrite() function</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.cpp part 2 file</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.5" id="ch12list05">
			<title>notepad_part.cpp part 2: Implementation of setReadWrite<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 2</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="unnumbered">
void NotepadPart::setReadWrite( bool rw )
{
  m_edit->setReadOnly( !rw );
  if (rw)
    connect( m_edit, SIGNAL( textChanged() ), this, SLOT( setModified() ) );
  else
    disconnect( m_edit, SIGNAL( textChanged() ), this, SLOT( setModified() ) );

  ReadWritePart::setReadWrite( rw ); // always call the parent implementation
}<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 2</tertiary>
				</indexterm>
				<indexterm>
					<primary>setReadWrite() function</primary>
				</indexterm>
				<indexterm>
					<primary>functions</primary>
					<secondary>setReadWrite()</secondary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>setReadWrite() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>setReadWrite() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart part</primary>
					<secondary>setReadWrite() function</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_part.cpp part 2 file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>In the example, there are no actions to disable, but the multiline widget has to be set to its read-only mode.</para>
		<para>The connection to<indexterm>
				<primary>setModified() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>setModified()</secondary>
			</indexterm>
			<literal>setModified()</literal>, done in read/write mode only, enables the framework to keep track of the state of the document. When closing a document that has been modified, the framework automatically asks whether it should save it and allow you to cancel the close. Note that to make all this work, you just needed to connect a signal when the part is in read/write mode and disconnect it when it's in read-only mode. This avoids warnings when a loading a file, which changes the text.</para>
		<para>It might seem a bit painful to have to handle both read/write and read-only mode, but doing this gives for free the possibility to embed the part as a viewer, in Konqueror, for instance, so it's usually worth doing.</para>
		<para>Your part is created; you need to make it useful. The method that all read-only parts&mdash;and by inheritance, all read/write parts as well&mdash;must reimplement is the <literal>openFile()</literal> method. This is where a part opens and displays the local file, whose full path is provided in the member variable <literal>m_file</literal>, and which the framework downloaded from a remote location first, if necessary. Because your part is a text viewer, all it has to do is read the file into a <literal>QString</literal> and set the multiline widget's text from it, as shown in <link linkend="ch12list06">Listing 12.6</link>.<indexterm>
				<primary>openFile() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>openFile()</secondary>
			</indexterm>
			<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>openFile() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>openFile() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>openFile() function</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.cpp part 3 file</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.6" id="ch12list06">
			<title>notepad_part.cpp part 3: Implementation of openFile<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 3</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: bool NotepadPart::openFile()
 2: {
 3:   QFile f(m_file);
 4:   QString s;
 5:   if ( f.open(IO_ReadOnly) )
 6:   {
 7:     QTextStream t( &amp;f );
 8:     while ( !t.eof() ) {
 9:       s += t.readLine() + "\n";
10:     }
11:     f.close();
12:   }
13:   m_edit->setText(s);
14:
15:   return true;
16: }<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 3</tertiary>
				</indexterm>
				<indexterm>
					<primary>openFile() function</primary>
				</indexterm>
				<indexterm>
					<primary>functions</primary>
					<secondary>openFile()</secondary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>openFile() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>openFile() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart part</primary>
					<secondary>openFile() function</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_part.cpp part 3 file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>The last thing you need to do is, of course, to provide saving; otherwise, the user will not like it! All read/write parts have to reimplement <literal>saveFile()</literal> to save the document to <literal>m_file</literal>, as shown in <link linkend="ch12list07">Listing 12.7</link>. Note that the framework takes care of Save As (changing the URL to Save To), as well as uploading the saved file, if necessary.<indexterm>
				<primary>saveFile() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>saveFile()</secondary>
			</indexterm>
			<indexterm>
				<primary>parts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>saveFile() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>NotepadPart example</secondary>
				<tertiary>saveFile() function</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadPart part</primary>
				<secondary>saveFile() function</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_part.cpp part 4 file</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.7" id="ch12list07">
			<title>notepad_part.cpp part 4: Implementation of saveFile<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 4</tertiary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: bool NotepadPart::saveFile()
 2: {
 3:   if ( !isReadWrite() )
 4:     return false;
 5:   QFile f(m_file);
 6:   QString s;
 7:   if ( f.open(IO_WriteOnly) ) {
 8:     QTextStream t( &amp;f );
 9:     t &lt;&lt; m_edit->text();
10:     f.close();
11:     return true ;
12:   } else
13:     return false;
14: }<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_part.cpp part 4</tertiary>
				</indexterm>
				<indexterm>
					<primary>saveFile() function</primary>
				</indexterm>
				<indexterm>
					<primary>functions</primary>
					<secondary>saveFile()</secondary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>saveFile() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>saveFile() function</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart part</primary>
					<secondary>saveFile() function</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_part.cpp part 4 file</primary>
				</indexterm>
			</programlisting>
		</example>
	</section>
	<section id="ch12lev1sec6">
		<title>Making a Part Available Using Shared Libraries</title>
		<para>You <indexterm>
				<primary>parts</primary>
				<secondary>including in shared libraries</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>including in shared libraries</secondary>
			</indexterm>
			<indexterm>
				<primary>libraries</primary>
				<secondary>parts, including</secondary>
			</indexterm>
			<indexterm>
				<primary>shared libraries</primary>
				<secondary>parts, including</secondary>
			</indexterm>know how to create a part now. But currently, it can be used only by linking directly to its code. Although this is enough in some cases, such as KWrite's part embedded by KWrite itself, it is much more flexible to provide dynamic linking to the library containing the part. This is not directly related to <literal>KParts</literal>, but it is necessary to make it possible for any application to use the part.</para>
		<para>The first step is to compile the part in a shared library, which is really simple using <literal>automake</literal>. The relevant portion of Makefile.am is shown in <link linkend="ch12list08">Listing 12.8</link>
			<indexterm>
				<primary>parts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>makefiles</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>makefiles</tertiary>
			</indexterm>
			<indexterm>
				<primary>libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>makefiles</tertiary>
			</indexterm>
			<indexterm>
				<primary>shared libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>makefiles</tertiary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.8" id="ch12list08">
			<title>Extract from <literal>Makefile.am<indexterm>
						<primary>listings</primary>
						<secondary>NotepadPart part</secondary>
						<tertiary>Makefile.am</tertiary>
					</indexterm>
					<indexterm>
						<primary>parts</primary>
						<secondary>NotepadPart example</secondary>
						<tertiary>Makefile.am</tertiary>
					</indexterm>
					<indexterm>
						<primary>KParts</primary>
						<secondary>NotepadPart example</secondary>
						<tertiary>Makefile.am</tertiary>
					</indexterm>
					<indexterm>
						<primary>NotepadPart part</primary>
						<secondary>Makefile.am</secondary>
					</indexterm>
					<indexterm>
						<primary>Makefile.am file (NotepadPart)</primary>
					</indexterm>
				</literal>
			</title>
			<programlisting linenumbering="unnumbered">
lib_LTLIBRARIES = libnotepad.la
libnotepad_la_SOURCES = notepad_part.cpp notepad_factory.cpp
libnotepad_la_LIBADD = $(LIB_KFILE) $(LIB_KPARTS)
libnotepad_la_LDFLAGS = $(all_libraries) $(KDE_PLUGIN)
METASOURCES = AUTO<indexterm>
					<primary>parts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>makefiles</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>makefiles</tertiary>
				</indexterm>
				<indexterm>
					<primary>libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>makefiles</tertiary>
				</indexterm>
				<indexterm>
					<primary>shared libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>makefiles</tertiary>
				</indexterm>
			</programlisting>
		</example>
		<para>Your part is now available in a shared library, but this is not enough. You must provide a way for anybody opening that library dynamically to create a part. This is done using a factory, derived from KLibFactory, which you'll do in the class <literal>NotepadFactory</literal>. An application willing to open a shared library dynamically uses the class <literal>KLibLoader</literal>, which takes care of locating the library, opening it, and calling an initialization function&mdash;here <literal>init_libnotepad()</literal>. This function creates a <literal>NotepadFactory</literal> and returns it to <literal>KLibLoader</literal>, which can then call the <literal>create</literal> method on the factory. This means that all you need to do in the library itself is define <literal>init_libnotepad()</literal> and the <literal>NotepadFactory</literal>.</para>
		<para>The header for the factory is the one shown in <link linkend="ch12list09">Listing 12.9</link>.<indexterm>
				<primary>parts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>shared libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>factories</primary>
				<secondary>NotepadFactory</secondary>
				<tertiary>notepad_factory.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadFactory</primary>
				<secondary>notepad_factory.h header</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_factory.h header</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.9" id="ch12list09">
			<title>notepad_factory.h: Header File for NotepadFactory<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_factory.h factory header</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart partnotepad_factory.h header</primary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.h file (NotepadFactory)</primary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: #include &lt;klibloader.h>
 2: class KInstance;
 3: class KAboutData;
 4: class NotepadFactory: public KLibFactory
 5: {
 6:   Q_OBJECT
 7: public:
 8:   NotepadFactory( QObject * parent = 0, const char * name = 0 );
 9:   ~NotepadFactory();
10:
11:   // reimplemented from KLibFactory
12:   virtual QObject * create( QObject * parent = 0, const char * name = 0,
13:         const char * classname = "QObject",
14:         const QStringList &amp;args = QStringList());
15:
16:   static KInstance * instance();
17:
18: private:
19:  static KInstance * s_instance;
20:  static KAboutData * s_about;
21: };<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_factory.h factory header</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.h header</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart partnotepad_factory.h header</primary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.h file (NotepadFactory)</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>As required by KLibFactory, your factory implements the <literal>create</literal> method, which creates a <literal>Notepad</literal> part and sets it to read/write mode or read-only mode, depending on whether the <literal>classname</literal> is <literal>KParts::ReadWritePart</literal> or <literal>KParts::ReadOnlyPart</literal>.<indexterm>
				<primary>parts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>shared libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory headers</tertiary>
			</indexterm>
			<indexterm>
				<primary>factories</primary>
				<secondary>NotepadFactory</secondary>
				<tertiary>notepad_factory.h header</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadFactory</primary>
				<secondary>notepad_factory.h header</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_factory.h header</primary>
			</indexterm>
		</para>
		<para>It also features a static instance, which is used in the part, instead of creating your own instance for each part. It is static because usually there is only one instance per library.</para>
		<para>This means the code of <literal>notepad_part.cpp</literal> should be modified to call <literal>setInstance( NotepadFactory::instance() );</literal> instead of creating its own instance.</para>
		<para>The implementation for the NotepadFactory is shown in <link linkend="ch12list10">Listing 12.10</link>.<indexterm>
				<primary>parts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>including in shared libraries</secondary>
				<tertiary>factory implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>shared libraries</primary>
				<secondary>parts, including</secondary>
				<tertiary>factory implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>factories</primary>
				<secondary>NotepadFactory</secondary>
				<tertiary>notepad_factory.cpp implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>NotepadFactory</primary>
				<secondary>notepad_factory.cpp implementation</secondary>
			</indexterm>
			<indexterm>
				<primary>notepad_factory.cpp implementation</primary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.10" id="ch12list10">
			<title>notepad_factory.cpp: NotepadFactory Implementation<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_factory.cpp factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementatio</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart partnotepad_factory.cpp implementatio</primary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.cpp implementatio (NotepadFactory)</primary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: #include "notepad_factory.h"
 2:
 3: #include &lt;klocale.h>
 4: #include &lt;kstddirs.h>
 5: #include &lt;kinstance.h>
 6: #include &lt;kaboutdata.h>
 7:
 8: #include "notepad_part.h"
 9:
10: extern "C"
11: {
12:     void* init_libnotepad()
13:     {
14:     return new NotepadFactory;
15:     }
16: };
17:
18: KInstance* NotepadFactory::s_instance = 0L;
19: KAboutData* NotepadFactory::s_about = 0L;
20:
21: NotepadFactory::NotepadFactory( QObject* parent, const char* name )
22:     : KLibFactory( parent, name )
23: {
24: }<indexterm>
					<primary>parts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>shared libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>factories</primary>
					<secondary>NotepadFactory</secondary>
					<tertiary>notepad_factory.cpp implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadFactory</primary>
					<secondary>notepad_factory.cpp implementation</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.cpp implementation</primary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_factory.cpp factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementatio</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart partnotepad_factory.cpp implementatio</primary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.cpp implementatio (NotepadFactory)</primary>
				</indexterm>
25:
26: NotepadFactory::~NotepadFactory()
27: {
28:   delete s_instance;
29:   s_instance = 0L;
30:   delete s_about;
31: }
32:
33: QObject* NotepadFactory::create( QObject* parent, const char* name,
34:                                 const char* classname, const QStringList&amp;)
35: {
36:   if ( parent &amp;&amp;!parent->inherits("QWidget") )
37:   {
38:     kdError() &lt;&lt; "NotepadFactory: parent does not inherit QWidget" &lt;&lt; endl;
39:     return 0L;
40:   }
41:
42:   NotepadPart* part = new NotepadPart( (QWidget*) parent, name );
43:   // readonly ?
44:   if (QCString(classname) == "KParts::ReadOnlyPart")
45:      part->setReadWrite(false);
46:
47:   // otherwise, it has to be readwrite
48:   else if (QCString(classname) != "KParts::ReadWritePart")
49:   {
50:     kdError() &lt;&lt; "classname isn't ReadOnlyPart nor ReadWritePart !" &lt;&lt; endl;
51:     return 0L;
52:   }
53:
54:   emit objectCreated( part );
55:   return part;
56: }
57:
58: KInstance* NotepadFactory::instance()
59: {
60:   if( !s_instance )
61:   {
62:     s_about = new KAboutData( "notepadpart",
63:                               I18N_NOOP( "Notepad" ), "2.0pre" );
64:     s_instance = new KInstance( s_about );
65:   }
66:   return s_instance;
67: }
68:
69: #include "notepad_factory.moc"<indexterm>
					<primary>parts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>including in shared libraries</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>shared libraries</primary>
					<secondary>parts, including</secondary>
					<tertiary>factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>factories</primary>
					<secondary>NotepadFactory</secondary>
					<tertiary>notepad_factory.cpp implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadFactory</primary>
					<secondary>notepad_factory.cpp implementation</secondary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.cpp implementation</primary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>NotepadPart part</secondary>
					<tertiary>notepad_factory.cpp factory implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>parts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>NotepadPart example</secondary>
					<tertiary>notepad_factory.cpp implementatio</tertiary>
				</indexterm>
				<indexterm>
					<primary>NotepadPart partnotepad_factory.cpp implementatio</primary>
				</indexterm>
				<indexterm>
					<primary>notepad_factory.cpp implementatio (NotepadFactory)</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>The implementation is a bit long but contains nothing complex. Basically, you define the function that is the entry point of the library, <literal>init_libnotepad()</literal>. It needs to be linked as a C function to avoid C++ name mangling. C linkage means that the symbol in the library will match the function name.</para>
		<para>Then you define the <literal>NotepadFactory</literal>. The <literal>create</literal> method checks that the parent is a widget because this is needed for your part (remember, you create your widget with the parent widget given as an argument to the constructor). After creating the part, it has to emit <literal>objectCreated</literal> so that the library loader can do a proper reference counting; it automatically unloads the library after all objects created from it have been destroyed.</para>
		<para>The <literal>instance()</literal> method returns the static instance, creating it first, if necessary. To create an instance, I recommend that you give it a <literal>KAboutData</literal> pointer. This gives some information about the instance representing the library (here an instance name, a translatable description of it, and a version number). You can add a lot more information in the <literal>KAboutData</literal> object, such as authors, home page, and bug-report address. See the documentation for details.</para>
		<para>The standard KDE dialogs such as the Bug Report Dialog and the About Dialog use the data stored in <literal>KAboutData</literal> to show information about the current program, but in the future they will probably be improved to show information about the active part as well, which can have completely different About data from the application.</para>
		<note role="normal">
			<para>KParts provides a factory base class, <literal>KParts::Factory</literal>, which enhances KlibFactory by making it possible to have a parent for the widget different from the parent for the part. It also takes care of loading the translation message catalog for the newly created part. Look in kparts/factory.h for more on this.</para>
		</note>
	</section>
	<section id="ch12lev1sec7">
		<title>Creating a KParts Application</title>
		<para>If an<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
			</indexterm> application wants to use parts and the GUI merging feature, its own GUI needs to be defined in XML. The top level windows of the application will then use the class <literal>KParts::MainWindow</literal>.</para>
		<para>Note that it's also possible to use a part in a standard application, using <literal>KTMainWindow</literal>, but then no GUI merging happens. In this case, only the functionality provided by the widget and by the part API are available, so the application has to create the GUI for part's functionality itself, or the part has to provide it through context menus. In any case, it is much less flexible.</para>
		<para>As an example of a window based on <literal>KParts::MainWindow</literal>, you are going to create a PostScript viewer very easily, by embedding the part provided by KDE's PostScript viewer, KGhostView.</para>
		<note role="normal">
			<para>You need to install the package kdegraphics if you want to test this example.</para>
		</note>
		<para>The first thing to look at is the mainwindow's GUI; an example is given in <link linkend="ch12list11">Listing 12.11</link>.<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow GUI</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow GUI</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>mainwindow GUI</tertiary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.11" id="ch12list11">
			<title>ghostviewtest_shell.rc: The Mainwindow's GUI<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest_shell.rc</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest_shell.rc</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest_shell.rc file</primary>
				</indexterm>
			</title>
			<programlisting linenumbering="unnumbered">
&lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
&lt;kpartgui name="KGVShell" version="1">
&lt;MenuBar>
 &lt;Menu name="file">&lt;text>&amp;amp;File&lt;/text>
  &lt;Action name="file_open"/>
  &lt;Merge/>
  &lt;Action name="file_quit"/>
&lt;/Menu>
&lt;/MenuBar>
&lt;ToolBar name="KGV-ToolBar">&lt;text>KGhostView&lt;/text>
 &lt;Action name="file_open"/>
 &lt;Action name="file_quit"/>
&lt;/ToolBar>
&lt;/kpartgui><indexterm>
					<primary>parts</primary>
					<secondary>embedding</secondary>
					<tertiary>mainwindow GUI</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>embedding</secondary>
					<tertiary>mainwindow GUI</tertiary>
				</indexterm>
				<indexterm>
					<primary>embedding</primary>
					<secondary>parts</secondary>
					<tertiary>mainwindow GUI</tertiary>
				</indexterm>
				<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest_shell.rc</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest_shell.rc</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest_shell.rc file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>By analogy with a command line's shell, a main window is often called a shell. In its GUI you define the actions that will always be shown, whichever part is active. The listing for a simple <literal>KParts</literal> mainwindow is shown in <link linkend="ch12list12">Listing 12.12</link>
			<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.12" id="ch12list12">
			<title>ghostviewtest.h: Header for a Simple KParts Mainwindow<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest.h</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest.h</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest.h file</primary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: #include &lt;kparts/mainwindow.h>
 2:
 3: class Shell : public KParts::MainWindow
 4: {
 5:   Q_OBJECT
 6: public:
 7:   Shell();
 8:   virtual ~Shell();
 9:
10:   void openURL( const KURL &amp; url );
11:
12: protected slots:
13:   void slotFileOpen();
14:
15: private:
16:   KParts::ReadOnlyPart *m_gvpart;
17: };<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest.h</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest.h</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest.h file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>The mainwindow inherits <literal>KParts::MainWindow</literal> instead of <literal>KTMainWindow</literal>. Nothing else is required; the <literal>openURL()</literal> here is just so that <literal>main()</literal> can call <literal>openURL()</literal> on the window. The URL could be passed to the constructor instead.<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>mainwindow header</tertiary>
			</indexterm>
		</para>
		<para>The code for the mainwindow embedding the KGhostView part is part of the KParts examples, which can be found under kdelibs/kparts/tests/ghostview*, so <link linkend="ch12list13">Listing 12.13</link> only shows the relevant lines of ghostview.cpp.<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>mainwindow implementation</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>mainwindow implementation</tertiary>
			</indexterm>
		</para>
		<example role="codelisting" label="12.13" id="ch12list13">
			<title>Excerpt of ghostviewtest.cpp: Implementation of the Simple KParts Mainwindow<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest.cpp</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest.cpp</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest.cpp file</primary>
				</indexterm>
			</title>
			<programlisting linenumbering="numbered">
 1: Shell::Shell()
 2: {
 3:   setXMLFile( "ghostviewtest_shell.rc" );
 4:
 5:   KAction * paOpen = new KAction( i18n( "&amp;Open file" ), "fileopen", 0,
 6:             this, SLOT( slotFileOpen() ), actionCollection(), "file_open" );
 7:
 8:   KAction * paQuit = new KAction( i18n( "&amp;Quit" ), "exit", 0,
 9:             this, SLOT( close() ), actionCollection(), "file_quit" );
10:
11:   // Try to find libkghostview
12:   KLibFactory *factory = KLibLoader::self()->factory( "libkghostview" );
13:   if (factory)
14:   {
15:     // Create the part
16:     m_gvpart = (KParts::ReadOnlyPart *)factory->create( this, "kgvpart",
17:                "KParts::ReadOnlyPart" );
18:     // Set the main widget
19:     setView( m_gvpart->widget() );
20:     // Integrate its GUI
21:     createGUI( m_gvpart );
22:   }
23:   else
24:     kdFatal() &lt;&lt; "No libkghostview found !" &lt;&lt; endl;
25: }
26:
27: Shell::~Shell()
28: {
29:   delete m_gvpart;
30: }
31:
32: void Shell::openURL( const KURL &amp; url )
33: {
34:   m_gvpart->openURL( url );
35: }<indexterm>
					<primary>parts</primary>
					<secondary>embedding</secondary>
					<tertiary>mainwindow implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>KParts</primary>
					<secondary>embedding</secondary>
					<tertiary>mainwindow implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>embedding</primary>
					<secondary>parts</secondary>
					<tertiary>mainwindow implementation</tertiary>
				</indexterm>
				<indexterm>
					<primary>GhostViewTest</primary>
					<secondary>ghostviewtest.cpp</secondary>
				</indexterm>
				<indexterm>
					<primary>listings</primary>
					<secondary>GhostViewTest</secondary>
					<tertiary>ghostviewtest.cpp</tertiary>
				</indexterm>
				<indexterm>
					<primary>ghostviewtest.cpp file</primary>
				</indexterm>
			</programlisting>
		</example>
		<para>A mainwindow is created much like a part, with an XML file and actions. To find a part, it uses <literal>KLibLoader</literal> to get the KLibFactory for the library. A flexible application would use .desktop files for this and KIO's trader for selecting the user's preferred component, but for the sake of simplicity, open the library by its name here. After the factory has been created, the mainwindow makes it create a <literal>ReadOnlyPart</literal>, and because here you have only one part in the window, the part's widget is set as the main widget of the window with <literal>setView</literal>. Then a mainwindow needs to call<indexterm>
				<primary>createGUI() function</primary>
			</indexterm>
			<indexterm>
				<primary>functions</primary>
				<secondary>cretaeGUI()</secondary>
			</indexterm>
			<literal>createGUI()</literal> to make the framework create the GUI, merging the actions of the mainwindow with those of the active part. A mainwindow with no part will simply call <literal>createGUI(0L)</literal>.</para>
		<para>Using this mainwindow, for instance from <literal>main()</literal>, is as simple as</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
Shell *shell = new Shell;
shell->openURL( url );
shell->show();
</programlisting>
		</informalexample>
		<para>Compile kdelibs/kparts/tests/ghostviewtest to test this simple example of how to embed a part.</para>
	</section>
	<section id="ch12lev1sec8">
		<title>Embedding More Than One Part in the Same Window</title>
		<para>The <indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>multiple parts</primary>
				<secondary>embedding</secondary>
			</indexterm>previous example showed how to embed a part as the single widget of a window. <literal>KParts</literal> also makes it possible to embed more than one part in the same window, and it handles the activation of a part when the user clicks it (or uses Tab to give it the focus). This is the task of the <literal>PartManager</literal>.</para>
		<para>To display more than one part in a window, the solution is usually to use a splitter, or even nested splitters, such as in Konqueror. KOffice has another way of embedding several parts&mdash;by using frames for the child parts&mdash;but it still uses <literal>PartManager</literal>.<indexterm>
				<primary>PartManager</primary>
			</indexterm>
			<indexterm>
				<primary>parts</primary>
				<secondary>PartManager</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>PartManager</secondary>
			</indexterm>
		</para>
		<para>Now modify the example to make it display, in addition to the PostScript document, the PostScript code for it. To display the text, the application uses the Notepad part in read-only mode. The two widgets will be hosted by a splitter.</para>
		<para>Displaying raw PostScript is not very useful, but this example could, for instance, be turned into an application showing the LaTeX source and the PostScript result side by side.</para>
		<para>
			<literal>ghostviewtest.h</literal> needs to be modified slightly to add the following private members:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
KParts::ReadOnlyPart *m_notepadpart;
KParts::PartManager *m_manager;
QSplitter *m_splitter;
</programlisting>
		</informalexample>
		<para>
			<literal>ghostviewtest.cpp</literal> needs to be more modified. To include the PartManager definition, use the following:<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>multiple parts</primary>
				<secondary>embedding</secondary>
			</indexterm>
		</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
#include &lt;kparts/partmanager.h>
</programlisting>
		</informalexample>
		<para>In the constructor, create the part manager and connect its main signal, <literal>activePartChanged</literal>, to your <literal>createGUI</literal> slot. This means you don't need to call <literal>createGUI</literal> directly; it is called every time the active part changes.</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
m_manager = new KParts::PartManager( this );
// When the manager says the active part changes,
// the builder updates (recreates) the GUI
connect( m_manager, SIGNAL( activePartChanged( KParts::Part * ) ),
         this, SLOT( createGUI( KParts::Part * ) ) );
</programlisting>
		</informalexample>
		<para>Then create the splitter and transform the <literal>setView</literal> statement into the following:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
m_splitter = new QSplitter( this );
setView( m_splitter );
</programlisting>
		</informalexample>
		<para>so that the main widget is now the splitter. Both parts need to be created with the splitter as a parent (instead of the window):</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
KLibFactory *factory = KLibLoader::self()->factory( "libkghostview" );
if (factory)
{
  m_gvpart = (KParts::ReadOnlyPart *)factory->create( m_splitter,
              "kgvpart", "KParts::ReadOnlyPart" );
}
else
   kdFatal() &lt;&lt; "No libkghostview found !" &lt;&lt; endl;

factory = KLibLoader::self()->factory( "libnotepad" );
if (factory)
  m_notepadpart = (KParts::ReadOnlyPart *)factory->create( m_splitter,
                   "knotepadpart", "KParts::ReadOnlyPart" );
else
   kdFatal() &lt;&lt; "No libnotepad found !" &lt;&lt; endl;
</programlisting>
		</informalexample>
		<para>After the parts are created, they should be added to the part manager. At the same time, you can specify which one should initially be active:<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>multiple parts</primary>
				<secondary>embedding</secondary>
			</indexterm>
		</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
m_manager->addPart( m_gvpart, true ); // sets as the active part
m_manager->addPart( m_notepadpart, false );
</programlisting>
		</informalexample>
		<para>Then the splitter can be set to a minimum size, as shown:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
m_splitter->setMinimumSize( 400, 300 );
m_splitter->show();
</programlisting>
		</informalexample>
		<para>Finally, add the following line to <literal>openURL()</literal> to open the same URL in both parts:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
m_notepadpart->openURL( url );
</programlisting>
		</informalexample>
		<para>As you can see, the main idea is that the mainwindow creates a main widget (here, the splitter), creates all parts inside it, and registers the part to a part manager. Try clicking one part and then the other; each time the active part changes, the GUI is updated (both menus and toolbars) to show the GUI of the active part.</para>
		<para>Note also the change in the window caption. This is handled by the <literal>Part</literal> class, which receives the <literal>GUIActivateEvent</literal> from the mainwindow when the part is activated or deactivated. To set a different caption for a part, you need to emit <literal>setWindowCaption</literal> both in <literal>openFile()</literal> and in <literal>guiActivateEvent()</literal>.<indexterm>
				<primary>parts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>embedding</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>embedding</primary>
				<secondary>parts</secondary>
				<tertiary>multiple parts</tertiary>
			</indexterm>
			<indexterm>
				<primary>multiple parts</primary>
				<secondary>embedding</secondary>
			</indexterm>
		</para>
	</section>
	<section id="ch12lev1sec9">
		<title>Creating a KParts Plug-in</title>
		<para>A<indexterm>
				<primary>parts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>plug-ins</primary>
				<secondary>KParts plug-ins</secondary>
			</indexterm> plug-in is the way to implement some functionality out of a part but still in a shared library, with actions defined by the plug-in to access this functionality. Those actions, whose layout is described in XML as usual, can be merged in a part's user interface or in a mainwindow's, depending on whether it applies to a part or to an application.</para>
		<para>Several reasons exist for using plug-ins. One is saving memory, because the plug-in is not loaded until one of its actions is called, but the main reason is reusability&mdash;the same plug-in can apply to several parts or applications. For instance, a spell-checker plug-in can apply to all kinds of text editors, mail composers, word processors, and even presenters.</para>
		<para>A plug-in can have a user interface, such as the dialog box for the spell checker, but not necessarily. Plug-ins can also act directly on the part or the application or anything else.<indexterm>
				<primary>parts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>plug-ins</primary>
				<secondary>KParts plug-ins</secondary>
			</indexterm>
		</para>
		<para>The XML for a spell-checker plug-in is shown below:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
&lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
&lt;kpartplugin library="libspellcheck">
&lt;MenuBar>
 &lt;Menu name="edit">&lt;Text>&amp;amp;Edit&lt;/Text>
  &lt;Action name="spellcheck"/>
 &lt;/Menu>
&lt;/MenuBar>
&lt;/kpartgui>
</programlisting>
		</informalexample>
		<para>Note the additional attribute in the main tag: library defines the name of the library to open to find the plug-in. This is because no .desktop file exists for plug-ins. Installing the preceding XML file in <literal>partplugins/</literal>, under <literal>share/apps/notepadpart</literal>, automatically inserts the plug-in's action in the <literal>NotepadPart</literal> user interface.</para>
		<para>You know how the plug-in's library will be opened; now you need only to create a factory in the library, as usual, and let it create an instance of the plug-in. Writing the factory, which doesn't even need an instance in the simple case, and the <literal>init_libspellcheck()</literal> function will be left as an exercise to the reader.<indexterm>
				<primary>parts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>plug-ins</primary>
				<secondary>KParts plug-ins</secondary>
			</indexterm>
		</para>
		<para>To define a plug-in, simply inherit <literal>KParts::Plugin</literal> and add slots for its actions:</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
#include &lt;kparts/plugin.h>
class PluginSpellCheck : public KParts::Plugin
{
    Q_OBJECT
public:
    PluginSpellCheck( QObject* parent = 0, const char* name = 0 );
    virtual ~PluginSpellCheck() {}
public slots:
    void slotSpellCheck();
};
</programlisting>
		</informalexample>
		<para>In the implementation, you have to create the plug-in actions; no <literal>setXMLFile</literal> is here because it has been found by the part already.<indexterm>
				<primary>parts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>plug-ins</primary>
				<secondary>KParts plug-ins</secondary>
			</indexterm>
		</para>
		<para>Because in this example you are not going to create a real spell checker&mdash;a <literal>libkspell</literal> exists for that&mdash; call the action <quote>select current line</quote> and implement that in the slot.</para>
		<informalexample>
			<programlisting linenumbering="unnumbered">
#include "plugin_spellcheck.h"
#include "notepad.h" // this plugin applies to a notepad part
#include &lt;qmultilineedit.h>
#include &lt;kaction.h>

PluginSpellCheck::PluginSpellCheck( QObject* parent, const char* name )
    : Plugin( parent, name )
{
    (void) new KAction( i18n( "&amp;Select current line (plug-in)" ), 0, this,
                SLOT(slotSpellCheck()), actionCollection(), "spellcheck" );
}

void PluginSpellCheck::slotSpellCheck()
{
    // Check that the parent is a NotepadPart
    if ( !parent()->inherits("NotepadPart") )
       kdFatal() &lt;&lt; "Spell-check plug-in for wrong part (not NotepadPart)" &lt;&lt; endl;
    else
    {
         NotepadPart * part = (NotepadPart *) parent();
         QMultiLineEdit * widget = (QMultiLineEdit *) part->widget();
         widget->selectAll(); //selects current line !
    }
}
</programlisting>
		</informalexample>
		<para>Note that to access the part's widget, the plug-in has to assume&mdash;and check&mdash;that it has been installed for a <literal>NotepadPart</literal>. This means that you should not install it under another part's directory. But selecting the current line in an image viewer wouldn't mean much anyway.</para>
		<para>A more flexible plug-in would instead check and cast the parent to <literal>ReadWritePart</literal> and then check the type of its widget to be <literal>QMultiLineEdit</literal>.<indexterm>
				<primary>parts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>KParts</primary>
				<secondary>plug-ins</secondary>
			</indexterm>
			<indexterm>
				<primary>plug-ins</primary>
				<secondary>KParts plug-ins</secondary>
			</indexterm>
		</para>
	</section>
	<section id="ch12lev1sec10">
		<title>Summary</title>
		<para>After the presentation of component technology and how to lay out actions using XML, you have seen most of what KParts can do: three types of parts, part mainwindows, part manager, plug-ins, as well as how dynamic loading works&mdash;library factories and library loader.</para>
		<para>You can do other interesting things with parts. Having a part embed itself in Konqueror is very simple; it's just a matter of providing a .desktop file for it, stating that it is a service that implements some servicetypes, which are the mimetypes that the part allows to view, plus the servicetype <literal>KParts::ReadOnlyPart</literal>. That's it. Konqueror will use the part to view the files of those mimetypes if no other service is set as more preferred in Configure File Types.</para>
		<para>To provide better integration with Konqueror, you can also provide a <literal>KParts::BrowserExtension</literal> for the part, as defined in kparts/browserextension.h. This is what makes it possible to save and restore a view in Konqueror's history and for the part to use Konqueror's <quote>standard actions.</quote> Examples of parts using the browser extension can be found in KView, KDVI, KGhostView, KWrite and all built-in Konqueror views.</para>
	</section>
</chapter>
