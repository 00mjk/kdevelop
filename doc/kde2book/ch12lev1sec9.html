<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Creating a KParts Plug-in</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="Creating and Using Components (KParts)"
HREF="ch12.html"/><LINK
REL="PREVIOUS"
TITLE="Embedding More Than One Part in the Same Window"
HREF="ch12lev1sec8.html"/><LINK
REL="NEXT"
TITLE="Summary"
HREF="ch12lev1sec10.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch12lev1sec8.html"
>Prev</A
> <A
HREF="ch12lev1sec10.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch12lev1sec9"
>12.9. Creating a KParts Plug-in</A
></H1
><P
>A
			
			 plug-in is the way to implement some functionality out of a part but still in a shared library, with actions defined by the plug-in to access this functionality. Those actions, whose layout is described in XML as usual, can be merged in a part's user interface or in a mainwindow's, depending on whether it applies to a part or to an application.</P
><P
>Several reasons exist for using plug-ins. One is saving memory, because the plug-in is not loaded until one of its actions is called, but the main reason is reusability&#8212;the same plug-in can apply to several parts or applications. For instance, a spell-checker plug-in can apply to all kinds of text editors, mail composers, word processors, and even presenters.</P
><P
>A plug-in can have a user interface, such as the dialog box for the spell checker, but not necessarily. Plug-ins can also act directly on the part or the application or anything else.
			
			
		</P
><P
>The XML for a spell-checker plug-in is shown below:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;&lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd"&gt;
   3&nbsp;&lt;kpartplugin library="libspellcheck"&gt;
   4&nbsp;&lt;MenuBar&gt;
   5&nbsp; &lt;Menu name="edit"&gt;&lt;Text&gt;&amp;amp;Edit&lt;/Text&gt;
   6&nbsp;  &lt;Action name="spellcheck"/&gt;
   7&nbsp; &lt;/Menu&gt;
   8&nbsp;&lt;/MenuBar&gt;
   9&nbsp;&lt;/kpartgui&gt;
  10&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Note the additional attribute in the main tag: library defines the name of the library to open to find the plug-in. This is because no .desktop file exists for plug-ins. Installing the preceding XML file in <TT
CLASS="literal"
>partplugins/</TT
>, under <TT
CLASS="literal"
>share/apps/notepadpart</TT
>, automatically inserts the plug-in's action in the <TT
CLASS="literal"
>NotepadPart</TT
> user interface.</P
><P
>You know how the plug-in's library will be opened; now you need only to create a factory in the library, as usual, and let it create an instance of the plug-in. Writing the factory, which doesn't even need an instance in the simple case, and the <TT
CLASS="literal"
>init_libspellcheck()</TT
> function will be left as an exercise to the reader.
			
			
		</P
><P
>To define a plug-in, simply inherit <TT
CLASS="literal"
>KParts::Plugin</TT
> and add slots for its actions:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;#include &lt;kparts/plugin.h&gt;
   3&nbsp;class PluginSpellCheck : public KParts::Plugin
   4&nbsp;{
   5&nbsp;    Q_OBJECT
   6&nbsp;public:
   7&nbsp;    PluginSpellCheck( QObject* parent = 0, const char* name = 0 );
   8&nbsp;    virtual ~PluginSpellCheck() {}
   9&nbsp;public slots:
  10&nbsp;    void slotSpellCheck();
  11&nbsp;};
  12&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>In the implementation, you have to create the plug-in actions; no <TT
CLASS="literal"
>setXMLFile</TT
> is here because it has been found by the part already.
			
			
		</P
><P
>Because in this example you are not going to create a real spell checker&#8212;a <TT
CLASS="literal"
>libkspell</TT
> exists for that&#8212; call the action <SPAN
CLASS="QUOTE"
>"select current line"</SPAN
> and implement that in the slot.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;#include "plugin_spellcheck.h"
   3&nbsp;#include "notepad.h" // this plugin applies to a notepad part
   4&nbsp;#include &lt;qmultilineedit.h&gt;
   5&nbsp;#include &lt;kaction.h&gt;
   6&nbsp;
   7&nbsp;PluginSpellCheck::PluginSpellCheck( QObject* parent, const char* name )
   8&nbsp;    : Plugin( parent, name )
   9&nbsp;{
  10&nbsp;    (void) new KAction( i18n( "&amp;Select current line (plug-in)" ), 0, this,
  11&nbsp;                SLOT(slotSpellCheck()), actionCollection(), "spellcheck" );
  12&nbsp;}
  13&nbsp;
  14&nbsp;void PluginSpellCheck::slotSpellCheck()
  15&nbsp;{
  16&nbsp;    // Check that the parent is a NotepadPart
  17&nbsp;    if ( !parent()-&gt;inherits("NotepadPart") )
  18&nbsp;       kdFatal() &lt;&lt; "Spell-check plug-in for wrong part (not NotepadPart)" &lt;&lt; endl;
  19&nbsp;    else
  20&nbsp;    {
  21&nbsp;         NotepadPart * part = (NotepadPart *) parent();
  22&nbsp;         QMultiLineEdit * widget = (QMultiLineEdit *) part-&gt;widget();
  23&nbsp;         widget-&gt;selectAll(); //selects current line !
  24&nbsp;    }
  25&nbsp;}
  26&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Note that to access the part's widget, the plug-in has to assume&#8212;and check&#8212;that it has been installed for a <TT
CLASS="literal"
>NotepadPart</TT
>. This means that you should not install it under another part's directory. But selecting the current line in an image viewer wouldn't mean much anyway.</P
><P
>A more flexible plug-in would instead check and cast the parent to <TT
CLASS="literal"
>ReadWritePart</TT
> and then check the type of its widget to be <TT
CLASS="literal"
>QMultiLineEdit</TT
>.
			
			
		</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch12lev1sec9"/></TD
></TR
><ANNOTATION
NAME="ch12lev1sec9"
TITLE="Creating a KParts Plug-in"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch12lev1sec8.html"
>Prev</A
> <A
HREF="ch12lev1sec10.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>