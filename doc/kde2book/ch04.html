<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Creating Custom KDE Widgets</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="Fundamentals of KDE Application Programming"
HREF="p01.html"/><LINK
REL="PREVIOUS"
TITLE="Exercises"
HREF="ch03lev1sec8.html"/><LINK
REL="NEXT"
TITLE="Painting Widgets"
HREF="ch04lev1sec2.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="chapter"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch03lev1sec8.html"
>Prev</A
> <A
HREF="ch04lev1sec2.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="ch04"
>Chapter 4. Creating Custom KDE Widgets</A
></H1
><P
><I
CLASS="emphasis"
>by David Sweet</I
></P
><DIV
CLASS="highlights"
><A
NAME="AEN3542"
></A
><P
><B
>In This Chapter</B
></P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
><I
CLASS="emphasis"
><A
HREF="ch04.html#ch04lev1sec1"
>Widget Basics</A
></I
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
><I
CLASS="emphasis"
><A
HREF="ch04lev1sec2.html"
>Painting Widgets</A
></I
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
><I
CLASS="emphasis"
><A
HREF="ch04lev1sec3.html"
>Using Child Widgets</A
></I
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
><I
CLASS="emphasis"
><A
HREF="ch04lev1sec4.html"
>Handling User Input</A
></I
></P
></LI
></UL
></DIV
><P
>By now you should have a good idea of what simple KDE code looks like and what Qt has to offer. Now we will look in more detail at the building blocks of GUIs: the widgets. Although KDE and Qt offer many useful and powerful widgets, you still need to create your own to customize your UI. It is easy to do this&#8212;and to do it with good form&#8212;if you know how.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch04lev1sec1"
>4.1. Widget Basics</A
></H1
><P
>Widgets are graphical user-interface elements. Simple widgets can be controls or indicators such as a pushbutton or a text label. More complex widgets can perform more significant computation or may require significant user input, such as the spell checker widget or the HTML-rendering widget.</P
><P
>In KDE, widgets are implemented using C++ classes. Usually there is a one-to-one widget-to-class correspondence. For example, a pushbutton is implemented by <TT
CLASS="literal"
>QPushButton</TT
>. All widgets are ultimately derived from the <TT
CLASS="literal"
>QWidget</TT
> base class.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec1"
>4.1.1. Understanding the <TT
CLASS="literal"
>QWidget</TT
> Base Class</A
></H2
><P
><TT
CLASS="literal"
>QWidget</TT
> handles window system events, manages generic widget attributes, knows about its parent and children, and handles functions unique to a top-level widget (if it should be one). Window system events include geometry changes and user input. The widget is clipped by its parent's borders and by the children that lay on top of it. Top-level widgets have no parent. They lie in a window on the desktop and have window borders and decorations drawn by the window manager.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H3
CLASS="section"
><A
NAME="ch04lev3sec1"
>4.1.1.1. System Events</A
></H3
><P
>Window system events tell the widget when it needs to repaint, reposition, or resize itself, when mouse clicks or keystrokes have been directed toward that widget, when the widget receives or loses the focus, and so on. <TT
CLASS="literal"
>QWidget</TT
> handles the events by calling a virtual method for each event. Each method gets passed, as an argument, a class containing information about the event. To handle the event, the corresponding method must be reimplemented in the subclass of <TT
CLASS="literal"
>QWidget</TT
>.</P
><P
>A very important system event is the paint event. In response to this event, a widget draws (or <SPAN
CLASS="QUOTE"
>"paints"</SPAN
>) itself. It is sent to the widget every time the widget needs to be displayed or redisplayed. For example, the event is sent when the widget is first created, when it is made visible after being hidden, or when it is being uncovered after having been fully or partially obscured. The paint event is discussed in detail in the next section, and techniques for repainting efficiently are discussed in <A
HREF="ch09.html"
>Chapter 9, <SPAN
CLASS="QUOTE"
>"Constructing a Responsive User Interface."</SPAN
></A
></P
><P
>The following is a list of the (protected, virtual) <TT
CLASS="literal"
>QWidget</TT
> event handlers and corresponding events.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void event (QEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This is the main event handler. This method dispatches the events to their specialized event handlers. Normally, you do not need to reimplement this method. The argument tells the type of event.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void mousePressEvent (QMouseEvent * )</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when one of the mouse buttons is pressed down with the mouse cursor inside this widget. The argument tells which button was pressed, whether a modifier key (Ctrl, Alt, or Shift) was pressed in combination with it, and where the cursor was when the button was pressed.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void mouseReleaseEvent (QMouseEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when one of the mouse buttons is released with the mouse cursor inside this widget. (See <TT
CLASS="literal"
>mousePressEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void mouseDoubleClickEvent (QMouseEvent * )</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the user double-clicks on the widget. (See <TT
CLASS="literal"
>mousePressEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void mouseMoveEvent (QMouseEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the user moves the mouse with the cursor over the widget. This event is generated only when a button is held down, unless you turn on mouse tracking with <TT
CLASS="literal"
>QWidget::setMouseTracking (true)</TT
>. (See <TT
CLASS="literal"
>mousePressEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void wheelEvent (QWheelEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the user moves the mouse wheel (if there is one) and this widget has the focus. The argument tells how far and in which direction the wheel has been rotated. This event can be ignored by calling <TT
CLASS="literal"
>QWheelEvent::ignore()</TT
> if it is not processed. In this case, the event gets passed to the parent widget for processing.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void keyPressEvent (QKeyEvent *)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a key is pressed and this widget has the focus. The argument contains a code telling which key was pressed and whether a modifier key (Ctrl, Alt, or Shift) was being held down. If you have turned on key compression with <TT
CLASS="literal"
>QWidget::setKeyCompression (true)</TT
>, the argument may contain a text string representing all the keys that were pressed since the last time you received this event.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void keyReleaseEvent (QKeyEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a key has been released and this widget has the focus.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void focusInEvent (QFocusEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when this widget receives the focus. If this widget is willing to accept the focus, the default implementation calls <TT
CLASS="literal"
>QWidget::repaint()</TT
> to redraw the widget with a <I
CLASS="emphasis"
>focused</I
> look.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void focusOutEvent (QFocusEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when this widget loses the focus. If this widget is willing to accept the focus, the default implementation calls <TT
CLASS="literal"
>QWidget::repaint()</TT
> to redraw the widget with an <I
CLASS="emphasis"
>unfocused</I
> look.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void enterEvent (QEvent *)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the mouse cursor enters the widget.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void leaveEvent (QEvent *)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the mouse cursor leaves the widget.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void paintEvent (QPaintEvent *)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the widget needs to be repainted, such as when it is first created or uncovered after being totally or partially obscured by another window. The argument tells which part of the widget needs to be repainted.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void moveEvent (QMoveEvent *)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the widget has been moved relative to its parent. The argument tells the new and old positions.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void resizeEvent (QResizeEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the widget has been resized. The argument tells the new and old sizes.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void closeEvent (QCloseEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>For a top-level widget, this gets called when the user tries to close the window (using the close button on the window frame, for example). For other widgets, this gets called when the application calls the <TT
CLASS="literal"
>QWidget::close()</TT
> method. In a Qt (non-KDE) application, this would be a good place to ask, <SPAN
CLASS="QUOTE"
>"Are you sure?"</SPAN
> KDE applications should use <TT
CLASS="literal"
>KTMainWindow::queryClose()</TT
> for this purpose. You can accept or ignore the close event by setting a flag in the <TT
CLASS="literal"
>QCloseEvent</TT
> argument.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void dragEnterEvent (QDragEnterEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a user is dragging data and the mouse cursor first enters this widget. The argument tells where the mouse cursor is, what kind of data is being dragged, and what the data is.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void dragMoveEvent (QDragMoveEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a user drags data over this widget. (See <TT
CLASS="literal"
>dragEnterEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void dragLeaveEvent (QDragLeaveEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a user is dragging data and the mouse cursor leaves this widget. (See <TT
CLASS="literal"
>dragEnterEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void dropEvent (QDropEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when a user drops (in a drag-and-drop operation) data onto your widget. (See <TT
CLASS="literal"
>dragEnterEvent()</TT
> for a description of the argument.)</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void showEvent (QShowEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called when the widget is first created or when the window in which it lies is deiconified. The argument tells whether the show event originated inside the application or outside the application (for example, the user clicked the deiconify button on the taskbar).</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void hideEvent (QHideEvent *)</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Gets called right after the widget has been hidden. The argument tells whether the show event originated inside the application or outside the application (for example, the user clicked the iconify button on the window).</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev3sec1"/></TD
></TR
><ANNOTATION
NAME="ch04lev3sec1"
TITLE="System Events"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec1"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec1"
TITLE="Understanding the QWidget Base Class"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec2"
>4.1.2. Widget Attributes</A
></H2
><P
><TT
CLASS="literal"
>QWidget</TT
> keeps track of various properties that may be of use to it or to subclasses. It holds a <TT
CLASS="literal"
>Qfont</TT
>, which describes a font for the widget. The font is not used by <TT
CLASS="literal"
>QWidget</TT
> directly, but by subclasses. A <TT
CLASS="literal"
>QCursor</TT
> is kept in <TT
CLASS="literal"
>QWidget</TT
> and is drawn as the mouse cursor whenever the cursor passes over the widget. You can also access the position, size, colors, and other widget attributes via the <TT
CLASS="literal"
>QWidget</TT
> public interface.</P
><P
><TT
CLASS="literal"
>QWidget</TT
> also holds a pointer to a <TT
CLASS="literal"
>QStyle</TT
> object. This object describes many common look-and-feel characteristics of Qt widgets, as discussed in <A
HREF="ch03.html"
>Chapter 3, <SPAN
CLASS="QUOTE"
>"The Qt Toolkit."</SPAN
></A
></P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec2"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec2"
TITLE="Widget Attributes"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec3"
>4.1.3. Signals and Slots</A
></H2
><P
><TT
CLASS="literal"
>QWidget</TT
> is a subclass of <TT
CLASS="literal"
>QObject</TT
>, therefore it may make use of signals and slots. Widgets use signals to communicate user interaction and/or changes in their state. A pushbutton, for example, might emit a <TT
CLASS="literal"
>clicked()</TT
> signal to indicate that the user has clicked the button. A check box might emit a <TT
CLASS="literal"
>checked()</TT
> signal to indicate that it has just been put into the checked state either by direct user interaction or by a call from another part of the application.</P
><P
>Slots are used to change the widget's state. This way, a widget can be easily configured to react to events that do not directly affect it. Signals from other widgets (or more generally, other subclasses of <TT
CLASS="literal"
>QObject</TT
>) can be connected to a widget's slots to affect its state. Imagine an FM radio application: You connect the <TT
CLASS="literal"
>clicked()</TT
> signals of a set of radio buttons to a station name display so that the display reflects the station chosen by the user, even though the user didn't interact directly with the display.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec3"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec3"
TITLE="Signals and Slots"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec4"
>4.1.4. Sample Widget Class Declaration</A
></H2
><P
>A sample widget header file containing its public interface is shown in <A
HREF="ch04.html#ch04list01"
>Listing 4.1</A
>.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch04list01"
></A
><P
><B
>Example 4.1. kpushbutton.h: Class Declaration for a KDE Widget</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;1: #include &lt;qwidget.h&gt;
   3&nbsp;2:
   4&nbsp;3: /**
   5&nbsp;4:  * KPushButton
   6&nbsp;5:  * A sample widget header file. This widget would
   7&nbsp;6:  *  implement a standard pushbutton.
   8&nbsp;7:  **/
   9&nbsp;8:
  10&nbsp;9: class KPushButton : public QWidget
  11&nbsp;10: {
  12&nbsp;11:  Q_OBJECT
  13&nbsp;12:
  14&nbsp;13:  public:
  15&nbsp;14:   /**
  16&nbsp;15:    * Create the pushbutton.
  17&nbsp;16:    **/
  18&nbsp;17:   KPushButton (QWidget *parent, const char *name=0);
  19&nbsp;18:
  20&nbsp;19:   /**
  21&nbsp;20:    * Set the text to be drawn on the button.
  22&nbsp;21:    **/
  23&nbsp;22:   void text (QString _text);
  24&nbsp;23:
  25&nbsp;24:   /**
  26&nbsp;25:    * Get the text being drawn on the button.
  27&nbsp;26:    **/
  28&nbsp;27:   QString text () const;
  29&nbsp;28:
  30&nbsp;29:  signals:
  31&nbsp;30:   /**
  32&nbsp;31:    * Button was clicked by the user.
  33&nbsp;32:    **/
  34&nbsp;33:   void clicked ();
  35&nbsp;34:
  36&nbsp;35:  slots:
  37&nbsp;36:   /**
  38&nbsp;37:    * Animate a button press.
  39&nbsp;38:    **/
  40&nbsp;39:   void animate ();
  41&nbsp;40:
  42&nbsp;41:  private:
  43&nbsp;42:   QString theText;
  44&nbsp;43:
  45&nbsp;44: }</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
><A
HREF="ch04.html#ch04list01"
>Listing 4.1</A
> shows kpushbutton.h, a class declaration for a fictitious class called <TT
CLASS="literal"
>KPushButton</TT
>. Included in the declaration are important method types and class documentation.</P
><P
><TT
CLASS="literal"
>KPushButton</TT
> is a declared as a subclass of <TT
CLASS="literal"
>QWidget</TT
> (line 9). The constructor (line 17) takes a pointer to a <TT
CLASS="literal"
>QWidget</TT
> as an argument that specifies the parent widget. This, along with the class name, is passed to <TT
CLASS="literal"
>QWidget</TT
>. The name is used only internally, and thus, the often-used value of <TT
CLASS="literal"
>0</TT
> is made the default.</P
><P
>Methods are provided to get and set the configurable UI parameters (in this case, just the text; see lines 19-27). In the standard style of KDE 2.0 and Qt 2.0, the same method name is used for getting and setting a parameter. The function overloading feature of C++ allows this to be done in most cases. (It would fail if both methods required the same arguments in the same order!)</P
><P
>The widget emits a signal (declared on line 33) when the button is clicked, as discussed previously, and accepts, via a slot (declared on line 39), a command to animate the clicking of the button.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec4"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec4"
TITLE="Sample Widget Class Declaration"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch04lev2sec5"
>4.1.5. Documentation</A
></H2
><P
>The class in <A
HREF="ch04.html#ch04list01"
>Listing 4.1</A
> is documented in the <TT
CLASS="literal"
>kdoc</TT
> style introduced in <A
HREF="ch02.html"
>Chapter 2, <SPAN
CLASS="QUOTE"
>"A Simple KDE Application."</SPAN
></A
> It is discussed in detail in <A
HREF="ch15.html"
>Chapter 15, <SPAN
CLASS="QUOTE"
>"Creating Documentation."</SPAN
></A
> You should be familiarizing yourself with the basic form of the documentation: The documentation appears in comments that look like <TT
CLASS="literal"
>/** &#8230; **/</TT
>. You should also get used to the idea of documenting your classes, if you are not already, because it is such an important part of writing code for a multiprogrammer project.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev2sec5"/></TD
></TR
><ANNOTATION
NAME="ch04lev2sec5"
TITLE="Documentation"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch04lev1sec1"/></TD
></TR
><ANNOTATION
NAME="ch04lev1sec1"
TITLE="Widget Basics"/></TABLE
></DIV
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch03lev1sec8.html"
>Prev</A
> <A
HREF="ch04lev1sec2.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>