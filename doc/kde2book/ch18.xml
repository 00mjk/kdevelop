<chapter label="18" role="chapter" id="ch18">
<title>The KDevelop IDE: The Integrated Development Environment for KDE</title>
<para><emphasis>by Ralf Nolden</emphasis></para>
<highlights>
<itemizedlist mark="none" spacing="compact">
<title>In this chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec1">General Issues</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec2">Creating KDE 2.0 Applications</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec3">Getting Started with the KDE 2.0 API</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec4">The Classbrowser and Your Project</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec5">The File Viewers&mdash;The Windows to Your Project Files</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec6">The KDevelop Debugger</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch18lev1sec7">KDevelop 2.0&mdash;A Preview</link></emphasis></para></listitem>
</itemizedlist></highlights>
<para>Although<indexterm><primary>KDevelop IDE</primary></indexterm><indexterm><primary>IDE (integrated development environment)</primary><see>KDevelop IDE</see></indexterm><indexterm><primary>integrated development environment (IDE)</primary><see>KDevelop IDE</see></indexterm> developing applications under UNIX systems can be a lot of fun, until now the programmer was lacking a comfortable environment that takes away the usual standard activities that have to be done over and over in the process of programming. The KDevelop IDE closes this gap and makes it a joy to work within a complete, integrated development environment, combining the use of the GNU standard development tools such as the <literal>g++</literal> compiler and the <literal>gdb</literal> debugger with the advantages of a GUI-based environment that automates all standard actions and allows the developer to concentrate on the work of writing software instead of managing command-line tools. It also offers direct and quick access to source files and documentation. KDevelop primarily aims to provide the best means to rapidly set up and write KDE software; it also supports extended features such as GUI designing and translation in conjunction with other tools available especially for KDE development. The KDevelop IDE itself is published under the GNU Public License (GPL), like KDE, and is therefore publicly available at no cost&mdash;including its source code&mdash;and it may be used both for free and for commercial development.<indexterm><primary>KDevelop IDE</primary></indexterm></para>
<section id="ch18lev1sec1">
<title>General Issues</title>
<para>Before <indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>languages</tertiary></indexterm><indexterm><primary>software development</primary><secondary>languages</secondary></indexterm><indexterm><primary>development</primary><secondary>languages</secondary></indexterm>going into the details of the IDE, let's first cover some issues that apply to development using the C and C++ programming languages in UNIX environments in general.</para>
<para>As you have learned, C++ is commonly used to develop KDE software. This is necessary because the Qt library on which KDE is based is also written in C++ and therefore offers interfaces to the library by C++ classes. KDE extends the Qt library by far and implements many things that are either missing in Qt or that are useful for a UNIX desktop but not on a Microsoft-based operating system. (Qt is a cross-platform toolkit, and applications written with Qt can be directly used under MS-based operating systems, either by recompiling on that environment or by compiling with a cross-compiler as a Win32 binary.)</para>
<para>You can, however, make use of other languages (especially scripting languages) that have a set of bindings that translates the Qt/KDE C++ classes to the other programming languages such as Python or Perl; therefore, KDE is not limited to using C++, although it is the preferred way to write KDE software.<indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>languages</tertiary></indexterm><indexterm><primary>software development</primary><secondary>languages</secondary></indexterm><indexterm><primary>development</primary><secondary>languages</secondary></indexterm></para>
<para>The <indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>project management</tertiary></indexterm><indexterm><primary>software development</primary><secondary>project management</secondary></indexterm><indexterm><primary>development</primary><secondary>project management</secondary></indexterm><indexterm><primary>project management</primary></indexterm>second issue that applies to software development is project management. An application usually consists of more than one source file, and compilation on different systems usually requires different settings for things such as compilers, paths to header file locations, and linker settings to bind all compiled object files to a binary. As you learned in <link linkend="ch16">Chapter 16, <quote>Packaging and Distributing Code,</quote></link> the management of all this is done via <literal>make</literal>. Writing Makefiles by hand is usually not a trivial task, and if they are specifically written for one development environment, you can never be sure that the same rules apply to any other system&mdash;not even another Linux distribution. Because of this, the GNU tools offer a development framework that automates much of the project management but still requires the developer to lay hands on the project-specific parts of the framework, which is again non-trivial.</para>
<para>The tools that help here are the <indexterm><primary>Automake tool</primary></indexterm><indexterm><primary>tools</primary><secondary>Automake</secondary></indexterm>Automake and<indexterm><primary>Autoconf tool</primary></indexterm><indexterm><primary>tools</primary><secondary>Autoconf</secondary></indexterm> Autoconf packages, which sometimes make things a bit simpler; however, sometimes they cause headaches because the developer wants to use C++, not fuss with Makefile generation and configure scripts. At least they ensure that the source distribution will compile automatically on almost all UNIX systems such as Linux, SCO UNIXWare, HP-UX, and the like without much trouble. This is an issue because developers like their applications to work under as many systems as possible.</para>
<para>You should know that when you retrieve a source package of KDE and most other applications that are available as source code for UNIX systems, you will have to compile it yourself. This has two advantages: First, the binary is specifically built on your system, and when it is cleanly built, it will run without any trouble. Second, it will install smoothly where you want it to.<indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>project management</tertiary></indexterm><indexterm><primary>software development</primary><secondary>project management</secondary></indexterm><indexterm><primary>development</primary><secondary>project management</secondary></indexterm><indexterm><primary>project management</primary></indexterm></para>
<para>To<indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>packages</tertiary></indexterm><indexterm><primary>software development</primary><secondary>packages</secondary><tertiary>creating</tertiary></indexterm>packages:creating<indexterm><primary>packages</primary><secondary>creating</secondary></indexterm> build a package, follow these steps: untar the <emphasis>package</emphasis>.tar.gz file and change to the created directory containing the source files; then enter <emphasis role="strong"><literal>./configure</literal></emphasis> and <emphasis role="strong"><literal>make</literal></emphasis> on the console. After that, you can install the software package as root with entering <literal>make install</literal>. This makes things so simple that even complete UNIX newbies who will probably never be interested in writing applications themselves are able to compile and install a source package. The developer, on the other hand, doesn't have to provide so much support for the installation process of the application on the user's platform, but only for the functionality.</para>
<para>The magic behind this is that the developer has to provide the source package only as Autoconf/Automake compatible. To write this framework, you need some knowledge that is not necessarily the developer's job&mdash;and this is where an IDE can help. It can provide programmers with the comfort of creating a complete framework and take care of the project management during the process of creating an application.<indexterm><primary>packages</primary><secondary>creating</secondary></indexterm></para>
<para>Another important issue is handling <literal>make</literal> and the compiler, as well as the linker, to produce the executables or libraries. These are command-line tools that require the knowledge of the according options, which are most often very cryptic and have to be learned and are easily forgotten. On the other hand, an IDE can <quote>remember</quote> these things for you. An example is the following scenario: while developing your application, you will most likely program an error, and you will have to debug the binary to follow the code while executing to find exactly where that mistake happens. This requires telling the compiler to include debugging information into the binary. Then the debugger can translate the function calls in the binary to the according lines in the source files. But you will also want to switch back to optimized compilation, even if it is only to test whether everything works as expected at a reasonable performance. Here, a simple menu that says debug/release within an IDE helps enormously&mdash;even more so if it allows you to debug your program with setting breakpoints directly in the source-code editor and running a debug session within the programming environment.<indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>project management</tertiary></indexterm><indexterm><primary>software development</primary><secondary>project management</secondary></indexterm><indexterm><primary>development</primary><secondary>project management</secondary></indexterm><indexterm><primary>project management</primary></indexterm></para>
<para>Accessing <indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>documentation</tertiary></indexterm><indexterm><primary>software development</primary><secondary>documentation</secondary></indexterm><indexterm><primary>development</primary><secondary>documentation</secondary></indexterm><indexterm><primary>documentation</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accesssing</primary><secondary>documentation</secondary></indexterm>documentation is the third element where an IDE can help you as a developer. Especially when using large C++ class libraries such as Qt and KDE, you will get lost without a good access to the API documentation. Fortunately, the Qt has excellent documentation, and the documentation for the KDE libraries can be created easily with the KDOC documentation tool. KDOC also can be used to document your own project, as you learned in <link linkend="ch15">Chapter 15, <quote>Creating Documentation.</quote></link></para>
<para>Because the documentation as a whole is used as HTML files, a development environment without an IDE will look like the following: an opened browser to read the documentation, a shell to run the compiler, and one or more editor window to write the code.</para>
<para>After this horror scenario, which is what long-time UNIX developers have lived with for years, let's have a look at what you can expect when using KDevelop to create your applications.<indexterm><primary>KDevelop IDE</primary><secondary>software development</secondary><tertiary>documentation</tertiary></indexterm><indexterm><primary>software development</primary><secondary>documentation</secondary></indexterm><indexterm><primary>development</primary><secondary>documentation</secondary></indexterm><indexterm><primary>documentation</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accesssing</primary><secondary>documentation</secondary></indexterm></para>
<section id="ch18lev2sec1">
<title>Be User Friendly&mdash;Be Developer Friendly</title>
<para>Why <indexterm><primary>KDevelop IDE</primary></indexterm>should users have all the ease of use when working under a graphical environment like KDE for production, such as KOffice and all the other KDE applications that make life easier, but the developers who are writing this beautiful software suffer and look at the <quote>normal</quote> user jealously? That's why we made KDevelop&mdash;for programmers who dislike working under UNIX the <quote>old</quote> way, who want to save time and be more productive, and who also like not only the results of their work but also how it is done. Often, new developers coming from environments that offer development systems based on a graphical user interface are afraid to switch to UNIX because they don't want to miss a comfortable environment. In the next sections, we'll walk through the KDevelop IDE to see what it looks like and what functionality is available.</para>
<para>When you first glance at KDevelop in <link linkend="ch18fig01">Figure 18.1</link>, you'll notice that it looks much like other KDE applications&mdash;the main window contains the usual user interface with a menubar, toolbars, a statusbar, and a central view area that is separated into three subwindows.</para>
<para><link linkend="ch18fig01">Figure 18.1</link> shows KDevelop 1.2, which is actually for running under KDE 1.1.x, but as you can see, the desktop it runs on is KDE 2.0. You may wonder what a KDE 1.x application has to do with this book covering KDE 2.0, but there is a simple answer: the 1.x series of KDevelop has been developed to be the most stable development environment so far, and we put forth a lot of effort to make it as usable as possible&mdash;even for KDE 2.0 development, which is directly supported. After two years of development, testing, and successful usage in industrial environments, KDevelop has proved to be an excellent, stable, and very friendly IDE that is today the developer's choice when starting to program with C/C++ under UNIX. Meanwhile, the KDevelop 2.0 IDE is under development by the KDevelop Team and will be made public when it reaches the same amount of functionality and stability as the 1.2 version (see <link linkend="ch18fig02">Figure 18.2</link>).</para>
<figure label="18.1" id="ch18fig01">
<title>The KDevelop 1.2 main window.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig01.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<figure label="18.2" id="ch18fig02">
<title>KDevelop 1.2 editing a sample project's options.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig02.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>With <indexterm><primary>KDevelop IDE</primary><secondary>versions</secondary><tertiary>KDevelop 2.0</tertiary></indexterm><indexterm><primary>versions</primary><secondary>KDevelop IDE</secondary><tertiary>version 2.0</tertiary></indexterm>KDevelop 2.0, our team will break with the traditional single-window philosophy commonly used by UNIX applications, and that is what developers have to expect: complete configurability and visibility all over the user interface of the IDE. This will make KDevelop even more attractive to users coming from other platforms and make the transition to UNIX much easier, further reducing the learning curve for handling the programming environment.</para>
<para>Until the release of KDevelop 2.0, we recommend using version 1.2 for production. It offers almost everything developers expect, especially stability and usability.<indexterm><primary>KDevelop IDE</primary><secondary>versions</secondary></indexterm><indexterm><primary>versions</primary><secondary>KDevelop IDE</secondary></indexterm></para>
<section id="ch18lev3sec1">
<title>The KDevelop User Interface</title>
<para>As<indexterm><primary>user interface (KDevelop IDE)</primary></indexterm><indexterm><primary>interface</primary><see>user interface</see></indexterm><indexterm><primary>graphical user interface</primary><see>user interface</see></indexterm><indexterm><primary>GUI (graphical user interface)</primary><see>user interface</see></indexterm> seen in <link linkend="ch18fig01">Figure 18.1</link>, the main window of KDevelop is separated into three subwindows. Each has a certain purpose and can be resized, enabled or disabled, and automatically switched on and off by a built-in autoswitch function.</para>
<section id="ch18lev4sec1">
<title>The Tree View</title>
<para>The<indexterm><primary>KDevelop IDE</primary><secondary>views</secondary><tertiary>Tree View</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary></indexterm><indexterm><primary>views</primary><secondary>KDevelop IDE</secondary><tertiary>Tree View</tertiary></indexterm> left pane contains one major part called the Tree View. It is created as a tabular window containing several pages:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The Class Viewer (CV)&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>CV (Class Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>CV (Class Viewer)</secondary></indexterm><indexterm><primary>Class Viewer (CV)</primary></indexterm><indexterm><primary>CV (Class Viewer)</primary></indexterm>Here, the C++ classes, C functions and structs, as well as namespaces of your project are displayed as a tree, which allows you to dive directly into the source files at the location of declaration and definition of attributes, functions, classes, and namespaces. The tree is initially built when loading a project by an amazingly fast-scanning implementation and actualized during automatic and manual saving to rematch location changes and added code to the displayed objects in the source files.</para></listitem>
<listitem><para>The Logical File Viewer (LFV)&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm><indexterm><primary>Logical File Viewer (LFV)</primary></indexterm><indexterm><primary>LFV (Logical File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm>The LFV sorts all project files into groups dependent on their MIME type; for example, all C++ source files are collected into a folder called sources, and all C++ header files are found in a folder called headers. New groups can easily be added via a context menu specifying the name of the folder and the file types to be collected.</para></listitem>
<listitem><para>The Real File Viewer (RFV)&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm><indexterm><primary>Real File Viewer (RFV)</primary></indexterm><indexterm><primary>RFV (Real File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm>Displays the project directories and files as they are located on your system and displays all files along with their status within the project as <quote>registered</quote> and <quote>CVS</quote> or <quote>local.</quote><indexterm><primary>KDevelop IDE</primary><secondary>views</secondary><tertiary>Tree View</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary></indexterm><indexterm><primary>views</primary><secondary>KDevelop IDE</secondary><tertiary>Tree View</tertiary></indexterm></para></listitem>
<listitem><para>The Documentation Tree View (DOC)&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>DOC (Documentation Tree View)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>DOC (Documentation Tree View)</secondary></indexterm><indexterm><primary>Documentation Tree View (DOC)</primary></indexterm><indexterm><primary>DOC (Documentation Tree View)</primary></indexterm>Offers easy access to all documentation available on your system: the KDevelop handbooks, the Qt library documentation as well as the full KDE-API documentation, project documents, and self-configured additional documentation. The library documentations can be accessed down to the location of class-member function automatically opening the right page in the Documentation-Browser.</para></listitem>
<listitem><para>The Variable Viewer (VAR)&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>VAR (Variable Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>VAR (Variable Viewer)</secondary></indexterm><indexterm><primary>Variable Viewer (VAR)</primary></indexterm><indexterm><primary>VAR (Variable Viewer)</primary></indexterm>Active while debugging your application with the internal debugger. Here the attribute values of your application's class instances are displayed during runtime in a debugging session.</para></listitem>
</itemizedlist>
<para>The Tree View is one of the most effective parts of the KDevelop user interface, offering the logistics to your project, information, and localization of source code from the <quote>object-oriented</quote> point of view.<indexterm><primary>KDevelop IDE</primary><secondary>views</secondary><tertiary>Tree View</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary></indexterm><indexterm><primary>views</primary><secondary>KDevelop IDE</secondary><tertiary>Tree View</tertiary></indexterm></para>
</section>
<section id="ch18lev4sec2">
<title>The Output View</title>
<para>At <indexterm><primary>KDevelop IDE</primary><secondary>views</secondary><tertiary>Output View</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary></indexterm><indexterm><primary>views</primary><secondary>KDevelop IDE</secondary><tertiary>Output View</tertiary></indexterm>the bottom of the KDevelop main window, you see the Output View. This is the second helper window that you will make use of often. Like the Tree View, it contains several pages, each for a certain purpose:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Messages&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Messages page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Messages page</secondary></indexterm><indexterm><primary>Messages page (KDevelop Output View</primary></indexterm>Any output that comes to KDevelop when running tools such as <literal>make</literal> or the KDOC documentation program will be displayed here. The messages window also brings you to the location of errors by clicking the error line of the output.</para></listitem>
<listitem><para>Stdout&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Stdout page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Stdout page</secondary></indexterm><indexterm><primary>Stdout page (KDevelop Output View</primary></indexterm>When starting your application from within KDevelop, it sends all output you would see normally on a console into that window. Thus, you can control the behavior in a way most developers do when using the <literal>cout</literal> function to get status information at runtime.</para></listitem>
<listitem><para>Stderr&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Stderr page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Stderr page</secondary></indexterm><indexterm><primary>Stderr page (KDevelop Output View</primary></indexterm>Here, the started application will put its information that is sent out via the <literal>cerr</literal> function to monitor error messages.</para></listitem>
<listitem><para>Breakpoint&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Breakpoint page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Breakpoint page</secondary></indexterm><indexterm><primary>Breakpoint page (KDevelop Output View</primary></indexterm>Lists the breakpoints set in the source files and monitors how often the application reached the breakpoint during a debugging session.</para></listitem>
<listitem><para>Frame Stack&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Frame Stack page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Frame Stack page</secondary></indexterm><indexterm><primary>Frame Stack page (KDevelop Output View</primary></indexterm>Lists the calling stack of the currently monitored application or function together with addresses.</para></listitem>
<listitem><para>Disassemble&mdash;<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary><tertiary>Disassemble page</tertiary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary><secondary>Disassemble page</secondary></indexterm><indexterm><primary>Disassemble page (KDevelop Output View</primary></indexterm>A machine-instruction view that displays the currently executed code in assembler language.</para></listitem></itemizedlist>
<para>The Output View therefore offers you the most information about the status of other applications, including the application that you are programming. Additionally, you're offered exact debugging information as well as an error-locating mechanism that brings you to the right place by a single click on the error line.<indexterm><primary>KDevelop IDE</primary><secondary>views</secondary><tertiary>Output View</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Output View</secondary></indexterm><indexterm><primary>Output View (KDevelop IDE)</primary></indexterm><indexterm><primary>views</primary><secondary>KDevelop IDE</secondary><tertiary>Output View</tertiary></indexterm></para>
</section>
<section id="ch18lev4sec3">
<title>The Working Area</title>
<para>The <indexterm><primary>KDevelop IDE</primary><secondary>working area</secondary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>working area</secondary></indexterm><indexterm><primary>working area (KDevelop IDE)</primary></indexterm>window that contains the actual editor is called the <emphasis>working area</emphasis> and is placed at the right of the Tree View and above the Output View. This window is again split into several pages:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Resource/Header Files&mdash;<indexterm><primary>Resource/Header Files window (KDevelop)</primary></indexterm>The first editor window, displaying C++ header files and any other file that is not a source file to be compiled like normal text files.</para></listitem>
<listitem><para>C/C++ Files&mdash;<indexterm><primary>C/C++ Files window (KDevelop)</primary></indexterm>The second editor window for opening and editing C/C++ source files (*.cpp- files). Source files can be compiled separately without rebuilding the whole project when the file to compile is loaded into this editor window.</para></listitem>
<listitem><para>Documentation-Browser&mdash;<indexterm><primary>Documentation-Browser window (KDevelop)</primary></indexterm>This window is an HTML browser like KFM and is used together with the documentation tree to open the documentation for you. Results from search requests over the documentation will be displayed here for direct browsing, as well.</para></listitem>
<listitem><para>Tools&mdash;<indexterm><primary>Tools window (KDevelop)</primary></indexterm>The Tools window is an embedding area for other applications that can be started from within KDevelop, such as KIconEdit, KTranslator, Cervesia, and the like.<indexterm><primary>KDevelop IDE</primary><secondary>working area</secondary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>working area</secondary></indexterm><indexterm><primary>working area (KDevelop IDE)</primary></indexterm></para></listitem></itemizedlist>
</section>
<section id="ch18lev4sec4">
<title>The Dialog Editor</title>
<para>Because<indexterm><primary>KDevelop IDE</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>Dialog Editor (KDevelop IDE)</primary></indexterm><indexterm><primary>editors</primary><secondary>Dialog Editor (KDevelop)</secondary></indexterm> KDevelop aims to focus on KDE/Qt developers, it contains a what-you-see-is-what-you-get (WYSIWYG) Dialog Editor that integrates seamlessly into the IDE (see <link linkend="ch18fig03">Figure 18.3</link>). The Dialog Editor can be accessed either automatically when opening or creating a dialog file or via the menu item Dialog Editor.</para>
<figure label="18.3" id="ch18fig03">
<title>The KDevelop Dialog Editor with a sample dialog ready for editing.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig03.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>The Dialog Editor has several <indexterm><primary>KDevelop IDE</primary><secondary>Dialog Editor</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Dialog Editor</secondary><tertiary>advantages</tertiary></indexterm><indexterm><primary>Dialog Editor (KDevelop IDE)</primary><secondary>advantages</secondary></indexterm><indexterm><primary>editors</primary><secondary>Dialog Editor (KDevelop)</secondary><tertiary>advantages</tertiary></indexterm>advantages for a KDE/Qt developer: it lets you directly create, edit, and build GUI components and includes a preview functionality. The user interfaces can then be directly used within a project and adapted to further functionality needs. This is very easy because you can set all available properties for a GUI component, such as a push button, on the right in the Properties window. After creating a user interface, KDevelop creates the according source files in C++ as a class derived from classes provided by Qt, such as <literal>QWidget</literal> or <literal>QDialog</literal>. Thereafter, the developer implements the signals and slots into that class and adds the instantiation for calling the dialog at the desired place within the application's source code. By that, developing user interfaces for your applications is as easy as it could be with the simple steps of visually designing them and generating the source code afterward.<indexterm><primary>KDevelop IDE</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>Dialog Editor (KDevelop IDE)</primary></indexterm><indexterm><primary>editors</primary><secondary>Dialog Editor (KDevelop)</secondary></indexterm></para>
<note role="normal">
<para>It<indexterm><primary>KDevelop IDE</primary><secondary>Dialog Editor</secondary><tertiary>weaknesses</tertiary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Dialog Editor</secondary><tertiary>weaknesses</tertiary></indexterm><indexterm><primary>Dialog Editor (KDevelop IDE)</primary><secondary>weaknesses</secondary></indexterm><indexterm><primary>editors</primary><secondary>Dialog Editor (KDevelop)</secondary><tertiary>weaknesses</tertiary></indexterm> cannot be denied, however, that the current Dialog Editor has one weakness that may require you to re-edit the source code output. Because it can handle the creation of user interfaces only on the basis of fixed geometry measurements, your application will have problems with translations if the texts are longer than your English originals. This will cut off the ending, for example, on buttons and labels if these are too short to display the full translation. Thus, you need to make use of the geometry management functions provided by the Qt library and implement a layout by yourself, separated from the default output of the Dialog Editor.</para>
</note>
<para>You will read more about the Dialog Editor later on when you'll have a closer look at actually developing a KDE application with KDevelop.<indexterm><primary>KDevelop IDE</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Dialog Editor</secondary></indexterm><indexterm><primary>Dialog Editor (KDevelop IDE)</primary></indexterm><indexterm><primary>editors</primary><secondary>Dialog Editor (KDevelop)</secondary></indexterm></para>
</section>
</section>
</section>
</section>
<section id="ch18lev1sec2">
<title>Creating KDE 2.0 Applications</title>
<para>Now <indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>Application Wizard</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>KDevelop Application Wizard</tertiary></indexterm><indexterm><primary>Application Wizard (KDevelop)</primary></indexterm><indexterm><primary>wizards</primary><secondary>Application Wizard (KDevelop)</secondary></indexterm>you'll start with a sample session of creating a first KDE application that is compliant with the KDE 2.0 API and offers the already described Autoconf/Automake framework. As usual, whenever you're creating a new project with KDevelop, from the Project menu choose New. Then the Application Wizard of KDevelop (see <link linkend="ch18fig04">Figure 18.4</link>) will help you define the type, the name, and other properties of your new project:</para>
<para>After selecting the desired project type, you get a preview of the application as it will look after generating and compiling the source code, and a brief description. The next page lets you set the different project settings, such as the name, the initial version, the author name and email, and the directory where the project will be generated. The lower section allows you to select which additional features you need; API Documentation, User Documentation, icons, linkfile, and even the source code itself can be deselected if you want to start your application from scratch. The third page of this wizard allows you to enable CVS support on the initial generation. You should notice that this is restricted to be used with a local CVS repository. If you intend to use a dedicated nonlocal CVS server, you have to do the import of the generated source tree separately with a tool such as Cervesia. After the source tree is on the CVS server's repository, you can then check out again to work on a local copy with KDevelop.<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>Application Wizard</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>KDevelop Application Wizard</tertiary></indexterm><indexterm><primary>Application Wizard (KDevelop)</primary></indexterm><indexterm><primary>wizards</primary><secondary>Application Wizard (KDevelop)</secondary></indexterm></para>
<figure label="18.4" id="ch18fig04">
<title>The KDevelop Application Wizard.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig04.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<note role="tip">
<para>Cervesia is included in the KDE Development Kit provided by the KDevelop Project. The kit contains all the KDE tools needed to develop specific KDE applications.</para>
</note>
<para>If you're a developer who works alone on projects, local CVS is always a good option because it gives you the full power of version control on your standalone machine.</para>
<para>The fourth and fifth pages of the wizard allow you to define the header for generated files. The header of a file is usually a comment that includes the filename, the date of creation, the author's name, and a license notice for the file. The default is good enough for most developers because it uses the GPL as a license, but you're not restricted to that&mdash;you can change the license notice either directly in the preview editing window or load an already existing template for your file header.</para>
<para>Page six is the last page of the wizard. Here, you click the Create button to start the generation of the project. If the button is not enabled (selectable), you've probably not filled in a setting, such as the project name. The project will then be built as defined; you'll get the output of the processes in the upper window, and errors are displayed in the lower one. The Finish button will be available if the project has been built successfully, bringing you back to the KDevelop project editor that automatically loads the generated project to let you get started with programming your KDE 2.0 application (as shown in <link linkend="ch18fig05">Figure 18.5</link>).</para>
<figure label="18.5" id="ch18fig05">
<title>The KDevelop project editor after generating a KDE 2.0 application with the Application Wizard.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig05.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>You've seen how easily you can get started with developing your applications for KDE&mdash;fully based on a graphical user interface that automatically solves beginners' as well as experts' problems&mdash;to set up a complete framework for a project that conforms with Autoconf/Automake, includes pregenerated source files and running code, license, documentation, and even version control!<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>Application Wizard</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>KDevelop Application Wizard</tertiary></indexterm><indexterm><primary>Application Wizard (KDevelop)</primary></indexterm><indexterm><primary>wizards</primary><secondary>Application Wizard (KDevelop)</secondary></indexterm></para>
<section id="ch18lev2sec2">
<title>Available Templates for KDE 2.0 Projects</title>
<para>The<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary></indexterm> KDevelop Application Wizard generates your project by application templates. These are predefined packages that run <quote>out of the box</quote> after generating. For KDE 2.0, programmers can choose from three types of application frameworks:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>KDE Mini application&mdash;<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary><tertiary>KDE Mini</tertiary></indexterm><indexterm><primary>KDE Mini application template</primary></indexterm><indexterm><primary>Mini application template</primary></indexterm>This generates an application that has the usual Autoconf/Automake framework with a single window (an instance of a <literal>QWidget</literal> inherited class that the project contains). This type of project is used mostly by programmers who want to start their application from a very basic code tree to create programs such as a kcontrol module, a wizard, or an application that needs only one window as the main GUI interface.</para></listitem>
<listitem><para>KDE Normal application&mdash;<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary><tertiary>KDE Normal</tertiary></indexterm><indexterm><primary>KDE Normal application template</primary></indexterm><indexterm><primary>Normal application template</primary></indexterm>The KDE Normal type of framework offers the predefined automatic configuration files and a source tree that contains three classes that build up a document-view interface. Therefore, these classes are<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><formalpara><title><literal>projectnameApp</literal>&mdash;</title><para>This is the base class for the application window, derived from the <literal>KTMainWindow</literal> class of the kdeui library.</para></formalpara></listitem>
<listitem><formalpara><title><literal>projectnameDoc</literal>&mdash;</title><para>This is the base class for the document instances. The <literal>Doc</literal> class takes the part of loading and saving a document as a file, and it takes care of providing the interface to access the document data to other classes and instances. This class is derived from <literal>QObject</literal> because it isn't necessarily a window, but more a general tool class that deals with data structures; it should be able to communicate with other application instances via the Qt signal/slot mechanism.</para></formalpara></listitem>
<listitem><formalpara><title><literal>projectnameView</literal>&mdash;</title><para>The <literal>view</literal> class, on the other hand, is directly derived from <literal>QWidget</literal> because it represents the <quote>view</quote> in which the user of the application sees the document data on the screen. Therefore, the instance of this class is directly connected to the document instance that provides the data or at least a data area into which the view class can write. The conclusion is that a Doc-instance could live without a view, but a View-instance could never live without a Doc-instance; otherwise, it would attempt to write into areas that don't exist!</para></formalpara></listitem>
</itemizedlist>
<para>You should, however, notice that this kind of application type is designed to build a Single Document Interface (SDI) framework. SDI means that one application main window can handle only one main view area that takes care of one document instance. That raises the issue that a separate document class may not be needed that much, but it is always a good style to create the classes of an application that take care of one special task.<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary><tertiary>KDE Normal</tertiary></indexterm><indexterm><primary>KDE Normal application template</primary></indexterm><indexterm><primary>Normal application template</primary></indexterm></para></listitem>
<listitem><para>KDE-MDI application&mdash;<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary><tertiary>KDE-MDI</tertiary></indexterm><indexterm><primary>KDE-MDI application template</primary></indexterm>Because the Qt library provides a child window class (<literal>QWorkspace</literal>) since version 2.1 (which is used by KDE 2.0), we implemented a fully functional Multiple Document Interface (MDI) application framework that is also based on the Document-View model. Nevertheless, the Qt library lacks classes that are specifically designed to take care of the document part of applications, so the document class is again derived from <literal>QObject</literal>.</para></listitem>
</itemizedlist>
<para>Now you've seen that KDevelop offers a variety of frameworks&mdash;even specialized for KDE 2.0. These frameworks are also provided as Qt-only based applications, which make it possible to directly port commercial applications to operating systems using Qt in conjunction with their professional license or to compile a version that runs with the new Qt/Embedded library for embedded systems.<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>templates</tertiary></indexterm><indexterm><primary>templates</primary><secondary>KDevelop application templates</secondary></indexterm></para>
</section>
<section id="ch18lev2sec3">
<title>Editing Your Project</title>
<para>After<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>project editing</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>project editing</tertiary></indexterm><indexterm><primary>projects</primary><secondary>editing</secondary></indexterm><indexterm><primary>editing</primary><secondary>projects</secondary></indexterm> project generation, the usual development steps will take place within KDevelop. You're provided with the Classbrowser, the Classtools, the file viewers to navigate within your project sources, and the internal KWrite editor to edit the sources. The New and Edit menus should give you the most-needed editing commands, and you can configure the syntax highlighting of the source code and other options, such as the printing configuration, in the Options menu. Furthermore, one of the most useful tools for editing is the Search in Files dialog option available in the Edit menu, which lets you look up expressions all over your project tree. The results are listed in a box within the dialog, allowing you to go directly to the location of the matching file and line.</para>
<para>Maintaining your project is very easy. The New File dialog lets you create a whole set of predefined file types, such as source files, desktop files, docbook documentation, pixmaps, and the like. Classes can be created on-the-fly with the New Class dialog, including a file header; inheriting a class automatically adds the needed include statement, as well. Source files that you've created already can be added to the project directly with the Add Existing Files functionality. After each time you've added a file to your project, the KDevelop project- management system automatically updates the Makefile.ams and takes care of the configuration process.</para>
<para>File properties make it easy to set the installation destination for resource files such as pixmaps.</para>
<para>You see how easy project maintainance gets when you use KDevelop; you just have to take care of the code you're writing.<indexterm><primary>KDevelop IDE</primary><secondary>KDE applications, creating</secondary><tertiary>project editing</tertiary></indexterm><indexterm><primary>applications</primary><secondary>creating</secondary><tertiary>project editing</tertiary></indexterm><indexterm><primary>projects</primary><secondary>editing</secondary></indexterm><indexterm><primary>editing</primary><secondary>projects</secondary></indexterm></para>
</section>
</section>
<section id="ch18lev1sec3">
<title>Getting Started with the KDE 2.0 API</title>
<para>The main issue for a programmer who wants to write an application using libraries such as Qt and the extensions offered by KDE is where to get the information about the interfaces (the classes of the libraries) and how to use them. This is a special area where KDevelop gives you a great help, even if you choose to use a different programming environment for writing your application. Long-term emacs users, for example, might prefer to stay with their editor and write their framework themselves.</para>
<para>First let's look at what KDevelop offers in documentation availability:<indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>KDevelop <indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>online handbooks</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>online handbooks</tertiary></indexterm>ships with five handbooks in HTML format that are available for online reading and that can also be printed out using the sgmltools on the SGML files that come with the source code of KDevelop. These handbooks contain a user manual describing the whole IDE and its features, as well as an introduction to development in general, a programming handbook for KDE development, and a tutorial handbook with a guide showing how to create and run KDE/Qt applications with KDevelop (including a step-by-step introduction to using the KDE API to create a sample project and the source code of the sample program). Furthermore, the book <emphasis>The KDE Library Reference Guide</emphasis> contains detailed explanations about the Qt signal/slot mechanism, an explanation of the event loop of a GUI-based application, event-handling implementation and manipulation, as well as a description of the commonly used KDE classes. Finally, the <emphasis>KDE 2.0 Developer's Guide</emphasis> introduces the developer to some principles and guidelines toward targeting KDE 2.0 application development. The IDE also contains a complete C/C++ reference that will assist the developer in certain questions about the C and C++ programming languages.</para></listitem>
<listitem><para>Within <indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>API documentation</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>API documentation</tertiary></indexterm>KDevelop, you can generate the complete KDE API with the help of KDOC via the Setup (you may choose to generate it for KDE 1.x or KDE 2.0, whatever system you want to develop for). This includes the KDE standard libraries, the KDE base libraries (kcontrol and libkonq) for writing modules to extend Konqueror or the KDE Control Center, as well as the KOffice libraries used to create KOffice applications. You can regenerate the API documentation any time you want, especially if the API has changed or has been extended. This is a good way to get the newest set of information available. In addition, the documentation is cross-referenced with the Qt online API documentation that comes with the distribution of the Qt library. Therefore, you have full access to the inheritance structure and can easily look up relationships between KDE and Qt.</para></listitem>
<listitem><para>KDevelop<indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>searching</primary><secondary>KDevelop documentation</secondary></indexterm> allows you to make search requests over the complete documentation on your system. To enable this, the system needs to have a search engine installed (available are htdig or glimpse for use with KDevelop). The search engines contain an indexing function to create a search database that it will use to look up your request and build up the results that will then be displayed as an HTML page in the documentation browser. The required indexing can be done easily via a graphical interface available in the KDevelop setup.</para></listitem>
<listitem><para>KDevelop <indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>Documentation-Browser</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>Documentation-Browser</tertiary></indexterm><indexterm><primary>Documentation-Browser (KDevelop)</primary></indexterm>contains a documentation browser that offers direct access to the API and that works in conjunction with the documentation tree described previously. The documentation tree displays all libraries and user documentation as books containing chapters; for libraries, these are the classes that again can be unfolded to list all methods of a class and that will bring you directly where you need to go&mdash;the documentation to the exact method you want to use. Retrieving the information you need is not a matter of browsing through header files on the system, nor is it a matter of organizing bookmarks for each library in your favorite browser. With KDevelop's browsing facilities, you have the best available access to the API that you need to have to successfully develop your application within a reasonable timeframe (see <link linkend="ch18fig06">Figure 18.6</link>).<indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>Documentation-Browser</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>Documentation-Browser</tertiary></indexterm><indexterm><primary>Documentation-Browser (KDevelop)</primary></indexterm></para></listitem></itemizedlist>
<figure label="18.6" id="ch18fig06">
<title>The KDevelop Documentation-Browser with the Tree View displaying the KDE 2.0 API down to the member functions of classes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig06.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<section id="ch18lev2sec4">
<title>How to Search for Information</title>
<para>KDevelop<indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>searching</primary><secondary>KDevelop documentation</secondary></indexterm> provides several ways to look up information about keywords, classes, or generally anything of interest to the developer that could be explained somewhere in the documentation. At first, looking up used methods within the source code can be done by setting the cursor into the method's name and then pressing the right mouse button and selecting Search: <emphasis><literal>expression</literal></emphasis>. The search engine will then look up the desired information, switch to the Documentation-Browser, and display a results page containing a preview of the first result of each page. You can then select which search result seems to have the information you want&mdash;just like searching on the Internet with a search engine such as Yahoo!.</para>
<para>When you're switching to one result, the found expression is automatically highlighted for you. For looking up the next expression on the same page matching your search, you could use the F3 shortcut or from the View menu of KDevelop, select Repeat Search.</para>
<para>Other possibilities to look up expressions are</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The Search for Help On dialog, available from the Help menu. This dialog allows you to enter the search expression.</para></listitem>
<listitem><para>Within the Documentation-Browser, you can mark text that can then be looked up with the context menu, the same as described for the editor window.</para></listitem>
<listitem><para>Selecting text and using the Help menu item Search Marked Text or the appropriate shortcut to call this function.</para></listitem></itemizedlist>
<para>You'll surely like these features within KDevelop because the amount of documentation grows with the extending of the KDE/Qt API, and it would be very hard to find the functions you need if you don't know exactly which one to use or whether that functionality is provided by the libraries at all.<indexterm><primary>KDevelop IDE</primary><secondary>documentation</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>KDevelop IDE</secondary><tertiary>searching</tertiary></indexterm><indexterm><primary>searching</primary><secondary>KDevelop documentation</secondary></indexterm></para>
</section>
</section>
<section id="ch18lev1sec4">
<title>The Classbrowser and Your Project</title>
<para>Now <indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm>have a closer look at the actual work of a developer and what will help you most while implementing your classes and functions: the Classbrowser and the Classtools.</para>
<para>While implementing KDevelop, we have thought over how to make information about the user's project as transparent as possible with a reasonably fast viewer. Users who know other IDEs are already used to the concept of a Classbrowser, but I know of at least some IDEs where this feature either doesn't work correctly or it slows down the machine so much that you need to have some resources in the back to develop at a reasonable speed. KDevelop, on the other hand, contains a Classparser that scans all files while loading a project&mdash;without affecting performance. The Classtree then displays the results of this scan and automatically updates itself either on saving by the autosave functionality or when running or compiling your application. A manual refresh can be done as well to rescan all sources. The quality and stability of the Classparser has proven so well that it is already used in various other GPL projects, such as KUML (a development tool using the Unified Modeling Language) for similar purposes.<indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm></para>
<para>The Classparser <indexterm><primary>KDevelop IDE</primary><secondary>Classparser</secondary></indexterm><indexterm><primary>Classparser (KDevelop)</primary></indexterm><indexterm><primary>parsers</primary><secondary>Classparser (KDevelop)</secondary></indexterm>takes all source files, reads them, and looks up all classes, their methods and members according to their access scope (public, private, or protected, including signals or slots), their inheritance, namespaces, and global functions and attributes. Then it builds a database that stores this information and creates a Tree View that contains these classes, which can be unfolded to display their members. As a result, you can use the Classbrowser to rapidly browse your sources, keeping an overview of which names you have already used, and you can navigate down into your project. Just selecting a class opens the right header file and sets the cursor at the class declaration. Over members or C functions, it opens the right implementation file&mdash;it doesn't matter how many you like to use to implement a class&mdash;and sets the cursor at the head of the implementation. (See <link linkend="ch18fig07">Figure 18.7</link>.)</para>
<figure label="18.7" id="ch18fig07">
<title>The KDevelop Classbrowser displaying the KDevelop source code, graphically structured with an opened class allowing direct access to methods and attributes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig07.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>This results in a new habit of treating source files from the programmer's view. Formerly, the programmer had to take care to remember where things were declared and implemented to find them again when they were needed. When working on large projects, this is a major undertaking that often results in a time-consuming search for interfaces and their accompanying implementation. The way KDevelop treats your sources makes you totally independent of where you put something. You have access to it at any time via the Classbrowser.</para>
<para>The Classbrowser displays a project's objects as items collected in the following folder tree:<indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Classes</para></listitem>
<listitem><para>Globals</para></listitem>
<listitem><para>Namespaces</para></listitem>
<listitem><para>Structures</para></listitem>
<listitem><para>Functions</para></listitem>
<listitem><para>Variables</para></listitem>
</itemizedlist>
<para>Easy to understand, isn't it? Now, besides the basic functionality of simple mouse clicks over these folders and their contents, the Classviewer offers even more by pop-up menus over the items it displays.<indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm></para>
<para>Over the Classes folder, the menu offers</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>New File&mdash;<indexterm><primary>New File command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>New File</tertiary></indexterm>Opens the New File dialog to create a new source file. The same can be done via the menu with File, New.</para></listitem>
<listitem><para>New Class&mdash;<indexterm><primary>New Class command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>New Class</tertiary></indexterm>Opens the New Class dialog to create a new class together with its sources, including constructor and destructor implementation. The dialog can also be invoked by selecting Project, New Class from the menubar.</para></listitem>
<listitem><para>Add Folder&mdash;<indexterm><primary>Add Folder command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Add Folder</tertiary></indexterm>Adds a folder to the Classtree and creates a <quote>real</quote> folder in the project directory when the first class or file is added to that subfolder with New File or New Class.</para></listitem>
<listitem><para>Options&mdash;<indexterm><primary>Options command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Options</tertiary></indexterm>Opens the Project Options dialog displaying the project options where you can set compiler flags and warnings, linker flags to set the libraries to link the project against, and <literal>make</literal> options to tell <literal>make</literal> certain settings, such as how many compilers to start simultaneously.</para></listitem>
<listitem><para>Graphical Classview&mdash;<indexterm><primary>Graphical Classview command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Graphical Classview</tertiary></indexterm>Shows the Classtree in a graphical Tree View, including the inheritance of the base classes.<indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm></para></listitem></itemizedlist>
<para>Over a class, the pop-up menu allows the following options:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Go to Declaration&mdash;<indexterm><primary>Go to Declaration command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Go to Declaration</tertiary></indexterm>Opens the file containing the class declaration and sets the cursor on the declaration's first line.</para></listitem>
<listitem><para>Add Member Function&mdash;<indexterm><primary>Add Member Function command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Add Member Function</tertiary></indexterm>Opens the Add Member Function dialog to add a method to the selected class (see <link linkend="ch18fig08">Figure 18.8</link>).</para></listitem>
<listitem><para>Add Member Variable&mdash;<indexterm><primary>Add Member Variable command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Add Member Variable</tertiary></indexterm>Opens the Add Member Variable dialog to add a member variable to the selected class.</para></listitem>
<listitem><para>Parent Classes&mdash;<indexterm><primary>Parent Classes command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Parent Classes</tertiary></indexterm>Opens the Classtools dialog with the current class and displays a tree showing all classes the selected class inherits.</para></listitem>
<listitem><para>Child Classes&mdash;<indexterm><primary>Child Classes command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Child Classes</tertiary></indexterm>Opens the Classtools dialog with the current class and displays all classes that inherit from the selected class.</para></listitem>
<listitem><para>Classtool&mdash;<indexterm><primary>Classtool command (Classbrowser pop-up menu)</primary></indexterm><indexterm><primary>commands</primary><secondary>Classbrowser pop-up menus</secondary><tertiary>Classtool</tertiary></indexterm>Opens the Classtools dialog with the selected class.<indexterm><primary>KDevelop IDE</primary><secondary>Classbrowser</secondary></indexterm><indexterm><primary>Classbrowser (KDevelop)</primary></indexterm><indexterm><primary>browsers</primary><secondary>Classbrowser (KDevelop)</secondary></indexterm></para></listitem></itemizedlist>
<para>Over a selected function in the Globals folder, the pop-up menu offers going to the declaration and definition, as well.</para>
<para>You see how easily you can handle your project in a more object-oriented way than what usual development has meant under UNIX when you're supported by the Classbrowser. In my experience, the Classbrowser usually significantly reduces the time of development because you do not have to look up and remember everything yourself, so it is a feature every developer will like from the start of using KDevelop.</para>
<figure label="18.8" id="ch18fig08">
<title>The Add New Method dialog lets you easily add a method to a class, including its documentation, declaration, and an implementation head, with support for signals and slots used by Qt/KDE.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig08.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
</section>
<section id="ch18lev1sec5">
<title>The File Viewers&mdash;The Windows to Your Project Files</title>
<para>Although<indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary></indexterm> the documentation Tree View and the Classviewer already provide what you, as a developer, will make use of most of the time, you should certainly be given access to the actual files of your project. This is provided by the File Viewers, separated into two trees. One is the Logical File Viewer (LFV); the other is the Real File Viewer (RFV), which you'll have a closer look at now.</para>
<section id="ch18lev2sec5">
<title>The Logical File Viewer (LFV)</title>
<para>The<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm><indexterm><primary>Logical File Viewer (LFV)</primary></indexterm><indexterm><primary>LFV (Logical File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm> first page on the right of the Classbrowser tree is the Logical File Viewer (LFV). Its purpose is generally to provide access to your project files, but in a more sophisticated way than a simple Tree View. First, only the registered project files are shown, such as header files, implementation files, READMEs, and the like. These are collected into groups, which are shown as folders. On creating a new project with the Application Wizard, a set of predefined folders is already created for your project, which you can extend directly in the LFV by adding new folders via a dialog or editing the given folder's file filters.</para>
<para><link linkend="ch18fig09">Figure 18.9</link> shows a sample project with its files displayed in the LFV, as well as the dialog for adding a new group:</para>
<figure label="18.9" id="ch18fig09">
<title>The Logical File Viewer shows your project files separated into groups, depending on the file filters set.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig09.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>What else does the LFV offer? Clicking a file you want to open automatically opens the file and the right application to display it. A good example is pixmap graphics, which are often used in KDE applications as menubar and toolbar symbols. On selecting such a pixmap, KIconEdit gets started inside KDevelop on the Tool page and lets you edit the pixmap directly. The same functionality is provided for a number of common file formats appearing in projects, such as dialog definition files for KDevelop's dialog editor and po files containing translations for a given language.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm><indexterm><primary>Logical File Viewer (LFV)</primary></indexterm><indexterm><primary>LFV (Logical File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>LFV (Logical File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>LFV (Logical File Viewer)</secondary></indexterm></para>
</section>
<section id="ch18lev2sec6">
<title>The Real File Viewer (RFV)</title>
<para>On <indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm><indexterm><primary>Real File Viewer (RFV)</primary></indexterm><indexterm><primary>RFV (Real File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm>the other hand, you may need to have access to the whole directory structure of your project and all files therein. Therefore, the Real File Viewer (RFV), located next to the LFV, is the right place to go for actions such as deleting files, adding files to the project, and even some really cool things such as using CVS (Concurrent Version System) to manage your project&mdash;and all that from within one graphical interface (see <link linkend="ch18fig10">Figure 18.10</link>).</para>
<para>In detail, the RFV offers</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Switching between project files and all file display modes</para></listitem>
<listitem><para>Updating the Makefile.ams of selected folders or the whole project tree</para></listitem>
<listitem><para>Creating and deleting files and folders</para></listitem>
<listitem><para>Changing a subdirectory's target to a shared or static library</para></listitem>
<listitem><para>Using CVS commands on files and folders, such as adding, removing, updating, and check in</para></listitem></itemizedlist>
<figure label="18.10" id="ch18fig10">
<title>The Real File Viewer of KDevelop offers you direct access to all project files and even CVS commands.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig10.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>Of course, opening files works the same as with the LFV.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>Tree View</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>Tree View (KDevelop IDE)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm><indexterm><primary>Real File Viewer (RFV)</primary></indexterm><indexterm><primary>RFV (Real File Viewer)</primary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>File Viewers</secondary><tertiary>RFV (Real File Viewer)</tertiary></indexterm><indexterm><primary>File Viewers (KDevelop)</primary><secondary>RFV (Real File Viewer)</secondary></indexterm></para>
</section>
</section>
<section id="ch18lev1sec6">
<title>The KDevelop Debugger</title>
<para>In<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary></indexterm><indexterm><primary>gdb debugger</primary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary></indexterm> the set of tools available for developers under the GNU license, there is a debugger, the <literal>gdb</literal>. <literal>gdb</literal> itself is a command-line tool like <literal>g++</literal> and <literal>gcc</literal> and is used to monitor applications during runtime. The application binary therefore has to include runtime information for the debugger, which can be turned on during compilation. Then <literal>gdb</literal> will deliver as much information about your application as available: addresses, method names, object values, location of methods in your source files, and much more. However, to make the best use of it, a lot of freely available GUI front ends are provided, such as <literal>ddd</literal> or <literal>kdbg</literal>, which let you run your application with <literal>gdb</literal> and display the runtime information delivered by <literal>gdb</literal>. KDevelop, however, contains a new internal debugging front end to <literal>gdb</literal> that lets you use all features within the same environment so that you don't have to switch between your coding editor and the debugger application. Its integration is seamless and easy to use, and you are still provided the possibility to use an external debugging front end as a tool in the Tools window.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary></indexterm><indexterm><primary>gdb debugger</primary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary></indexterm></para>
<section id="ch18lev2sec7">
<title>Setting the Debugger Options</title>
<para>The<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>options</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm> debugger settings, like all other KDevelop configuration options, are located in KDevelop Setup, which can be accessed via the Options menu. Select the debugger tabulator to change the debugging settings.</para>
<para>There you can select between the default use of the internal KDevelop debugger or using an external debugger with the debugger name you want to use (<literal>ddd</literal> or <literal>kdbg</literal>).</para>
<para>Next, three major settings for the internal debugger are worth a closer look. First is the option to set Pending Breakpoints. A breakpoint is a mark in the source code at a certain line where you want the debugger to stop your application&mdash;for example, when you're searching for a segmentation fault or you want to inspect how often your application will call the same method to increase the performance when you know how to reduce the number of times a method gets called. Now, applications often make use of libraries that they are linked to. Although static libraries are included into the binary, dynamic libraries such as the KDE and Qt libraries are loaded when an application calls a method that is in one of these libraries. That means as long as a method that is placed in a library didn't get called, the library won't be loaded. When you want to set a breakpoint exactly at a method call that is in a library, <literal>gdb</literal> can't set it if the library isn't in the system's memory. The Pending Breakpoint option helps here because it deactivates the breakpoint as long as the library hasn't been loaded, and it tries to activate it as soon as the library is available in memory.</para>
<para>The second option that is very important is the floating toolbar. In debugging mode of KDevelop, this brings up a separate little toolbar window that contains the debugging commands as icons and that will stay on top. This is a nice feature that makes debugging easier, and you can still monitor the source code in KDevelop behind your application window (see <link linkend="ch18fig11">Figure 18.11</link>). There is also the option to use a separate I/O window for applications that make use of command-line input calls, such as <literal>cin</literal> and <literal>fgets</literal>. In that case, checking the floating toolbar is again a good option so that your input window doesn't get obscured when activating debugging commands.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>options</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>options</tertiary></indexterm></para>
</section>
<section id="ch18lev2sec8">
<title>How to Enable Debugging Information</title>
<para>To <indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>enabling debugging information</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>enabling</primary><secondary>debugging</secondary><tertiary>gdb debugger</tertiary></indexterm>debug your application, all you have to do is to tell the compiler to include debugging code into the binary that serves as a reference from the object code to the original source code so that breakpoints can be set and monitored.</para>
<para>For this, open the Project Options dialog available in the Project menu. Switch to the compiler options tabulator and check the Generate Debugging Information option together with the debugging level. By default, debugging is turned on at project creation, so you shouldn't worry if your application loads a bit slower when running a normal test. To see how it will perform when compiled normally, deselect this option and enable optimization instead, which can be done on the same page. A commonly used optimization level is -02, which will work in most cases, but you're on the safe side using -01.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>enabling debugging information</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>enabling debugging information</tertiary></indexterm><indexterm><primary>enabling</primary><secondary>debugging</secondary><tertiary>gdb debugger</tertiary></indexterm></para>
<figure label="18.11" id="ch18fig11">
<title>The KDevelop debugger is your gateway to the CPU and memory usage of your application. It allows you to monitor your program's execution line by line along the source code.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig11.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
</section>
<section id="ch18lev2sec9">
<title>Running a Debugging Session</title>
<para>To <indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>running</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>running</primary><secondary>gdb debugger</secondary></indexterm>actually use the debugger, you have to run your application within <literal>gdb</literal>. For that, use the Debug menu, which offers the normal Start operation and advanced selection of starting methods, such as appending arguments or attaching your application to another process. Notice that you have to set a breakpoint before starting the debugger; otherwise, your program won't stop! Setting breakpoints is one of the easiest tasks. The editor windows have a gray pane on the left; you just have to click the line on which you want to stop, and a breakpoint symbol is placed. The context menu over this pane offers advanced options to the debugger as well as switching between breakpoint and bookmark modes. Then the debugger will start your program and the debugging options and windows will be available. These are<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>_____debugger)</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>commands</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>commands</primary><secondary>gdb debugger</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Run&mdash;<indexterm><primary>Run command (gdb debugger)</primary></indexterm>Executes or continues the program.</para></listitem>
<listitem><para>Run to Cursor&mdash;<indexterm><primary>Run to Cursor command (gdb debugger)</primary></indexterm>Executes the program until the current cursor position in the source code is reached.</para></listitem>
<listitem><para>Step Over&mdash;<indexterm><primary>Steo Over command (gdb debugger)</primary></indexterm>Executes one line of code and will stop the application on the next line.</para></listitem>
<listitem><para>Step Over Instruction&mdash;<indexterm><primary>Step Over Instruction command (gdb debugger)</primary></indexterm>Executes exactly one machine instruction. The assembler code that is executed and where the machine instructions can be monitored is the Disassemble tab in the output window.</para></listitem>
<listitem><para>Step In&mdash;<indexterm><primary>Step In command (gdb debugger)</primary></indexterm>Executes one line of code where you will step into the method call, if necessary.</para></listitem>
<listitem><para>Step In Instruction&mdash;<indexterm><primary>Step In Instruction command (gdb debugger)</primary></indexterm>Executes one machine instruction as described previously.</para></listitem>
<listitem><para>Step Out&mdash;<indexterm><primary>Step Out command (gdb debugger)</primary></indexterm>Runs to the end of the stack frame and out of the function the application is currently processing.</para></listitem>
<listitem><para>Viewers&mdash;<indexterm><primary>Viewers command (gdb debugger)</primary></indexterm>Opens the debugging viewers dialog where you can inspect a variety of values of the running application, such as the disassembled code, memory status, library status, and CPU register states.</para></listitem>
<listitem><para>Stop&mdash;<indexterm><primary>Stop command (gdb debugger)</primary></indexterm>Stops the application execution.</para></listitem>
<listitem><para>Exit&mdash;<indexterm><primary>Exit command (gdb debugger)</primary></indexterm>Stops the application execution and exits the debugger.<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb debugger)</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>commands</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>commands</tertiary></indexterm><indexterm><primary>commands</primary><secondary>gdb debugger</secondary></indexterm></para></listitem></itemizedlist>
<para>With these options, you can control the processing of your application's execution at runtime. On the other hand, you certainly don't want only to hop through the source code, but you might also want to know which values your variables have during execution time. This is the easiest way to find the cause of a segmentation fault. To those who aren't experts with programming yet, you may have encountered a program suddenly exiting without you wanting it to exit. It is just gone and your work is lost. The cause of this is most often a segmentation fault. That means that the computer tries to access an object the program refers to, but the object doesn't exist. The program will crash in that case because it violates the memory protection by wanting to access an address area that it isn't allowed to. Development of C++ and C applications often involve the use of pointers to objects that are the cause of most segmentation faults; therefore, you surely want to watch if a pointer is valid during runtime. The KDevelop debugger now offers the Watch functionality for variables. In the VAR tabulator, you get a Tree View of all objects of the application and their status. There, you can select which variables you want to watch. This is often useful for local variables within a method call you're monitoring. Variables to be watched can be added to the Watch section by using the input field on the bottom of the VAR window or by a context menu within the tree.</para>
<para>Now you should be able to successfully run and debug your application and make it as safe as it can be. Keep in mind that users expect your application to be stable, and they certainly don't want to lose their work&mdash;the same as you don't want your IDE to crash while you're programming!<indexterm><primary>user interface (KDevelop IDE)</primary><secondary>gdb (debugger)</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>KDevelop IDE</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>debuggers</primary><secondary>gdb</secondary><tertiary>options</tertiary></indexterm><indexterm><primary>gdb debugger</primary><secondary>running</secondary></indexterm><indexterm><primary>troubleshooting</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>diagnostic tools</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>tools</primary><secondary>gdb debugger</secondary><tertiary>running</tertiary></indexterm><indexterm><primary>running</primary><secondary>gdb debugger</secondary></indexterm></para>
</section>
</section>
<section id="ch18lev1sec7">
<title>KDevelop 2.0&mdash;A Preview</title>
<para>Coming <indexterm><primary>KDevelop IDE</primary><secondary>versions</secondary><tertiary>KDevelop 2.0</tertiary></indexterm><indexterm><primary>versions</primary><secondary>KDevelop IDE</secondary><tertiary>version 2.0</tertiary></indexterm>near to the end of this chapter, you will certainly think about what is in store for developers with the upcoming KDE 2.0 version of KDevelop. As I said earlier, it is currently not the best option to make use of it for production; it is under constant development and it will bear some major changes and improvements that will make programming even easier (see <link linkend="ch18fig12">Figure 18.12</link>).</para>
<para>Most changes will take place in the areas of the user interface. The current development version already contains an MDI structure that allows you to open several source-code windows at the same time, whereas the 1.x series of KDevelop is single-window based. This improves switching between source files, and you will be able to see more of your code at one time. Furthermore, you'll have the Documentation-Browser at your side while you're editing, so you don't have to switch any more between the editor and the documentation windows. The MDI interface we're using also allows you to switch the child windows into top-level mode and back, which will be of good use for all programmers who have more than one monitor. Now you can spread out your coding windows all over the place.<indexterm><primary>KDevelop IDE</primary><secondary>versions</secondary><tertiary>KDevelop 2.0</tertiary></indexterm><indexterm><primary>versions</primary><secondary>KDevelop IDE</secondary><tertiary>version 2.0</tertiary></indexterm></para>
<para>Further, the Tree View and the Output View can be <quote>docked</quote> and <quote>undocked</quote> into the main window of KDevelop. You can also separate each tabulator of these views into single windows. With KDevelop 2.0, usability will reach a next level for programmers&mdash;so stay tuned.</para>
<para>Other features that will arise are a new Dialog Editor, an exchangeable editor interface to let you choose your favorite coding editor, better project management, and improved classparsing. We'll also try to support more programming languages in the future, but this is currently still a topic under discussion. Everyone's invited to participate on the project, so there is an open door for those that want to have new features. Feel free to implement them and help us to create an even more competitive and developer-friendly development environment.</para>
<figure label="18.12" id="ch18fig12">
<title>KDevelop 2.0 at its current state of development.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/18fig12.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
</section>
<section id="ch18lev1sec8">
<title>Summary</title>
<para>With this chapter, I hope I have at least covered most of KDevelop's features, although I have only scratched the surface. KDevelop 1.2 generally provides everything a C/C++ programmer needs for development of KDE 2.0 applications, and after a long development period of nearly two years, it has proven to be stable and reliable. KDevelop can be your first step to getting on the path to code a new, successful application for UNIX.</para>
<para>If you have any comments, feel free to contact us, and if you would like to join, support, or sponsor the KDevelop project&mdash;you're welcome!</para>
<para>Information about KDevelop, the team, and the project can be found on the Internet at <ulink url="http://www.kdevelop.org">http://www.kdevelop.org</ulink>. There you will find a list of contact addresses to the developers, as well as addresses for our support mailing lists. I hope you will enjoy using KDevelop for your own KDE 2.0 project as much as I will enjoy using your application if it's GPL!</para>
</section>
</chapter>
