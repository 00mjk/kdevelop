<chapter label="4" role="chapter" id="ch04">
<title>Creating Custom KDE Widgets</title>
<para><emphasis>by David Sweet</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In This Chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch04lev1sec1">Widget Basics</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch04lev1sec2">Painting Widgets</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch04lev1sec3">Using Child Widgets</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch04lev1sec4">Handling User Input</link></emphasis></para></listitem>
</itemizedlist>
</highlights>
<para>By<indexterm><primary>widgets</primary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary></indexterm> now you should have a good idea of what simple KDE code looks like and what Qt has to offer. Now we will look in more detail at the building blocks of GUIs: the widgets. Although KDE and Qt offer many useful and powerful widgets, you still need to create your own to customize your UI. It is easy to do this&mdash;and to do it with good form&mdash;if you know how.</para>
<section id="ch04lev1sec1">
<title>Widget Basics</title>
<para>Widgets <indexterm><primary>widgets</primary><secondary>defined</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>defined</tertiary></indexterm>are graphical user-interface elements. Simple widgets can be controls or indicators such as a pushbutton or a text label. More complex widgets can perform more significant computation or may require significant user input, such as the spell checker widget or the HTML-rendering widget.</para>
<para>In KDE, widgets are implemented using C++ classes. Usually there is a one-to-one widget-to-class correspondence. For example, a pushbutton is implemented by <literal>QPushButton</literal>. All widgets are ultimately derived from the <literal>QWidget</literal> base class.<indexterm><primary>widgets</primary><secondary>defined</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>defined</tertiary></indexterm></para>
<section id="ch04lev2sec1">
<title>Understanding the <literal>QWidget</literal> Base Class</title>
<para><literal>QWidget</literal> <indexterm><primary>widgets</primary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary></indexterm><indexterm><primary>QWidget class</primary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary></indexterm>handles window system events, manages generic widget attributes, knows about its parent and children, and handles functions unique to a top-level widget (if it should be one). Window system events include geometry changes and user input. The widget is clipped by its parent's borders and by the children that lay on top of it. Top-level widgets have no parent. They lie in a window on the desktop and have window borders and decorations drawn by the window manager.</para>
<section id="ch04lev3sec1">
<title>System Events</title>
<para>Window <indexterm><primary>widgets</primary><secondary>event handlers</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary></indexterm><indexterm><primary>system events</primary><secondary>handling</secondary><see>event handling</see></indexterm>system events tell the widget when it needs to repaint, reposition, or resize itself, when mouse clicks or keystrokes have been directed toward that widget, when the widget receives or loses the focus, and so on. <literal>QWidget</literal> handles the events by calling a virtual method for each event. Each method gets passed, as an argument, a class containing information about the event. To handle the event, the corresponding method must be reimplemented in the subclass of <literal>QWidget</literal>.</para>
<para>A very important system event is the paint event. In response to this event, a widget draws (or <quote>paints</quote>) itself. It is sent to the widget every time the widget needs to be displayed or redisplayed. For example, the event is sent when the widget is first created, when it is made visible after being hidden, or when it is being uncovered after having been fully or partially obscured. The paint event is discussed in detail in the next section, and techniques for repainting efficiently are discussed in <link linkend="ch09">Chapter 9, <quote>Constructing a Responsive User Interface.</quote></link><indexterm><primary>widgets</primary><secondary>event handlers</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary></indexterm></para>
<para>The following is a list of the (protected, virtual) <literal>QWidget</literal> event handlers and corresponding events.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void event (QEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>event()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>event()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>event()</tertiary></indexterm><indexterm><primary>event() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>This is the main event handler. This method dispatches the events to their specialized event handlers. Normally, you do not need to reimplement this method. The argument tells the type of event.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mousePressEvent (QMouseEvent * )<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>mousePressEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>mousePressEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mousePressEvent()</tertiary></indexterm><indexterm><primary>mousePressEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when one of the mouse buttons is pressed down with the mouse cursor inside this widget. The argument tells which button was pressed, whether a modifier key (Ctrl, Alt, or Shift) was pressed in combination with it, and where the cursor was when the button was pressed.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mouseReleaseEvent (QMouseEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>mouseReleaseEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>mouseReleaseEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mouseReleaseEvent()</tertiary></indexterm><indexterm><primary>mouseReleaseEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when one of the mouse buttons is released with the mouse cursor inside this widget. (See <literal>mousePressEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mouseDoubleClickEvent (QMouseEvent * )<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>mouseDoubleClickEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>mouseDoubleClickEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mouseDoubleClickEvent()</tertiary></indexterm><indexterm><primary>mouseDoubleClickEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when the user double-clicks on the widget. (See <literal>mousePressEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mouseMoveEvent (QMouseEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>mouseMoveEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>mouseMoveEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mouseMoveEvent()</tertiary></indexterm><indexterm><primary>mouseMoveEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when the user moves the mouse with the cursor over the widget. This event is generated only when a button is held down, unless you turn on mouse tracking with <literal>QWidget::setMouseTracking (true)</literal>. (See <literal>mousePressEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void wheelEvent (QWheelEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>wheelEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>wheelEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>wheelEvent()</tertiary></indexterm><indexterm><primary>wheelEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when the user moves the mouse wheel (if there is one) and this widget has the focus. The argument tells how far and in which direction the wheel has been rotated. This event can be ignored by calling <literal>QWheelEvent::ignore()</literal> if it is not processed. In this case, the event gets passed to the parent widget for processing.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void keyPressEvent (QKeyEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>keyPressEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>keyPressEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>keyPressEvent()</tertiary></indexterm><indexterm><primary>keyPressEvent() event handler</primary><secondary>widgets</secondary></indexterm>
</programlisting>
</informalexample>
<para>Gets called when a key is pressed and this widget has the focus. The argument contains a code telling which key was pressed and whether a modifier key (Ctrl, Alt, or Shift) was being held down. If you have turned on key compression with <literal>QWidget::setKeyCompression (true)</literal>, the argument may contain a text string representing all the keys that were pressed since the last time you received this event.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void keyReleaseEvent (QKeyEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>keyReleaseEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>keyReleaseEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>keyReleaseEvent()</tertiary></indexterm><indexterm><primary>keyReleaseEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when a key has been released and this widget has the focus.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void focusInEvent (QFocusEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>focusInEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>focusInEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>focusInEvent()</tertiary></indexterm><indexterm><primary>focusInEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when this widget receives the focus. If this widget is willing to accept the focus, the default implementation calls <literal>QWidget::repaint()</literal> to redraw the widget with a <emphasis>focused</emphasis> look.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void focusOutEvent (QFocusEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>focusOutEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>focusOutEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>focusOutEvent()</tertiary></indexterm><indexterm><primary>focusOutEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when this widget loses the focus. If this widget is willing to accept the focus, the default implementation calls <literal>QWidget::repaint()</literal> to redraw the widget with an <emphasis>unfocused</emphasis> look.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void enterEvent (QEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>enterEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>enterEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>enterEvent()</tertiary></indexterm><indexterm><primary>enterEvent() event handler</primary><secondary>widgets</secondary></indexterm>
</programlisting>
</informalexample>
<para>Gets called when the mouse cursor enters the widget.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void leaveEvent (QEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>leaveEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>leaveEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>leaveEvent()</tertiary></indexterm><indexterm><primary>leaveEvent() event handler</primary><secondary>widgets</secondary></indexterm>
</programlisting>
</informalexample>
<para>Gets called when the mouse cursor leaves the widget.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void paintEvent (QPaintEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>paintEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>paintEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>paintEvent()</tertiary></indexterm><indexterm><primary>paintEvent() event handler</primary><secondary>widgets</secondary></indexterm>
</programlisting>
</informalexample>
<para>Gets called when the widget needs to be repainted, such as when it is first created or uncovered after being totally or partially obscured by another window. The argument tells which part of the widget needs to be repainted.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void moveEvent (QMoveEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>moveEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>moveEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>moveEvent()</tertiary></indexterm><indexterm><primary>moveEvent() event handler</primary><secondary>widgets</secondary></indexterm>
</programlisting>
</informalexample>
<para>Gets called when the widget has been moved relative to its parent. The argument tells the new and old positions.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void resizeEvent (QResizeEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>resizeEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>resizeEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>resizeEvent()</tertiary></indexterm><indexterm><primary>resizeEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when the widget has been resized. The argument tells the new and old sizes.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void closeEvent (QCloseEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>closeEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>closeEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>closeEvent()</tertiary></indexterm><indexterm><primary>closeEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>For a top-level widget, this gets called when the user tries to close the window (using the close button on the window frame, for example). For other widgets, this gets called when the application calls the <literal>QWidget::close()</literal> method. In a Qt (non-KDE) application, this would be a good place to ask, <quote>Are you sure?</quote> KDE applications should use <literal>KTMainWindow::queryClose()</literal> for this purpose. You can accept or ignore the close event by setting a flag in the <literal>QCloseEvent</literal> argument.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void dragEnterEvent (QDragEnterEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>dragEnterEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>dragEnterEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>dragEnterEvent()</tertiary></indexterm><indexterm><primary>dragEnterEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when a user is dragging data and the mouse cursor first enters this widget. The argument tells where the mouse cursor is, what kind of data is being dragged, and what the data is.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void dragMoveEvent (QDragMoveEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>dragMoveEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>dragMoveEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>dragMoveEvent()</tertiary></indexterm><indexterm><primary>dragMoveEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when a user drags data over this widget. (See <literal>dragEnterEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void dragLeaveEvent (QDragLeaveEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>dragLeaveEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>dragLeaveEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>dragLeaveEvent()</tertiary></indexterm><indexterm><primary>dragLeaveEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when a user is dragging data and the mouse cursor leaves this widget. (See <literal>dragEnterEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void dropEvent (QDropEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>dropEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>dropEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>dropEvent()</tertiary></indexterm><indexterm><primary>dropEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when a user drops (in a drag-and-drop operation) data onto your widget. (See <literal>dragEnterEvent()</literal> for a description of the argument.)</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void showEvent (QShowEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>showEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>showEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>showEvent()</tertiary></indexterm><indexterm><primary>showEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called when the widget is first created or when the window in which it lies is deiconified. The argument tells whether the show event originated inside the application or outside the application (for example, the user clicked the deiconify button on the taskbar).</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void hideEvent (QHideEvent *)<indexterm><primary>widgets</primary><secondary>event handlers</secondary><tertiary>hideEvent()</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>event handlers</secondary><tertiary>showEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>event handlers</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>showEvent()</tertiary></indexterm><indexterm><primary>showEvent() event handler</primary><secondary>widgets</secondary></indexterm></programlisting>
</informalexample>
<para>Gets called right after the widget has been hidden. The argument tells whether the show event originated inside the application or outside the application (for example, the user clicked the iconify button on the window).</para>
</section>
</section>
<section id="ch04lev2sec2">
<title>Widget Attributes</title>
<para><literal>QWidget</literal><indexterm><primary>widgets</primary><secondary>attributes</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>attributes</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>attributes</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>attributes</tertiary></indexterm><indexterm><primary>attributes</primary><secondary>widget attributes</secondary></indexterm> keeps track of various properties that may be of use to it or to subclasses. It holds a <literal>Qfont</literal>, which describes a font for the widget. The font is not used by <literal>QWidget</literal> directly, but by subclasses. A <literal>QCursor</literal> is kept in <literal>QWidget</literal> and is drawn as the mouse cursor whenever the cursor passes over the widget. You can also access the position, size, colors, and other widget attributes via the <literal>QWidget</literal> public interface.</para>
<para><literal>QWidget</literal> also holds a pointer to a <literal>QStyle</literal> object. This object describes many common look-and-feel characteristics of Qt widgets, as discussed in <link linkend="ch03">Chapter 3, <quote>The Qt Toolkit.</quote></link><indexterm><primary>widgets</primary><secondary>attributes</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>attributes</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>attributes</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>attributes</tertiary></indexterm><indexterm><primary>attributes</primary><secondary>widget attributes</secondary></indexterm></para>
</section>
<section id="ch04lev2sec3">
<title>Signals and Slots</title>
<para><literal>QWidget</literal> <indexterm><primary>widgets</primary><secondary>signals</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>signals</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>signals</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>signals</tertiary></indexterm><indexterm><primary>signals (widgets)</primary></indexterm>is a subclass of <literal>QObject</literal>, therefore it may make use of signals and slots. Widgets use signals to communicate user interaction and/or changes in their state. A pushbutton, for example, might emit a <literal>clicked()</literal> signal to indicate that the user has clicked the button. A check box might emit a <literal>checked()</literal> signal to indicate that it has just been put into the checked state either by direct user interaction or by a call from another part of the application.</para>
<para>Slots<indexterm><primary>widgets</primary><secondary>slots</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>slots</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>slots</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>slots</tertiary></indexterm><indexterm><primary>slots (widgets)</primary></indexterm> are used to change the widget's state. This way, a widget can be easily configured to react to events that do not directly affect it. Signals from other widgets (or more generally, other subclasses of <literal>QObject</literal>) can be connected to a widget's slots to affect its state. Imagine an FM radio application: You connect the <literal>clicked()</literal> signals of a set of radio buttons to a station name display so that the display reflects the station chosen by the user, even though the user didn't interact directly with the display.</para>
</section>
<section id="ch04lev2sec4">
<title>Sample Widget Class Declaration</title>
<para>A <indexterm><primary>widgets</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KPushButton example</tertiary></indexterm>sample widget header file containing its public interface is shown in <link linkend="ch04list01">Listing 4.1</link>.</para>
<example role="codelisting" label="4.1" id="ch04list01">
<title>kpushbutton.h: Class Declaration for a KDE Widget<indexterm><primary>listings</primary><secondary>KPushButton class declaration</secondary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qwidget.h>
2:
3: /**
4:  * KPushButton
5:  * A sample widget header file. This widget would
6:  *  implement a standard pushbutton.
7:  **/
8:
9: class KPushButton : public QWidget
10: {
11:  Q_OBJECT
12:
13:  public:
14:   /**
15:    * Create the pushbutton.
16:    **/
17:   KPushButton (QWidget *parent, const char *name=0);
18:
19:   /**
20:    * Set the text to be drawn on the button.
21:    **/
22:   void text (QString _text);
23:
24:   /**
25:    * Get the text being drawn on the button.
26:    **/
27:   QString text () const;
28:
29:  signals:
30:   /**
31:    * Button was clicked by the user.
32:    **/
33:   void clicked ();
34:
35:  slots:
36:   /**
37:    * Animate a button press.
38:    **/
39:   void animate ();
40:
41:  private:
42:   QString theText;
43:
44: }<indexterm><primary>widgets</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KPushButton example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KPushButton class declaration</secondary></indexterm></programlisting>
</example>
<para><link linkend="ch04list01">Listing 4.1</link> shows kpushbutton.h, a class declaration for a fictitious class called <literal>KPushButton</literal>. Included in the declaration are important method types and class documentation.</para>
<para><literal>KPushButton</literal> is a declared as a subclass of <literal>QWidget</literal> (line 9). The constructor (line 17) takes a pointer to a <literal>QWidget</literal> as an argument that specifies the parent widget. This, along with the class name, is passed to <literal>QWidget</literal>. The name is used only internally, and thus, the often-used value of <literal>0</literal> is made the default.</para>
<para>Methods are provided to get and set the configurable UI parameters (in this case, just the text; see lines 19-27). In the standard style of KDE 2.0 and Qt 2.0, the same method name is used for getting and setting a parameter. The function overloading feature of C++ allows this to be done in most cases. (It would fail if both methods required the same arguments in the same order!)</para>
<para>The widget emits a signal (declared on line 33) when the button is clicked, as discussed previously, and accepts, via a slot (declared on line 39), a command to animate the clicking of the button.<indexterm><primary>widgets</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>sample class declaration</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>sample class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KPushButton example</tertiary></indexterm></para>
</section>
<section id="ch04lev2sec5">
<title>Documentation</title>
<para>The<indexterm><primary>widgets</primary><secondary>documentation</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>documentation</tertiary></indexterm><indexterm><primary>QWidget class</primary><secondary>documentation</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>documentation</tertiary></indexterm><indexterm><primary>documentation</primary><secondary>widgets</secondary></indexterm> class in <link linkend="ch04list01">Listing 4.1</link> is documented in the <literal>kdoc</literal> style introduced in <link linkend="ch02">Chapter 2, <quote>A Simple KDE Application.</quote></link> It is discussed in detail in <link linkend="ch15">Chapter 15, <quote>Creating Documentation.</quote></link> You should be familiarizing yourself with the basic form of the documentation: The documentation appears in comments that look like <literal>/** &hellip; **/</literal>. You should also get used to the idea of documenting your classes, if you are not already, because it is such an important part of writing code for a multiprogrammer project.</para>
</section>
</section>
<section id="ch04lev1sec2">
<title>Painting Widgets</title>
<para>Although<indexterm><primary>widgets</primary><secondary>painting</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>QPainter class</primary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary></indexterm> visible changes to the widget can happen at various times during the life of your application, you should paint only during a <literal>paintEvent()</literal>. The drawing you do in <literal>paintEvent()</literal> is done with the <literal>QPainter</literal> class. It offers pixel addressing, drawing primitives, text drawing and other, more advanced functions. Widget drawing needs to be done efficiently to provide a smooth, understandable GUI, and mechanisms are provided by Qt for doing so.</para>
<section id="ch04lev2sec6">
<title>When Painting Occurs</title>
<para>The<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>paintEvent() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>QPainter class</primary><secondary>methods</secondary><tertiary>paintEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>methods</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>paintEvent() method</tertiary></indexterm><indexterm><primary>paintEvent() method</primary></indexterm><indexterm><primary>methods</primary><secondary>paintEvent()</secondary></indexterm> <literal>paintEvent()</literal> method is called automatically when</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Your widget is shown for the first time.</para></listitem>
<listitem><para>After a window has been moved to reveal some part (or all) of the widget.</para></listitem>
<listitem><para>The window in which the widget lies is restored after being minimized.</para></listitem>
<listitem><para>The window in which the widget lies is resized.</para></listitem>
<listitem><para>The user switches from another desktop to the desktop on which the widget's window lies.</para></listitem></itemizedlist>
<para>You<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>invoking paint events</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>invoking paint events</tertiary></indexterm><indexterm><primary>invoking</primary><secondary>paint events</secondary></indexterm><indexterm><primary>QPainter class</primary><secondary>methods</secondary><tertiary>update()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>methods</tertiary></indexterm><indexterm><primary>update() method</primary><secondary>QPainter class</secondary></indexterm><indexterm><primary>methods</primary><secondary>update()</secondary><tertiary>QPainter class</tertiary></indexterm> can generate paint events manually by calling <literal>QWidget::update()</literal>. <literal>QWidget::update()</literal> erases the widget before generating the paint event. You can pass arguments to <literal>update()</literal>, which can restrict painting only to areas (rectangles, in particular) that need it. The two equivalent forms of the method are <literal>QWidget::update (int x, int y, int width, int height)</literal> and <literal>QWidget::update (QRect rectangle)</literal>, where <literal>x</literal> and <literal>y</literal> give the upper-left corner of the rectangle, and <literal>width</literal> and <literal>height</literal> are obvious. Because <literal>update()</literal> places a paint event into the event queue, no painting occurs until the current method exits and control returns to the event handler. This is a good thing because other events may be waiting there to be processed, and events need to be processed in a timely manner for the GUI to operate smoothly.</para>
<para>You can also invoke painting of the widget by calling <literal>QWidget::repaint (int x, int y, int width, int height, bool erase)</literal> (or one of several convenience-method forms), where all the arguments mean the same as in the case of the <literal>update()</literal> method, and <literal>erase</literal> tells repaint whether to erase the rectangle before painting it. <literal>repaint()</literal> calls <literal>paintEvent()</literal> directly. It does not place a paint event into the event queue, so use this method with care. If you try to call <literal>repaint()</literal> repeatedly from a simple loop to create an animation, for example, the animation will be drawn, but the rest of your user interface will be unresponsive because the events corresponding to mouse button clicks, keyboard presses, and so on will be waiting in the queue. Even if you are not performing a task as potentially time-consuming as animation, it is generally better to use <literal>update()</literal> to help keep your GUI alive.</para>
<para>If you paint something on your widget outside the <literal>paintEvent()</literal>, you still need to include the logic and commands necessary to paint that same thing in <literal>paintEvent()</literal>. Otherwise, the painting you did would disappear the next time the widget is updated.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>paintEvent() method</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>QPainter class</primary><secondary>methods</secondary><tertiary>paintEvent()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>methods</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>paintEvent() method</tertiary></indexterm><indexterm><primary>paintEvent() method</primary></indexterm><indexterm><primary>methods</primary><secondary>paintEvent()</secondary></indexterm></para>
</section>
<section id="ch04lev2sec7">
<title>Repainting Efficiently</title>
<para>I <indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>repainting</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>repainting</tertiary></indexterm><indexterm><primary>repainting</primary><secondary>widgets</secondary></indexterm><indexterm><primary>QPainter class</primary><secondary>methods</secondary><tertiary>repaint()</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>methods</tertiary></indexterm><indexterm><primary>repaint() method</primary><secondary>QPainter class</secondary></indexterm><indexterm><primary>methods</primary><secondary>repaint()</secondary><tertiary>QPainter class</tertiary></indexterm>mentioned earlier in this chapter that <literal>update()</literal> and <literal>repaint()</literal> may take arguments describing the rectangle that needs to be updated. The description of this rectangle is passed to <literal>paintEvent()</literal> through the <literal>QPaintEvent</literal> class, which is the argument to <literal>paintEvent()</literal>.</para>
<para>For the rectangle information to be useful, you must specifically take advantage of it in your <literal>paintEvent()</literal>. Unless the painting you do will always be simple and quick, you should take the time to repaint only the rectangle that is requested in the <literal>QPaintEvent</literal>. There are ways to improve upon this for more difficult repainting tasks, which will be covered in <link linkend="ch09">Chapter 9</link>.</para>
</section>
<section id="ch04lev2sec8">
<title>Painting Your Widget with QPainter</title>
<para><literal>QPainter</literal> is responsible for all the drawing you do with Qt. It is used to draw on widgets and offscreen buffers (pixmaps) and to generate Postscript output for printing. Specifically, <literal>QPainter</literal> draws on one of the objects derived from <literal>QPaintDevice</literal>: <literal>QWidget</literal>, <literal>QPixmap</literal>, <literal>QPrinter</literal>, and <literal>QPicture</literal>.</para>
</section>
<section id="ch04lev2sec9">
<title>Recording Drawing Commands with QPicture</title>
<para><literal>QPicture</literal> <indexterm><primary>widgets</primary><secondary>drawing commands, recording</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>drawing commands, recording</tertiary></indexterm><indexterm><primary>drawing commands</primary><secondary>recording</secondary><tertiary>QPicture class</tertiary></indexterm><indexterm><primary>QPicture class</primary><secondary>drawing commands, recording</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPicture class</secondary><tertiary>drawing commands, recording</tertiary></indexterm><indexterm><primary>recording</primary><secondary>drawing commands</secondary><tertiary>QPicture class</tertiary></indexterm>is used for recording drawing commands. The commands can then be <quote>played back</quote> onto another paint device (a widget, a pixmap, or a printer). To make printing easy, you could, in your reimplementation of <literal>paintEvent()</literal>, record all your drawing commands in a <literal>QPicture</literal>, and then play them back onto the widget. With the drawing commands still saved in <literal>QPicture</literal>, you could respond to a print command by replaying the <literal>QPicture</literal> onto a <literal>QPrinter</literal>. This is useful only in the simplest cases because</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Often, the printer output will not be the same as the screen output (consider a typical text editor, for example).</para></listitem>
<listitem><para>For complex enough output, the extra time spent recording and replaying in <literal>paintEvent()</literal> will incur an unacceptable performance hit (which might be the case with an image-manipulation program).<indexterm><primary>widgets</primary><secondary>drawing commands, recording</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>drawing commands, recording</tertiary></indexterm><indexterm><primary>drawing commands</primary><secondary>recording</secondary><tertiary>QPicture class</tertiary></indexterm><indexterm><primary>QPicture class</primary><secondary>drawing commands, recording</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPicture class</secondary><tertiary>drawing commands, recording</tertiary></indexterm><indexterm><primary>recording</primary><secondary>drawing commands</secondary><tertiary>QPicture class</tertiary></indexterm></para></listitem></itemizedlist>
</section>
<section id="ch04lev2sec10">
<title>A Simple Widget</title>
<para>Listings 4.2&ndash;4.4 give the code for a simple widget called <literal>KXOSquare</literal>. This widget draws an <literal>X</literal> or an <literal>O</literal> inside a square (see <link linkend="ch04fig01">Figure 4.1</link>).<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary></indexterm></para>
<para>The first time this widget paints itself, it draws a black box around at its border (the box is drawn just inside the widget's borders, actually). When you click the widget with the left mouse button, it draws a blue <literal>X</literal> inside. When you click the widget with the right mouse button, it draws a red <literal>O</literal>.</para>
<para>Let's take a look at the class declaration. In <link linkend="ch04list02">Listing 4.2</link> the widget is, as all widgets are, derived from the class <literal>QWidget</literal>. The state of the widget is described by one of three <literal>enum</literal> values: <literal>None</literal> (the initial state), <literal>X</literal>, or <literal>O</literal>. The widget paints itself to reflect its state in the reimplemented method <literal>paintEvent()</literal>. The state of the widget may be changed by calling the method <literal>newState()</literal>. This method has been declared as a slot so that the widget may respond to signals in a convenient way to change a widget's state. The widget emits the signal <literal>changeRequest()</literal> whenever the user clicks the square. It is up to the programmer using this class to use the signal appropriately. In this example, the function <literal>main()</literal> does the simplest thing and connects the signal to the <literal>newState()</literal> slot.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class declaration</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm></para>
<figure label="4.1" id="ch04fig01">
<title>KXOSquare draws a blue <literal>X</literal> or a red <literal>O</literal> in response to mouse clicks.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig01.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="4.2" id="ch04list02">
<title>kxosquare.cpp is the Class Declaration for <literal>KXOSquare</literal>, a Widget that Draws an <literal>X</literal> or an <literal>O</literal> in a Square<indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class declaration</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #ifndef __KXOSQUARE_H__
2: #define __KXOSQUARE_H__
3:
4:
5: #include &lt;qwidget.h>
6:
7:
8: /**
9:  * KXOSquare
10:  * Draws a square in one of three states: empty, with an X inside,
11:  *  or with an O inside.
12:  **/
13: class KXOSquare : public QWidget
14: {
15:  Q_OBJECT
16:
17:  public:
18:   enum State {None=0, X=1, O=2};
19: <indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class declaration</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm>
20:   /**
21:    * Create the widget.
22:    **/
23:   KXOSquare (QWidget *parent, const char *name=0);
24:
25:   public slots:
26:   /**
27:    * Change the state of the widget to @p state.
28:    **/
29:     void newState (State state);
30:
31:  signals:
32:   /**
33:    * The user has requested that the state be changed to @p state
34:    *  by clicking on the square.
35:    **/
36:     void changeRequest (State state);
37:
38:  protected:
39:     /**
40:      * Draw the widget.
41:      **/
42:     void paintEvent (QPaintEvent *);
43:
44:     /**
45:      * Process mouse clicks.
46:      **/
47:     void mousePressEvent (QMouseEvent *);
48:
49:  private:
50:   State thestate;
51: };
52:
53: #endif<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class declaration</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm></programlisting>
</example>
<note role="normal">
<para>The executable is named <literal>kxosquaretest</literal> because this is a common way to indicate that the application exists only to test or demonstrate a widget and is not a full-fledged KDE application. I will use this form throughout the book.</para>
</note>
<para><link linkend="ch04list03">Listing 4.3</link> shows that class definition for the <literal>KXOSquare</literal> widget.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class definition</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class definition</tertiary></indexterm></para>
<example role="codelisting" label="4.3" id="ch04list03">
<title>kxosquare.cpp: Class Definition for the <literal>KXOSquare</literal> Widget<indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class definition</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qpainter.h>
2:
3: #include "kxosquare.moc"
4:
5: KXOSquare::KXOSquare (QWidget *parent, const char *name=0) :
6:   QWidget (parent, name)
7: {
8:   thestate = None;
9: }
10:
11: void
12: KXOSquare::paintEvent (QPaintEvent *)
13: {
14:   QPainter qpainter (this);
15:
16:   qpainter.drawRect (rect());
17:
18:   switch (thestate)
19:     {
20:     case X:
21:       qpainter.setPen (QPen (Qt::blue, 3));
22:       qpainter.drawLine (rect().x(), rect().y(),
23:           rect().x()+rect().width(), rect().y()+rect().height());
24:       qpainter.drawLine (rect().x(), rect().y()+rect().height(),
25:           rect().x()+rect().width(), rect().y());
26:       break;
27:     case O:
28:       qpainter.setPen (QPen (Qt::red, 3));
29:       qpainter.drawEllipse (rect());
30:       break;
31:     }
32: }<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class definition</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class definition</tertiary></indexterm>
33:
34: void
35: KXOSquare::mousePressEvent (QMouseEvent *mouseevent)
36: {
37:   switch (mouseevent->button())
38:     {
39:     case Qt::LeftButton:
40:       emit changeRequest (X);
41:       break;
42:     case Qt::RightButton:
43:       emit changeRequest (O);
44:       break;
46:
47: }
48:
49: void
50: KXOSquare::newState (State state)
51: {
52:   thestate = state;
53:   update();
54: }<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>kxosquare.cpp class definition</secondary></indexterm><indexterm><primary>kposquare.cpp class declaration (KXOSquare widget)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>kxosquare.cpp class definition</tertiary></indexterm></programlisting>
</example>
<para><literal>KXOSquare::paintEvent()</literal> (lines 11-32) shows a somewhat typical usage of <literal>QPainter</literal> in a <literal>paintEvent()</literal>. The <literal>QPainter</literal> object is created with <literal>this</literal> as its paint device (see line 14), meaning that it will draw on the <literal>KXOSquare</literal> widget. The argument, of type <literal>QPaintEvent *</literal>, is ignored.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>code analysis</secondary></indexterm></para>
<note role="tip">
<para>Only because the items being drawn are so simple and can be rendered very quickly do you repaint the entire widget. To save time, you should paint only the rectangle specified in the <literal>QPaintEvent</literal> argument when the widget is complex.</para>
<para>You should do all of your painting inside <literal>paintEvent()</literal>. Since paint events are sometimes generated by the windowing system and sometimes by your application, you can be sure when <literal>paintEvent()</literal> will be called. If you make changes to the state of the widget in other methods and do your painting in <literal>paintEvent()</literal> based on the current state of the widget, then your program's logic will be simpler.</para></note>
<para>Line 22 draws the <indexterm><primary>bounding boxes</primary><secondary>drawing</secondary></indexterm><indexterm><primary>drawing</primary><secondary>bounding boxes</secondary></indexterm>black bounding box using the <literal>QPainter</literal> method <literal>drawRect()</literal>. Other <literal>QPainter</literal> methods are also demonstrated:<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>code analysis</secondary></indexterm><indexterm><primary>drawRect() method</primary></indexterm><indexterm><primary>methods</primary><secondary>drawRect()</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>setPen (QPen</literal> <emphasis><literal>qpen)</literal></emphasis><indexterm><primary>setPen() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setPen()</secondary></indexterm></para>
<para>Sets the color used to draw lines and figure edges.</para></listitem>
<listitem><para><literal>drawLine (int</literal> <emphasis><literal>x1</literal></emphasis>, <literal>int</literal> <emphasis><literal>y1</literal></emphasis>, <literal>int</literal> <emphasis><literal>x2</literal></emphasis>, <literal>int</literal> <emphasis><literal>y2</literal></emphasis>) <indexterm><primary>drawLine() method</primary></indexterm><indexterm><primary>methods</primary><secondary>drawLine()</secondary></indexterm></para>
<para>Draws a line from the point <literal>(</literal><emphasis><literal>x1</literal></emphasis>, <emphasis><literal>y1</literal></emphasis><literal>)</literal> to the point <literal>(</literal><emphasis><literal>x2</literal></emphasis>, <emphasis><literal>y2</literal></emphasis><literal>)</literal>. <indexterm><primary>lines</primary><secondary>drawing</secondary></indexterm><indexterm><primary>drawing</primary><secondary>lines</secondary></indexterm></para></listitem>
<listitem><para><literal>drawEllipse (QRect</literal> <emphasis><literal>rect</literal></emphasis><literal>)</literal> <indexterm><primary>drawEllipse() method</primary></indexterm><indexterm><primary>methods</primary><secondary>drawEllipse()</secondary></indexterm></para>
<para>Draws an ellipse that just fits inside the rectangle, <emphasis><literal>rect</literal></emphasis> (that is, the ellipse is tangent to all four sides of the rectangle). <indexterm><primary>ellipses</primary><secondary>drawing</secondary></indexterm><indexterm><primary>drawing</primary><secondary>ellipses</secondary></indexterm></para></listitem></itemizedlist>
<para>The first <literal>QPen</literal>, defined by <literal>QPen (Qt::blue, 3)</literal> in line 21, is blue with a width of 3 pixels. The other <literal>QPen</literal>, defined in line 28, is red with a width of 3 pixels.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>code analysis</secondary></indexterm></para>
<para>The next listing, <link linkend="ch04list04">Listing 4.4</link>, presents a short <literal>main()</literal> function that creates and shows the widget. You can compile the whole program with the command</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++  kxosquare.cpp main.cpp -I$KDEDIR/include</emphasis>

       <emphasis role="strong">I/usr/include/qt -L$KDEDIR/lib -lkdecore -lkdeui -o kxosquaretest</emphasis>
</programlisting>
</informalexample>
<para>The option <literal>-o kxosuaretest</literal> tells <literal>g++</literal> to create an executable with name <literal>kxosquaretest</literal>.<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>testing</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KXOSquare widget</tertiary></indexterm></para>
<example role="codelisting" label="4.4" id="ch04list04">
<title>main.cpp Contains a <literal>main()</literal> Function that Can Be Used to Test the Widget <literal>KXOSquare</literal><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>main() method</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;kapp.h>
2:
3: #include "kxosquare.h"
4:
5: int
6: main (int argc, char *argv[])
7: {
8:   KApplication kapplication (argc, argv, "kxosquaretest");
9:   KXOSquare *kxosquare = new KXOSquare (0);
10:
11:   kapplication.setMainWidget (kxosquare);
12:   kxosquare->connect ( kxosquare, SIGNAL (changeRequest (State)),
13:                SLOT (newState (State)) );
14:
15:   kxosquare->show();
16:   return kapplication.exec();
17: }<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>testing</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KXOSquare widget</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KXOSquare widget</secondary><tertiary>main() method</tertiary></indexterm></programlisting>
</example>
<para>The signal <literal>changeRequest()</literal> takes a variable of type <literal>KXOSquare *</literal> as its second argument because, as you will see next, this provides added flexibility. Notice, however, that in <literal>main()</literal>, line 11 of main.cpp, I call</para>
<informalexample>
<programlisting linenumbering="unnumbered">
kxosquare.connect ( kxosquare,
                      SIGNAL (changeRequest (KXOSquare::State, KXOSquare *)),
                      SLOT (newState (KXOSquare::State)) );</programlisting>
</informalexample>
<para>The signal and slot don't have the same arguments. In this case that's just fine. It is acceptable for the slot to have fewer arguments than the signal as long as the arguments that are retained match. The following forms are not acceptable:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
  connect ( pwidget1, SIGNAL (<emphasis>mysignal</emphasis> <emphasis>(int, char)</emphasis>),
            pwidget2, SLOT (<emphasis>myslot (char)</emphasis>) );

  connect ( pwidget1, SIGNAL (<emphasis>mysignal (int, char)</emphasis>),
            pwidget2, SLOT (<emphasis>myslot (int, char, char)</emphasis>) );
</programlisting>
</informalexample>
<para>The following are acceptable:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
  connect ( pwidget1, SIGNAL (<emphasis>mysignal (int, char)</emphasis>),
            pwidget2, SLOT (<emphasis>myslot (int, char)</emphasis>) );

  connect ( pwidget1, SIGNAL (<emphasis>mysignal (int, char)</emphasis>),
            pwidget2, SLOT (<emphasis>myslot (int)</emphasis>) );<indexterm><primary>widgets</primary><secondary>painting</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>painting</tertiary></indexterm><indexterm><primary>painting</primary><secondary>widgets</secondary><tertiary>KXOSquare example</tertiary></indexterm><indexterm><primary>KXOSquare widget (painting example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>testing</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KXOSquare widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KXOSquare widget</tertiary></indexterm></programlisting>
</informalexample>
</section>
</section>
<section id="ch04lev1sec3">
<title>Using Child Widgets</title>
<para>You <indexterm><primary>widgets</primary><secondary>child widgets</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary></indexterm>should use the KDE and Qt widgets provided in the respective libraries as children of your custom widgets wherever they would be useful and appropriate. By doing so, you save on development time and reduce the overall memory footprint of your application. If the user is running your application under KDE (or is running another KDE-based application), your application will be sharing the KDE and Qt libraries with the programs already using them. The code you write from scratch is not shared and thus increases the overall memory use of your application + KDE.</para>
<para>You already saw in <link linkend="ch02">Chapter 2</link> how child widgets are used by <literal>KTMainWindow</literal>. The menubar, toolbar, status line, and content area are all children of <literal>KTMainWindow</literal>.</para>
<para>Now you will design a simple widget, called <literal>KChildren</literal>, that creates children and connects them to each other using the signal/slot mechanism to deliver a functioning, custom widget. All this widget's functionality, therefore, comes from its child widgets! The widget is shown in <link linkend="ch04fig02">Figure 4.2</link>, and its code is given in Listings 4.5&ndash;4.7.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary></indexterm></para>
<figure label="4.2" id="ch04fig02">
<title>The <literal>KChildren</literal> widget shows how to use child widgets to easily create custom widgets.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig02.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="4.5" id="ch04list05">
<title>kchildren.h Contains the Class Declaration for <literal>KChildren</literal>, a Custom Widget<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>kchildren.h class declaration</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>kchildren.h class declaration</secondary></indexterm><indexterm><primary>kchildren.h class declaration (KChildren widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>kchildren.h class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KChildren example</tertiary></indexterm></title>
<programlisting linenumbering="unnumbered">
#ifndef __KCHILDREN_H__
#define __KCHILDREN_H__

/**
 * KChildren
 * Create and connect some child widgets.
 **/

#include &lt;qwidget.h>

class KChildren : public QWidget
{
 public:
  KChildren (QWidget *parent, const char *name=0);
};

#endif<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>kchildren.h class declaration</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>kchildren.h class declaration</secondary></indexterm><indexterm><primary>kchildren.h class declaration (KChildren widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>kchildren.h class declaration</tertiary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KChildren example</tertiary></indexterm></programlisting>
</example>
<para>This class declaration (<link linkend="ch04list05">Listing 4.5</link>) is perhaps the simplest you could imagine for KDE widget, yet the widget is still functional.</para>
<para>The next listing, <link linkend="ch04list06">Listing 4.6</link>, shows the class definition that, in this case, consists mainly of the definition of the class constructor.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>kchildren.cpp class definition</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>kchildren.cpp class definition</secondary></indexterm><indexterm><primary>kchildren.cpp class definition (KChildren widget)</primary></indexterm><indexterm><primary>defiing</primary><secondary>widget classes</secondary><tertiary>KChildren example</tertiary></indexterm></para>
<example role="codelisting" label="4.6" id="ch04list06">
<title>kchildren.cpp is the Class Definition for <literal>KChildren</literal><indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>kchildren.cpp class definition</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qlcdnumber.h>
2: #include &lt;qslider.h>
3:
4: #include "kchildren.h"
5:
6: KChildren::KChildren (QWidget *parent, const char *name) :
7:   QWidget (parent, name)
8: {
9:
10:   QLCDNumber *qlcdnumber = new QLCDNumber (2, this);
11:   qlcdnumber->display (0);
12:   qlcdnumber->setGeometry (10, 10, 100, 150);
13:
14:   QSlider *qslider = new QSlider (Qt::Horizontal, this);
15:   qslider->setGeometry (10, 165, 100, 10);
16:
17:   connect ( qslider, SIGNAL (valueChanged (int)),
18:         qlcdnumber, SLOT (display (int)) );
19:
20: }<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>kchildren.cpp class definition</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>kchildren.cpp class definition</secondary></indexterm><indexterm><primary>kchildren.cpp class definition (KChildren widget)</primary></indexterm><indexterm><primary>defiing</primary><secondary>widget classes</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>kchildren.cpp class definition</tertiary></indexterm></programlisting>
</example>
<para>This widget creates an LCD number and slider as child widgets. The child widgets are managed by the Qt classes <literal>QLCDNumber</literal> and <literal>QSlider</literal>, respectively. In <link linkend="ch04list06">Listing 4.6</link> on line 17, the call to <literal>connect()</literal> connects the <literal>QSlider::valueChanged(int)</literal> signal to the <literal>QLCDNumber:: display(int)</literal> slot so that whenever the user moves the slider, the LCD number is updated. The actual number displayed is determined by <literal>QSlider</literal> and ranges from 0 at full left to 99 at full right.</para>
<para>In this particular simple widget all the functionality is provided by the KDE/Qt child widgets. In general, you'll have to do a little more work than simply instantiating widgets and connecting them, but the KDE/Qt widgets let you think more about the unique functionality of your application and less about the details of UI components.</para>
<para><link linkend="ch04list07">Listing 4.7</link> shows a <literal>main()</literal> function that can be used to test the function that can be used to test the <literal>KChildren</literal> widget. Following convention, this program would be compiled to an executable called <literal>kchildrentest</literal>.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KChildren widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KChildren widget</tertiary></indexterm></para>
<example role="codelisting" label="4.7" id="ch04list07">
<title>main.cpp is a <literal>main()</literal> Function Suitable for Testing the <literal>KChildren</literal> Widget<indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>main() method</tertiary></indexterm></title>
<programlisting linenumbering="unnumbered">
#include &lt;kapp.h>
#include "kchildren.h"
int
main (int argc, char *argv[])
{
  KApplication kapplication (argc, argv, "kchildrentest");
  KChildren *kchildren = new KChildren (0);
  kapplication.setMainWidget (kchildren);
  kchildren->show();
  return kapplication.exec();
}<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>KChildren example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>KChildren example</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KChildren sample widget (child widget)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KChildren widget</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KChildren widget</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KChildren widget</secondary><tertiary>main() method</tertiary></indexterm></programlisting>
</example>
<section id="ch04lev2sec11">
<title>Geometry Management</title>
<para>In this widget you do need to do a little more than create and connect the widgets, as I alluded to previously. You need to position them (relative to the main widget, <literal>KChildren</literal>) and set their size. This is called <emphasis>geometry management</emphasis>. <indexterm><primary>widgets</primary></indexterm> In <literal>KChildren</literal> the geometry management was performed by placing the widgets at fixed, hard coded positions and giving them fixed sizes. For example, line 12 of <link linkend="ch04list06">Listing 4.6</link>,</para>
<informalexample>
<programlisting linenumbering="unnumbered">
qlcdnumber->setGeometry (10, 10, 100, 150);</programlisting>
</informalexample>
<para>places the LCD number widget's upper-left corner at 10 pixels to the right and 10 pixels down from the <literal>KChildren</literal> widget's upper-left corner. The LCD number widget has a width of 100 pixels and a height of 150 pixels.</para>
<para>This is poor geometry management. Why? Try resizing the window. Notice that the child widgets are unaffected&mdash;even if you resize the window so small that the child widgets cannot be accessed (see <link linkend="ch04fig03">Figure 4.3</link>). Proper geometry management should take into account the size of the parent widget and the size requirements of the child widgets. (A widget may, for example, need to be of some minimum size before it can be drawn in a reasonably useful or recognizable way.)<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary></indexterm><indexterm><primary>geometry management (widgets)</primary></indexterm></para>
<figure label="4.3" id="ch04fig03">
<title>The <literal>KChildren</literal> widget does not adapt to different-sized windows because it uses poor geometry management.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig03.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>Qt provides two geometry managers that can take care of this task for you in most cases. They<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QBoxLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QBoxLayout manager</secondary></indexterm><indexterm><primary>QBoxLayout geometry manager</primary></indexterm> are <literal>QBoxLayout</literal> and <literal>QGridLayout</literal>. The former looks at your widgets as a horizontal or vertical string of widgets, and the latter places your widgets on a grid. <literal>QGridLayout</literal> <indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm>is the more flexible of the two, and I will show you an example using it.</para>
<note role="tip">
<para>Use a geometry manager class to organize your widgets instead of hard coding pixel values.</para>
</note>
<para>The widget <literal>KTicTacToe</literal> is presented in Listings 4.8&ndash;4.10 It creates a tic-tac-toe game board by arranging nine <literal>KXOSquare</literal> widgets in a 3&times;3 grid. See <link linkend="ch04fig04">Figure 4.4</link> for a screen shot of the widget.</para>
<para>The first listing, <link linkend="ch04list08">Listing 4.8</link>, shows the class declaration. Most of the work is done in the constructor, but you declare one slot, <literal>processClicks()</literal>, which will interpret the user's mouse clicks.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm><indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>ktictactoe.h class declaration</secondary></indexterm><indexterm><primary>ktictactoe.h class declaration (KTicTacToe widget)</primary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KTicTacToe example</tertiary></indexterm></para>
<figure label="4.4" id="ch04fig04">
<title>The <literal>KTicTacToe</literal> widget uses the KXOSquare widget nine times to create a game board.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig04.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="4.8" id="ch04list08">
<title>ktictactoe.h is the Class Declaration for the Widget <literal>KTicTacToe</literal><indexterm><primary>listings</primary><secondary>KTicTacToe widget</secondary><tertiary>ktictactoe.h class declaration</tertiary></indexterm><indexterm><primary>TicTacToe widget</primary><see>KTicTacToe widget</see></indexterm><indexterm><primary>code listings</primary><see>listings</see></indexterm><indexterm><primary>program listings</primary><see>listings</see></indexterm><indexterm><primary>source code listings</primary><see>listings</see></indexterm></title>
<programlisting linenumbering="numbered">
1: #ifndef __KTICTACTOE_H__
2: #define __KTICTACTOE_H__
3:
4: #include &lt;qarray.h>
5: #include &lt;qwidget.h>
6:
7: #include "kxosquare.h"
8:
9: /**
10:  * KTicTacToe
11:  * Draw and manage a Tic-Tac-Toe board using KXOSquare.
12:  **/
13: class KTicTacToe : public QWidget
14:{
15:  Q_OBJECT
16:
17:  public:
18:   /**
19:    * Create an empty game board.
20:    **/
21:   KTicTacToe (QWidget *parent, const char *name=0);
22:
23:
24:  protected slots:
25:    /**
26:     * Process user input.
27:     **/
28:    void processClicks (KXOSquare *, KXOSquare::State);
29:
30: };
31:
32: #endif<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm><indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>ktictactoe.h class declaration</secondary></indexterm><indexterm><primary>ktictactoe.h class declaration (KTicTacToe widget)</primary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KTicTacToe example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KTicTacToe widget</secondary><tertiary>ktictactoe.h class declaration</tertiary></indexterm></programlisting>
</example>
<para>At the top of the grid is a <literal>QLabel</literal> that displays the title <quote>Tic-Tac-Toe.</quote> The grid that you create with <literal>QGridLayout</literal> has 4 rows and 3 columns. Three rows are for the game board, and 1 extra row at the top is for the title. The title (the <literal>QLabel</literal>) spans all 3 columns.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm></para>
<para>This work is done in the constructor, given in <link linkend="ch04list09">Listing 4.9</link>.</para>
<example role="codelisting" label="4.9" id="ch04list09">
<title>ktictactoe.cpp is the Class Definition for <literal>KTicTacToe</literal><indexterm><primary>listings</primary><secondary>KTicTacToe widget</secondary><tertiary>ktictactoe.cpp class definition</tertiary></indexterm><indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>ktictactoe.cpp class definition</secondary></indexterm><indexterm><primary>ktictactoe.cpp class definition (KTicTacToe widget)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KTicTacToe example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qlayout.h>
2: #include &lt;qlabel.h>
3:
4: #include "ktictactoe.moc"
5:
6: KTicTacToe::KTicTacToe (QWidget *parent, const char *name) :
7:   QWidget (parent, name)
8: {
9:   int row, col;
10:
11:   QGridLayout *layout = new QGridLayout (this, 4, 3);
12:
13:   const int rowlabel0 = 0, rowlabel1 = 0, collabel0 = 0, collabel1 = 2,
14:     rowsquares0 = 1, rowsquares1 = 4, colsquares0 = 0, colsquares1 = 3;
15:
16:   for (row=rowsquares0; row&lt;rowsquares1; row++)
17:     for (col=colsquares0; col&lt;colsquares1; col++)
18:       {
19:     KXOSquare *kxosquare = new KXOSquare (this);
20:     layout->addWidget (kxosquare, row, col);
21:     connect ( kxosquare,
22:           SIGNAL (changeRequest (KXOSquare *, KXOSquare::State)),
23:           SLOT (processClicks (KXOSquare *, KXOSquare::State)) );
24:       }
25:
26:   QLabel *label = new QLabel ("Tic-Tac-Toe", this);
27:   label->setAlignment (Qt::AlignCenter);
28:   label->setMinimumSize (label->sizeHint());
29:   layout->addMultiCellWidget (label,
30:                   rowlabel0, rowlabel1,
31:                   collabel0, collabel1);
32: }
33:
34:
35: void
36: KTicTacToe::processClicks (KXOSquare *square, KXOSquare::State state)
37: {
38:   //In this simple example, just pass along the click to the appropriate
39:   // square.
40   square->newState (state);
41: }<indexterm><primary>listings</primary><secondary>KTicTacToe widget</secondary><tertiary>ktictactoe.cpp class definition</tertiary></indexterm><indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>ktictactoe.cpp class definition</secondary></indexterm><indexterm><primary>ktictactoe.cpp class definition (KTicTacToe widget)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KTicTacToe example</tertiary></indexterm></programlisting>
</example>
<para>The layout manager, of type <literal>QLayout</literal>, is not a widget itself. On line 19, each child widget is created with <literal>KTicTacToe</literal> as its parent.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm></para>
<para>A widget typically is added to the layout with <literal>QGridLayout::addWidget()</literal>. For example, you add a <literal>KXOSquare</literal> to the layout with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
layout->addWidget (kxosquare, row, col);</programlisting>
</informalexample>
<para>in line 20 of <link linkend="ch04list09">Listing 4.9</link>.</para>
<para>You may break the strict grid structure of your widget by using <literal>QGridLayout:: addMultiCellWidget()</literal>, as you did with <literal>QLabel</literal> (lines 29-31):</para>
<informalexample>
<programlisting linenumbering="unnumbered">
 layout->addMultiCellWidget (label, rowlabel1, rowlabel2,
                             collabel1, collabel2);</programlisting>
</informalexample>
<para>This call adds <literal>QLabel</literal> to the grid so that it spans column <literal>collabel1</literal> to column <literal>collabel2</literal>, or column 0 to column 2. Widgets can also call multiple rows. If <literal>rowlabel1</literal> and <literal>rowlabel2</literal> had different values, this call would make the <literal>QLabel</literal> span row <literal>rowlabel1</literal> to row <literal>rowlabel2</literal>.</para>
<para>Now try resizing the window. The title text moves itself so that it is always centered, as requested on line 27 of <link linkend="ch04list09">Listing 4.9</link>.</para>
<para>The squares resize themselves to fit their parent widget, which, in turn, fills the window (see <link linkend="ch04fig05">Figure 4.5</link>). If you shrink the window very small, the squares nearly disappear, but the text remains totally visible (see <link linkend="ch04fig06">Figure 4.6</link>). This is because you set the minimum size of the <literal>QLabel</literal> in line 28 of <link linkend="ch04list09">Listing 4.9</link> with<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
label->setMinimumSize (label->sizeHint());</programlisting>
</informalexample>
<para>The <literal>QSize</literal> class returned by <literal>label->sizeHint()</literal> contains the size of the rectangle needed to comfortably contain the text. You didn't set any minimum size for the squares, so they are content simply to disappear as the window is made ever smaller.</para>
<para>You have used constants (for example, <literal>rowlabel1</literal>, <literal>rowsquare1</literal>) to describe the layout of the widgets on the grid instead of hard coding the values in the calls to <literal>addWidget()</literal> and <literal>addMultiCellWidget()</literal>. This keeps the specification of the layout of the entire grid in one location, lines 13 and 14 of <link linkend="ch04list09">Listing 4.9</link>, making future changes to it easier.<indexterm><primary>widgets</primary><secondary>child widgets</secondary><tertiary>geometry management</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>child widgets</tertiary></indexterm><indexterm><primary>child widgets</primary><secondary>geometry management</secondary><tertiary>QGridLayout manager</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>QGridLayout manager</secondary></indexterm><indexterm><primary>QGridLayout geometry manager</primary></indexterm></para>
<figure label="4.5" id="ch04fig05">
<title>The <literal>KTicTacToe</literal> widget adapts to different-sized windows because it uses Qt's geometry management.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig05.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<figure label="4.6" id="ch04fig06">
<title>The geometry manager was asked not to let the text label shrink too much. No such request was made for the game board, so it nearly disappears when you shrink the window too much.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig06.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
<section id="ch04lev2sec12">
<title>Playing the Game</title>
<para>This <indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>playing the game</secondary></indexterm>is quite a simple version of Tic-Tac-Toe. The <literal>KTicTacToe</literal> widget doesn't enforce the rules and doesn't declare a winner! The slot <literal>KTicTacToe::processClicks()</literal> is the place for this type of logic. The <literal>KXOSquare::changeRequest()</literal> signal thus serves as a hook into the <literal>KXOSquare</literal> widget, allowing you to intercept the simple <quote>click ==> draw X or O</quote> logic and apply arbitrary logic to the widget's functioning. This is one way to make a widget more general and thus useful to more developers. To simplify the interface, you might add a (<literal>bool</literal>) flag to the constructor's argument list, which, when <literal>true</literal>, causes the constructor to connect the <literal>changeRequest()</literal> signal to the <literal>newState()</literal> slot. (Note: In this particular case, the arguments of the signal and slot don't match, so some intermediate slot, which called <literal>newState()</literal> in <literal>KXOSquare,</literal> is necessary.) If the flag had a default value of <literal>true</literal>, the simplest usage of <literal>KXOSquare</literal> gives the simplest behavior. More sophisticated behavior could still be achieved by sending <literal>false</literal> for the flag's value and managing the signal as you did in <literal>KTicTacToe</literal>.<indexterm><primary>KTicTacToe widget (geometry management example)</primary><secondary>playing the game</secondary></indexterm></para>
</section>
</section>
<section id="ch04lev1sec4">
<title>Handling User Input</title>
<para>Applications <indexterm><primary>widgets</primary><secondary>user input</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary></indexterm>receive user input most commonly via mouse and keyboard. You saw earlier that mouse and keyboard information is passed to a KDE/Qt application from the window system via events. The events that are important here are</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>mousePressEvent()</literal></para></listitem>
<listitem><para><literal>mouseMoveEvent()</literal></para></listitem>
<listitem><para><literal>mouseReleaseEvent()</literal></para></listitem>
<listitem><para><literal>mouseDoubleClickEvent()</literal></para></listitem>
<listitem><para><literal>keyPressEvent()</literal></para></listitem>
<listitem><para><literal>keyReleaseEvent()</literal> for processing keyboard input</para></listitem></itemizedlist>
<para><literal>KDisc</literal> (see Listings 4.10&ndash;4.12) demonstrates use of the <literal>mouseMoveEvent()</literal> and <literal>keyPressEvent()</literal>. The widget draws a disc on itself and lets the user move the disc around by dragging with the mouse or pressing one of the four arrow keys (see <link linkend="ch04fig07">Figure 4.7</link>).<indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>KDisc example</tertiary></indexterm></para>
<figure label="4.7" id="ch04fig07">
<title>The <literal>KDisc</literal> widget processes mouse-move events to let the user drag the disc around.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/04fig07.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="4.10" id="ch04list10">
<title>kdisc.h Contains the Class Declaration for the <literal>KDisc</literal> Widget<indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>ktictactoe.h class declaration</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>kdisc.h class declaration</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KDisc example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #ifndef __KDISC_H__
2: #define __KDISC_H__
3:
4: #include &lt;qwidget.h>
5:
6:
7: /**
8:  * KDisc
9:  * Lets the user move a disc around with the mouse or keyboard.
10:  **/
11: class KDisc : public QWidget
12: {
13:  public:
14:   KDisc (QWidget *parent, const char *name=0);
15:
16:    protected:
17:     /**
18:      * Disc the widget.
19:      **/
20:     void paintEvent (QPaintEvent *);
21:
22:     /**
23:      * Draw the disc under the mouse cursor.
24:      **/
25:     void mouseMoveEvent (QMouseEvent *);
26:
27:     /**
28:      * Examine the key pressed and move the disc accordingly.
29:      **/
30:     void keyPressEvent (QKeyEvent *);
31:
32:  private:
33:     QPoint discposition;
34:
35: };
36:
37: #endif<indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>ktictactoe.h class declaration</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>kdisc.h class declaration</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KDisc example</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>KDisc example</tertiary></indexterm></programlisting>
</example>
<para>The previous listing, <link linkend="ch04list10">Listing 4.10</link>, shows the class definition for the <literal>KDisc</literal> widget. You will be processing paint events to draw the disc; mouse-move events to move the disc in response to a mouse drag; and key press events to move the disc when one of the four arrow keys is pressed. See <link linkend="ch04list11">Listing 4.11</link> for the code that accomplishes these tasks. The following two sections discuss the mouse events and key events, respectively.</para>
<example role="codelisting" label="4.11" id="ch04list11">
<title>kdisc.cpp Contains the Class Definition for the <literal>KDisc</literal> Widget<indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>ktictactoe.cpp class definition</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>kdisc.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KDisc example</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>KDisc example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qpainter.h>
2:
3: #include "kdisc.h"
4:
5: KDisc::KDisc (QWidget *parent, const char *name=0) :
6:   QWidget (parent, name)
7: {
8:
9:   discposition = QPoint (0, 0);
10:   setMouseTracking (true);
11: }
12:
13: void
14: KDisc::paintEvent (QPaintEvent *)
15: {
16:   QPainter painter (this);
17:
18:   painter.setPen ( QPen (Qt::black, 3) );
19:   painter.setBrush ( QBrush (Qt::blue, Qt::Dense4Pattern) );
20:
21:   painter.drawEllipse (discposition.x(), discposition.y(),
22:                25, 25);
23: }
24:
25: void
26: KDisc::mouseMoveEvent (QMouseEvent *qmouseevent)
27: {
28: <indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>ktictactoe.cpp class definition</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>kdisc.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KDisc example</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>KDisc example</tertiary></indexterm>
29:   if (qmouseevent->state()==Qt::LeftButton)
30:     {
31:       discposition = qmouseevent->pos();
32:       update();
33:     }
34:
35: }
36:
37: void
38: KDisc::keyPressEvent (QKeyEvent *qkeyevent)
39: {
40:
41:   switch (qkeyevent->key())
42:     {
43:     case Qt::Key_Left:
44:       discposition = QPoint ( discposition.x()-10,
45:                   discposition.y() );
46:       update();
47:       break;
48:     case Qt::Key_Right:
49:       discposition = QPoint ( discposition.x()+10,
50:                   discposition.y() );
51:       update();
52:       break;
53:     case Qt::Key_Up:
54:       discposition = QPoint ( discposition.x(),
55:                   discposition.y()-10 );
56:       update();
57:       break;
58:     case Qt::Key_Down:
59:       discposition = QPoint ( discposition.x(),
60:                   discposition.y()+10 );
61:       update();
62:       break;
63:     default:
64:       qkeyevent->ignore();
65:     }
66:
67: }<indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>KDisc widget example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>ktictactoe.cpp class definition</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>kdisc.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KDisc example</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>KDisc example</tertiary></indexterm></programlisting>
</example>
<section id="ch04lev2sec13">
<title>Mouse Presses</title>
<para>In <indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>mouse clicks, handling</primary><secondary>widgets</secondary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm><literal>KXOSquare</literal> you processed a mouse click with <literal>mouseReleaseEvent()</literal>. The <literal>QMouseEvent::button()</literal> method tells which button was clicked. The reason you chose <literal>mouseReleaseEvent()</literal> and not <literal>mousePressEvent()</literal> is because you shouldn't consider a user's mouse click to be registered until the mouse button is released. This way, the user will have a chance to change his or her mind. This behavior is common practice. Try clicking pushbuttons on your screen. Notice that no action occurs until the mouse button is released.</para>
<para>In <literal>mouseMoveEvent()</literal> you test <literal>QMouseEvent::state()</literal>, not <literal>QMouseEvent::button()</literal> to check the state of the mouse. If the left button is being held down, the disc is moved so that it is centered under the mouse cursor (see line 31 of <link linkend="ch04list11">Listing 4.11</link>):</para>
<informalexample>
<programlisting linenumbering="unnumbered">
  discposition = qmouseevent->pos();</programlisting>
</informalexample>
<para>Then <literal>update()</literal> is called to clear the widget, erase the disc, and call <literal>paintEvent()</literal> to redraw the disc in its new position.</para>
<para>In <literal>KDisc::KDisc</literal> (see line 10 of <link linkend="ch04list11">Listing 4.11</link>) you call</para>
<informalexample>
<programlisting linenumbering="unnumbered">
  setMouseTracking (true);</programlisting>
</informalexample>
<para>This informs Qt that you want to receive mouse-move events. Because the mouse can move around quite a bit, this can generate lots of events. Generating and passing these events takes time; therefore, by default, they are not generated. For this widget, you need those events to make your UI function as you have designed it.<indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm><indexterm><primary>mouse clicks, handling</primary><secondary>widgets</secondary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>mouse clicks</tertiary></indexterm></para>
</section>
<section id="ch04lev2sec14">
<title>Keystrokes</title>
<para><literal>QKeyEvent::key()</literal> <indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>keystrokes, handling</primary><secondary>widgets</secondary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm>returns a code telling which key was pressed. The constants, such as <literal>Qt::Key_Left</literal>, <literal>Qt::Key_Right</literal>, and so on, are defined in qnamespace.h. (qnamespace.h is included by qwindowdefs.h, which is, in turn, included by qwidget.h. Thus it is enough to include qwidget.h if you want to process keypresses.)</para>
<para>You call <literal>QKeyEvent::ignore()</literal> when you don't process the key press. This lets Qt know to pass the keystroke on to our parent widget.</para>
<note role="normal">
<para>Don't return from a keystroke event handler without calling <literal>QKeyEvent::ignore()</literal> if you don't process the passed keystroke.</para>
</note>
<para>Next, in <link linkend="ch04list12">Listing 4.12</link>, is a <literal>main()</literal> function that you can use to create an executable that creates and shows the widget.</para>
<example role="codelisting" label="4.12" id="ch04list12">
<title>main.cpp Contains a <literal>main()</literal> Function Suitable for Testing <literal>KDisc</literal><indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KDisc</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KDisc</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;kapp.h>
2:
3: #include "kdisc.h"
4:
5: int
6: main (int argc, char *argv[])
7: {
8:   KApplication kapplication (argc, argv, "kdisctest");
9:   KDisc *kdisc = new KDisc (0);
10:
11:   kapplication.setMainWidget (kdisc);
12:
13:   kdisc->show();
14:   return kapplication.exec();
15: }<indexterm><primary>widgets</primary><secondary>user input</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>user input</tertiary></indexterm><indexterm><primary>user input</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>input (user)</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm><indexterm><primary>keystrokes, handling</primary><secondary>widgets</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDisc widget</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KDisc widget (user input example)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KDisc</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KDisc</tertiary></indexterm><indexterm><primary>event handling</primary><secondary>widgets</secondary><tertiary>keystrokes</tertiary></indexterm></programlisting>
</example>
</section>
</section>
<section id="ch04lev1sec5">
<title>Summary</title>
<para>In this chapter you looked at various aspects of widgets. You learned about event processing and the roles of signals and slots in widget design. You also saw how to paint a custom widget and manage child widgets.</para>
<para><literal>QWidget</literal> handles window system events by calling virtual methods. You reimplement these methods to process the events. Each method receives a class containing information about the event as an argument.</para>
<para>Signals are used to notify other widgets or other parts of the application that the state of the widget has changed. Slots are used to change the state of the widget. They can be connected to signals or invoked directly (because they are methods). A widget's signals and slots should be documented in the header file.</para>
<para>You should paint your widget only inside the <literal>paintEvent()</literal> method. This is easy to do if you save the state of your widget as private or protected data and paint the widget to reflect that state. You can then change the state in any other method and call <literal>update()</literal> to generate a paint event and update the widget. Drawing is done with <literal>QPainter</literal>.</para>
<para>Child widgets need to be properly placed on their parent if the parent widget is to be attractive and in the standard style. You can easily and properly place child widgets by using one of the geometry managers provided by Qt: <literal>QBoxLayout</literal> or <literal>QGridLayout</literal>.</para>
</section>
<section id="ch04lev1sec6">
<title>Exercises</title>
<para>See <link linkend="ap-c">Appendix C, <quote>Answers, for the exercise answers.</quote></link></para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch04que01"><para><link linkend="ch04ans01">Modify the method <literal>KTicTacToe::processClicks()</literal> so that the user is required to take turns between <literal>X</literal> and <literal>O</literal>.</link></para></question></qandaentry>
<qandaentry>
<question id="ch04que02"><para><link linkend="ch04ans02">Reimplement <literal>KXOSquare::sizeHint()</literal> and use this method appropriately in the constructor of <literal>KTicTacToe</literal>. Compare what happens now when you resize the window to what happened before.</link></para></question></qandaentry>
<qandaentry>
<question id="ch04que03">
<para><link linkend="ch04ans03">What's the difference between <literal>QPen</literal> and <literal>QBrush</literal>? Examine the <literal>KDisc</literal> code and consult the Qt documentation.</link></para></question></qandaentry>
<qandaentry>
<question id="ch04que04">
<para><link linkend="ch04ans04">Get to know <literal>QPainter</literal>. Construct different <literal>QPens</literal> and <literal>QBrushes</literal> in <literal>KDisc</literal>. Draw figures other than a disc.</link></para></question></qandaentry>
<qandaentry>
<question id="ch04que05">
<para><link linkend="ch04ans05">Try using <literal>mousePressEvent()</literal> instead of <literal>mouseReleaseEvent()</literal> in <literal>KDisc</literal>. Can you tell the difference? Which feels right?</link></para></question></qandaentry></qandaset>
</section>
</chapter>
