<chapter label="11" role="chapter" id="ch11">
<title>Alternative Application Types</title>
<para><emphasis>by David Sweet</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In this chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch11lev1sec1">Dialog-Based Applications</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch11lev1sec2">Single-Instance Applications</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch11lev1sec3">Panel Applets</link></emphasis></para></listitem>
</itemizedlist>
</highlights>
<para>Not every application fits neatly into the document-centric model described in <link linkend="ch02">Chapter 2, <quote>A Simple KDE Application</quote></link>, and <link linkend="ch05">Chapter 5, <quote>KDE User Interface Compliance.</quote></link> For example, short-lived, single-task applications (such as KPPP or KFind) use a dialog box for their main window. For some applications it only makes sense for one instance of an application to be running (for example, Kicker, KPPP). Still other applications, called applets, run in a small space on the panel and usually serve as status indicators or perform limited functions.</para>
<section id="ch11lev1sec1">
<title>Dialog-Based Applications</title>
<para>Short-lived,<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary></indexterm><indexterm><primary>KDialogApp</primary><secondary>(dialog-based application)</secondary></indexterm> single-task applications can be implemented in dialog boxes. Think of KFind, for example. This application searches for files on your local hard disk and then, typically, the user exits the application. A find operation is commonly included in a dialog box in document- centric applications, and so the appearance of a system-level find operation in a dialog box is not unfamiliar to the user.</para>
<para>Other utilities also use dialog boxes: KFontManager and KPPP. The motivation for writing KFontManager into a dialog is the same as that for KFind: It performs a common application function (usually implemented in a dialog box), but at the system level. KPPP is appropriately placed in a dialog box because the user interaction (in normal use) is limited. The user chooses only which connection to try and, when connected, wants to get back to work.<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary></indexterm><indexterm><primary>KDialogApp</primary><secondary>(dialog-based application)</secondary></indexterm></para>
<section id="ch11lev2sec1">
<title>Creating the Dialog-Based Application</title>
<para>Creating <indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary></indexterm><indexterm><primary>KDialogApp</primary><secondary>(dialog-based application)</secondary></indexterm>a dialog-based application is different from creating a document-centric application, but not more difficult. No standard <literal>"KdialogApplication"</literal> base class exists from which all such applications are derived (as <literal>KTMainWindow</literal> analogously provides a common base for all document-centric applications), but there are generally fewer UI elements to worry about, and thus, such a base class is not necessary. In fact, in <link linkend="ch11list01">Listings 11.1</link> and <link linkend="ch11list02">11.2</link>, you see how to derive from <literal>KDialogBase</literal> a base class dialog box and this serves you well.</para>
<para>Listings 11.1&ndash;11.3 show how to construct a dialog-based application.<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>kdialogapp.h class definition</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>kdialogapp.h class definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>kdialogapp.h class definition</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>kdialogapp.h class definition</secondary></indexterm><indexterm><primary>kdialogapp.h file (KDialogApp)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KDialogApp</tertiary></indexterm></para>
<example role="codelisting" label="11.1" id="ch11list01">
<title>kdialogapp.h: Class Declaration for <literal>KDialogApp</literal>, a Dialog-Based Application<indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>kdialogapp.h class definition</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KDIALOG_H__
 2: #define __KDIALOG_H__
 3:
 4: #include &lt;kdialogbase.h>
 5:
 6: class KDialogApp : public KDialogBase
 7: {
 8:  public:
 9:   KDialogApp (QWidget *parent = 0, const char *name = 0);
10:
11:  protected slots:
12:     /**
13:      * The Start button was pressed.
14:      **/
15:   void slotUser2(void);
16:     /**
17:      * The Quit button was pressed.
18:      **/
19:   void slotUser1(void);
20:
21: };
22:
23: #endif<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>kdialogapp.h class definition</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>kdialogapp.h class definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>kdialogapp.h class definition</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>kdialogapp.h class definition</secondary></indexterm><indexterm><primary>kdialogapp.h file (KDialogApp)</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KDialogApp</tertiary></indexterm><indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>kdialogapp.h class definition</secondary></indexterm>
</programlisting>
</example>
<para>It is necessary for the main application widget to be (ultimately) derived from <literal>QDialog</literal> because <literal>QDialog</literal> provides its own event loop for processing window system events. <literal>KDialogApp</literal> is derived from <literal>KDialogBase</literal> for simplicity, but <literal>KDialog</literal> or <literal>QDialog</literal> would work as well. <literal>KDialogBase</literal> offers virtual methods that can be overloaded (here, <literal>slotUser1()</literal>, line 19 and <literal>slotUser2()</literal>, line 15) to provide responses to button clicks.<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>kdialogapp.cpp class declaration</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>kdialogapp.cpp class declaration</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>kdialogapp.cpp class declaration</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>kdialogapp.cpp class declaration</secondary></indexterm><indexterm><primary>kdialogapp.cpp file (KDialogApp)</primary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KDialogApp</tertiary></indexterm></para>
<example role="codelisting" label="11.2" id="ch11list02">
<title>kdialogapp.cpp: Class Definition for <literal>KDialogApp<indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>kdialogapp.cpp class definition</secondary></indexterm></literal></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qlabel.h>
 2:
 3: #include &lt;kapp.h>
 4: #include &lt;kmessagebox.h>
 5:
 6: #include "kdialogapp.h"
 7:
 8: KDialogApp::KDialogApp (QWidget *parent, const char *name) :
 9:   KDialogBase (parent, name, true, "kdialogapp", User1 | User2,
10:            User2, true, "&amp;Quit", "&amp;Start")
11: {
12:   QLabel *qlabel = new QLabel ("Content area.", this);
13:   setMainWidget (qlabel);
14: }
15:
16: void
17: KDialogApp::slotUser2(void)
18: {
19:   KMessageBox::sorry (this, "No functions implemented!");
20: }
21:
22: void
23: KDialogApp::slotUser1(void)
24: {
25:   close();
26: }<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>kdialogapp.cpp class declaration</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>kdialogapp.cpp class declaration</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>kdialogapp.cpp class declaration</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>kdialogapp.cpp class declaration</secondary></indexterm><indexterm><primary>kdialogapp.cpp file (KDialogApp)</primary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KDialogApp</tertiary></indexterm><indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>kdialogapp.cpp class definition</secondary></indexterm>
</programlisting>
</example>
<para><literal>KDialogBase</literal>, as it is used here, creates a dialog box that displays a custom widget with two control buttons below it. The arguments&mdash;beyond the first two&mdash;passed to the <literal>KDialogBase</literal> constructor (line 9) configure the dialog (see <link linkend="ch08">Chapter 8, <quote>Using Dialog Boxes</quote></link>, for more information about <literal>KDialogBase</literal>). Arguments three through nine do the following:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>true</literal>&mdash;Create a modal dialog. Passing <literal>true</literal> lets you make use of <literal>QDialog</literal>'s (from which <literal>KDialogBase</literal> is derived) local event loop.</para></listitem>
<listitem><para><literal>User1 [verbar] User2</literal>&mdash;Create two user-defined buttons. The virtual methods <literal>slotUser1()</literal> and <literal>slotUser2()</literal> will be called when the buttons are clicked. The buttons are displayed right to left (see <link linkend="ch11fig01">Figure 11.1</link>).</para></listitem>
<listitem><para><literal>User2</literal>&mdash;Make the button <literal>User2</literal> the default button. If the user presses Enter, the default button is clicked.</para></listitem>
<listitem><para><literal>true</literal>&mdash;Draw a horizontal line between the content area and the control buttons.</para></listitem>
<listitem><para><literal>Quit</literal>&mdash;The text for button <literal>User1</literal>.</para></listitem>
<listitem><para><literal>Start</literal>&mdash;The text for button <literal>User2</literal>.</para></listitem>
</itemizedlist>
<figure label="11.1" id="ch11fig01">
<title>Screenshot of <literal>KDialogApp</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/11fig01.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>You place a label in the content area in lines 12 and 13. Note that the <literal>setMainWidget()</literal> method is a member of <literal>KDialogBase</literal>. You should place your dialog application's main widget in here.<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>main() method</secondary></indexterm><indexterm><primary>amin() method</primary><secondary>KDialogApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KDialogApp</tertiary></indexterm></para>
<example role="codelisting" label="11.3" id="ch11list03">
<title>main.cpp: The <literal>main()</literal> Function Needed to Start <literal>KDialogApp<indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>main() method</secondary></indexterm></literal></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kdialogapp.h"
 4:
 5: void main (int argc, char *argv[])
 6: {
 7:   KApplication *kapplication = new KApplication (argc, argv, "kdialogapp");
 8:
 9:   KDialogApp * kdialogapp = new KDialogApp;
10:   kdialogapp->exec();
11: }<indexterm><primary>KDialogApp (dialog-based application)</primary><secondary>main() method</secondary></indexterm>
</programlisting>
</example>
<para>You need to create a <literal>KApplication</literal> object to provide initialization of the Qt toolkit, but you do not need to make any calls to <literal>KApplication</literal> methods. The event loop provided by <literal>QDialog</literal> is started with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
kdialogapp->exec();
</programlisting>
</informalexample>
<para>The program exits after this call completes. <literal>kdialogapp->exec()</literal> exits when the dialog is finished, which happens when the user closes the window, presses the Quit button, or presses Esc.<indexterm><primary>dialog boxes</primary><secondary>dialog-based application (KDialogApp)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>dialog-based application (KDialogApp)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applications</primary><secondary>dialog-based (KDialogApp)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KDialogApp</primary><secondary>main() method</secondary></indexterm><indexterm><primary>amin() method</primary><secondary>KDialogApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KDialogApp</tertiary></indexterm></para>
</section>
</section>
<section id="ch11lev1sec2">
<title>Single-Instance Applications</title>
<para>Sometimes <indexterm><primary>single-instance application</primary></indexterm>it only makes sense to run one instance of an application. Examples include Kicker, the KDE panel, Kwin the KDE window manager, and KPPP, the Internet dial-up tool.</para>
<para>To allow developers to create single-instance applications with minimal effort, KDE offers <literal>KUniqueApplication</literal>. It is a subclass of <literal>KApplication</literal> and thus offers all of <literal>KApplication</literal>'s functionality and ensures that only one instance of the application is running. To use <literal>KUniqueApplication,</literal> you need to modify your usual <literal>main()</literal> function a bit; see <link linkend="ch11list04">Listing 11.4</link>.<indexterm><primary>single-instance application</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KUniqueApplication</tertiary></indexterm></para>
<example role="codelisting" label="11.4" id="ch11list04">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Starting a Single-Instance Application<indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>main.cpp</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include "kunique.h"
 2:
 3: void
 4: main (int argc, char *argv[])
 5: {
 6:   if (KUnique::start(argc, argv, "kunique"))
 7:     {
 8:       KUnique *kunique = new KUnique (argc, argv, "kunique");
 9:       kunique->exec();
10:     }
11: }<indexterm><primary>single-instance application</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>main() method</secondary></indexterm><indexterm><primary>main() method</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KUniqueApplication</tertiary></indexterm>
</programlisting>
</example>
<para><literal>KUniqueapplication</literal> accomplishes the feat of starting only one application using DCOP, an interprocess communication system (see <link linkend="ch13">Chapter 13, <quote>DCOP&mdash;Desktop Communication Protocol</quote></link> for a discussion). When <literal>KUnique::start()</literal> is called, <literal>KUniqueApplication</literal> tries to register itself with DCOP under your application's name (<literal>kunique</literal> in this case). If that name is already in use, <literal>KUnique::start()</literal> returns <literal>false</literal> and your application exits. Otherwise, your application is registered under its name. In either case, a DCOP call is sent off, which calls the virtual method <literal>KUnique::newInstance()</literal> (see <link linkend="ch11list05">Listing 11.5</link>).<indexterm><primary>single-instance application</primary><secondary>kunique.cpp call definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>kunique.cpp call definition</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>kunique.cpp call definition</secondary></indexterm><indexterm><primary>kunique.cpp file</primary></indexterm></para>
<example role="codelisting" label="11.5" id="ch11list05">
<title>kunique.cpp: Class Definition for <literal>KUnique</literal>, a Single-Instance Application<indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>kunique.cpp call definition</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kwin.h>
 2:
 3: #include "kunique.h"
 4: #include "ksimpleapp.h"
 5:
 6: KUnique::KUnique (int&amp;argc, char** argv,
 7:           const QCString&amp;rAppName = 0) :
 8:   KUniqueApplication (argc, argv, rAppName)
 9: {
10:   ksimpleapp=0;
11: }
12:
13: int
14: KUnique::newInstance (QValueList&lt;QCString> params)
15: {
16:   if (ksimpleapp==0)
17:     {
18:       ksimpleapp = new KSimpleApp;
19:       ksimpleapp->show();
20:     }
21:   else
22:     {
23:       ksimpleapp->slotRepositionText();
24:       KWin::setActiveWindow (ksimpleapp->winId());
25:     }
26: }<indexterm><primary>single-instance application</primary><secondary>kunique.cpp call definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>kunique.cpp call definition</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>kunique.cpp call definition</secondary></indexterm><indexterm><primary>kunique.cpp file</primary></indexterm><indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>kunique.cpp call definition</tertiary></indexterm>
</programlisting>
</example>
<para>In the method <literal>newInstance()</literal> <indexterm><primary>newInstance() method</primary></indexterm><indexterm><primary>methods</primary><secondary>newInstance()</secondary></indexterm>(lines 13-26), you either create a new instance of the main application widget (usually a subclass of <literal>KTMainWindow</literal>; here <literal>KSimpleApp</literal> is used&mdash;a main widget presented in <link linkend="ch02">Chapter 2</link>) or, if it already exists, respond to the user's attempt to restart the application. Your application's response to a restart attempt might be the following:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>To issue a <quote>sorry</quote> message with <literal>KMessageBox::sorry()</literal>, saying that the application is already running</para></listitem>
<listitem><para>To open the document requested, as a command-line parameter, in addition to or instead of the currently opened document</para></listitem>
</itemizedlist>
<para>In any case, the response should indicate to the user that you are aware of the user's attempt to start the application. At a minimum, you should set the currently running window as the active window using the static method <literal>KWin::setActiveWindow()</literal>.<indexterm><primary>setActiveWindow() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setActiveWindow()</secondary></indexterm> This method is demonstrated on line 24. <literal>KUnique</literal> interprets a request to start the application again as a request to perform the only action it knows: to reposition the text (see <link linkend="ch02">Chapter 2</link> for an explanation of this action).</para>
<para>The final bit of code needed to compile <literal>KUnique</literal>, the header file, is given in <link linkend="ch11list06">Listing 11.6</link>.<indexterm><primary>single-instance application</primary><secondary>kunique.h class definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>kunique.h class definition</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>kunique.h class definition</secondary></indexterm><indexterm><primary>kunique.h class definition</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>kunique.h</tertiary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><see>class definitions</see></indexterm><indexterm><primary>class definitions</primary><secondary>***copy from defining***</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><see>class declarations</see></indexterm><indexterm><primary>class declarations</primary><secondary>***copy from declaring***</secondary></indexterm></para>
<example role="codelisting" label="11.6" id="ch11list06">
<title>kunique.h: Class Declaration for <literal>KUnique<indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>kunique.h call definition</tertiary></indexterm></literal></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KUNIQUE_H__
 2: #define __KUNIQUE_H__
 3:
 4: #include &lt;kuniqueapp.h>
 5:
 6: class KSimpleApp;
 7:
 8: class KUnique : public KUniqueApplication
 9: {
10:  public:
11:   KUnique (int&amp;argc, char** argv,
12:        const QCString&amp;rAppName = 0);
13:
14:   int newInstance (QValueList&lt;QCString> params);
15:
16:  private:
17:   KSimpleApp *ksimpleapp;
18: };
19:
20: #endif<indexterm><primary>single-instance application</primary><secondary>kunique.h class definition</secondary></indexterm><indexterm><primary>applications</primary><secondary>single-instance</secondary><tertiary>kunique.h class definition</tertiary></indexterm><indexterm><primary>KUniqueApplication</primary><secondary>kunique.h class definition</secondary></indexterm><indexterm><primary>kunique.h class definition</primary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>kunique.h</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>kunique.h call definition</tertiary></indexterm>
</programlisting>
</example>
</section>
<section id="ch11lev1sec3">
<title>Panel Applets</title>
<para>Panel<indexterm><primary>panel applet (KWeather)</primary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary></indexterm><indexterm><primary>KWeather applet</primary></indexterm> applets are small applications with minimal user interfaces that run in the KDE panel, Kicker. They generally indicate the status of some part of the system, such as CPU load, network activity, the system time, or provide easy access to functions that are not directly related to the work being performed by the user, such as a desktop pager, a CD player controller, or an instant-messaging client. For creating your own panel applet, the KDE libraries provide the class <literal>KPanelApplet</literal>. It is derived from <literal>QWidget</literal> (and <literal>DCOPObject</literal>) and takes the place of <literal>KTMainWindow</literal> in the design of your application. <link linkend="ch11list07">Listing 11.7</link> shows our usual <literal>main()</literal> function modified to create an applet.<indexterm><primary>panel applet (KWeather)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KWeather applet</primary><secondary>main() method</secondary></indexterm></para>
<example role="codelisting" label="11.7" id="ch11list07">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Starting a Panel applet<indexterm><primary>listings</primary><secondary>KWeather applet</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KWeather applet</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KWeather applet</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kweather.h"
 4:
 5:  int
 6: main(int argc, char *argv[])
 7: {
 8:     KApplication kapplication (argc, argv, "kweather");
 9:
10:     KWeather *kweather = new KWeather;
11:
12:     return kapplication.exec();
13: }<indexterm><primary>panel applet (KWeather)</primary><secondary>main() method</secondary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>KWeather applet</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KWeather applet</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KWeather applet</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KWeather applet</tertiary></indexterm>
</programlisting>
</example>
<para>This applet, the subclass of <literal>KPanelApplet</literal>, is called <literal>KWeather</literal>. <literal>KWeather</literal> is a mock-up of an applet that displays the outside weather, say, to a graduate student trapped in a windowless office. A complete implementation of <literal>KWeather</literal> might query a weather service via HTTP (using <literal>KIONetAccess</literal>) to determine the actual weather. In this implementation the weather is always rainy and 48&deg;F so that the graduate student won't feel that he is missing out on a nice day.</para>
<para><link linkend="ch11list08">Listing 11.8</link> shows how the <literal>KWeather</literal> class is implemented.<indexterm><primary>panel applet (KWeather)</primary><secondary>kweather.cpp class definition</secondary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary><tertiary>kweather.cpp class definition</tertiary></indexterm><indexterm><primary>KWeather applet</primary><secondary>kweather.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>kweather.cpp</tertiary></indexterm><indexterm><primary>kweather.cpp file</primary></indexterm></para>
<example role="codelisting" label="11.8" id="ch11list08">
<title>kweather.cpp: Class Definition for <literal>KWeather</literal>, a Panel Applet<indexterm><primary>listings</primary><secondary>KWeather applet</secondary><tertiary>kweather.cpp class definition</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;stdio.h>
 2:
 3: #include &lt;qlabel.h>
 4:
 5: #include &lt;kiconloader.h>
 6: #include &lt;kpopupmenu.h>
 7:
 8: #include "kweather.h"
 9:
10: KWeather::KWeather (QWidget* parent, const char* name)
11:     : KPanelApplet (parent, name)
12: {
13:   setPalette(QPalette(Qt::gray));
14:   QLabel *qlabel = new QLabel ("Rainy\n  48F", this);
15:   qlabel->setAlignment (Qt::AlignVCenter);
16:   setMinimumSize (qlabel->sizeHint());
17:
18:   setActions (Preferences);
19:
20:   dock("kweather");
21: }
22:
23: void
24: KWeather::preferences()
25: {
26:   printf ("Here we let the user configure the panel applet.\n");
27: }
</programlisting>
</example>
<para>In the constructor, you create your content area, a <literal>QLabel</literal>. Be sure when you design your content area that it will fit comfortably in the small area given to it by Kicker, the KDE panel. The content area here consists of two lines of text on a colored background. It fits nicely. Generally, a well-designed icon can convey more information in the small space&mdash;or at least convey it in a more appealing way.</para>
<para>The call on line 16 to <literal>setMinimumSize()<indexterm><primary>setMinimumSize() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setMinimumSize()</secondary></indexterm></literal> keeps Kicker from shrinking the widget so that the text is too small to read. Kicker is trying to minimize usage of the valuable panel space, so be sure to set a minimum size for your widget.</para>
<para>KPanelApplet provides a context menu (a pop-up menu that appears when the user clicks the applet with the right mouse button, also known as an <quote>RMB menu</quote>). This menu provides the minimum of choices to the user: Move and Remove, which allow the user to, respectively, move the applet along the panel or remove from the panel, thus exiting the applet.You may add other menu entries&mdash;About, Help, and Preferences&mdash;using the method <literal>setActions()</literal>, as on line 18. The enum constants About, Help and Preferences may be combined with the bitwis-or operator (i.e., <literal>&amp;</literal>) and passed to <literal>setActions()</literal> to add any combination of these menu entries. To respond to the user's selection of one of these menu entries, you should reimplement the corresponding virtual method: <literal>about()</literal>, <literal>help()</literal>, or <literal>preferences()</literal>. The latter is reimplemented, as an example, on lines 23-27.</para>
<para>The final bit of code needed for <literal>KWeather</literal> is given in <link linkend="ch11list09">Listing 11.9</link>.<indexterm><primary>panel applet (KWeather)</primary><secondary>kweather.h class definition</secondary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary><tertiary>kweather.h class definition</tertiary></indexterm><indexterm><primary>KWeather applet</primary><secondary>kweather.h class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>kweather.h</tertiary></indexterm><indexterm><primary>kweather.h file</primary></indexterm></para>
<example role="codelisting" label="11.9" id="ch11list09">
<title>kweather.h: Class Declaration for <literal>KWeather<indexterm><primary>listings</primary><secondary>KWeather applet</secondary><tertiary>kweather.h class definition</tertiary></indexterm></literal></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KWEATHER_H__
 2: #define __KWEATHER_H__
 3:
 4: #include &lt;kapplet.h>
 5:
 6: class KWeather : public KApplet
 7: {
 8:
 9: public:

10:   KWeather (QWidget * parent=0, const char *name=0);
11:
12:  protected:
13:   void mousePressEvent (QMouseEvent *);
14:
15: };
16:
17: #endif<indexterm><primary>panel applet (KWeather)</primary><secondary>kweather.h class definition</secondary></indexterm><indexterm><primary>applets</primary><secondary>panel applet (KWeather)</secondary><tertiary>kweather.h class definition</tertiary></indexterm><indexterm><primary>KWeather applet</primary><secondary>kweather.h class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>kweather.h</tertiary></indexterm><indexterm><primary>kweather.h file</primary></indexterm><indexterm><primary>listings</primary><secondary>KWeather applet</secondary><tertiary>kweather.h class definition</tertiary></indexterm>
</programlisting>
</example>
</section>
<section id="ch11lev1sec4">
<title>Summary</title>
<para>This chapter presented alternative application styles to complement the document-centric model discussed throughout the previous chapters. Your application might be based in a dialog box if it is a short-lived, single-task application or on the panel as an applet (using <literal>KApplet</literal>) if it is a long-lived, single-task application. Additionally, you can ensure that only one instance of your application runs by deriving from <literal>KUniqueApplication</literal>. You should think carefully about which (if any) of these application types are appropriate before coding an application (and consider the possibility of multiple modes, similar to KPPP).</para>
</section>
<section id="ch11lev1sec5">
<title>Exercises</title>
<para>See <link linkend="ap-c">Appendix C, <quote>Answers,</quote></link> for the exercise answers.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch11que01"><para><link linkend="ch11ans01">Suppose you would like to have only one instance of your panel applet running at a time. (Who would want, for example, two pagers in their panel?) Combine <literal>KWeather</literal> and <literal>KUnique</literal> into one application that runs only once and displays a <quote>sorry</quote> message if the user tries to start it a second time.</link></para>
</question>
</qandaentry>
</qandaset>
</section>
</chapter>
