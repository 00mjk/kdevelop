<chapter label="3" role="chapter" id="ch03">
<title>The Qt Toolkit</title>
<para><emphasis>by Daniel Marjam&auml;ki</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In This Chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec1">What It Is For (Look and Feel)</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec2">Inside the QT Toolkit</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec3">Signals and Slots</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec4">Meta Object Compiler (<literal>moc</literal>)</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec5">The Utility CLasses</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch03lev1sec6">Special Features (ImageIO, OpenGL, Mesa)</link></emphasis></para></listitem></itemizedlist></highlights>
<para>KDE is built on Qt, so the KDE programmer<indexterm><primary>Qt tookit</primary></indexterm><indexterm><primary>toolkits</primary><secondary>Qt</secondary></indexterm><indexterm><primary>KDE</primary><secondary>Qt toolkit</secondary></indexterm><indexterm><primary>programming</primary><secondary>Qt toolkit</secondary></indexterm> must know Qt. Even if you use only KDE widgets in your programs, you should know something about Qt.</para>
<para>The Qt toolkit is a collection of classes that simplify the creation of programs. The classes are both visible (buttons, windows) and invisible (timer).</para>
<para>This chapter won't cover all features of the Qt toolkit. The most important topics are here, but you may need more information eventually. You can find more information on<indexterm><primary>Web sites</primary><secondary>Trolltech</secondary></indexterm><indexterm><primary>Trolltech Web site</primary></indexterm> the <citetitle>Trolltech</citetitle> Web site <ulink url="http://www.trolltech.com/">(http://www.trolltech.com/)</ulink>.</para>
<section id="ch03lev1sec1">
<title>What It Is For (Look and Feel)</title>
<para>X Windows programming, the traditional way, is both time consuming and hard. The Qt toolkit makes it easier and faster to create X Window programs.<indexterm><primary>X Windows programming</primary><secondary>Qt toolkit</secondary></indexterm></para>
<note role="normal">
<para>Another good feature of Qt is that you can recompile your code for different desktops (X Window, MS Windows).</para>
</note>
<para>A good program must have an easy-to-understand and easy-to-use user interface. Qt provides several widgets, which can give your programs such an interface. Widgets are controls such as buttons, windows, text boxes, list boxes, and so on.</para>
</section>
<section id="ch03lev1sec2">
<title>Inside the Qt Toolkit</title>
<para>The Qt toolkit contains everything you need to write your own Qt programs. Lots of classes are available. Some of them are visible and are meant <indexterm><primary>Qt toolkit</primary><secondary>overview</secondary></indexterm>to be used as user-interface classes. Some of them are invisible, and they are there to make your programming simpler.</para>
<note role="tip">
<para>Keep in mind that it is better to use KDE classes than QT classes, <indexterm><primary>classes</primary><secondary>KDE versus QT</secondary></indexterm>when available. That ensures that your KDE programs will look and feel like all other KDE programs. KDE may also use the KDE features better. However, you must know some Qt. The Qt features I present to you in this chapter are vital for many KDE programs.</para>
</note>
<para>A utility program called the<indexterm><primary>Qt</primary><secondary>moc (Meta Object Compiler)</secondary></indexterm><indexterm><primary>moc (Meta Object Compiler</primary></indexterm><indexterm><primary>Meta Object Compiler (moc)</primary></indexterm> Meta Object Compiler, or <literal>moc</literal>, is also included with Qt. It processes header files to enable easy event handling, an important topic in modern GUI programming. I'll write more about it later in this chapter.</para>
<section id="ch03lev2sec1">
<title><literal>QObject</literal></title>
<para><literal>QObject</literal> is the base class <indexterm><primary>Qt</primary><secondary>QObject class</secondary></indexterm><indexterm><primary>QObject class</primary></indexterm>in Qt. All classes that have signals or slots must inherit from this class,<indexterm><primary>classes</primary><secondary>QObject</secondary></indexterm><indexterm><primary>signals</primary></indexterm><indexterm><primary>slots</primary></indexterm> directly or indirectly. <literal>QPushButton</literal> is an example of a class that inherits from <literal>QObject</literal> indirectly. <literal>QPushButton</literal> inherits from <literal>QWidget</literal>, which inherits from <literal>QObject</literal>. Therefore, <literal>QPushButton</literal> inherits indirectly from <literal>QObject</literal>.</para>
<note role="normal">
<para>Signals and slots enable easy<indexterm><primary>event handling</primary><secondary>Qt</secondary></indexterm><indexterm><primary>Qt</primary><secondary>event handling</secondary></indexterm> event handling in Qt. They are explained in detail in <link linkend="ch03lev1sec3"><quote>Signals and Slots</quote></link> later in this chapter.</para>
</note>
</section>
<section id="ch03lev2sec2">
<title><literal>QWidget</literal></title>
<para><literal>QWidget</literal> is the base class for all visible classes in Qt. The <literal>QWidget</literal> simply represents an <indexterm><primary>Qt</primary><secondary>QWidget class</secondary></indexterm><indexterm><primary>QWidget class</primary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary></indexterm>empty area (see <link linkend="ch03fig01">Figure 3.1</link>).</para>
<figure label="3.1" id="ch03fig01">
<title>A <literal>QWidget</literal> inside a window.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig01.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>You use the <literal>QWidget</literal> class whenever you need an empty area. It is often used to create windows in your programs.</para>
<section id="ch03lev3sec1">
<title>Important Member Functions</title>
<para>The constructor for<indexterm><primary>Qt</primary><secondary>QWidget class</secondary><tertiary>member functions</tertiary></indexterm><indexterm><primary>functions</primary><secondary>QWidget class</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>functions</tertiary></indexterm> <literal>QWidget</literal> is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
QWidget(QWidget *<emphasis>parent</emphasis>=0, const char *<emphasis>name</emphasis>=0, WFlags <emphasis>f</emphasis>=0)
</programlisting>
</informalexample>
<para>The most important parameter is <emphasis><literal>parent</literal></emphasis>.</para>
<para>If you want to create a new window and put the widget inside it, you set <emphasis><literal>parent</literal></emphasis> to <literal>0</literal>. The window manager will draw the window for you.</para>
<para>When you put your widget inside a window, <emphasis><literal>parent</literal></emphasis> must contain a pointer to the parent object. The parent object is the object that you want to put your widget on.</para>
<para>The other parameters are rarely used. The parameter <emphasis><literal>name</literal></emphasis> gives your widget a name. The parameter <emphasis>f</emphasis> is a flags parameter. If a window is created for the widget, you can control the behavior of the window with this parameter.</para>
<para>To move and resize the widget, use the following function:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void setGeometry(int <emphasis>left</emphasis>, int <emphasis>top</emphasis>, int <emphasis>width</emphasis>, int <emphasis>height</emphasis>)
</programlisting>
</informalexample>
<para>The <emphasis><literal>left</literal></emphasis> and<emphasis><literal>top</literal></emphasis> parameters specify the upper-left corner of the widget. The <emphasis><literal>width</literal></emphasis> and <emphasis><literal>height</literal></emphasis> parameters specify the dimensions of the widget.</para>
<para>To show the widget, use the following function:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void show()
</programlisting>
</informalexample>
<para>Widgets are created invisible by default and must be shown to be seen.</para>
<para>The function that handles mouse press events is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mousePressEvent(QMouseEvent *<emphasis>event</emphasis>)
</programlisting>
</informalexample>
<para>You can implement it if you <indexterm><primary>mouse events</primary></indexterm>need to create a mouse button handler. The parameter <literal>event</literal> gives you important information about the mouse press event (such as cursor position and button status).<indexterm><primary>Qt</primary><secondary>QWidget class</secondary><tertiary>member functions</tertiary></indexterm><indexterm><primary>functions</primary><secondary>QWidget class</secondary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>functions</tertiary></indexterm></para>
<para>The function that handles mouse move events is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void mouseMoveEvent(QMouseEvent *<emphasis>event</emphasis>)
</programlisting>
</informalexample>
<para>Implement this function if you need to handle mouse cursor move events. The mouse cursor position and button state are given by the parameter <emphasis><literal>event</literal></emphasis>.</para>
<para>The following function is called when the graphics are updated:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void paintEvent(QPaintEvent *<emphasis>event</emphasis>)</programlisting>
</informalexample>
<para>You should implement this function if you have drawn graphics on the widget. Use the QPainter class to draw graphics (see the section <link linkend="ch03lev2sec3"><quote>Qpainter</quote></link> later in this chapter). The graphics will disappear if you don't redraw them. The parameter <emphasis><literal>event</literal></emphasis> contains information about where the graphics needs to be updated.</para>
<para>The function you use to set the caption is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void setCaption(const QString &amp;<emphasis>caption</emphasis>)
</programlisting>
</informalexample>
<para>If your widget has its own window (<literal>parent=0</literal>), the window title is set by this function. This is a slot (see the section <link linkend="ch03lev1sec3"><quote>Signals And Slots</quote></link> later in this chapter).</para>
</section>
<section id="ch03lev3sec2">
<title>Sample Use of <literal>QWidget</literal></title>
<para><link linkend="ch03list01">Listing 3.1</link> shows how you use the <literal>QWidget</literal> class. The program creates an empty window. When a mouse button is pressed, the program prints <literal>Mouse Press</literal> on the console (shown in <link linkend="ch03fig02">Figure 3.2</link>):</para>
<example role="codelisting" label="3.1" id="ch03list01">
<title>widget.cpp: A Window<indexterm><primary>listings</primary><secondary>QWidget class example</secondary></indexterm><indexterm><primary>Qt</primary><secondary>QWidget class</secondary><tertiary>example (listing)</tertiary></indexterm><indexterm><primary>classes</primary><secondary>QWidget</secondary><tertiary>example (listing)</tertiary></indexterm> with Mouse Handling</title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;qwidget.h>
 3: #include &lt;iostream.h>
 4: 
 5: 
 6: // A Window class definition
 7: class MyWindow : public QWidget
 8: {
 9: public:
10:   // Constructor, Parent is always 0 for windows
11:   MyWindow() : QWidget() { }
12: protected:
13:   // This function will be called when the user presses a mouse button
14:   void mousePressEvent(QMouseEvent *);
15: };
16: 
17: 
18: void MyWindow::mousePressEvent(QMouseEvent *)
19: {
20:   // Print "Mouse Press" on the console
21:   cout &lt;&lt; "Mouse Press" &lt;&lt; endl;
22: }
23: 
24: 
25: int main(int argc, char **argv){
26:   KApplication app(argc, argv);
27: 
28:   // Create a MyWindow object
29:   MyWindow window;
30: 
31:   // Move and resize the MyWindow object
32:   // left=200, top=200, width=400, height=300
33:   window.setGeometry(200,200,400,300);
34: 
35:   // Main window = MyWindow object
36:   app.setMainWidget(&amp;window);
37: 
38:   window.setCaption("QWidget example");
39: 
40:   // Show the window
41:   window.show();
42: 
43:   // Go to the main loop
44:   return app.exec();
45: }
</programlisting>
</example>
<figure label="3.2" id="ch03fig02">
<title>Mouse-handling window</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig02.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
</section>
<section id="ch03lev2sec3">
<title><literal>QPainter</literal></title>
<para><literal>QWidget</literal> and its children cannot draw <indexterm><primary>QPainter class</primary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary></indexterm><indexterm><primary>Qt</primary><secondary>QPainter class</secondary></indexterm><indexterm><primary>widgets</primary><secondary>drawing graphics on</secondary></indexterm>graphics, and that's why <literal>QPainter</literal> is needed. <literal>QPainter</literal> draws graphics on widgets.</para>
<section id="ch03lev3sec3">
<title>Important Member Functions</title>
<para>The constructor for <literal>QPainter</literal> is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
QPainter()
</programlisting>
</informalexample>
<para>Before you can draw any graphics on a widget, you must call the following function:<indexterm><primary>QPainter class</primary><secondary>member function</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>functions</tertiary></indexterm><indexterm><primary>Qt</primary><secondary>QPainter class</secondary><tertiary>functions</tertiary></indexterm><indexterm><primary>functions</primary><secondary>QPainter class</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
bool begin(const QPaintDevice *<emphasis>pd</emphasis>)
</programlisting>
</informalexample>
<para>In the parameter <literal>pd</literal> (Paint Device), you tell <literal>QPainter</literal> on what object you want to draw graphics.</para>
<para>To draw a line, for example, use the following function:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void drawLine(int <emphasis>x1</emphasis>, int <emphasis>y1</emphasis>, int <emphasis>x2</emphasis>, int <emphasis>y2</emphasis>)
</programlisting>
</informalexample>
<para>The parameters are simple; they define the start and end points. A line will be drawn between these two points. The coordinates are relative to the object that you draw on. This is not the only graphics operation you can perform, but it is the only one presented here. Functions are available that draw circles, bars, rectangles, and almost anything you can imagine. The Qt reference contains all the information you need. As I have written before, I recommend that you download the Qt documentation from the <citetitle>trolltech</citetitle> Web site <ulink url="http://www.trolltech.com">(http://www.trolltech.com)</ulink>.</para>
<para>To flush graphics, use the<indexterm><primary>graphics</primary><secondary>flushing</secondary></indexterm><indexterm><primary>flushing graphics</primary></indexterm> following function:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void flush();
</programlisting>
</informalexample>
<para><literal>QPainter</literal> uses a buffered system. Graphics operations are stored in memory only&mdash;they do not affect what you see on the screen. This function flushes the graphics in memory to the screen. The destructor for <literal>QPainter</literal> flushes automatically, you don't have to flush if your <literal>QPainter</literal> object is destroyed when all the graphics have been drawn.</para>
<para>When you don't want to draw more graphics on the current object, you can use the following function:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
bool end()
</programlisting>
</informalexample>
<para>Use this function when you have been drawing on one widget, and you want to switch to another widget.</para>
</section>
<section id="ch03lev3sec4">
<title>Sample Use of <literal>QPainter</literal></title>
<para><link linkend="ch03list02">Listing 3.2</link> shows you how the <literal>QPainter</literal> is used. The <literal>QPainter</literal> is used in the <literal>paintEvent</literal> function and is shown in <link linkend="ch03fig03">Figure 3.3</link>.</para>
<example role="codelisting" label="3.2" id="ch03list02">
<title>Drawing a Line in a<indexterm><primary>listings</primary><secondary>QPainter class example usage</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPainter</secondary><tertiary>example usage (listing)</tertiary></indexterm><indexterm><primary>QPainter class</primary><secondary>example usage (listing)</secondary></indexterm> Window</title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;qwidget.h>
 3: #include &lt;qpainter.h>
 4: 
 5: class MyWindow : public Qwidget
 6: {
 7:   public:
 8:     MyWindow() : QWidget() { }
 9:   protected:
10:     void paintEvent(QPaintEvent *);
11: };
12: 
13: void MyWindow::paintEvent(QPaintEvent *)
14: {
15:   // Draw graphics on this object
16:   QPainter paint(this);
17:   // Draw a line (the destructor will make the line visible)
18:   paint.drawLine(10,10,190,140);
19: }
20: 
21: 
22: int main(int argc, char **argv)
23: {
24:   KApplication app(argc, argv);
25:   MyWindow window;
26:   window.setGeometry(50,50,200,150);
27:   app.setMainWidget(&amp;window);
28:   window.setCaption("Qpainter");
29:   window.show();
30:   return app.exec();
31: }
</programlisting>
</example>
<figure label="3.3" id="ch03fig03">
<title><literal>QPainter</literal> example.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig03.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
</section>
<section id="ch03lev2sec4">
<title><literal>QPushButton</literal></title>
<para>You use <literal>QPushButton</literal> when you need a button in your program. <literal>QPushButton</literal> is derived from <indexterm><primary>QPushButton class</primary></indexterm><indexterm><primary>classes</primary><secondary>QPushButton</secondary></indexterm><indexterm><primary>Qt</primary><secondary>QPushButton class</secondary></indexterm>the <literal>QWidget</literal> class.</para>
<section id="ch03lev3sec5">
<title>Important Members</title>
<para>The constructor for <literal>QPushButton</literal> is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
QPushButton(const QString &amp;<emphasis>text</emphasis>, QWidget *<emphasis>parent</emphasis>,
const char *<emphasis>name</emphasis>=0)
</programlisting>
</informalexample>
<para>The parameter <emphasis><literal>text</literal></emphasis> specifies the button caption. The parameter <emphasis><literal>parent</literal></emphasis> is a pointer to the object that you wish to put the button on. The third parameter,<indexterm><primary>QPushButton class</primary><secondary>member functions</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPushButton</secondary><tertiary>functions</tertiary></indexterm><indexterm><primary>Qt</primary><secondary>QPushButton class</secondary><tertiary>functions</tertiary></indexterm><indexterm><primary>functions</primary><secondary>QPushButton class</secondary></indexterm> <emphasis><literal>name</literal></emphasis>, is not important.</para>
<para>The following signal is emitted when the button is clicked:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void clicked()
</programlisting>
</informalexample>
<para>Buttons can be clicked by the mouse or by the keyboard.</para>
</section>
<section id="ch03lev3sec6">
<title>Sample Use of <literal>QPushButton</literal></title>
<para>The <literal>QPushButton</literal> class is mainly used to put buttons inside windows. <link linkend="ch03list03">Listing 3.3</link> demonstrates this and is shown in <link linkend="ch03fig04">Figure 3.4</link>:</para>
<example role="codelisting" label="3.3" id="ch03list03">
<title>A Window with <indexterm><primary>listings</primary><secondary>QPushButton class example usage</secondary></indexterm><indexterm><primary>QPushButton class</primary><secondary>listing</secondary></indexterm><indexterm><primary>classes</primary><secondary>QPushButton</secondary><tertiary>listing</tertiary></indexterm>a Button in It</title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;qpushbutton.h>
 3: #include &lt;qwidget.h>
 4: 
 5: 
 6: // The window class
 7: class MyWindow : public QWidget
 8: {
 9: public:
10:   MyWindow();
11: private:
12:   QPushButton *button;
13: };
14: 
15: 
16: MyWindow::MyWindow() : QWidget()
17: {
18:   // Create a new button; caption="Button", parent=this
19:   button = new QPushButton("Button", this);
20: 
21:   // Move and resize the button
22:   button->setGeometry(50, 10, 100, 30);
23: 
24:   // Show the button
25:   button->show();
26: }
27: 
28: 
29: int main(int argc, char **argv)
30: {
31:   KApplication app(argc, argv);
32:   MyWindow window;
33:   window.setGeometry(200,200,400,300);
34:   window.setCaption("QPushButton Example");
35:   app.setMainWidget(&amp;window);
36:   window.show();
37:   return app.exec();
38: }
</programlisting>
</example>
<figure label="3.4" id="ch03fig04">
<title><literal>QPushButton</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig04.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
</section>
</section>
<section id="ch03lev1sec3">
<title>Signals and Slots</title>
<para>The most important features of Qt <indexterm><primary>Qt</primary><secondary>signals</secondary></indexterm><indexterm><primary>signals</primary><secondary>(Qt)</secondary></indexterm><indexterm><primary>slots</primary><secondary>(Qt)</secondary></indexterm><indexterm><primary>Qt</primary><secondary>slots</secondary></indexterm>are signals and slots.</para>
<para>Signals tell you that something has just happened. Signals are emitted (sent) when the user works with the computer. For example, when the user clicks the mouse or presses keys on a keyboard a signal is emitted. Signals can also be emitted when something happens inside the computer&mdash;when the clock ticks, for example.</para>
<para>Slots are the functions that respond to certain signals. It is important that your program <indexterm><primary>functions</primary><secondary>slots</secondary></indexterm>responds to signals. Otherwise, it might look as if your program hangs. KDE programs don't&mdash;or shouldn't&mdash;hang!</para>
<para>Signals and slots are very object independent. Slots that handle a signal can be put in any object in your program. The object that sends the signal doesn't have to know anything about the slot or the object where the slot can be found. For example, you may have one window that contains a button and one window that contains a text box. You can let the text box respond to button clicks.</para>
<para>Signals and slots are primarily used for <indexterm><primary>event handling</primary><secondary>signals and slots</secondary></indexterm>events handling, but you can use it for easy communication between objects too. When two windows need to communicate with each other, you can use signals and slots. Communication this way is much easier than doing it with pointers.</para>
<note role="normal">
<para>Event handling is solved by callbacks in many other toolkits. A callback <indexterm><primary>callbacks</primary></indexterm>is a pointer to a function. The widgets contain callbacks, pointers to functions, for each event. When an event occurs, the appropriate function is called. It is simple in theory, but it is hard in practice. The callbacks are not type safe, which means that it is easy to make mistakes. Callbacks also can't take any number of parameters of any type like signals and slots do.</para>
</note>
<section id="ch03lev2sec5">
<title>Creating a Slot</title>
<para>Creating a slot is easy. Any class that inherits from <literal>QObject</literal> can have slots.</para>
<para>First you must enable signals and slots. In the class definition, add the word <literal>Q_OBJECT</literal>. This is a keyword, which the <literal>moc</literal> understands.<indexterm><primary>slots</primary><secondary>creating</secondary></indexterm><indexterm><primary>Qt</primary><secondary>slots</secondary><tertiary>creating</tertiary></indexterm></para>
<para>The slot is just a member function in your class, but you must declare it in a slots section. Slots can be public, private, or protected.<indexterm><primary>classes</primary><secondary>slots</secondary></indexterm></para>
<para>The following example shows a class with a slot:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
class MyWindow : public QWidget
{
  Q_OBJECT  // Enable signals and slots
public:
  MyWindow();
public slots:  // This slots section is public
  void mySlot();  // A public slot
};
</programlisting>
</informalexample>
<para>The slot in the preceding class definition is called <literal>mySlot</literal>. The keyword before <literal>slots</literal> defines the access mode. The slot <literal>mySlot</literal> above is public.</para>
<para>You write the implementation for the slot as if it was a common member function. The following example shows you what a slot implementation may look like:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void MyWindow::mySlot()
{
  cout &lt;&lt; "slotPublic" &lt;&lt; endl;
}
</programlisting>
</informalexample>
</section>
<section id="ch03lev2sec6">
<title>Emitting a Signal</title>
<para>When you want to tell Qt that an event has occurred, you emit a signal. When that happens, Qt executes all slots that are connected to the signal.<indexterm><primary>signals</primary><secondary>emitting</secondary></indexterm><indexterm><primary>Qt</primary><secondary>signals</secondary><tertiary>emitting</tertiary></indexterm><indexterm><primary>emitting signals</primary></indexterm></para>
<para>Before a signal can be emitted, it must be defined. The class that emits a signal must contain the signal definition. Signals are defined in a <literal>signals</literal> section in your class. The following class definition defines a signal:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
class MyWindow : public QWidget
{
  Q_OBJECT  // Enable signals and slots
public:
  MyWindow();
signals:
  void created();
};
</programlisting>
</informalexample>
<para>Signals are emitted with the command <literal>emit</literal>. The signal may be emitted like so:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
// Constructor for MyWindow
MyWindow::MyWindow() : QWidget()
{
  // Emit the signal created()
  emit created();
}
</programlisting>
</informalexample>
<para>The example above is only a simple demonstration that shows you how it works.</para>
</section>
<section id="ch03lev2sec7"><title>Connecting a Slot to a Signal</title>
<para>To make a slot respond to a certain signal, you must connect them to each other. You can <indexterm><primary>slots</primary><secondary>connecting to signals</secondary></indexterm><indexterm><primary>Qt</primary><secondary>slots</secondary><tertiary>connecting to signals</tertiary></indexterm><indexterm><primary>signals</primary><secondary>connecting to slots</secondary></indexterm><indexterm><primary>Qt</primary><secondary>signals</secondary><tertiary>connecting to slots</tertiary></indexterm>connect several slots to one signal.</para>
<para>It is very simple to connect a slot to a signal. The command <literal>connect</literal> does this. The syntax is simple:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
connect(<emphasis>startobject</emphasis>, SIGNAL(<emphasis>signal()</emphasis>), <emphasis>targetobject</emphasis>, SLOT(<emphasis>slot()</emphasis>))
</programlisting>
</informalexample>
<para>The parameter <emphasis><literal>startobject</literal></emphasis> contains a pointer to the object that the signal comes from.</para>
<para>The parameter <emphasis><literal>signal</literal></emphasis> specifies what signal to handle. The signal must be emitted by the<indexterm><primary>startobject parameter</primary></indexterm> <emphasis><literal>startobject</literal></emphasis>.</para>
<para>The object which responds to a signal is specified in the parameter <emphasis><literal>targetobject</literal><indexterm><primary>targetobject parameter</primary></indexterm></emphasis>.</para>
<para>The slot which responds to the signal is specified in the parameter <emphasis><literal>slot</literal></emphasis>. The slot must be in the object specified by <emphasis><literal>targetobject</literal></emphasis>.</para>
<para>The following class demonstrates that several slots can be connected to the same signal, and one slot can be connected to several signals:</para>
<example role="codelisting" label="3.4" id="ch03list04">
<title>buttons.h: <indexterm><primary>listings</primary><secondary>connecting slots to signals</secondary></indexterm>Class Definition for the Class <literal>MyWindow</literal></title>
<programlisting linenumbering="numbered">
 1:class MyWindow : public QWidget
 2:{
 3:  Q_OBJECT  // Enable slots and signals
 4:public:
 5: MyWindow();
 6:private slots:
 7:  void slotButton1();
 8:  void slotButton2();
 9:  void slotButtons();
10:private:
11:  QPushButton *button1;
12:  QPushButton *button2;
13: };
</programlisting>
</example>
<para>The listing below contains the class implementation:</para>
<example role="codelisting" label="3.5" id="ch03list05">
<title>buttons.cc: Class Implementation for the Class <literal>MyWindow</literal> Declared in <link linkend="ch03list04">Listing 3.4</link></title>
<programlisting linenumbering="numbered">
 1: MyWindow::MyWindow() : QWidget()
 2: {
 3:   // Create button1 and connect button1->clicked() to this->slotButton1()
 4:   button1 = new QPushButton("Button1", this);
 5:   button1->setGeometry(10,10,100,40);
 6:   button1->show();
 7:   connect(button1, SIGNAL(clicked()), this, SLOT(slotButton1()));
 8: 
 9:   // Create button2 and connect button2->clicked() to this->slotButton2()
10:   button2 = new QPushButton("Button2", this);
11:   button2->setGeometry(110,10,100,40);
12:   button2->show();
13:   connect(button2, SIGNAL(clicked()), this, SLOT(slotButton2()));
14: 
15:   // When any button is clicked, call this->slotButtons()
16:   connect(button1, SIGNAL(clicked()), this, SLOT(slotButtons()));
17:   connect(button2, SIGNAL(clicked()), this, SLOT(slotButtons()));
18: }
19: 
20: 
21: // This slot is called when button1 is clicked.
22: void MyWindow::slotButton1()
23: {
24:   cout &lt;&lt; "Button1 was clicked" &lt;&lt; endl;
25: }
26: 
27: 
28: // This slot is called when button2 is clicked
29: void MyWindow::slotButton2()
30: {
31:   cout &lt;&lt; "Button2 was clicked" &lt;&lt; endl;
32: }
33: 
34: 
35: // This slot is called when any of the buttons were clicked
36: void MyWindow::slotButtons()
37: {
38:   cout &lt;&lt; "A button was clicked" &lt;&lt; endl;
39: }
</programlisting>
</example>
</section>
<section id="ch03lev2sec8">
<title>Signals and Slots with Parameters</title>
<para>During communication, it is sometimes useful to say more than <quote>Hey!</quote> That is all <indexterm><primary>slots</primary><secondary>parameters</secondary></indexterm><indexterm><primary>Qt</primary><secondary>slots</secondary><tertiary>parameters</tertiary></indexterm><indexterm><primary>signals</primary><secondary>parameters</secondary></indexterm><indexterm><primary>Qt</primary><secondary>paremeters</secondary></indexterm><indexterm><primary>parameters</primary><secondary>signals and slots</secondary></indexterm>that the preceding signals say.</para>
<para>If you need to say more, the simplest way is to use parameters in your signals and slots.</para>
<para>For example, you may have two windows both containing a button and a text box. When the user types in text and clicks the button in one window, the caption for the other window will change to whatever was typed in.</para>
<para>The solution is to use slots and signals with parameters. Give both the signal and slot a parameter that contains the new window caption. When you emit the signal you set this parameter.</para>
<para>The following example code shows how parameters work. The signal and slot are both in the same class, but of course that is not necessary:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
class MyWindow : public QWidget
{
  Q_OBJECT  // Enable signals and slots
public:
  MyWindow();
private slots:
  void slotChanged(int i);
signals:
  void changed(int i);
};
</programlisting>
</informalexample>
<para>The class constructor may connect the slot to the signal, like this:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
MyWindow::MyWindow() : QWidget()
{
  connect(this, SIGNAL(changed(int)), this, SLOT(slotChanged(int)));
}
</programlisting>
</informalexample>
<para>The slot and the signal must have compatible parameters. In the preceding example, they each have one integer as a parameter.</para>
<para>It is easy to emit a signal with a parameter. The following function emits the signal <literal>changed(int i)</literal>:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void MyWindow::emitter(int i)
{
  emit changed(i);
}
</programlisting>
</informalexample>
</section>
<section id="ch03lev2sec9">
<title>Slots in Temporary Classes</title>
<para>When a signal is emitted, the slots connected to it are activated.<indexterm><primary>slots</primary><secondary>temporary classes</secondary></indexterm><indexterm><primary>Qt</primary><secondary>slots</secondary><tertiary>temporary classes</tertiary></indexterm><indexterm><primary>classes</primary><secondary>slots in temporary classes</secondary></indexterm></para>
<para>Take a look at the following class constructor:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
MyWindow::MyWindow() : QWidget()
{
  MyClass *temp = new MyClass();

  button = new QPushButton(this, "Button");
  button->setGeometry(0,0,100,30);
  button->show();
  connect(button, SIGNAL(clicked()), temp, SLOT(slotTemp()));

  delete temp;
}
</programlisting>
</informalexample>
<para>A button is created. The <literal>clicked()</literal> signal is connected to <literal>temp->slotTemp()</literal>. When you delete <literal>temp</literal>, the slot <literal>slotTemp()</literal> is also deleted. If the user clicks the button, an error will occur. Always consider this when you delete Qt objects.</para>
</section>
</section>
<section id="ch03lev1sec4">
<title>Meta Object Compiler (<literal>moc</literal>)</title>
<para>The Meta Object Compiler (<literal>moc</literal>) is a useful addition to Qt. It is a tool that <indexterm><primary>Qt</primary><secondary>moc</secondary></indexterm><indexterm><primary>moc</primary></indexterm><indexterm><primary>Meta Object Compiler</primary></indexterm>saves a lot of work, and it is very simple to use.</para>
<para>It converts Qt class definitions into C++ code.</para>
<section id="ch03lev2sec10">
<title>Using the <literal>moc</literal> Tool</title>
<para>You probably already know that a compiler converts code into ones and zeros. The code may sometimes be understandable, but the ones and zeros are not.</para>
<para>The <literal>moc</literal> is not a compiler, although the name may suggest that. The <literal>moc</literal> looks in your code and searches for certain keywords. When a keyword is found, it is replaced by other code. This saves you a lot of programming because the resulting code is much more complex than the original.</para>
<section id="ch03lev3sec7">
<title>The <literal>moc</literal> Keywords</title>
<para>The <literal>moc</literal> keywords are <literal>Q_OBJECT</literal>, <literal>public slots:</literal>, <literal>protected slots:</literal>, <literal>private slots:</literal>, and <literal>signals:</literal>.</para>
<para>The <literal>Q_OBJECT</literal> keyword tells <literal>moc</literal> that the class is a Qt class.</para>
<para>All slots must be defined below a <literal>slots</literal> keyword. Slots can be public, protected, or private. You must specify the access mode before the <literal>slots</literal> keyword (all public slots are defined below <literal>public slots</literal> for example).<indexterm><primary>Qt</primary><secondary>moc</secondary><tertiary>keywords</tertiary></indexterm><indexterm><primary>moc</primary><secondary>keywords</secondary></indexterm><indexterm><primary>Meta Object Compiler</primary><secondary>keywords</secondary></indexterm><indexterm><primary>keywords</primary><secondary>moc</secondary></indexterm></para>
<para>All signals must be defined below the <literal>signals:</literal> keyword. Signals are always public.</para>
</section>
</section>
<section id="ch03lev2sec11">
<title>Sample Use of the <literal>moc</literal></title>
<para>You will now see how to use <literal>moc</literal> with a small sample program. The main window in the program contains a button. When you click the button, the slot <literal>slotButton()</literal> is<indexterm><primary>slots</primary><secondary>slotButton()</secondary></indexterm><indexterm><primary>slotButton()</primary></indexterm> executed. <link linkend="ch03list06">Listing 3.6</link> contains the code:</para>
<example role="codelisting" label="3.6" id="ch03list06">
<title>mywindow.h:<indexterm><primary>listings</primary><secondary>moc example</secondary></indexterm> Class Declaration with <literal>moc</literal> Keywords</title>
<programlisting linenumbering="numbered">
  1: #include &lt;qwidget.h>
 2: #include &lt;qpushbutton.h>
 3: 
 4: class MyWindow : public QWidget
 5: {
 6:   Q_OBJECT
 7: public:
 8:   MyWindow();
 9: public slots:
10:   void slotButton();
11: private:
12:   QPushButton *button;
13: };
</programlisting>
</example>
<para><link linkend="ch03list07">Listing 3.7</link> shows the class implementation. You must put the class definition and class implementation in different files, because the class implementation needs the code that <literal>moc</literal> generates.</para> 
<example role="codelisting" label="3.7" id="ch03list07">
<title>mywindow.cpp:<indexterm><primary>listings</primary><secondary>moc example</secondary></indexterm><indexterm><primary>listings</primary><secondary>MyWindow class implementation</secondary></indexterm><indexterm><primary>MyWindow class implementation</primary></indexterm> Class Implementation for <literal>MyWindow</literal></title>
<programlisting linenumbering="numbered">
 1: #include "mywindow.moc"
 2: #include &lt;iostream.h>
 3: 
 4: MyWindow::MyWindow() : QWidget()
 5: {
 6:   button = new QPushButton("Click me", this);
 7:   button->setGeometry(10,10,100,40);
 8:   button->show();
 9: 
10:   connect(button, SIGNAL(clicked()), this, SLOT(slotButton()));
11: }
12: 
13: void slotButton()
14: {
15:   cout &lt;&lt; "You clicked me" &lt;&lt; endl;
16: }
</programlisting>
</example>
<para><link linkend="ch03list08">Listing 3.8</link> shows what the main program file looks like. It uses the <literal>MyWindow</literal> class which you have just created.</para>
<example role="codelisting" label="3.8" id="ch03list08">
<title>main.cpp: <indexterm><primary>listings</primary><secondary>moc example</secondary></indexterm>The Main Program File</title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include "mywindow.h"
 3: 
 4: int main(int argc, char **argv)
 5: {
 6:   KApplication app(argc, argv);
 7:   MyWindow window;
 8:   window.setGeometry(100,100,200,100);
 9:   window.setCaption("Aha!");
10:   app.setMainWidget(&amp;window);
11:   window.show();
12:   return app.exec();
13: }
</programlisting>
</example>
<para>Now you will compile the program.<indexterm><primary>Qt</primary><secondary>moc</secondary><tertiary>main program file example</tertiary></indexterm><indexterm><primary>moc</primary><secondary>main program file example</secondary></indexterm><indexterm><primary>Meta Object Compiler</primary><secondary>main program file example</secondary></indexterm> Common C++ programs are compiled in two steps. First, all object files are created, and then the object files are linked into a program.</para>
<para>Creating all object files takes two steps when you are using signals and slots, because you must use <literal>moc</literal> first to precompile the class definitions.</para>
<para>Note that the main.cpp file in <link linkend="ch03list08">Listing 3.8</link> can be compiled into an object file directly. No <literal>moc</literal> keywords are in it, nor does it include any files generated by <literal>moc</literal>. To create the object file for main.cpp, type the following:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++ -I$QTDIR/include -c main.cpp</emphasis>
</programlisting>
</informalexample>
<para>The mywindow.cpp file, containing the class declaration for <literal>MyWindow</literal>, can't be compiled yet. The class declaration contains some <literal>moc</literal> keywords (<literal>Q_OBJECT</literal>, <literal>public slots</literal>), which must be translated into C++ code first. To translate, use the <literal>moc</literal> tool. The following command precompiles the mywindow.h file and the result is written to <literal>mywindow.moc</literal>:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">moc mywindow.h -o mywindow.moc</emphasis>
</programlisting>
</informalexample>
<para>Now you can compile the mywindow.cpp file like so:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++ -I/$QTDIR/include -c mywindow.cpp</emphasis>
</programlisting>
</informalexample>
<para>At this point, all object files have been created.</para>
<para>To link the object files into an executable program, use the following command:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++ -o myprog main.o mywindow.o -L/$QTDIR/lib -lqt</emphasis>
</programlisting>
</informalexample>
<para>The name of the executable file will be myprog.</para>
<para>Now you can execute your program.<indexterm><primary>Qt</primary><secondary>moc</secondary><tertiary>executing programs</tertiary></indexterm><indexterm><primary>moc</primary><secondary>executing programs</secondary></indexterm><indexterm><primary>Meta Object Compiler</primary><secondary>executing programs</secondary></indexterm></para>
<para>I'll now give you a quick summary of the compiling process. The first step is to precompile all necessary files with <literal>moc</literal>. All class definitions that contains <literal>moc</literal> keywords must be precompiled. The second step is to create all the object files. The third and last step is to link all the object files together.</para>
</section>
</section>
<section id="ch03lev1sec5">
<title>The Utility Classes</title> 
<para>The utility classes store and process information for you. They are template classes.<indexterm><primary>Qt</primary><secondary>utility classes</secondary></indexterm><indexterm><primary>classes</primary><secondary>utility (Qt)</secondary></indexterm><indexterm><primary>utility classes</primary><secondary>(Qt)</secondary></indexterm></para>
<section id="ch03lev2sec12">
<title>Templates</title>
<para>One of the newer features of<indexterm><primary>templates</primary><secondary>C++</secondary></indexterm><indexterm><primary>C++</primary><secondary>templates</secondary></indexterm><indexterm><primary>classes</primary><secondary>template</secondary></indexterm> C++ are templates. In a template class, the same code can handle any data type. That means you don't have to rewrite your code for all data types you might want to handle. <link linkend="ch03list09">Listing 3.9</link> shows a sample template class called <literal>MyList</literal>. <literal>MyClass</literal> below handles both <literal>int</literal> and <literal>char</literal> values:</para>
<example role="codelisting" label="3.9" id="ch03list09">
<title>stl.cpp: A Program <indexterm><primary>template classes</primary><secondary>listing</secondary></indexterm><indexterm><primary>listings</primary><secondary>template classes</secondary></indexterm>That Shows How Template Classes Work</title>
<programlisting linenumbering="numbered">
 1: #include &lt;iostream.h>
 2: 
 3: template &lt;class C> class MyList
 4: {
 5:   C list[2];
 6:   public:
 7:     MyList(void) { }
 8:     void insert(int index, C item){ list[index] = item; }
 9:     C get(int index){ return list[index]; }
10: };
11: 
12: int main()
13: {
14:   MyList&lt;int> list1;
15:   list1.insert(0, 43);
16:   list1.insert(1, 14);
17:   cout &lt;&lt; list1.get(0) &lt;&lt; list1.get(1) &lt;&lt; endl;
18: 
19:   MyList&lt;char> list2;
20:   list2.insert(0, 'a');
21:   list2.insert(1, 'b');
22:   cout &lt;&lt; list2.get(0) &lt;&lt; list2.get(1) &lt;&lt; endl;
23: 
24:   return 0;
25: }
</programlisting>
</example>
<para>The template class <literal>MyList</literal> can store values of any type.  The preceding example demonstrates that it can store both <literal>char</literal> and <literal>int</literal> values.</para>
</section>
<section id="ch03lev2sec13">
<title>Standard Template Library (STL)</title>
<para>STL stands for Standard Template Library. STL is part of C++. It is a set of standard templates. These templates were created because they solve common<indexterm><primary>Qt</primary><secondary>STL</secondary></indexterm><indexterm><primary>STL</primary><secondary>(Standard Template Library)</secondary></indexterm><indexterm><primary>templates</primary><secondary>STL</secondary></indexterm> problems such as storing values.</para>
<para>You can use STL in your KDE programs, although it's not recommended. Many template classes are available in Qt and KDE; you should use those instead of the STL classes if you can. The Qt and KDE classes are made especially for Qt and KDE programs.</para>
</section>
<section id="ch03lev2sec14">
<title><literal>QList</literal>&mdash;A Qt Template Class</title>
<para>This class is a Qt template <indexterm><primary>classes</primary><secondary>template</secondary><tertiary>QList</tertiary></indexterm><indexterm><primary>Qlist class</primary></indexterm><indexterm><primary>Qt</primary><secondary>classes</secondary><tertiary>QList</tertiary></indexterm><indexterm><primary>templates</primary><secondary>QList class</secondary></indexterm>class. It maintains lists. The items in the lists can be of any type.</para>
<para>The lists are so-called linked lists. This means that each list item stores a reference to the previous and the next list items.</para>
<section id="ch03lev3sec8">
<title>Important Member Functions</title>
<para>To append an item to the list, <indexterm><primary>functions</primary><secondary>QList class</secondary></indexterm>use the following:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void append(const type *<emphasis>item</emphasis>)
</programlisting>
</informalexample>
<para>To get the first item in the list, use the following:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
type *first()
</programlisting>
</informalexample>
<para>The first item becomes the current item.</para>
<para>To get the next item in the list, use</para>
<informalexample>
<programlisting linenumbering="unnumbered">
type *next()
</programlisting>
</informalexample>
<para>The next item becomes the current item.</para>
</section>
<section id="ch03lev3sec9">
<title>Sample Use of <literal>QList</literal></title>
<para><link linkend="ch03list10">Listing 3.10</link> shows how to use <literal>QList</literal>. I have created a simple class called <literal>MyClass</literal>. I use <literal>QList</literal> to keep a list of <literal>MyClass</literal> objects.</para>
<example role="codelisting" label="3.10" id="ch03list10">
<title>qlist.cpp: QList <indexterm><primary>listings</primary><secondary>QList class example</secondary></indexterm>Example</title>
<programlisting linenumbering="numbered">
 1: #include &lt;qlist.h>
 2: #include &lt;iostream.h>
 3: 
 4: class MyClass{
 5: public:
 6:   MyClass() { t=0; }
 7:   int get() { return t++; }
 8: private:
 9:   int t;
10: };
11: 
12: 
13: int main()
14: {
15:   QList&lt;MyClass> list;
16:   MyClass *temp;
17: 
18:   // Delete all list items, when the list is deleted.
19:   list.setAutoDelete(TRUE);
20: 
21:   for (int i=0;i&lt;3;i++)
23:     // Create a list item
24:     temp = new MyClass;
25: 
26:     // Append the list item to the list
27:     list.append(temp);
28: }
29: 
30:   // Call the member function get() in every list item,
31:   // and print the result on the screen.
32:   for (temp = list.first(); temp != 0; temp=list.next())
33:     cout &lt;&lt; temp.get() &lt;&lt; endl;
34: 
35:   return 0;
36: }
</programlisting>
</example>
<para>The list items in <literal>QList</literal> can be of any type. One possible use of <literal>QList</literal> is in a MDI program to keep a list of pointers to the windows.</para>
</section>
</section>
</section>
<section id="ch03lev1sec6">
<title>Special Features (ImageIO, OpenGL, Mesa)</title>
<para>There are some special features in Qt that you should know about. They provide you with special features that are not normally included with toolkits.</para>
<section id="ch03lev2sec15">
<title>ImageIO</title>
<para>This special feature <indexterm><primary>Qt</primary><secondary>ImageIO</secondary></indexterm><indexterm><primary>ImageIO</primary></indexterm>adds support for some image file formats. It opens and saves pictures for you.</para>
<section id="ch03lev3sec10">
<title>Using ImageIO</title>
<para>The ImageIO feature adds support for many graphics file formats. The <literal>QImage</literal> widget uses this feature to open and save graphics files.</para>
</section>
<section id="ch03lev3sec11">
<title>A Sample ImageIO Program</title>
<para><link linkend="ch03list11">Listing 3.11</link> shows you how it works. The program will open and display a JPEG image (shown in <link linkend="ch03fig05">Figure 3.5</link>):</para>
<example role="codelisting" label="3.11" id="ch03list11">
<title>imageio.cpp: An Image<indexterm><primary>listings</primary><secondary>ImageIO sample program</secondary></indexterm> Viewer Program</title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;qwidget.h>
 3: #include &lt;qpainter.h>  // The QPainter class draws graphics on widgets.
 4: #include &lt;qimage.h>
 5: 
 6: class MyWindow : public QWidget
 7: {
 8:   public:
 9:     // Constructor for the window, just call the QWidget constructor
10:     MyWindow() : QWidget() { }
11:   protected:
12:     void paintEvent(QPaintEvent *);
13: };
14: 
15: // This function is called when the window area must be updated.
16: // Load and view the image
17: void MyWindow::paintEvent(QPaintEvent *ev)
18: {
19:   // Load the image that we want to show
20:   QImage image;
21:   if (image.load("test.jpg", 0))  // If the image was loaded,
22:   {                               // Show the image.
23:     // Draw graphics in this window
24:     QPainter paint(this);
25:     // Draw the image we loaded on the window
26:     paint.drawImage(0, 0, image, 0, 0,
27:                     image.width(), image.height());
28:   }
29: }
30: 
31: 
32: int main(int argc, char **argv)
33: {
34:   KApplication app(argc, argv)
35:   // Create the window
36:   MyWindow window;
37:   app.setMainWidget(&amp;window);
38:   window.setCaption("ImageIO Example");
39:   window.setGeometry(100,100,300,300);
40:   window.show();
41:   return app.exec();
42: }
</programlisting>
</example>
<figure label="3.5" id="ch03fig05">
<title>Showing a JPEG Picture with ImageIO.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig05.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>To compile the program, use the following commands:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++ -c -I$QTDIR/include</emphasis> <emphasis role="bolditalic">imageio.cpp</emphasis>
<emphasis role="strong">g++ -o</emphasis> <emphasis role="bolditalic">iio imageio.o</emphasis> <emphasis role="strong">-L$QTDIR/lib -lqt -lqimgio -ljpeg</emphasis>
</programlisting>
</informalexample>
<para>This feature is useful in all programs that need to load or store pictures. Image viewers and paint programs are two kinds of programs that may benefit from ImageIO.</para>
</section>
</section>
<section id="ch03lev2sec16">
<title>OpenGL, Mesa</title>
<para>OpenGL is an API for 2D and<indexterm><primary>Qt</primary><secondary>OpenGL</secondary></indexterm><indexterm><primary>OpenGl</primary></indexterm><indexterm><primary>Mesa</primary></indexterm><indexterm><primary>Qt</primary><secondary>Mesa</secondary></indexterm> 3D graphics programming. It is quite useful, but you must buy a license before you may develop an OpenGL program.</para>
<para>Mesa is a free library with similar functions. You can compile and run most OpenGL programs with Mesa.</para>
<para>If you want to learn more about the OpenGL language, I recommend either the <citetitle>OpenGL</citetitle> Web <indexterm><primary>Web sites</primary><secondary>OpenGl</secondary></indexterm><indexterm><primary>Web sites</primary><secondary>Mesa</secondary></indexterm>site, <ulink url="http://www.opengl.org">(http://www.opengl.org)</ulink>, or the <citetitle>Mesa</citetitle> Web site, <ulink url="http://www.mesa3d.org">(http://www.mesa3d.org)</ulink>.</para>
<section id="ch03lev3sec12">
<title>The QGL Widget</title>
<para>If you want to create <indexterm><primary>widgets</primary><secondary>QGL</secondary></indexterm><indexterm><primary>QGL widget</primary></indexterm><indexterm><primary>OpenGL</primary><secondary>creating programs</secondary></indexterm>OpenGL programs, I recommend the <literal>QGL</literal> widget. <literal>QGL</literal> is a widget that enables OpenGL code in Qt programs. The OpenGL compatibility in QGL comes from Mesa. The <literal>QGL</literal> widget has three virtual member functions, into which you put your OpenGL code.<indexterm><primary>functions</primary><secondary>QGL widget</secondary></indexterm><indexterm><primary>initializeGL() function (QGL widget)</primary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>initializeGL()</literal> is called first. In this function you write the code that sets up the OpenGL rendering.</para></listitem>
<listitem><para><literal>paintGL()</literal> is called <indexterm><primary>paintGL() function (QGL widget)</primary></indexterm>when the graphics must be drawn. This is where you put all the code that draws things on the screen.</para></listitem>
<listitem><para><literal>resizeGL(int width, int height)</literal> is called <indexterm><primary>resiceGL(int width, int height) function (QGL widget)</primary></indexterm>when the widget is resized. If you want to respond to resize events, this is where you do it.</para></listitem></itemizedlist>
<note role="caution">
<para>You must install the<indexterm><primary>libraries</primary><secondary>Mesa</secondary></indexterm><indexterm><primary>libraries</primary><secondary>OpenGL</secondary></indexterm> Mesa or OpenGL libraries before you can use the OpenGL special feature in Qt. The Mesa libraries can be downloaded from <ulink url="http://www.mesa3d.org">http://www.mesa3d.org</ulink></para>
</note>
</section>
<section id="ch03lev3sec13">
<title>A Sample OpenGL Program</title>
<para><link linkend="ch03list12">Listing 3.12</link> demonstrates the OpenGL special feature.</para>
<example role="codelisting" label="3.12" id="ch03list12">
<title>main.cpp: <indexterm><primary>listings</primary><secondary>OpenGL program example</secondary></indexterm><indexterm><primary>OpenGL</primary><secondary>sample program (listing)</secondary></indexterm>OpenGL Program for Qt</title>
<programlisting linenumbering="unnumbered">
#include &lt;kapp.h>
#include &lt;qgl.h>

// The QGLWidget is a QWidget with support for OpenGL
class MyWindow : public QGLWidget
{
  public:
    MyWindow() : QGLWidget() { }
  protected:
    // The functions where you put your OpenGL code.
    void initializeGL();     // The start code for the widget
    void resizeGL(int, int); // The widget is resized
    void paintGL();          // Redraw the graphics.
};


void MyWindow::initializeGL()
{
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0.0, 10.0, 0.0, 10.0, -1.0, 1.0);
}
 
void MyWindow::paintGL()
{
  glClear(GL_COLOR_BUFFER_BIT);

  glColor3f(0.0, 0.1, 0.4);

  glBegin(GL_POLYGON);
  glVertex3f(3.0, 5.5, 0.0);
  glVertex3f(5.0, 8.0, 0.0);
  glVertex3f(7.0, 5.5, 0.0);
  glEnd();

  glBegin(GL_LINE_LOOP);
  glVertex3f(3.0, 4.5, 0.0);
  glVertex3f(5.0, 2.0, 0.0);
  glVertex3f(7.0, 4.5, 0.0);
  glEnd();

  glFlush();
}

void MyWindow::resizeGL(int w, int h)
{
  glViewport(0, 0, (GLint)w, (GLint)h);
}

// A standard main() function
int main(int argc, char **argv)
{
  KApplication app(argc, argv, "QGL");
  MyWindow window;
  window.setGeometry(100,100,300,200);
  window.setCaption("OpenGL extension");
  app.setMainWidget(&amp;window);
  window.show();
  return app.exec();
}
</programlisting>
</example>
<para>This sample program is shown in <link linkend="ch03fig06">Figure 3.6</link>.</para>
<figure label="3.6" id="ch03fig06">
<title>The OpenGL sample program.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/03fig06.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
</section>
</section>
<section id="ch03lev1sec7">
<title>Summary</title>
<para>KDE is based on Qt. Much of the code in KDE programs are Qt specific (using Qt widgets or features such as signals and slots), so you have to know Qt to be able to create KDE programs. It is highly recommended that you download the Qt reference from the official <citetitle>Trolltech</citetitle> Web site <ulink url="http://www.trolltech.com">(http://www.trolltech.com)</ulink>.</para>
<para>The base class in Qt is <literal>QObject</literal>. If your class has signals or slots, your class must inherit from <literal>QObject</literal>.</para>
<para><literal>QWidget</literal> is the base class for all visible classes.</para>
<para>Always use KDE widgets instead of Qt widgets when it's possible. That ensures that the look and feel of your KDE program is consistent with other KDE programs. Some features in KDE may also be better used by the KDE widgets.</para>
<para>You use signals and slots when you need to handle events. They are object independent. Each slot can respond to several signals. Several slots can respond to the same signal.</para>
<para>A widget that uses signals or slots does not have to be compiled with <literal>moc</literal>. The <literal>moc</literal> tool is only required when your class definition contains <literal>moc</literal> keywords. The <literal>moc</literal> keyword <literal>Q_OBJECT</literal> enables signals and slots.</para>
<para>Events handling is not the only use of signals and slots. Classes can use signals and slots for easy communication with each other. One example of this is when you have a program with several windows. It is common that the code for one window needs to execute some code for another window. This problem can be easily solved with signals and slots.</para>
<para>When you write MDI programs, the <literal>QList</literal> class may be used to store the window pointers.</para>
</section>
<section id="ch03lev1sec8">
<title>Exercises</title>
<para>Answers to the exercises can be found in <link linkend="ap-c">Appendix C</link>, <quote>Answers</quote>.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch03que01"><para><link linkend="ch03ans01">Write a program that shows an empty window.</link></para></question>
</qandaentry>
<qandaentry>
<question id="ch03que02"><para><link linkend="ch03ans02">Create a program that shows a window with a button in it.</link></para></question>
</qandaentry>
</qandaset>
</section>
</chapter>
