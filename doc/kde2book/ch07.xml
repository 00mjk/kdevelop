<chapter label="7" role="chapter" id="ch07">
<title>Further KDE Compliance</title>
<para><emphasis>by David Sweet</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In This Chapter</title>
<listitem><para><emphasis><link linkend="ch07lev1sec1">Drag and Drop</link></emphasis></para></listitem>
<listitem><para><emphasis><link linkend="ch07lev1sec2">Application Configuration Information</link></emphasis></para></listitem>
<listitem><para><emphasis><link linkend="ch07lev1sec3">Session Management</link></emphasis></para></listitem>
<listitem><para><emphasis><link linkend="ch07lev1sec4">Application Resources</link></emphasis></para></listitem>
<listitem><para><emphasis><link linkend="ch07lev1sec5">Network Transparency</link></emphasis></para></listitem>
</itemizedlist></highlights>
<para>Complying with KDE standards requires more than using the right widgets. Applications should offer drag-and-drop support, keep track of program options, cleanly handle session management, and make use of application resources such as translated text strings. Another important aspect of KDE compliance is called <emphasis>network transparency</emphasis>. <indexterm><primary>network transparency</primary></indexterm>This refers to allowing users to load and save remotely stored files as easily as local ones. Fortunately, the KDE libraries contain classes which simplify these tasks.</para>
<section id="ch07lev1sec1">
<title>Drag and Drop</title>
<para>Drag <indexterm><primary>drag and drop</primary></indexterm><indexterm><primary>GUIs</primary></indexterm><indexterm><primary>drag and drop</primary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary></indexterm> and drop is by now a familiar aspect of operating systems. The user clicks an object and, without releasing the mouse button, moves the mouse pointer (drags the object) to another position, and then releases the button (drops the object). Usually and icon is displayed under or near the mouse pointer that indicates what kind of data is being dragged and whether the current widget lying under the pointer is a valid drop <emphasis>target</emphasis>.</para>
<para>Drag and drop is used, for example, to move a file or folder from one folder to another. The user can also drag a file onto an open application and, if the file type is appropriate, expect the application to open the file for viewing or editing. In KDE, drag and drop is also used to place applications, (in the form of <literal>.desktop</literal> files, discussed in <quote>Application Resources</quote>) on the panel.</para>
<para>The Qt drag-and-drop system is based on XDND protocol. This is a publicly available drag-and-drop protocol and is used by GNOME/GTK+, Mozilla, Star Office, XEmacs, and other projects and applications. The drag types are described using public, standard MIME types, which means that drag data types should be identifiable even when the drag is coming from a non-Qt system. You can find more information about the <indexterm><primary>XDND protocol</primary></indexterm><indexterm><primary>protocols</primary><secondary>XDND</secondary></indexterm><indexterm><primary>drag and drop</primary><secondary>XDND protocol</secondary></indexterm><indexterm><primary>Web sites</primary><secondary>XDND protocol</secondary></indexterm>XDND protocol at <ulink url="http://www.cco.caltech.edu/~jafl/xdnd/">http://www.cco.caltech.edu/~jafl/xdnd/</ulink>.</para>
<para>KDE/Qt applications can also accept drops which have been dragged from Motif-based applications, such as Netscape Navigator, further integrating the user's desktop. (Currently, however, you cannot drag <emphasis>from</emphasis> a KDE/Qt program to a Motif program.)<indexterm><primary>drag and drop</primary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary></indexterm></para>
<section id="ch07lev2sec1">
<title>Responding to Drop Events</title>
<para>When<indexterm><primary>drag and drop</primary><secondary>responding to drop events</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>drop events</primary><secondary>responding to</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drop events</secondary></indexterm><indexterm><primary>responding to drop events</primary></indexterm> a user drags some data over a widget, a drag-enter event is generated. A drop generates a drop event. You can reimplement the <literal>QWidget</literal> handlers for these events to process drops.</para>
<para><link linkend="ch07list01">Listings 7.1</link> and <link linkend="ch07list02">7.2</link> show code for a widget called <literal>KDropDemo</literal>, which demonstrates how to process drop events.<indexterm><primary>KDropDemo widget</primary></indexterm></para>
<example role="codelisting" label="7.1" id="ch07list01">
<title>kdropdemo.h: Contains the Class Definition for the Widget <literal>KDropDemo</literal><indexterm><primary>KDropDemo widget</primary><secondary>kdropdemo.h class definition</secondary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>kdropdemo.h file (KDropDemo widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>kdropdemo.h</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KDROPDEMO_H__
 2: #define __KDROPDEMO_H__
 3:
 4:
 5: #include &lt;qlabel.h>
 6:
 7: /**
 8:  * KDropDemo
 9:  * Accepts dropped URLs.
10:  **/
11: class KDropDemo : public QLabel
12: {
13:  public:
14:   KDropDemo (QWidget *parent, const char *name=0);
15:
16:  protected:
17:   void dropEvent (QDropEvent *qdropevent);
18:   void dragEnterEvent (QDragEnterEvent *qdragenterevent);
19: };
20:
21: #endif<indexterm><primary>KDropDemo widget</primary><secondary>kdropdemo.h class definition</secondary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>kdropdemo.h file (KDropDemo widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>kdropdemo.h</tertiary></indexterm></programlisting>
</example>
<para><literal>KDropDemo</literal> inherits <literal>QLabel</literal>, but any subclass of <literal>QWidget</literal> can accept drops in the same way as presented here. You just need to reimplement <literal>dragEnterEvent()</literal> and <literal>dropEvent()</literal>, as shown in <link linkend="ch07list02">Listing 7.2</link>, to process the corresponding events.<indexterm><primary>drag and drop</primary><secondary>responding to drop events</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>drop events</primary><secondary>responding to</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drop events</secondary></indexterm><indexterm><primary>responding to drop events</primary></indexterm></para>
<example role="codelisting" label="7.2" id="ch07list02">
<title>kdropdemo.cpp: Contains the Class Declaration for the Widget <literal>KDropDemo</literal><indexterm><primary>KDropDemo widget</primary><secondary>kdropdemo.cpp class declaration</secondary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>kdropdemo.cpp file (KDropDemo widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>kdropdemo.cpp</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qdragobject.h>
 2:
 3: #include "kdropdemo.h"
 4:
 5: KDropDemo::KDropDemo (QWidget *parent, const char *name) :
 6:   QLabel (parent, name)
 7: {
 8:   setAcceptDrops(true);
 9:   setText ("---------------No drops yet.---------------");
10: }
11:
12: void
13: KDropDemo::dragEnterEvent (QDragEnterEvent *qdragenterevent)
14: {
15:   qdragenterevent->accept (QTextDrag::canDecode (qdragenterevent));
16: }
17:
18: void
19: KDropDemo::dropEvent (QDropEvent *qdropevent)
20: {
21:   QString text;
22:
23:   if (QTextDrag::decode (qdropevent, text))
24:     {
25:       setText (text);
26:     }
27: }<indexterm><primary>KDropDemo widget</primary><secondary>kdropdemo.cpp class declaration</secondary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>kdropdemo.cpp file (KDropDemo widget)</primary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>kdropdemo.cpp</tertiary></indexterm></programlisting>
</example>
<para>First, you need to tell Qt that you want to accept drops by calling <literal>setAcceptDrops(true)</literal> <indexterm><primary>setAcceptDrops() function</primary></indexterm><indexterm><primary>functions</primary><secondary>setAcceptDrops()</secondary></indexterm>in line 8. This instructs Qt to generate drag-enter and drop events for your application. Before you get a drop event for any given particular data type, you also need to announce that you are interested in it. You do this in the method <literal>dragEnterEvent()</literal>. <indexterm><primary>dragEnterEvent() function</primary></indexterm><indexterm><primary>functions</primary><secondary>dragEnterEvent()</secondary></indexterm>The method <literal>QDragEnterEvent::accept()</literal> is called to tell Qt that you are interested in some data type. Line 15 says you are interested in receiving text drops.<indexterm><primary>drag and drop</primary><secondary>responding to drop events</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>drop events</primary><secondary>responding to</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drop events</secondary></indexterm><indexterm><primary>responding to drop events</primary></indexterm></para>
<para>You can determine whether the data is actually text by calling the static method <literal>QTextDrag::canDecode()</literal> <indexterm><primary>canDecode() function</primary></indexterm><indexterm><primary>functions</primary><secondary>canDecode()</secondary></indexterm>with the pointer to the instance of <literal>QDragEnterEvent</literal> as an argument in the method <literal>dropEvent()</literal> (see lines 18&ndash;27). This makes the process somewhat transparent. Qt contains classes that support text (<literal>QTextDrag</literal>) and images (<literal>QImageDrag</literal>). To accept drags of other types, you need to examine the data's MIME type (returned by the methods <literal>QDragObject::provides()</literal> or <literal>QDragObject::format()</literal>). If you plan to drag and drop custom data types within an application, you will need to create subclasses of <literal>QDragObject</literal>, which will hold data of your custom types.</para>
<para>In <literal>dropEvent()</literal>, <indexterm><primary>dropEvent() function</primary></indexterm><indexterm><primary>functions</primary><secondary>dropEvent()</secondary></indexterm>you do the interesting work. You decode the data into a <literal>QString</literal> using <literal>QTextDrag</literal> (line 23) and change the text of the <literal>QLabel</literal> to the new <literal>QString</literal>.</para>
<para><link linkend="ch07list03">Listing 7.3</link> presents a simple <literal>main()</literal> function that you can use to try out <literal>KDropDemo</literal>.</para>
<example role="codelisting" label="7.3" id="ch07list03">
<title>main.cpp: Contains a <literal>main()</literal> Function Suitable for Testing the <literal>KDropDemo</literal> Widget<indexterm><primary>KDropDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>main() function</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KDropDemo widget</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>main() function</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kdropdemo.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "kdropdemotest");
 9:   KDropDemo kdropdemo (0);
10:
11:   kdropdemo.show();
12:   kapplication.setMainWidget (&amp;kdropdemo);
13:  return  kapplication.exec();
14: }<indexterm><primary>KDropDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>main() function</primary><secondary>KDropDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KDropDemo widget</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KDropDemo widget</secondary><tertiary>main() function</tertiary></indexterm>
</programlisting>
</example>
<para>You can try this widget out by dragging a file from <literal>konqueror</literal> to the window. The URL of the file will be displayed in the widget. (You may have to enlarge the window to see the entire URL.) <link linkend="ch07fig01">Figure 7.1</link> shows the results of this drag-and-drop action.<indexterm><primary>drag and drop</primary><secondary>responding to drop events</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>responding to drop events</tertiary></indexterm><indexterm><primary>drop events</primary><secondary>responding to</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drop events</secondary></indexterm><indexterm><primary>responding to drop events</primary></indexterm></para>
<figure label="7.1" id="ch07fig01">
<title><literal>KDropDemo</literal> accepts text drop events and displays the data contained in them. Here it has just accepted a URL drop from Konqueror.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/07fig01.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
<section id="ch07lev2sec2">
<title>Starting a Drag</title>
<para>The <indexterm><primary>drag and drop</primary><secondary>starting a drag</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>starting</primary><secondary>drag events</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drag events</secondary></indexterm><indexterm><primary>drag events</primary><secondary>starting</secondary></indexterm>problem with starting a drag lies not in informing Qt that you would like it to be done, but in informing the user that it is possible. How can you do this?</para>
<para>The draggable objects in Konqueror are the icons representing the files or folders. This is a common enough situation (in terms of file managers) that many users are familiar with.</para>
<para>Netscape Navigator 4.51 places a small icon on the toolbar that is draggable and represents the page being viewed. To inform the user that they can drag this icon, a message saying so is placed in the statusbar whenever the user passes the mouse pointer over the icon. Also, a ToolTip pops up to again inform the user that the icon is draggable. (These types of help messages are discussed in the next section.)</para>
<para>The next example shows how to start the drag process. (Because this widget is not presented in the context of an application, this example will focus on dragging and not on the problem of informing the user that the widget is a place to start dragging.)</para>
<para><link linkend="ch07list04">Listings 7.4</link>&ndash;<link linkend="ch07list06">7.6</link> show code that demonstrates how to start a drag event.</para>
<example role="codelisting" label="7.4" id="ch07list04">
<title>kdragdemo.h: Contains a Class Declaration for the Widget <literal>KDragDemo</literal><indexterm><primary>KDragDemo widget</primary><secondary>kdragdemo.h class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>kdragdemo.h class definition</tertiary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>kdragdemo.h file (KDragDemo widget)</primary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KDRAGDEMO_H__
 2: #define __KDRAGDEMO_H__
 3:
 4:
 5: #include &lt;qlabel.h>
 6:
 7: /**
 8:  * KDragDemo
 9:  *
10:  **/
11: class KDragDemo : public QLabel
12: {
13:  public:
14:   KDragDemo (QWidget *parent, const char *name=0);
15:
16:  protected:
17:   bool dragging;
18:
19:   void mouseMoveEvent (QMouseEvent *qmouseevent);
20:   void mouseReleaseEvent (QMouseEvent *qmouseevent);
21: };
22:
23: #endif<indexterm><primary>KDragDemo widget</primary><secondary>kdragdemo.h class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>kdragdemo.h class definition</tertiary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>kdragdemo.h file (KDragDemo widget)</primary></indexterm></programlisting>
</example>
<para>In the nomenclature of XDND, the widget you are creating is a drag <emphasis>source</emphasis>. You can drag the text to any target that accepts text drops, such as <literal>kdropdemotest</literal>.<indexterm><primary>drag and drop</primary><secondary>starting a drag</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>starting</primary><secondary>drag events</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drag events</secondary></indexterm><indexterm><primary>drag events</primary><secondary>starting</secondary></indexterm></para>
<para>Again, we derive from <literal>QLabel</literal> but note that the technique presented here is valid for any subclass of <literal>QWidget</literal>.</para>
<example role="codelisting" label="7.5" id="ch07list05">
<title>kdragdemo.cpp: Contains a Class Definition for the Widget <literal>KDragDemo</literal><indexterm><primary>KDragDemo widget</primary><secondary>kdragdemo.cpp class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>kdragdemo.cpp class declaration</tertiary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>kdragdemo.cpp file (KDragDemo widget)</primary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qdragobject.h>
 2:
 3: #include &lt;kglobalsettings.h>
 4:
 5: #include "kdragdemo.h"
 6:
 7:
 8: KDragDemo::KDragDemo (QWidget *parent, const char *name) :
 9:   QLabel (parent, name)
10: {
11:   setText ("This is draggable text.");
12: }
13:
14:
15: void
16: KDragDemo::mousePressEvent (QMouseEvent *qmouseevent)
17: {
18:   startposition = qmouseevent->pos();
19: }
20:
21: void
22: KDragDemo::mouseMoveEvent (QMouseEvent *qmouseevent)
23: {
24:   int mindragdist = KGlobalSettings::dndEventDelay();
25:
26:   if (qmouseevent->state()&amp;Qt::LeftButton
27:       &amp;&amp;(   qmouseevent->pos().x() > startposition.x() + mindragdist
28:       || qmouseevent->pos().x() &lt; startposition.x() - mindragdist
29:       || qmouseevent->pos().y() > startposition.y() + mindragdist
30:       || qmouseevent->pos().y() &lt; startposition.y() - mindragdist) )
31:     {
32:       QTextDrag *qtextdrag = new QTextDrag( text(), this);
33:       qtextdrag->dragCopy();
34:     }
35: }<indexterm><primary>KDragDemo widget</primary><secondary>kdragdemo.cpp class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>kdragdemo.cpp class declaration</tertiary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>kdragdemo.cpp file (KDragDemo widget)</primary></indexterm>
</programlisting>
</example>
<para>In the constructor, you set the text to be displayed in the window. The start of a drag is defined as when the user holds down the left mouse button and moves the mouse more than a certain number of pixels. That certain number is used in all KDE applications (to give them a consistent feel) and is returned by the static function <literal>KGlobalSettings::dndEventDelay()</literal>. You can implement this behavior by first saving the position at which the user first clicks the mouse, on line 18, in the method <literal>mousePressEvent()</literal>. Then, in the method  <literal>mouseMoveEvent()</literal> check <literal>QMouseEvent::state()</literal> (line 26) to see whether the mouse button is being held down&mdash;in which case the bit given by <literal>Qt::LeftButton</literal> will be set in <literal>QMouseEvent()::stat()</literal>&mdash;and see whether the user has moved more than <literal>KGlobalSettings::dndEventDelay()</literal> pixels in any direction from <literal>startposition</literal>. The first time this happens, you create a <literal>QTextDrag</literal> (derived from <literal>QDragObject</literal>) object (line 20). This object handles the communication with potential XDND targets and, since it is owned by Qt, don't delete it at any point.</para>
<para>On line 33, you indicate to the <literal>QTextDrag</literal> object that you want to allow drag-and-drop operations that result in the data being copied to the target. The types of operations are</para>
<itemizedlist mark="none" spacing="compact">
<listitem><para><literal>DragCopy</literal><indexterm><primary>DragCopy operations</primary></indexterm></para>
<para>Copy the data from the source to the target.</para></listitem>
<listitem><para><literal>DragMove</literal><indexterm><primary>DragMove operations</primary></indexterm></para>
<para>Copy the data from the source to the target, and remove it from the source.</para></listitem>
<listitem><para><literal>DragDefault</literal><indexterm><primary>DragDefault operations</primary></indexterm></para>
<para>The mode is determined by Qt.</para></listitem>
<listitem><para><literal>DragCopyOrMove</literal><indexterm><primary>DragCopyOrMove operations</primary></indexterm></para>
<para>The default mode is used unless the user holds down the control key while dragging.<indexterm><primary>drag and drop</primary><secondary>starting a drag</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>starting</primary><secondary>drag events</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drag events</secondary></indexterm><indexterm><primary>drag events</primary><secondary>starting</secondary></indexterm></para></listitem></itemizedlist>
<para>These are constants of type <literal>DragMode</literal> and are defined in qdragobject.h. To use them, call <literal>QDragObject::drag()</literal> (with a <literal>DragMode</literal> as an argument instead of <literal>dragCopy())</literal>.</para>
<para>To avoid creating more instances of <literal>QTextDrag</literal> for each of the subsequent mouse-move events you should expect to receive, set the flag <literal>dragging</literal> to <literal>true</literal> and avoid starting new drags while this flag is still <literal>true</literal>. Reset it to <literal>false</literal> after the user releases the mouse button. This indicates the end of the drag operation regardless of whether the drop was successful.</para>
<para><link linkend="ch07list06">Listing 7.6</link> is a <literal>main()</literal> function, which you can use to create a simple program, kdragdemotest, which you can use to test the <literal>KDragDemo</literal> widget. You can try kdragdemotest by dragging to kdropdemotest. You can also drag to KEdit or Konsole. <link linkend="ch07fig02">Figure 7.2</link> shows kdragdemotest.<indexterm><primary>drag and drop</primary><secondary>starting a drag</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>starting</primary><secondary>drag events</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drag events</secondary></indexterm><indexterm><primary>drag events</primary><secondary>starting</secondary></indexterm></para>
<figure label="7.2" id="ch07fig02">
<title>kdragdemotest shows some draggable text. You can drag the text starting from anywhere inside the widget to a suitable target, such as kdropdemotest.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/07fig02.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="7.6" id="ch07list06">
<title>main.cpp: Contains a <literal>main()</literal> Function Suitable for Testing <literal>KDragDemo</literal><indexterm><primary>KDragDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KDragDemo widget</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kdragdemo.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "kdragdemotest");
 9:   KDragDemo kdragdemo (0);
10:
11:   kdragdemo.show();
12:   kapplication.setMainWidget (&amp;kdragdemo);
13:   return kapplication.exec();
14: }<indexterm><primary>drag and drop</primary><secondary>starting a drag</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>navigation</primary><secondary>drag and drop</secondary><tertiary>starting a drag</tertiary></indexterm><indexterm><primary>starting</primary><secondary>drag events</secondary></indexterm><indexterm><primary>event handling</primary><secondary>drag events</secondary></indexterm><indexterm><primary>drag events</primary><secondary>starting</secondary></indexterm><indexterm><primary>KDragDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KDragDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KDragDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KDragDemo widget</tertiary></indexterm>
</programlisting>
</example>
</section>
</section>
<section id="ch07lev1sec2">
<title>Application Configuration Information</title>
<para>Configuration <indexterm><primary>application configuration files</primary></indexterm><indexterm><primary>configuration files</primary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary></indexterm>information for KDE applications is stored in human-readable text files in a standard format. An example is shown in <link linkend="ch07list07">Listing 7.7</link>. Applications generally store user settings, such as the name of a mail server or the number of times to try connecting to a site before giving up and user preferences for things such as UI layout and colors. The files are stored as human-readable text so that users and administrators can read and modify these files with any text editor. These files offer advantages over the binary-format configuration files used on some other systems:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>You can automate configuration and reconfiguration (from scripts, for example).</para></listitem>
<listitem><para>The files are safer from corruption. Having a few small errors in a file such as the one in <link linkend="ch07list07">Listing 7.7</link> is unlikely to make it unreadable to a human. The human can correct these errors so that the application can read the file. Small errors in a compact, binary format may destroy information and make the file unusable by the application.</para></listitem></itemizedlist>
<para>KDE configuration files store information as Key, Value pairs as shown in <link linkend="ch07list07">Listing 7.7</link> One pair appears per line.<indexterm><primary>application configuration files</primary><secondary>example of</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>example of</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>example of</tertiary></indexterm></para>
<example role="codelisting" label="7.7" id="ch07list07">
<title>A Sample KDE Application Configuration File<indexterm><primary>listings</primary><secondary>application configuration file example</secondary></indexterm></title>
<programlisting linenumbering="numbered">
1: #KDE Config File
2: DefaultHeight=300
3: [Options]
4: BackgroundColor=255,255,255
5: ForegroundColor=100,100,255
</programlisting>
</example>
<para>The pairs can be grouped to help organize the information for the application or to make the file more readable. Group names appear in brackets alone on a line preceding the group they label (line 3). <indexterm><primary>application configuration files</primary><secondary>example of</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>example of</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>example of</tertiary></indexterm></para>
<para>The files can also include comments. Comments appear on lines starting with a <literal># (line 1)</literal>.</para>
<para>KDE <indexterm><primary>application configuration files</primary></indexterm> configuration files are stored in .kde/share/config in the user's home directory. Each application creates a configuration file called <emphasis>kappnamerc</emphasis>, where <emphasis>kappname</emphasis> is the name of the application. For example, knotes creates knotesrc.</para>
<section id="ch07lev2sec3">
<title>Accessing Configuration Files</title>
<para>Configuration<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files;accessing</primary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm> files are read and written with the <literal>KConfig</literal> class. The default configuration file, <emphasis>kappnamerc</emphasis>, can be accessed with the <literal>KConfig</literal> object returned by the method <literal>KApplication::config()</literal>. You typically access this object with <literal>kapp->config()</literal>. (<literal>kapp</literal> is a macro defined in kapp.h that returns a pointer to the current <literal>KApplication</literal> object. A KDE application uses only one <literal>KApplication</literal> object; therefore, <literal>kapp</literal> can reliably be used from any source-code file that is part of your application.)</para>
<para><link linkend="ch07list08">Listings 7.8</link> and <link linkend="ch07list09">7.9</link> show the code for <literal>KConfigDemo</literal>, a widget that demonstrates the use of <literal>KConfig</literal>.<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm></para>
<example role="codelisting" label="7.8" id="ch07list08">
<title>kconfigdemo.h: Class Declaration for <literal>KConfigDemo</literal>, a widget that demonstrates <literal>KConfig</literal><indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>kconfigdemo.h class declaration</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>kconfigdemo.h class declaration</secondary></indexterm><indexterm><primary>kconfigdemo.h file (KConfigDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KConfigDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KCONFIGDEMO_H__
 2: #define __KCONFIGDEMO_H__
 3:
 4: #include &lt;qlineedit.h>
 5:
 6: /**
 7:  * KConfigDemo
 8:  * Show how to access KDE configuration files with KConfig.
 9:  **/
10: class KConfigDemo : public QLineEdit
11: {
12:  public:
13:   KConfigDemo ();
14:
15:  protected:
16:   void closeEvent (QCloseEvent *qcloseevent);
17:
18: };
19:
20: #endif<indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>kconfigdemo.h class declaration</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>kconfigdemo.h class declaration</secondary></indexterm><indexterm><primary>kconfigdemo.h file (KConfigDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KConfigDemo widget</secondary></indexterm>
</programlisting>
</example>
<para><literal>KConfigDemo</literal> is a line editor widget that saves its text in a configuration file when the user closes the window, and it reloads it the next time the program is run.<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm></para>
<para><literal>KConfigDemo</literal> is subclassed from <literal>QLineEdit</literal>, which does most of the work for you. You just need to add the configuration file access.</para>
<example role="codelisting" label="7.9" id="ch07list09">
<title>kconfigdemo.cpp: Class Definition for <literal>KConfigDemo</literal><indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>kconfigdemo.cpp class definition</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>kconfigdemo.cpp class definition</secondary></indexterm><indexterm><primary>kconfigdemo.cpp file (KConfigDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KConfigDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;kconfig.h>
 3:
 4: #include "kconfigdemo.h"
 5:
 6: KConfigDemo::KConfigDemo () : QLineEdit (0)
 7: {
 8:   kapp->config()->setGroup ("LineEditor");
 9:   setText (kapp->config()->readEntry ("Text", "Hello"));
10: }
11:
12: void
13: KConfigDemo::closeEvent (QCloseEvent *qcloseevent)
14: {
15:   kapp->config()->setGroup ("LineEditor");
16:   kapp->config()->writeEntry ("Text", text());
17:   kapp->config()->sync();
18:
19:   qcloseevent->accept();
20: }<indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>kconfigdemo.cpp class definition</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>kconfigdemo.cpp class definition</secondary></indexterm><indexterm><primary>kconfigdemo.cpp file (KConfigDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KConfigDemo widget</secondary></indexterm></programlisting>
</example>
<para>In the constructor, you look in the group <literal>LineEditor</literal> (line 8) for the key <literal>Text</literal> (line 9). (Note: If you had not specified a group with <literal>setGroup()</literal>, the Key, Value pair would have been written to the default, unnamed group.) <literal>readEntry()</literal> returns the value found to the right of <literal>Text=</literal> in the configuration file as a <literal>QString</literal>. In the event that the key <literal>Text</literal> does not appear at all&mdash;as is the case when the program is run for the first time&mdash;<literal>readEntry()</literal> returns <literal>Hello</literal>, the value specified as the default (line 9).<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm></para>
<para>You want to save the text when the user closes the window. To do this, reimplement the virtual method <literal>closeEvent()</literal>. This method is called when a close request is made, but before the window is actually closed. In this method, place the text of the widget (returned by <literal>text()</literal>) to the configuration file into the group <literal>LineEditor</literal>. The call on line 17 is very important. This call actually writes the new configuration information to disk.</para>
<note role="caution">
<para><literal>KConfig</literal> caches the information in memory until the method <literal>KConfig::sync()</literal> is called, so be sure to call it before your application exits or else your settings will be lost.</para>
</note>
<para>Finally, call <literal>qcloseevent->accept()</literal>, which lets Qt know that the widget is willing to grant the user's request and be closed.<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm></para>
<para><link linkend="ch07list10">Listing 7.10</link> is for a <literal>main()</literal> function that you can use to test <literal>KConfigDemo</literal>. <link linkend="ch07fig03">Figure 7.3</link> shows the program that is created&mdash;kconfigdemotest&mdash;running.</para>
<example role="codelisting" label="7.10" id="ch07list10">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Testing <literal>KConfigDemo</literal><indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>main() function</primary><secondary>KConfigDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KConfigDemo widget</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kconfigdemo.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "kconfigdemotest");
 9:
10:   KConfigDemo *kconfigdemo = new KConfigDemo;
11:
12:   kapplication.setMainWidget (kconfigdemo);
13:
14:   kconfigdemo->show();
15:   return kapplication.exec();
16: } <indexterm><primary>listings</primary><secondary>KConfigDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>KConfigDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>main() function</primary><secondary>KConfigDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KConfigDemo widget</tertiary></indexterm></programlisting>
</example>
<para><literal>KConfig</literal> can read and write many types of data, not just strings. For example, in the next section you read and write a <literal>QFont</literal>. The supported types are listed in the documentation (and header file) for <literal>KConfigBase</literal>.<indexterm><primary>application configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>configuration files</primary><secondary>accessing</secondary></indexterm><indexterm><primary>files</primary><secondary>application configuration files</secondary><tertiary>accessing</tertiary></indexterm><indexterm><primary>accessing</primary><secondary>application configuration files</secondary></indexterm></para>
<figure label="7.3" id="ch07fig03">
<title>KConfigDemo saves the text you enter in its configuration file.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/07fig03.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
</section>
<section id="ch07lev1sec3">
<title>Session Management</title>
<para>We <indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm> touched on session management in <link linkend="ch02">Chapter 2 <quote>A Simple KDE Application.</quote></link> You created <literal>KSimpleApp</literal> and endowed it with the capability to be restarted and maintain its position and size across sessions. (<emphasis>Session</emphasis> refers to the time between logging in and logging out.) Actually, this functionality was provided by <literal>KTMainWindow</literal> from which the class <literal>KSimpleApp</literal> was derived.</para>
<para>In general, you'll want to save more information across sessions than just the window position and size. <literal>KTMainWindow</literal> offers the virtual methods <indexterm><primary>saveProperties() function</primary></indexterm><indexterm><primary>functions</primary><secondary>saveProperties()</secondary></indexterm><literal>saveProperties()</literal> and <literal>readProperties()</literal> <indexterm><primary>readProperties() function</primary></indexterm><indexterm><primary>functions</primary><secondary>readProperties()</secondary></indexterm>for this purpose. Also, you will want to save the user's data (or at least offer this option) before a session exits. You reimplement the virtual method <literal>queryClose()</literal><indexterm><primary>queryClose() function</primary></indexterm><indexterm><primary>functions</primary><secondary>queryClose()</secondary></indexterm> to do this. Listings 7.11&ndash;7.13 show the source code for KSaveAcross, an application that demonstrates these features.<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm></para>
<example role="codelisting" label="7.11" id="ch07list11">
<title>ksaveacross.h: Class Declaration for <literal>KSaveAcross</literal>, a Widget That Demonstrates Session Management Features of <literal>KTMainWindow</literal><indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.h class declaration</tertiary></indexterm><indexterm><primary>ksaveacross.h file (KSaveAcross widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KSAVEACROSS_H__
 2: #define __KSAVEACROSS_H__
 3:
 4: #include &lt;ktmainwindow.h>
 5:
 6: /**
 7:  * KSaveAcross
 8:  * This application saves its data across sessions. Its data is
 9:  *  the contents of a QLineEdit.
10:  **/ <indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.h class declaration</tertiary></indexterm><indexterm><primary>ksaveacross.h file (KSaveAcross widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm>
11: class KSaveAcross : public KTMainWindow
12: {
13:  Q_OBJECT
14:  public:
15:   KSaveAcross (const char *name=0);
16:
17:  public slots:
18:    /**
19:     * Change the font used by qlineedit.
20:     **/<indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.h class declaration</tertiary></indexterm><indexterm><primary>ksaveacross.h file (KSaveAcross widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm>
21:   void slotChangeFont();
22:
23:  protected:
24:   QLineEdit *qlineedit;
25:
26:   /**
27:    * Ask the user if he/she wants to save the document.
28:    **/
29:   bool queryClose();
30:
31:   /**
32:    * Save the chosen font.
33:    **/
34:   void saveProperties (KConfig *kconfig);
35:   /**
36:    * Read the chosen font.
37:    **/
38:   void readProperties (KConfig *kconfig);
39:
40: };
41:
42: #endif<indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.h class declaration</tertiary></indexterm><indexterm><primary>ksaveacross.h file (KSaveAcross widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm></programlisting>
</example>
<para>The content area of the <literal>KSaveAcross</literal> widget is a <literal>QLineEdit</literal> widget. The menubar offers two choices: change the font used by the <literal>QLineEdit</literal> widget or quit the application. The font chosen by the user is saved across sessions.<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm></para>
<example role="codelisting" label="7.12" id="ch07list12">
<title>ksaveacross.cpp: Class Definition for <literal>KSaveAcross</literal><indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.cpp class definition</tertiary></indexterm><indexterm><primary>ksaveacross.cpp file (KSaveAcross widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2: #include &lt;kfontdialog.h>
 3: #include &lt;kstdaction.h>
 4: #include &lt;kaction.h>
 5: #include &lt;kmessagebox.h>
 6: #include &lt;kconfig.h>
 7:
 8: #include "ksaveacross.moc"
 9:
10:
11: KSaveAcross::KSaveAcross (const char *name)
12: {
13:   KStdAction::quit (kapp, SLOT (closeAllWindows()),
14:                actionCollection());
15:
16:   new KAction ("Change Font&hellip;", 0, this, SLOT(slotChangeFont()),
17:           actionCollection(), "change_font");
18:   createGUI();
19:
20:   qlineedit = new QLineEdit (this);
21:
22:   setView (qlineedit);
23: }
24:
25: void
26: KSaveAcross::slotChangeFont()
27: {
28:   QFont qfont = qlineedit->font();
29:
30:   if (KFontDialog::getFont (qfont))
31:     qlineedit->setFont(qfont);
32: }
33:
34: bool
35: KSaveAcross::queryClose()
36: {
37: <indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm> <indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.cpp class definition</tertiary></indexterm><indexterm><primary>ksaveacross.cpp file (KSaveAcross widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm>
38:
39:   const int yes=0, no=1, cancel=2;
40:   int yesnocancel;
41:
42:   yesnocancel =<indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.cpp class definition</tertiary></indexterm><indexterm><primary>ksaveacross.cpp file (KSaveAcross widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm>
43:     KMessageBox::
44:     questionYesNo (this, "Save changes to document?", "ksaveacross");
45:
46:   switch (yesnocancel)
47:     {
48:     case (yes):
49:       //You would save the document here and let the application exit.
50:       return true;
51:     case (no):
52:       //Let the application exit without saving the document.
53:       return true;
54:     case (cancel):
55:       //Don't save, but don't let the application exit.
56:       return false;
57:     }
58: }
59:
60:
61: void
62: KSaveAcross::saveProperties (KConfig *kconfig)
63: {
64:   kconfig->writeEntry ("LineEditorFont", qlineedit->font());
65:   kconfig->sync();
66: }
67:
68: void
69: KSaveAcross::readProperties (KConfig *kconfig)
70: {
71:   qlineedit->setFont (kconfig->readFontEntry ("LineEditorFont"));
72: }<indexterm><primary>KSaveAcross widget</primary><secondary>ksaveacross.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>ksaveacross.cpp class definition</tertiary></indexterm><indexterm><primary>ksaveacross.cpp file (KSaveAcross widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KSaveAcross widget</secondary></indexterm></programlisting>
</example>
<para>The method <indexterm><primary>saveProperties() function</primary></indexterm><indexterm><primary>functions</primary><secondary>saveProperties()</secondary></indexterm><literal>saveProperties()</literal> (lines 61&ndash;66) is called just before the application is terminated by the session manager. If the user quits the application normally, the method is not called. When the session manager restarts the application at the beginning of the next session, the method <indexterm><primary>readProperties() function</primary></indexterm><indexterm><primary>functions</primary><secondary>readProperties()</secondary></indexterm><literal>readProperties()</literal> is called. In these methods, you should save and read in properties that describe the current state of the application but that may not be saved in or specified in the configuration file. A Web browser, for example, might save the URL of the current page in the method <literal>saveProperties()</literal>, although it wouldn't want to store this in the configuration file.<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm></para>
<para><literal>saveProperties()</literal> and <literal>readProperties()</literal> work with <literal>KConfig</literal> objects. These <literal>KConfig</literal> objects do not operate on the default application configuration file. Instead, they operate on instance-specific configuration files created solely for the purpose of saving this session. The reading and writing methods were described in the previous section. Don't forget to call <literal>kconfig->sync()</literal> (line 65) at the end of <literal>saveProperties()</literal> to write the information to disk.</para>
<para>Before the application exits, it should ask the user whether he or she wishes to save the current document. If the application does this in the method <literal>queryClose()</literal> (a virtual method of the class <literal>KTMainWindow</literal>), the question is asked whether the application is closed by the user or by the session manager.</para>
<para>If <literal>queryClose()</literal> returns <literal>3false</literal>, the application does not exit. The reimplementation of <literal>queryClose()</literal> in <literal>KSaveAcross</literal> (line 34&ndash;58) presents the user with the choices Yes, No, and Cancel as answers to the question, <quote>Save changes to document?</quote> If the user answers Yes or No, <literal>queryClose()</literal> returns <literal>true</literal>, letting the application exit. If the user chooses Cancel, <literal>queryClose()</literal> returns <literal>false</literal> and the user can continue working.<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm></para>
<note role="normal">
<para>You'll need to create a file called ksaveacrossui.rc and place it in the directory $KDEDIR/share/apps/ksaveacross as explained in <link linkend="ch05">Chapter 5, <quote>KDE User Interface Compliance</quote></link>. A usable version of ksaveacrossui.rc is included with the code on this book's Web site.</para></note>
<para><link linkend="ch07list13">Listing 7.13</link> provides the <literal>main()</literal> function needed to create and start this application. Notice that I have included the session management code (lines 9&ndash;15), which was discussed in <link linkend="ch02">Chapter 2</link>. <link linkend="ch07fig04">Figure 7.4</link> shows running KSaveAcross.<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm></para>
<para>To create an executable, you'll need the code in <link linkend="ch07list13">Listing 7.13</link>, and you'll need to place the GUI file, ksaveacrossui.rc (found on this book's web site), in  the directory $KDEDIR/share/ kstatusbardemo.</para>
<example role="codelisting" label="7.13" id="ch07list13">
<title>main.cpp: A <literal>main()</literal> Function Suitable for Testing <literal>KSaveAcross</literal><indexterm><primary>KSaveAcross widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KSaveAcross widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KSaveAcross widget</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "ksaveacross.h"
 4:
 5: int
 6: main (int argc, char *argv[])/
 7: {
 8:   KApplication kapplication (argc, argv, "ksaveacross");
 9:
10:   if (kapplication.isRestored())<indexterm><primary>KSaveAcross widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KSaveAcross widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KSaveAcross widget</tertiary></indexterm>
11:       RESTORE(KSaveAcross)
12:   else
13:   {
14:     KSaveAcross *ksaveacross = new KSaveAcross;
15:     ksaveacross->show();
16:   }
17:
18:   return kapplication.exec();
19: }<indexterm><primary>session management</primary></indexterm><indexterm><primary>managing</primary><secondary>sessions</secondary></indexterm><indexterm><primary>KSaveAcross widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSaveAcross widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KSaveAcross widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KSaveAcross widget</tertiary></indexterm></programlisting>
</example>
<figure label="7.4" id="ch07fig04">
<title>KSaveAcross saves its options across sessions and offers to save the user's data before it is closed.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/07fig04.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
<section id="ch07lev1sec4">
<title>Application Resources</title>
<para>Applications often need to internally use data that is stored outside the program source code. You might choose to keep data outside the source code because it is large or subject to change. Such data, called application resources, might include icons, pixmaps, sounds, text strings, and documentation.</para>
<section id="ch07lev2sec4">
<title>Standard Resource Locations</title>
<para>By <indexterm><primary>resources</primary><secondary>standard resource locations</secondary></indexterm><indexterm><primary>application resources</primary><secondary>standard resource locations</secondary></indexterm><indexterm><primary>standard resource locations</primary></indexterm> default, global application resources are stored in the directory trees rooted at $KDEDIR/share and .kde/share (the latter being in the user's home directory). These subdirectories may exist in either place, and applications should make use of both sets of resources. Application-specific resources are stored in the subdirectory apps/<emphasis>kappname</emphasis> (where <emphasis>kappname</emphasis> is an application's name). These default locations can be modified by the user. The user can set the <literal>KDEDIRS</literal> (note the trailing <quote>S</quote> in this variable name) to contain a colon-separated list of directories under which the share subdirectory could lie. For example, the default setting is functionally equivalent to setting <literal>KDEDIRS</literal> equal to <literal>$KDEDIR:$HOME/.kde</literal> (where <literal>$HOME</literal> refers to the user's home directory).<indexterm><primary>resources</primary><secondary>standard resource locations</secondary></indexterm><indexterm><primary>application resources</primary><secondary>standard resource locations</secondary></indexterm><indexterm><primary>standard resource locations</primary></indexterm></para>
</section>
<section id="ch07lev2sec5">
<title>Application Resources</title>
<para>Applications <indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm>never need to specify full paths to resources or even be concerned with whether they are using resources from $KDEDIR/share or .kde/share. They can use the class <literal>KStandardDirs</literal> to locate resources by resource type. <link linkend="ch07table01">Table 7.1</link> summarizes the resource types that are supported by the <literal>KStandardDirs</literal> class. The subdirectory may lie in $KDEDIR or in .kde in the user's home directory.</para>
<table id="ch07table01" frame="topbot" label="7.1">
<title>Resource Types Supported by <literal>KStandardDirs</literal> Class<indexterm><primary>resources</primary><secondary>types</secondary></indexterm><indexterm><primary>application resources</primary><secondary>types</secondary></indexterm></title>
<tgroup cols="3" align="left" colsep="0" rowsep="0">
<colspec colname="c1"/>
<colspec colname="c2"/>
<colspec colname="c3"/>
<thead valign="top">
<row rowsep="1">
<entry><emphasis>Identifier</emphasis></entry>
<entry><emphasis>Subdirectory</emphasis></entry>
<entry><emphasis>Resource Type</emphasis></entry></row>
</thead>
<tbody valign="top">
<row>
<entry><literal>appdata</literal><indexterm><primary>appdata resource type</primary></indexterm></entry>
<entry>share/apps/kappnamerc</entry>
<entry>Application-specific data</entry>
</row>
<row>
<entry><literal>apps</literal><indexterm><primary>apps resource type</primary></indexterm></entry>
<entry>share/applnk</entry>
<entry>K-Menu structure</entry></row>
<row>
<entry><literal>cgi</literal><indexterm><primary>cgi resource type</primary></indexterm></entry>
<entry>cgi-bin</entry>
<entry>CGI scripts to run from KHelpcenter</entry></row>
<row>
<entry><literal>config</literal><indexterm><primary>config resource type</primary></indexterm></entry>
<entry>share/config</entry>
<entry>Configuration files (for example, kappnamerc)</entry></row>
<row>
<entry><literal>data</literal><indexterm><primary>data resource type</primary></indexterm></entry>
<entry>share/apps</entry>
<entry>Directory holding all application-specific data subdirectories</entry></row>
<row>
<entry><literal>exe</literal><indexterm><primary>exe resource type</primary></indexterm></entry>
<entry>bin</entry>
<entry>KDE executables (binaries) directory</entry></row>
<row>
<entry><literal>html</literal><indexterm><primary>html resource type</primary></indexterm></entry>
<entry>share/doc/html</entry>
<entry>HTML documentation</entry></row>
<row>
<entry><literal>icon</literal><indexterm><primary>icon resource type</primary></indexterm></entry>
<entry>share/icons</entry>
<entry>Application icons and miniicons</entry></row>
<row>
<entry><literal>lib</literal><indexterm><primary>lib resource type</primary></indexterm></entry>
<entry>lib</entry>
<entry>KDE libraries directory</entry></row>
<row>
<entry><literal>locale</literal><indexterm><primary>locale resource type</primary></indexterm></entry>
<entry>share/local</entry>
<entry>Translation files for the <literal>KLocale</literal> class</entry></row>
<row>
<entry><literal>mime</literal><indexterm><primary>mime resource type</primary></indexterm></entry>
<entry>share/mimelnk</entry>
<entry>Mime type description files</entry></row>
<row>
<entry><literal>services</literal><indexterm><primary>services resource type</primary></indexterm></entry>
<entry>share/services</entry>
<entry>Descriptions of the services provided by libraries and programs</entry></row>
<row>
<entry>servicetypes<indexterm><primary>lib resource type</primary></indexterm></entry>
<entry>share/servicetypes</entry>
<entry>Categories of services</entry></row>
<row>
<entry>sound<indexterm><primary>sound resource type</primary></indexterm></entry>
<entry>share/sounds</entry>
<entry>Application sounds</entry></row>
<row>
<entry>toolbar<indexterm><primary>toolbar resource type</primary></indexterm></entry>
<entry>share/toolbar</entry>
<entry>Pictures for use on toolbars</entry></row>
<row>
<entry>wallpaper<indexterm><primary>wallpaper resource type</primary></indexterm></entry>
<entry>share/wallpapers</entry>
<entry>Pictures for use as Idesktop wallpaper<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm><indexterm><primary>resources</primary><secondary>types</secondary></indexterm><indexterm><primary>application resources</primary><secondary>types</secondary></indexterm></entry>
</row>
</tbody>
</tgroup>
</table>
<para>Resources of the types mentioned in the preceding table can be accessed, loaded, and manipulated using standard KDE/Qt classes. Custom data types, stored in the application-specific resources directory, might, of course, need custom classes to manipulate them.</para>
<para>The widget <literal>KResourceDemo</literal>, given in <link linkend="ch07list14">Listings 7.14</link> and <link linkend="ch07list15">7.15</link>, shows how to find and load a picture, a sound, and a custom resource (in this case, a text file).</para>
<example role="codelisting" label="7.14" id="ch07list14">
<title>kresourcedemo.h: Class Declaration for <literal>KResourceDemo</literal>, a Widget That Demonstrates Loading and Using Application Resources<indexterm><primary>KResourceDemo widget</primary><secondary>kresourcedemo.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresourcedemo.h class declaration</tertiary></indexterm><indexterm><primary>kresourcedemo.h file (KResourceDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KResourceDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KRESOURCEDEMO_H__
 2: #define __KRESOURCEDEMO_H__
 3:
 4: #include &lt;qlabel.h>
 5:
 6: #include &lt;kaudio.h>
 7:
 8:
 9: /**
10:  * KResourceDemo
11:  * Show how to access application resources.
12:  **/
13: class KResourceDemo : public QLabel
14: {
15:  public:
16:   KResourceDemo (QWidget *parent);
17:
18: };
19:
20: #endif<indexterm><primary>KResourceDemo widget</primary><secondary>kresourcedemo.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresourcedemo.h class declaration</tertiary></indexterm><indexterm><primary>kresourcedemo.h file (KResourceDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KResourceDemo widget</secondary></indexterm></programlisting>
</example>
<para><literal>KResourceDemo</literal> is derived from the <literal>QLabel</literal> widget. Its background pixmap is the image Paper01.jpg, a standard KDE global resource. The text displayed in the widget is loaded from the file text.txt, an application-specific resource.<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
<example role="codelisting" label="7.15" id="ch07list15">
<title>kresourcedemo.cpp: Class Definition for <literal>KResourceDemo</literal><indexterm><primary>KResourceDemo widget</primary><secondary>kresourcedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresourcedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kresourcedemo.cpp file (KResourceDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KResourceDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qpixmap.h>
 2: #include &lt;qfile.h>
 3:
 4: #include &lt;kglobal.h>
 5: #include &lt;kstddirs.h>
 6: #include &lt;kimgio.h>
 7: #include &lt;klocale.h><indexterm><primary>KResourceDemo widget</primary><secondary>kresourcedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresourcedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kresourcedemo.cpp file (KResourceDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KResourceDemo widget</secondary></indexterm>
 8:
 9:
10: #include "kresourcedemo.h"
11:
12: KResourceDemo::KResourceDemo (QWidget *parent) :
13:   QLabel (parent)
14: {
15:   KStandardDirs *dirs = KGlobal::dirs();
16:
17:   //Load picture and set as background.
18:   QString picturepath;
19:   picturepath = dirs->findResource ("wallpaper", "Paper01.jpg");
20:
21:   kimgioRegister();
22:   QPixmap qpixmap;
23:   qpixmap.load (picturepath);
24:   setBackgroundPixmap (qpixmap);
25:
26:
27:   //Draw some text from a resource file.
28:   QFont qfont = font();
29:   qfont.setBold(true);
30:   setFont (qfont);
31:
32:   QString textpath;
33:   textpath = dirs->findResource ("appdata", "text.txt");
34:
35:   char * buffer = new char [1024];
36:   QFile qfile (textpath);
37:   qfile.open (IO_ReadOnly);
38:   qfile.readBlock (buffer, 1024);
39:
40:   QString datatext (buffer);
41:   delete buffer;
42:
43:   datatext.prepend (i18n("Here is some text:\n"));
44:   setText (datatext);
45: }<indexterm><primary>KResourceDemo widget</primary><secondary>kresourcedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresourcedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kresourcedemo.cpp file (KResourceDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KResourceDemo widget</secondary></indexterm></programlisting>
</example>
<para>A global instance of <literal>KStandardDirs</literal>, a class used to locate resources, is available from the static function <literal>KGlobal::dirs()</literal>. For readability, assign the return value to the pointer <literal>dirs</literal>.<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
<para>In line 19, <literal>findResource()</literal> returns the full path to the file Paper01.jpg. It searches for this file in the directories that hold resources of type <literal>wallpaper</literal>.</para>
<para>To manipulate a JPEG file like Paper01.jpg, you need to make use of the kimgio library. Be sure to compile this program by passing the option <literal>-lkimgio</literal> to <literal>g++</literal>. This links the kimgio library to the program, giving it access to the functions in the library.</para>
<para>Using the library is quite simple; just call<indexterm><primary>kimgioRegister() function</primary></indexterm><indexterm><primary>functions</primary><secondary>kingioRegister()</secondary></indexterm> <literal>kimgioRegister()</literal> (line 21) and you are done with kimgio! (See <link linkend="ch10">Chapter 10, <quote>Complex-Function KDE Widgets</quote></link>, for a discussion of <literal>KImgIO</literal>.) Now you load the picture into the instance of <literal>QPixmap</literal> called <literal>qpixmap</literal> with the statement<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
 qpixmap.load (picturepath)
</programlisting>
</informalexample>
<para>seen on line 23. The pixmap is set as the widget's background in line 24.</para>
<para>Next you find and load an application-specific resource, a text file in this case, and display its contents. In line 33, you search for a resource of type <literal>appdata</literal> called text.txt. This file, shown in <link linkend="ch07list16">Listing 7.16</link>, contains the text that will be displayed in the label. <link linkend="ch07fig05">Figure 7.5</link> shows a screenshot of KResourceDemo.</para>
<figure label="7.5" id="ch07fig05">
<title><literal>KResourceDemo</literal> places a pixmap in the background and some text in the foreground, both of which are stored as application resources.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/07fig05.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="7.16" id="ch07list16">
<title>Contents of $KDEDIR/share/appstext.txt, Which is Displayed by <literal>kresourcedemo</literal><indexterm><primary>KResourceDemo widget</primary><secondary>$KDEDIR/share/appstext.txt contents</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>$KDEDIR/share/appstext.txt contents</tertiary></indexterm><indexterm><primary>$KDEDIR/share/appstext.txt (KResourceDemo widget)</primary></indexterm></title>
<programlisting linenumbering="unnumbered">
This text was taken from the file
$KDEDIR/share/apps/kresourcedemo/text.txt
</programlisting>
</example>
<para>Lines 35&ndash;44 of <link linkend="ch07list15">Listing 7.15</link> contain code to read in and display the text. The code uses <literal>QFile,</literal> a class that allows you to read and write files. It is not covered in detail; therefore, see the Qt documentation for more information.</para>
<para>The final resource you access is a translation. The function <literal>i18n()</literal> is defined in klocal.h. (<emphasis>i18n</emphasis> is a commonly used shorthand for <emphasis>internationalization</emphasis>.<indexterm><primary>internationalization</primary></indexterm><indexterm><primary>i18n() function</primary></indexterm><indexterm><primary>functions</primary><secondary>i18n()</secondary></indexterm> Internationalization is such a long word that programmers abbreviate it by its first and last letters with a number in between that is equal to the number of letters left out of the word.) All string constants in an application should be enclosed in a call to <literal>i18n()</literal>. These strings can be translated to other languages, and when your application runs on a foreign desktop, the strings are displayed in the local language.<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
<para>You create the string translations by extracting all the strings passed to <literal>i18n()</literal> with <literal>xgettext</literal>, a GNU utility. Use the call<indexterm><primary>internationalization</primary></indexterm><indexterm><primary>i18n() function</primary></indexterm><indexterm><primary>functions</primary><secondary>i18n()</secondary></indexterm><indexterm><primary>xgettext utility</primary></indexterm><indexterm><primary>utilities</primary><secondary>xgettext</secondary></indexterm><indexterm><primary>GNU</primary><secondary>xgettext utility</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
  xgettext --c++ --keyword=i18n kresourcedemo.cpp --output=kresourcedemo.po
</programlisting>
</informalexample>
<para>to extract the strings from kresourcedemo.cpp and place them in the file kresourcedemo.po. PO stands for Portable Object. This reflects the fact that they are text files that can be easily moved between platforms. The file kresource.po is shown in <link linkend="ch07list17">Listing 7.17</link>.</para>
<example role="codelisting" label="7.17" id="ch07list17">
<title>kresource.po: The Translation Template File Generated by <literal>xgettext</literal><indexterm><primary>KResourceDemo widget</primary><secondary>kresource.po translation template file</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresource.po translation template file</tertiary></indexterm><indexterm><primary>kresource.po file (KResourceDemo widget)</primary></indexterm></title>
<programlisting linenumbering="numbered">
 1: # SOME DESCRIPTIVE TITLE.
 2: # Copyright (C) YEAR Free Software Foundation, Inc.
 3: # FIRST AUTHOR &lt;EMAIL@ADDRESS>, YEAR.
 4: #
 5: #, fuzzy
 6: msgid ""
 7: msgstr ""
 8: "Project-Id-Version: PACKAGE VERSION\n"
 9: "POT-Creation-Date: 1999-11-20 13:31-0500\n"
10: "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
11: "Last-Translator: FULL NAME &lt;EMAIL@ADDRESS>\n"
12: "Language-Team: LANGUAGE &lt;LL@li.org>\n"
13: "MIME-Version: 1.0\n"
14: "Content-Type: text/plain; charset=iso-8859-1\n"
15: "Content-Transfer-Encoding: ENCODING\n"
16:
17: #: kresourcedemo.cpp:45
18: msgid "Here is some text:\n"
19: msgstr ""<indexterm><primary>KResourceDemo widget</primary><secondary>kresource.po translation template file</secondary></indexterm><indexterm><primary>listings</primary><secondary>KResourceDemo widget</secondary><tertiary>kresource.po translation template file</tertiary></indexterm><indexterm><primary>kresource.po file (KResourceDemo widget)</primary></indexterm><indexterm><primary>xgettext utility</primary></indexterm><indexterm><primary>utilities</primary><secondary>xgettext</secondary></indexterm><indexterm><primary>GNU</primary><secondary>xgettext utility</secondary></indexterm></programlisting>
</example>
<para>To test the translation feature, fill in the <literal>msgstr</literal> entry at the bottom of kresourcedemo.po using any text editor. That is, change the empty string <literal>""</literal> to some other string, such as <quote>Look at this text!</quote> or try translating it into another language.<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
<para>The files used by running KDE programs are machine-object (binary) files. The machine-object file for kresourcedemo is created by <literal>msgfmt</literal> with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
  msgfmt kresourcedemo.po -o kresourcedemo.mo
</programlisting>
</informalexample>
<para>Move this file into $KDEDIR/share/locale/de/LC[lowbar]MESSAGES (create the directory if it does not exist). Now run the KDE control center from the K Menu on the panel. Click Language in the Desktop subtree and choose German as your primary language.</para>
<para>Now, open up a new terminal from the panel and run kresourcedemo. Instead of displaying <literal>Here is some text:</literal>, it should display the alternative string you entered in kresourcedemo.po.<indexterm><primary>resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>application resources</primary><secondary>accessing</secondary></indexterm><indexterm><primary>accessing</primary><secondary>resources</secondary></indexterm></para>
</section>
<section id="ch07lev2sec6">
<title>Creating .desktop Files</title>
<para>KDE 2.0 <indexterm><primary>resources</primary><secondary>.desktop files</secondary></indexterm><indexterm><primary>application resources</primary><secondary>.desktop files</secondary></indexterm><indexterm><primary>.desktop files</primary></indexterm><indexterm><primary>files</primary><secondary>.desktop</secondary></indexterm>uses files with the extension .desktop, in a standard Key, Value pair format (discussed shortly) to describe applications. These are called <quote>application .desktop files</quote> because these files are used to describe other objects as well (see <link linkend="ch12">Chapter 12, <quote>Creating and Using Components (KParts)</quote></link>). KDE 1.x used similar files, but with the extension .kdelnk. The extension .kdelnk is still supported, but it is best to use the newer .desktop extension to ensure future compatibility.<indexterm><primary>resources</primary><secondary>.desktop files</secondary></indexterm><indexterm><primary>application resources</primary><secondary>.desktop files</secondary></indexterm><indexterm><primary>.desktop files</primary></indexterm><indexterm><primary>files</primary><secondary>.desktop</secondary></indexterm></para>
</section>
</section>
<section id="ch07lev1sec5">
<title>Network Transparency</title>
<para>The<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm> term <quote>network transparent</quote> refers to an interface that allows a user to access remote files using the same methods as accessing local files. KDE applications should be network transparent to be KDE compliant. Luckily for you, the KDE application developers, all of the hard work of accessing remote files has been done and made available (in simplest form) through static convenience functions.</para>
<section id="ch07lev2sec7">
<title>Programming Example</title>
<para>The KDE library libkio contains the classes that implement network transparency (among other things). The class of particular interest is <literal>KIO::NetAccess</literal>. It contains the methods <literal>download()</literal> and <literal>upload()</literal>, which transfer files to and from remote sources. These methods work synchronously but keep your GUI alive, so they are easy to work with. The <literal>download()</literal> and <literal>upload()</literal> methods can use FTP and HTTP (or any protocol for which a handler has been written) for accessing remote files. (The protocol is identified by the protocol identifier in the URL. For example, <ulink url="http://www.kde.org">http://www.kde.org</ulink> uses HTTP.)<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm></para>
<para>The following program, KRemoteDemo, shows how the <literal>KIO::NetAccess</literal> methods <literal>download()</literal> and <literal>upload()</literal> <indexterm><primary>download() function</primary></indexterm><indexterm><primary>functions</primary><secondary>download()</secondary></indexterm><indexterm><primary>upload() function</primary></indexterm><indexterm><primary>functions</primary><secondary>upload()</secondary></indexterm>can be used to implement basic network transparency in a KDE application.</para>
<example role="codelisting" label="7.18" id="ch07list18">
<title>kremotedemo.h: Class declaration for <literal>KRemoteDemo</literal><indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.h class declaration</tertiary></indexterm><indexterm><primary>kremotedemo.h file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef __KREMOTEDEMO_H__
 2: #define __KREMOTEDEMO_H__
 3:
 4: #include &lt;qstring.h>
 5:
 6: #include &lt;ktmainwindow.h>
 7: #include &lt;kurl.h>
 8:
 9: class QMultiLineEdit;
10: class KAction;
11:
12: /**
13:  * KRemoteDemo
14:  *
15:  * Load and save remote and local files.
16:  **/
17: class KRemoteDemo : public KTMainWindow
18: {
19:   Q_OBJECT
20:
21:   public:
22:    KRemoteDemo (const char *name=0);
23:
24:   protected slots:
25:    void slotOpen();
26:    void slotSave();
27:
28:   protected:
29:    KAction *save;
30:    KURL kurl;
31:    QString localfilename;
32:    QMultiLineEdit *editor;
33: };
34:
35: #endif<indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.h class declaration</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.h class declaration</tertiary></indexterm><indexterm><primary>kremotedemo.h file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>declaring widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm></programlisting>
</example>
<para>This is a typical class declaration. KRemoteDemo uses a <literal>QMultiLineEdit</literal> object as its content area and offers remote or local file opening and saving (see <link linkend="ch07list19">Listing 7.19</link>).<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm></para>
<example role="codelisting" label="7.19" id="ch07list19">
<title>kremotedemo.cpp: Class definition for <literal>KRemoteDemo</literal><indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kremotedemo.cpp file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;errno.h>
 2: #include &lt;string.h>
 3:
 4: #include &lt;qmultilineedit.h>
 5:
 6: #include &lt;kapp.h>
 7: #include &lt;kstdaction.h>
 8: #include &lt;kaction.h>
 9: #include &lt;kfiledialog.h>
10: #include &lt;kio/netaccess.h>
11: #include &lt;knotifyclient.h>
12:
13: #include "kremotedemo.moc"
14:
15: KRemoteDemo::KRemoteDemo (const char *name) :
16:   KTMainWindow (name)
17: {
18:   KStdAction::open ( this, SLOT (slotOpen()),
19:                 actionCollection() );
20:   save = KStdAction::save ( this, SLOT (slotSave()),
21:                        actionCollection() );
22:   KStdAction::quit ( kapp, SLOT (closeAllWindows()),
23:                 actionCollection() );
24:   createGUI();
25:   save->setEnabled (false);
26:
27:   editor = new QMultiLineEdit (this);
28:   setView (editor);
29: }<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm><indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kremotedemo.cpp file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm>
30:
31: void
32: KRemoteDemo::slotOpen()
33: {
34:   kurl = KFileDialog::getOpenURL ();
35:
36:   if (kurl.isLocalFile())
37:     localfilename = kurl.path();
38:   else if (!KIO::NetAccess::download (kurl, localfilename))
39:     {
40:       KNotifyClient::event ("Could not download file.");
41:       return;
42:     }
43:<indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kremotedemo.cpp file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm>
44:
45:   QFile qfile (localfilename);
46:    if (qfile.open (IO_ReadOnly))
47:     {
48:       char *buffer = new char [qfile.size()+1];
49:
50:       qfile.readBlock (buffer, qfile.size());
51:       buffer [qfile.size()]='\0';
52:       editor->setText (buffer);
53:
54:       delete buffer;
55:     }
56:   else
57:     {
58:       QString qerr;
59:       qerr.sprintf ("Could not open file: %s", strerror (errno));
60:       KNotifyClient::event (qerr);
61:       return;
62:     }
63:   save->setEnabled (true);
64: }
65: <indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm>
66: void<indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kremotedemo.cpp file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm>
67: KRemoteDemo::slotSave()
68: {
69:   QFile qfile (localfilename);
70:    if (qfile.open (IO_ReadOnly))
71:     {
72:       qfile.writeBlock (editor->text(),
73:                    editor->text().length() );
74:       qfile.close();
75:     }
76:   else
77:     {
78:       QString qerr;
79:       qerr.sprintf ("Could not write file: %s", strerror (errno));
80:       KNotifyClient::event (qerr);
81:       return;
82:     }
83:
84:   if (!kurl.isLocalFile())
85:     if (!KIO::NetAccess::upload (localfilename, kurl))
86:     {
87:       KNotifyClient::event ("Could not upload file.");
88:       return;
89:     }
90: }<indexterm><primary>KRemoteDemo widget</primary><secondary>kremotedemo.cpp class definition</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>kremotedemo.cpp class definition</tertiary></indexterm><indexterm><primary>kremotedemo.cpp file (KRemoteDemo widget)</primary></indexterm><indexterm><primary>defining widget classes</primary><secondary>KRemoteDemo widget</secondary></indexterm></programlisting>
</example>
<para>The <literal>KRemoteDemo</literal> constructor, lines 15&ndash;29, uses actions to create the menubar and toolbar and creates an instance of <literal>QMultiLineEdit</literal> for use as the content area. The action corresponding to File, Save is stored in the variable <literal>save</literal> so that the action can be disabled and reenabled later after a file has been loaded. (For simplicity, and to avoid straying too far from the topic, a File, Save As function is not included here, so don't be surprised when you cannot save a newly created piece of text. In a full KDE application, you should include a File, Save As function and enable it when the document changes from empty to non-empty.)<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm></para>
<para>On line 36, in <literal>slotOpen()</literal>, <indexterm><primary>slotOpen() function</primary></indexterm><indexterm><primary>functions</primary><secondary>slotOpen()</secondary></indexterm>you check to see whether the URL returned by <literal>getOpenURL()</literal> refers to a local file. If it does, you open the file pointed to by <literal>kurl.path()</literal>, the full path to the file. If the URL does not refer to a local file, you download the remote file using <literal>KIO::NetAccess::download()</literal>. The second argument to this method (see line 38) is passed by reference and, if it is an empty string, filled in upon return with the name of a local, temporary file. This local file holds a copy of the downloaded remote file. The method <literal>download()</literal> returns <literal>false</literal> if an error occurs during download.</para>
<para>Notice that errors are reported to the user with <literal>KNotifyClient</literal>. In the event of a standard C library error, include the error string (returned by the standard C library function <literal>strerror()</literal>) in your report to the user (see lines 60 and 81). (Refer to <link linkend="ch06">Chapter 6, <quote>KDE Style Reference</quote></link> for details on <literal>KNotifyClient</literal>.)</para>
<para>The slot <literal>slotSave()</literal> <indexterm><primary>slotSave() function</primary></indexterm><indexterm><primary>functions</primary><secondary>slotSave()</secondary></indexterm>shows how to return an edited file to its proper local or remote place. The file is saved to the local location pointed to by the variable <literal>localfilename</literal>. This is either the original location of the file or the location of the temporary file created by <literal>download()</literal>. If it is a temporary file (if the file requested by the user was originally stored remotely), <literal>slotSave()</literal> uploads the file to it original location. The <literal>upload()</literal> method (line 88) will delete the temporary file after it has been uploaded.<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm></para>
<para>When you create a full KDE application, you should treat user-requested remote and local URLs in the same fashion. Beside loading and saving from and to the URLs, you should keep both local and remote URLs in the Recent submenu of the File menu.</para>
<para><link linkend="ch07list20">Listing 7.20</link> shows the <literal>main()</literal> function that you can use to create an executable application showing how <literal>KRemoteDemo</literal> works. You will also need to place the XML GUI file, kremotedemoui.rc (available from the Web site), in directory $KDEDIR/share/kremotedemo.</para>
<example role="codelisting" label="7.20" id="ch07list20">
<title>main.cpp: A main() function suitable for testing KRemoteDemo<indexterm><primary>KRemoteDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KRemoteDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KRemoteDemo widget</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "kremotedemo.h"
 4:
 5: int<indexterm><primary>KRemoteDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KRemoteDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KRemoteDemo widget</tertiary></indexterm>
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "kremotedemo");
 9:
10:   KRemoteDemo *KRemotedemo = new KRemoteDemo (0);
11:
12:   kapplication.setMainWidget (KRemotedemo);
13:
14:   KRemotedemo->show();
15:   return kapplication.exec();
16: }<indexterm><primary>network transparency</primary></indexterm><indexterm><primary>transparency (network)</primary></indexterm><indexterm><primary>KRemoteDemo widget</primary><secondary>main() function</secondary></indexterm><indexterm><primary>listings</primary><secondary>KRemoteDemo widget</secondary><tertiary>main() function</tertiary></indexterm><indexterm><primary>main() function</primary><secondary>KRemoteDemo widget</secondary></indexterm><indexterm><primary>functions</primary><secondary>main()</secondary><tertiary>KRemoteDemo widget</tertiary></indexterm></programlisting>
</example>
</section>
</section>
<section id="ch07lev1sec6">
<title>Summary</title>
<para>KDE offers users many features such as drag and drop, session management, internationalization, and network transparency, but application developers are the ones who must implement them. The KDE/Qt libraries make this task easier by performing common application functions. Configuration files are accessed with the class <literal>KConfig</literal>; session management is handled in most cases by <literal>KTMainWindow</literal>; application resources can be located with <literal>KStandardDirs</literal> and are usually manipulated with KDE/Qt classes, such as <literal>QPixmap</literal> or <literal>KAudioPlayer</literal>; files can be loaded or saved locally or remotely using <literal>KIO_NetAccess.</literal></para>
</section>
<section id="ch07lev1sec7">
<title>Exercises</title>
<para>Answers to the exercises can be found in <link linkend="ap-c">Appendix C, <quote>Answers</quote></link>.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch07que01">
<para><link linkend="ch07ans01">Starting with <literal>KDropDemo</literal> as a base, write a program that accepts drops of images. Use <literal>QImageObject</literal> instead of <literal>QTextObject</literal>.</link></para>
</question>
</qandaentry>
<qandaentry>
<question id="ch07que02">
<para><link linkend="ch07ans02">Now, using <literal>KDragDemo</literal> as a base, write a program that lets the user drag a pixmap to another application. You can use a <literal>QPixmap</literal> returned by <literal>BarIcon()</literal> as the data for the drag.</link></para>
</question>
</qandaentry>
<qandaentry>
<question id="ch07que03">
<para><link linkend="ch07ans03">Look up <literal>KAudio</literal> in the KDE class documentation. Using <literal>KStandardDirs</literal> and <literal>KAudio</literal>, locate and play one of the sounds distributed with KDE. (The sounds are in $KDEDIR/share/sounds.)</link></para>
</question>
</qandaentry>
</qandaset>
</section>
</chapter>
