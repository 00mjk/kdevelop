<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>The KDevelop Debugger</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="The KDevelop IDE: The Integrated Development Environment for KDE"
HREF="ch18.html"/><LINK
REL="PREVIOUS"
TITLE="The File Viewers&#8212;The Windows to Your Project Files"
HREF="ch18lev1sec5.html"/><LINK
REL="NEXT"
TITLE="KDevelop 2.0&#8212;A Preview"
HREF="ch18lev1sec7.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch18lev1sec5.html"
>Prev</A
> <A
HREF="ch18lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch18lev1sec6"
>18.6. The KDevelop Debugger</A
></H1
><P
>In the set of tools available for developers under the GNU license, there is a debugger, the <TT
CLASS="literal"
>gdb</TT
>. <TT
CLASS="literal"
>gdb</TT
> itself is a command-line tool like <TT
CLASS="literal"
>g++</TT
> and <TT
CLASS="literal"
>gcc</TT
> and is used to monitor applications during runtime. The application binary therefore has to include runtime information for the debugger, which can be turned on during compilation. Then <TT
CLASS="literal"
>gdb</TT
> will deliver as much information about your application as available: addresses, method names, object values, location of methods in your source files, and much more. However, to make the best use of it, a lot of freely available GUI front ends are provided, such as <TT
CLASS="literal"
>ddd</TT
> or <TT
CLASS="literal"
>kdbg</TT
>, which let you run your application with <TT
CLASS="literal"
>gdb</TT
> and display the runtime information delivered by <TT
CLASS="literal"
>gdb</TT
>. KDevelop, however, contains a new internal debugging front end to <TT
CLASS="literal"
>gdb</TT
> that lets you use all features within the same environment so that you don't have to switch between your coding editor and the debugger application. Its integration is seamless and easy to use, and you are still provided the possibility to use an external debugging front end as a tool in the Tools window.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch18lev2sec7"
>18.6.1. Setting the Debugger Options</A
></H2
><P
>The debugger settings, like all other KDevelop configuration options, are located in KDevelop Setup, which can be accessed via the Options menu. Select the debugger tabulator to change the debugging settings.</P
><P
>There you can select between the default use of the internal KDevelop debugger or using an external debugger with the debugger name you want to use (<TT
CLASS="literal"
>ddd</TT
> or <TT
CLASS="literal"
>kdbg</TT
>).</P
><P
>Next, three major settings for the internal debugger are worth a closer look. First is the option to set Pending Breakpoints. A breakpoint is a mark in the source code at a certain line where you want the debugger to stop your application&#8212;for example, when you're searching for a segmentation fault or you want to inspect how often your application will call the same method to increase the performance when you know how to reduce the number of times a method gets called. Now, applications often make use of libraries that they are linked to. Although static libraries are included into the binary, dynamic libraries such as the KDE and Qt libraries are loaded when an application calls a method that is in one of these libraries. That means as long as a method that is placed in a library didn't get called, the library won't be loaded. When you want to set a breakpoint exactly at a method call that is in a library, <TT
CLASS="literal"
>gdb</TT
> can't set it if the library isn't in the system's memory. The Pending Breakpoint option helps here because it deactivates the breakpoint as long as the library hasn't been loaded, and it tries to activate it as soon as the library is available in memory.</P
><P
>The second option that is very important is the floating toolbar. In debugging mode of KDevelop, this brings up a separate little toolbar window that contains the debugging commands as icons and that will stay on top. This is a nice feature that makes debugging easier, and you can still monitor the source code in KDevelop behind your application window (see <A
HREF="ch18lev1sec6.html#ch18fig11"
>Figure 18.11</A
>). There is also the option to use a separate I/O window for applications that make use of command-line input calls, such as <TT
CLASS="literal"
>cin</TT
> and <TT
CLASS="literal"
>fgets</TT
>. In that case, checking the floating toolbar is again a good option so that your input window doesn't get obscured when activating debugging commands.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch18lev2sec7"/></TD
></TR
><ANNOTATION
NAME="ch18lev2sec7"
TITLE="Setting the Debugger Options"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch18lev2sec8"
>18.6.2. How to Enable Debugging Information</A
></H2
><P
>To debug your application, all you have to do is to tell the compiler to include debugging code into the binary that serves as a reference from the object code to the original source code so that breakpoints can be set and monitored.</P
><P
>For this, open the Project Options dialog available in the Project menu. Switch to the compiler options tabulator and check the Generate Debugging Information option together with the debugging level. By default, debugging is turned on at project creation, so you shouldn't worry if your application loads a bit slower when running a normal test. To see how it will perform when compiled normally, deselect this option and enable optimization instead, which can be done on the same page. A commonly used optimization level is -02, which will work in most cases, but you're on the safe side using -01.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch18fig11"
></A
><P
><B
>Figure 18.11. The KDevelop debugger is your gateway to the CPU and memory usage of your application. It allows you to monitor your program's execution line by line along the source code.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/18fig11.gif"
></IMG
></P
></DIV
><HR/></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch18lev2sec8"/></TD
></TR
><ANNOTATION
NAME="ch18lev2sec8"
TITLE="How to Enable Debugging Information"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch18lev2sec9"
>18.6.3. Running a Debugging Session</A
></H2
><P
>To actually use the debugger, you have to run your application within <TT
CLASS="literal"
>gdb</TT
>. For that, use the Debug menu, which offers the normal Start operation and advanced selection of starting methods, such as appending arguments or attaching your application to another process. Notice that you have to set a breakpoint before starting the debugger; otherwise, your program won't stop! Setting breakpoints is one of the easiest tasks. The editor windows have a gray pane on the left; you just have to click the line on which you want to stop, and a breakpoint symbol is placed. The context menu over this pane offers advanced options to the debugger as well as switching between breakpoint and bookmark modes. Then the debugger will start your program and the debugging options and windows will be available. These are</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Run&#8212;Executes or continues the program.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Run to Cursor&#8212;Executes the program until the current cursor position in the source code is reached.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Step Over&#8212;Executes one line of code and will stop the application on the next line.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Step Over Instruction&#8212;Executes exactly one machine instruction. The assembler code that is executed and where the machine instructions can be monitored is the Disassemble tab in the output window.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Step In&#8212;Executes one line of code where you will step into the method call, if necessary.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Step In Instruction&#8212;Executes one machine instruction as described previously.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Step Out&#8212;Runs to the end of the stack frame and out of the function the application is currently processing.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Viewers&#8212;Opens the debugging viewers dialog where you can inspect a variety of values of the running application, such as the disassembled code, memory status, library status, and CPU register states.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Stop&#8212;Stops the application execution.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Exit&#8212;Stops the application execution and exits the debugger.</P
></LI
></UL
><P
>With these options, you can control the processing of your application's execution at runtime. On the other hand, you certainly don't want only to hop through the source code, but you might also want to know which values your variables have during execution time. This is the easiest way to find the cause of a segmentation fault. To those who aren't experts with programming yet, you may have encountered a program suddenly exiting without you wanting it to exit. It is just gone and your work is lost. The cause of this is most often a segmentation fault. That means that the computer tries to access an object the program refers to, but the object doesn't exist. The program will crash in that case because it violates the memory protection by wanting to access an address area that it isn't allowed to. Development of C++ and C applications often involve the use of pointers to objects that are the cause of most segmentation faults; therefore, you surely want to watch if a pointer is valid during runtime. The KDevelop debugger now offers the Watch functionality for variables. In the VAR tabulator, you get a Tree View of all objects of the application and their status. There, you can select which variables you want to watch. This is often useful for local variables within a method call you're monitoring. Variables to be watched can be added to the Watch section by using the input field on the bottom of the VAR window or by a context menu within the tree.</P
><P
>Now you should be able to successfully run and debug your application and make it as safe as it can be. Keep in mind that users expect your application to be stable, and they certainly don't want to lose their work&#8212;the same as you don't want your IDE to crash while you're programming!</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch18lev2sec9"/></TD
></TR
><ANNOTATION
NAME="ch18lev2sec9"
TITLE="Running a Debugging Session"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch18lev1sec6"/></TD
></TR
><ANNOTATION
NAME="ch18lev1sec6"
TITLE="The KDevelop Debugger"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch18lev1sec5.html"
>Prev</A
> <A
HREF="ch18lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>