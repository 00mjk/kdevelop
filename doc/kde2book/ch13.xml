<chapter label="13" role="chapter" id="ch13">
<title>DCOP&mdash;Desktop Communication Protocol</title>
<para><emphasis>by Cristian Tibirna</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec1">Motivation</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec2">History</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec3">Underlying Technologies</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec4">Architecture</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec5">Description of DCOP's Programming Interface</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec6">Developer Concerns and Tools in DCOP</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch13lev1sec7">DCOP Use in KDE 2.0&mdash;A Few Examples</link></emphasis></para></listitem>
</itemizedlist></highlights>
<para>One<indexterm><primary>DCOP</primary><secondary>(Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP;(Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>Desktop Communication Protocol. See DCOP</primary></indexterm><indexterm><primary>DCOP</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary></indexterm> major reason for the rampant dependence upon computers is their capability to greatly simplify the work and life of users. This capability is largely a consequence of the computers' <quote>education</quote>; that is, their programs. The educators (that happy bunch we love to call <emphasis>the hackers</emphasis>) discovered that sociology applies to computer programs as well as people. In order to behave as worthy citizens of a computer, the programs need to know how to communicate.</para>
<para>A long time ago, the UNIX fathers noticed the hunger of programs for communication. Therefore, they invented the genial <indexterm><primary>pipes</primary></indexterm><emphasis>pipes</emphasis>. Arguably, most of the force of UNIX comes from offering its users the ability to build combinations of small tools. These combinations can reach a potentially infinite complexity. These <quote>metatools</quote> help the user easily accomplish complex tasks. Pipes are an essential ingredient in these combinations. You have probably used, at least once, commands such as</para>
<para><informalexample>
<programlisting linenumbering="unnumbered">
]~> find . -name "*.cc" | xargs wc -l

]~> cat /etc/passwd | awk -F: 'print $4' > /tmp/users-realnames

]~> echo "What a happy world!" | mail -s "Oh yeah!" buddy@paradise.org
</programlisting>
</informalexample></para>
<para>Today, we want to develop programs with nicer faces and better capabilities, and we rediscover that communication between applications is essential. Yet, in the time of <emphasis>graphical interfaces</emphasis>, <emphasis>point and click</emphasis>, and <emphasis>what you see is what you get</emphasis>, it is less convenient to use traditional pipes. More advanced communication means are needed.</para>
<para>Thus appeared DCOP, the <emphasis>Desktop Communication Protocol</emphasis>. This name designates the set of tools that KDE programs use to pass information between them.</para>
<para>This chapter describes the programming interface that DCOP defines and gives a few directions and examples.<indexterm><primary>DCOP</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary></indexterm></para>
<section id="ch13lev1sec1">
<title>Motivation</title>
<para>The<indexterm><primary>DCOP</primary><secondary>goals</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>goals</tertiary></indexterm> K Desktop Environment was designed from the very beginning as a collection of programs, each targeted at resolving a strictly delimited category of tasks. However, the main goal of a desktop environment is to offer the user a unified way of functioning that preserves or even enhances his productivity in a heuristic way, despite the diversity of tasks the user has to accomplish. The validity of this goal is proven by the wealth of integration tools that proliferated around and inside the traditional UNIX window managers (from the times that preceded KDE).</para>
<para>Those window managers had scripting support and other kinds of programming interfaces. They offered hooks for programs willing to take advantage of the specific windowing information accessible to the window manager or to implement integration with the underlying operating system. There also were connections through which programs could manipulate the window manager.</para>
<para>It was not unusual for most window managers to come bundled with helper tools such as task lists, icon managers, or event handlers that took advantage of special communication functions in order to offer a better experience to the user of the graphical interface.</para>
<para>In running KDE, the need for communication between applications stands out. Here are a few examples of interprocess communication needs:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The desktop has to offer feedback about applications' startup dynamics.</para></listitem>
<listitem><para>Today's applications will often need to point the desktop browser to a URL or offer means for composing mail using the desktop's default mailer agent.</para></listitem>
<listitem><para>Applications need to be informed about changes operated by the user in the external configuration modules hosted by KDE's Control Center.<indexterm><primary>DCOP</primary><secondary>goals</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>goals</tertiary></indexterm></para></listitem>
<listitem><para>Users require a unified interface to the online help offered by applications.</para></listitem>
<listitem><para>The window manager (KWin) informs the panel (Kicker) about changes in the collection of managed windows.</para></listitem>
<listitem><para>Part of the changes occurring in a window's status are propagated by the window manager to the event notifier (KNotifier) for proper notification of the user. Also, the centralized notification resources are helpful for all applications, not only for the window manager.</para></listitem>
<listitem><para>The panel can manage special applications (panel applets) and needs to exchange with them the bits of information related to their status and activities, such as adding and removing applets, required geometry, special menu items to be added to the main menu of the panel, and so on.</para></listitem>
<listitem><para>Last, but not least, generic desktop control through scripting is in high demand.<indexterm><primary>DCOP</primary><secondary>goals</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>goals</tertiary></indexterm></para></listitem></itemizedlist>
<para>Communication is essential even between distinct instances of the same application. Starting with version 2.0 of KDE, the concept of <emphasis>unique application</emphasis> <indexterm><primary>unique applications</primary></indexterm>is available. This concept, very simple in essence, stipulates that an application can choose to never have more that one fully running instance. A user can try, of course, to spawn a second instance. It is up to this new process to discover if previous copies are already running. If an older instance exists, the new one should be capable of communicating with its predecessor. Through communication, it would be able to trigger the display of an information dialog box or to pass over the parameters provided by the user, such as the name of a file to open or a special command-line option.</para>
<para>When a given number of applications are in charge of similar tasks&mdash;for example, the processing of users' mail&mdash;collaboration between such applications is very useful. Imagine, for example, a tiny mail monitor that sits in the background and checks for new messages in multiple mailboxes. In the event of a new incoming message, the monitor should be able to send event information to the system's notification handler (KNotify), check whether there is any running mail agent, and if there is, try to communicate to the mail agent information that will promptly modify its status.</para>
<para>As you can see, building reliable means of communication in the backbone of KDE is necessary. Doing this in such a way that the resulting programming interface is simple, easy to use, and efficient is also highly important. DCOP offers all these and more.<indexterm><primary>DCOP</primary><secondary>goals</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>goals</tertiary></indexterm></para>
</section>
<section id="ch13lev1sec2">
<title>History</title>
<para>The <indexterm><primary>DCOP</primary><secondary>history of</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>history of</tertiary></indexterm><indexterm><primary>history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>development history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm>UNIX programmer doesn't lack choices when there's need for interprocess communication. KDE made (and still makes) use of many of the possible technologies: pipes, sockets, X Atoms, temporary files, shared memory, CORBA, and RPC.</para>
<para>From a historic point of view, however, in the beginning the developers were less preoccupied by building communication means into the burgeoning code base. When information (data or commands) were to be passed around, UNIX pipes or even common temporary files were used.</para>
<para>With the KDE window manager&mdash;named kwm in its first iteration&mdash;becoming more mature, a more consistent need appeared for collaboration between applications. A mechanism based on X Atoms was thus introduced by kwm's author, <indexterm><primary>Ettrich, Matthias</primary></indexterm>Matthias Ettrich. This was used until the 1.1.2 version of KDE. The<indexterm><primary>X Atoms</primary></indexterm> X Atoms are C language structures, defined and implemented in the X library. They are used by X Window as a convenient and rapid means of passing data between X clients (applications) and the X server, as well as between different X clients. Given their rather simple nature&mdash;that is, designed to answer specific needs that the X technology encounters&mdash;X Atoms have intrinsic limitations in terms of the size of data they can transfer as well as in the flexibility and complexity of the information passed through.</para>
<para>These limitations convinced the developers, even in early stages of the code, to search for better communication solutions. The CORBA journey and then DCOP came as a result of this search. Yet the X Atoms are still used in the second version of the KDE API, in conjunction with X ClientMessages, in the form of <indexterm><primary>KIPC</primary></indexterm>KIPC (see kdelibs/kdecore/kipc.h in the code base). This is a very simple and thus very efficient communication mechanism created by Geert Jansen<indexterm><primary>Jansen, Geert</primary></indexterm>. KIPC allows sending messages such as <quote>just changed</quote> messages related to most common desktop settings that have to be sent to all the KDE-enabled applications. A good example is the <quote>color palette just changed</quote> message that the Control Center sends to all KDE applications when the user chooses a new color scheme.<indexterm><primary>DCOP</primary><secondary>history of</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>history of</tertiary></indexterm><indexterm><primary>history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>development history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<note role="normal">
<para>For a rapid but complete understanding of KIPC, you can study the approximately 150 lines of effective code that constitute the inner details of this simple communications mechanism.</para>
</note>
<para>Since 1997, when work started on KOffice and other complex KDE applications, developers have started to create a fairly functional implementation of CORBA (see <ulink url="http://www.omg.org">http://www.omg.org</ulink>). <indexterm><primary>CORBA (Common Object Request Broker Architecture)</primary></indexterm><indexterm><primary>Common Object Request Broker Architecture (CORBA)</primary></indexterm>CORBA (Common Object Request Broker Architecture) is a complete, complex communication structure built to become an industry standard, capable of networked, cross-platform, reliable communication between any applications that subscribe to the standard.</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Functionality</para></listitem>
<listitem><para>Completeness</para></listitem>
<listitem><para>Availability</para></listitem>
<listitem><para>Robust C++ bindings</para></listitem></itemizedlist>
<para>Any combination of these is also why other implementations (such as the oft-proposed Orbit) were ruled out.<indexterm><primary>DCOP</primary><secondary>history of</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>history of</tertiary></indexterm><indexterm><primary>history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>development history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<para>The satisfactory results generated by the more than year-long CORBA experience of the KOffice developers were used, in late 1998, to merge this technology in the central KDE libraries. Alas, CORBA brought other limitations&mdash;and with these last evolutions to completely embrace KDE, these limitations became obvious:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>CORBA was too complex for the requirements of the desktop paradigm.</para></listitem>
<listitem><para>The dynamic character of a desktop became hindered by the static nature of CORBA.</para></listitem>
<listitem><para>It was difficult to convince developers of small applications that they had to read and understand thousand-page manuals before they could enable interprocess communication in their projects.</para></listitem>
<listitem><para>Compilation of the CORBA-enabled code base was very time-consuming and resource demanding.</para></listitem>
<listitem><para>MICO had performance problems including high CPU usage and large memory consumption.</para></listitem>
<listitem><para>The stability of the resulting applications wasn't satisfactory.<indexterm><primary>CORBA (Common Object Request Broker Architecture)</primary></indexterm><indexterm><primary>Common Object Request Broker Architecture (CORBA)</primary></indexterm></para></listitem></itemizedlist>
<para>A discussion started in the developer community that continued long after the final <quote>let's forget CORBA</quote> decision. This discussion resulted in the conclusion that this communications technology came with too much hassle compared to the gained benefits. One more element has to be added to the picture of the KDE inter-application communication situation as depicted shortly before the creation of DCOP: all the described technologies were present and used in the KDE code base simultaneously. Also, developers often found limitations or large development difficulties that were forcing them to create workarounds to fit their needs. For example, MICO was making use of STL (the Standard Templates Library), which was not portable enough for KDE and also had important performance problems. In order to solve these problems, a large amount of effort was invested by Simon Hausmann, Torben Weis, Steffen Hansen, and many others to replace STL with QTL (the Qt Templates Library) in KDE's CORBA. At a given moment, the heterogeneity of the communication solutions and the growing pains of keeping all issues properly handled became obvious.<indexterm><primary>DCOP</primary><secondary>history of</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>history of</tertiary></indexterm><indexterm><primary>history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>development history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<para>In this landscape, KDE developers <indexterm><primary>Ettrich, Matthias</primary></indexterm><indexterm><primary>Brown, Preston</primary></indexterm>Matthias Ettrich and Preston Brown engaged in a high-pitched development effort and created DCOP. This event coincided with the big KDE-TWO reunion, held in Erlangen, Germany, in October 1999. A new, better era thus began. An important step forward in the accomplishment of the protocol and its advanced functionalities was achieved during the third coding reunion of KDE developers, during the month of July 2000, in Trysil, Norway.</para>
<para>DCOP is released as free software. Based on largely available technology (ICE, the Inter-Client Exchange mechanism, available with X Window) and reasonably separate from the KDE technology, DCOP is intended as a generic interprocess communication technology. The authors keep faith that, given its qualities and the feeble resource usage, DCOP will soon become a widely spread commodity protocol.<indexterm><primary>DCOP</primary><secondary>history of</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>history of</tertiary></indexterm><indexterm><primary>history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>development history of</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
</section>
<section id="ch13lev1sec3">
<title>Underlying Technologies</title>
<para>Before<indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm> describing the programming interface and the usage details for the current implementation of DCOP, it might be of interest to get acquainted with the underlying technologies and ideas. This section is optional for a developer interested in rapidly gaining the necessary skills for KDE programming. However, even a brief look at issues related to the employed technologies will sometimes help with a better understanding of the DCOP technology itself. This section will be of great interest to the developers proceeding at creating bindings between KDE and other technologies or entities through the use of DCOP.</para>
<section id="ch13lev2sec1">
<title>ICE&mdash;The Inter-Client Exchange Mechanism</title>
<para>The<indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary><tertiary>ICE (Inter-Client Exchange) mechanism</tertiary></indexterm><indexterm><primary>Inter-Client Exchange (ICE) mechanism</primary></indexterm><indexterm><primary>ICE (Inter-Client Exchange) mechanism</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm> KDE developers consider the principle of technology reuse as being of central importance. Whenever possible, existing specifications, standards, and algorithms are adopted and used. As a direct consequence of this way of thinking, the waste of effort in duplication work is diminished. Another consequence is the improved possibility for cooperation with other programming projects.</para>
<para>The authors of DCOP have chosen the ICE mechanism for the communication needs. The main reasons for this choice, as indicated by the main authors, are as follows:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The ICE library comes as a standard part of X11R6, thus it is available on all platforms on which X11R6 (and KDE for that matter) exists.</para></listitem>
<listitem><para>ICE is a well-established technology, used in the session management mechanism defined by X11R6.</para></listitem>
<listitem><para>The ICE library doesn't need a running X server to function, but benefits from other useful tools and technologies that the X Window System offers, such as providing authentication or reporting errors.</para></listitem></itemizedlist>
<para>Detailed documentation concerning the ICE technology and the ICE library are available from public Internet resources. The <emphasis>X Window System Programmer's Guide</emphasis>, part of the large <emphasis>X Consortium Standard</emphasis>, contains a chapter (the eleventh) dedicated to ICE. This document <indexterm><primary>Web sites</primary><secondary>ICE (Inter-Client Exchange) documentation</secondary></indexterm>is available at <ulink url="http://www.rzg.mpg.de/rzg/batch/NEC/sx4a_doc/g1ae04e/contents.html">http://www.rzg.mpg.de/rzg/batch/NEC/sx4a_doc/g1ae04e/contents.html</ulink> or, in a hardcopy format, at <ulink url="ftp://ftp.x.org/pub/R6.4/xc/doc/hardcopy/ICE/">ftp://ftp.x.org/pub/R6.4/xc/doc/hardcopy/ICE/</ulink>.</para>
<para>Learning more about ICE and its API is useful for developers who can't or don't want to use KDE's DCOP infrastructure, yet want to add to their application capabilities of communication with KDE applications that use DCOP. As an example, during the development of the notification system that KDE uses for application launchers, KDE developers used code based on pure ICE in order to connect to the DCOP server for broadcasting application startup notification.</para>
<para>A practical example of using ICE directly (other than in the DCOP engine itself) is Rik Hemsley's C wrapper API, contained in the KDE 2 <indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary><tertiary>ICE (Inter-Client Exchange) mechanism</tertiary></indexterm><indexterm><primary>Inter-Client Exchange (ICE) mechanism</primary></indexterm><indexterm><primary>ICE (Inter-Client Exchange) mechanism</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm>libraries (kdelibs/dcop/dcopc.h and kdelibs/dcop/dcopc.c).</para>
</section>
<section id="ch13lev2sec2">
<title>Data Streaming</title>
<para>Applications<indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary><tertiary>data streaming</tertiary></indexterm><indexterm><primary>data streaming</primary></indexterm><indexterm><primary>streaming data</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm> use DCOP to pass <emphasis>data</emphasis> between them. The nature and the structure of data are characterized by diversity. The DCOP transport mechanism has to ignore these characteristics of manipulated data. Thus, data has to be serialized. Serialization is the operation through which a collection of typed data items is transformed into an atypic, program-independent (and eventually even platform-independent) stream of information. Serialization has to respect a set of conversion rules that are then used accordingly in the de-serialization process.</para>
<para>For serialization/de-serialization, KDE uses <literal>QDataStream</literal> objects as defined by the Qt library. Reference documentation for QDataStream is available at <indexterm><primary>Web sites</primary><secondary>QDataStream documentation</secondary></indexterm><ulink url="http://doc.trolltech.com/qdatastream.html">http://doc.trolltech.com/qdatastream.html</ulink>. The serialization format is described in <ulink url="http://doc.trolltech.com/datastreamformat.html">http://doc.trolltech.com/datastreamformat.html</ulink>. <literal>QDataStream</literal> assures binary data encoding independent of operating system, hardware platform, and byte order. Writing to and reading from a generic device through <literal>QDataStream</literal> serialization is simple (see <link linkend="ch13list01">Listings 13.1</link> and <link linkend="ch13list02">13.2</link>).<indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary><tertiary>data streaming</tertiary></indexterm><indexterm><primary>data streaming</primary><secondary>writing to devices</secondary></indexterm><indexterm><primary>streaming data</primary><secondary>writing to devices</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm><indexterm><primary>writing</primary><secondary>QDataStream serialization</secondary></indexterm><indexterm><primary>QDataStream objects</primary></indexterm><indexterm><primary>objects</primary><secondary>QDataStream</secondary></indexterm></para>
<example role="codelisting" label="13.1" id="ch13list01">
<title>Writing Through a <literal>QDataStream</literal><indexterm><primary>listings</primary><secondary>writing through QDataStream</secondary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qbitarray.h>
2: #include &lt;qdatastream.h>
3:
4: QByteArray message;
5: QDataStream stream(message, IO_WriteOnly);
6: int data = 10;
7: stream &lt;&lt; data; // put the data in the stream in usual way
</programlisting>
</example>
<example role="codelisting" label="13.2" id="ch13list02">
<title>Reading from a Raw <quote>Device</quote> Using a <literal>QDataStream</literal><indexterm><primary>data streaming</primary><secondary>reading devices</secondary></indexterm><indexterm><primary>streaming data</primary><secondary>reading devices</secondary></indexterm><indexterm><primary>reading</primary><secondary>devices</secondary><tertiary>QDataStream</tertiary></indexterm><indexterm><primary>listings</primary><secondary>reading from device with QDataStream</secondary></indexterm></title>
<programlisting linenumbering="numbered">
1: #include &lt;qbitarray.h>
2: #include &lt;qdatastream.h>
3:
4: QByteArray message;
5: QDataStream rstream(message, IO_ReadOnly);
6: int rdata;
7: rstream >> rdata; // get the data
</programlisting>
</example>
<para>You must imagine the <literal>QByteArray</literal> object as a piece of paper on which a message is written. The <literal>QDataStream</literal> object could then be the bottle in which the message can travel safely.</para>
<para>The data stream class implemented and used by the Qt library has many supplementary features, such as a means for setting the byte order manually, a tool for putting data in a printable form, and capabilities to operate on raw bytes collections. This technology is fast and convenient.</para>
<para>KDE's core libraries contain a few enhancements to <literal>QDataStream</literal> in the form of many new streaming operators that deal with supplementary data types that KDE classes need in DCOP (<literal>bool</literal>, <literal>unsigned long</literal>, and <literal>long</literal>). If you need to use these, you have to replace line 2 in the preceding listings with<indexterm><primary>DCOP</primary><secondary>underlying technologies</secondary><tertiary>data streaming</tertiary></indexterm><indexterm><primary>data streaming</primary></indexterm><indexterm><primary>streaming data</primary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>underlying technologies</tertiary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
#include &lt;kdatastream.h>
</programlisting>
</informalexample>
</section>
</section>
<section id="ch13lev1sec4">
<title>Architecture</title>
<para>The<indexterm><primary>DCOP</primary><secondary>architecture</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>architecture</tertiary></indexterm><indexterm><primary>architecture</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm> main actor in the in the DCOP world is the <emphasis>client</emphasis>. Every program needing to communicate has only to become a DCOP client. A DCOP server (an executable named, surprisingly enough, <emphasis>dcopserver</emphasis>), runs permanently on the desktop and acts as a dispatcher for messages all clients are passing. The dispatching is completely transparent to the clients. Hence, from their strict point of view, clients are peers of each other.</para>
<para>The protocol supports both <quote>send and forget</quote> (like a mail message) and <quote>call then listen</quote> (like a telephone call) functionalities. The DCOP server provides a means for client registration. Only clients that are implementing data processing need to register with the server (that is, clients that will receive and process messages have to make themselves known to the DCOP server). The calling-only clients can use the messaging mechanisms anonymously.<indexterm><primary>DCOP</primary><secondary>architecture</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>architecture</tertiary></indexterm><indexterm><primary>architecture</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<para>All communications are performed using data serialized by means of the <literal>QDataStream</literal> technology just described.</para>
<para>Messages can be</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Method Calls&mdash;In this case, the name of the object in the receptor client that implements the called method.</para></listitem>
<listitem><para>Signal Emissions&mdash;This allows Qt-style signal/slot communications over DCOP.</para></listitem></itemizedlist>
<para>Knowing the receptor client for an issued message isn't mandatory because message broadcasts are allowed. Usually, however, the receptor client is specified.</para>
<para><link linkend="ch13fig01">Figure 13.1</link> offers a graphical presentation of the DCOP client/server architecture.<indexterm><primary>DCOP</primary><secondary>architecture</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>architecture</tertiary></indexterm><indexterm><primary>architecture</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<figure label="13.1" id="ch13fig01">
<title>The client/server architecture of DCOP.<indexterm><primary>DCOP</primary><secondary>architecture</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>architecture</tertiary></indexterm><indexterm><primary>architecture</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/13fig01.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
</section>
<section id="ch13lev1sec5">
<title>Description of DCOP's Programming Interface</title>
<para>At<indexterm><primary>DCOP</primary><secondary>programming interface</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary></indexterm> its first implementation, the DCOP protocol offered only a handful of methods necessary for the proper functioning of interprocess communication. To date, it is possible to manually implement the DCOP mechanism in a program using only primordial DCOP methods: <literal>send()</literal>, <literal>call()</literal> and <literal>process()</literal>. An application has to make use of the default <literal>DCOPClient</literal> object offered by the base KDE class <literal>KApplication</literal> and then use the <literal>send()</literal> and/or <literal>call()</literal> methods. Also, part of the objects of an application can inherit the <literal>DCOPObject</literal> class and then overload the virtual <literal>process()</literal> method.</para>
<para>In order to make the use of DCOP even simpler, a compiler is provided for the DCOP IDL (Interface Description Language). This compiler, named <emphasis><literal>dcopidl</literal></emphasis>, while fulfilling a job similar to CORBA's integrated IDL compiler, remains simpler to use. This is because <literal>dcopidl</literal>'s functioning principle is similar to Qt's <literal>moc</literal> pre-compiler. Special preprocessor specifiers placed in a header (.h) file are enough for <literal>dcopidl</literal> to automatically generate <literal>_skel.cpp</literal> and <literal>_stub.cpp</literal> files for the future DCOP client.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary></indexterm></para>
<section id="ch13lev2sec3">
<title>Starting it All</title>
<para>Every <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopClient() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopClient() method</secondary></indexterm><indexterm><primary>dcopClient() method</primary></indexterm><indexterm><primary>methods</primary><secondary>dcopClient()</secondary></indexterm>application that complies with KDE's API can be easily invested with DCOP client functionality. A call to the <literal>KApplication::dcopClient()</literal> method determines an instantiation of a <literal>DCOPClient</literal> object inside the current <literal>KApplication</literal>. The programmer is provided with a pointer to this instance:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
DCOPClient *client = kapp->dcopClient();
</programlisting>
</informalexample>
<para>Up to here, the provided tools are inert. In order to actually enable DCOP, the client has to be <quote>attached</quote> to the server. A code line such as<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>attach() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>attach() method</secondary></indexterm><indexterm><primary>attach() method</primary></indexterm><indexterm><primary>methods</primary><secondary>attach()</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
bool done = client->attach();
</programlisting>
</informalexample>
<para>will accomplish this. At this moment, if the answer from the attaching call is true, the client is capable of communications because the <literal>dcopserver</literal> accepted an anonymous registration from it. For a few reasons (the most common of which is that the server is not available), the value returned by the <literal>attach()</literal> call can be false, in which case the <literal>KApplication</literal> object will pop up an error dialog box.</para>
<para>If the current client needs to send and also receive messages, and then process data extracted from these messages, a proper registration with the server is needed:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
QCString realAppId = client->registerAs(kapp->name());
</programlisting>
</informalexample>
<para>The <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>registerAs() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>registerAs() method</secondary></indexterm><indexterm><primary>registerAs() method</primary></indexterm><indexterm><primary>methods</primary><secondary>registerAs()</secondary></indexterm>parameter to <literal>registerAs()</literal> only suggests a registration identifier (id) for the current application. The returned value actually indicates the real application id, as decided by the server. In fact, a second parameter to <literal>registerAs()</literal>, which has an implicit value of true, imposes that the operating system process identifier (the PID) be attached to the application name. Application identifiers have to be allowed to differ from the requested id because an application can exist in multiple instances on the desktop at a given moment. But each instance needs a unique identifier in order for the communication to remain possible.</para>
<para>This chapter discusses in more detail later a special case of DCOPClient: a <literal>KUniqueApplication</literal>. It is important to mention that for clients based on <literal>KUniqueApplication</literal>, no attaching or registration to the dcopserver is needed, because in such a case these are both performed automatically.</para>
<para>A brief statement is required here about efficiency issues of the DCOP client implementation. If the <literal>KApplication:dcopClient()</literal> method never gets called or if its call is unsuccessful, a <literal>DCOPClient</literal> instance is not created, and hence no memory allocation occurs.</para>
</section>
<section id="ch13lev2sec4">
<title>Using <literal>send()</literal>, <literal>call()</literal>, <literal>process()</literal>, and Friends</title>
<para>If you are a programmer who needs a better understanding of how DCOP functions, you'll want to carefully read this section. Manual usage of the desktop protocol is explained here and the syntaxes and use of the <literal>send()</literal>, <literal>call()</literal>, and <literal>process()</literal> methods are described. If you believe that you would be better served by an automatic mechanism, you can safely skip this section. An automatic mechanism that builds DCOP capabilities in KDE applications is described later in the chapter.</para>
<section id="ch13lev3sec1">
<title>Send and Forget</title>
<para>Client<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>send() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>send() method</secondary></indexterm><indexterm><primary>send() method</primary></indexterm><indexterm><primary>methods</primary><secondary>send()</secondary></indexterm><quote>A</quote> <emphasis>sends</emphasis> a message to client <quote>B</quote>. The communication occurs only in one sense. The originator of the message doesn't want to know whether the recipient takes action as a consequence. This is the simplest method of communication provided by DCOP. Client <quote>B</quote> doesn't need to be different from <quote>A</quote> and doesn't need to be unique. Details of <emphasis>broadcast</emphasis> communication are covered later in this chapter. A client uses <literal>DCOPClient::send()</literal> as illustrated in <link linkend="ch13list03">Listing 13.3</link>.</para>
<example role="codelisting" label="13.3" id="ch13list03">
<title>Typical Use of <literal>DCOPClient::send()</literal><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPClient send() method</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: QByteArray  data;                     // "raw support" for data
2: QDataStream arg(data, IO_WriteOnly);  // "container" provides
                                         // easy access to data
3: int a_number = 3;
4: arg &lt;&lt; a_number;                      // put information on the
                           // "support" in the "container"
5: if (!client->send("otherClientId",    // identify the recipient
6:                   "anObject/aChildOject", //hierarchically designate
                           // the targeted object
7:                   "readAnInt(int)",   // signature of the method
                           // that will handle sent data
8:                   data));             // the data
9:   kdDebug &lt;&lt; "Sending data over DCOP failed" &lt;&lt; endl;
</programlisting>
</example>
<para>First, the sender client needs to indicate the complete hierarchy of the object providing the method designated to process the sent data (line 6). Second, the method's signature, as marked in line 7, indicates the types of parameters the method accepts. It doesn't provide the type returned because the C++ standard distinguishes overloaded methods by number and types of parameters and neglects the return type.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>send() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>send() method</secondary></indexterm><indexterm><primary>send() method</primary></indexterm><indexterm><primary>methods</primary><secondary>send()</secondary></indexterm></para>
<para>A second form of the method <literal>DCOPClient::send()</literal> (see <link linkend="ch13list04">Listing 13.4</link>), provided for convenience, uses <literal>QString</literal> (compare line 8 of <link linkend="ch13list03">Listing 13.3</link> with line 5 of <link linkend="ch13list04">Listing 13.4</link>) instead of <literal>QDataStream</literal> as a data carrier. This kind of usage occurs frequently.</para>
<example role="codelisting" label="13.4" id="ch13list04">
<title><literal>DCOPClient::send()</literal> with QString Data<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPClient send() method with QString data</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: bool send_fast = true;
2: client->send("travelingInTheAlps",
3:              "happyMan/hmWithBigVoice",
4:              "countTheEchos(QString)", // *example*
5:              QString("Hello World"),   // shouting off a cliff :-)
6:             send_fast));               // use "fast" IPC mechanisms
</programlisting>
</example>
<para>Line 6 in <link linkend="ch13list04">Listing 13.4</link> describes the feature of DCOP that allows a client to <emphasis>recommend</emphasis> use of a faster mechanism of communication. Such a mechanism isn't guaranteed to always be available. It will work only during communications between clients existing on the same local machine.</para>
<para>As already indicated, the sender client issues the message and continues his normal functions without waiting for communication acknowledgments. This is a very common need in the desktop environment. Often, such a send-and-forget message has to be issued to many clients at once. In a hypothetical situation, a configuration module notifies all existing konsole instances about a configuration change, using <literal>"konsole_*"</literal> as the first parameter of <literal>DCOPClient::send()</literal>.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>send() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>send() method</secondary></indexterm><indexterm><primary>send() method</primary></indexterm><indexterm><primary>methods</primary><secondary>send()</secondary></indexterm></para>
<para>Theoretically, a global broadcast (that is, using <quote>*</quote> as a first parameter of the <literal>DCOPClient::send()</literal> method) is also possible. Yet, because <literal>DCOPClient::send()</literal> doesn't check for acknowledgments, no guarantee is offered that even one client processed the message. Wildcards are also allowed in the second parameter (the objects hierarchy). Using many wildcards in DCOP communications is a bad idea, though, because it generates large amounts of IPC traffic.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>send() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>send() method</secondary></indexterm><indexterm><primary>send() method</primary></indexterm><indexterm><primary>methods</primary><secondary>send()</secondary></indexterm></para>
<note role="normal">
<para>A special mention is necessary: Use of wildcards assumes special support on the side of recipient clients. Their <literal>DCOPObject::process()</literal> method (see the section <link linkend="ch13lev3sec3"><quote>Analyze and Take Action</quote></link> later in this chapter) has to offer special code for handling wildcards. This is usually available with clients built using <literal>dcopidl</literal> (explained further later in this chapter) but seldomly so with manually written clients.</para>
</note>
</section>
<section id="ch13lev3sec2">
<title>Call and Listen</title>
<para>Client<indexterm><primary>DCOP</primary></indexterm><quote>A</quote> <emphasis>calls</emphasis> the peer client <quote>B</quote> and waits for an answer. This two-way communication is achieved through the use of the <literal>DCOPClient::call()</literal> method (see <link linkend="ch13list05">Listing 13.5</link>).</para>
<example role="codelisting" label="13.5" id="ch13list05">
<title>Typical Use of <literal>DCOPClient::call()</literal><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPClient call() method</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: QByteArray  data, reply_data;    // also prepare a byte array
                         // for the reply
 2: QCString reply_type; // will contain the type of the reply
 3: QDataStream arg(data, IO_WriteOnly);
 4: int a_number = 3;
 5: arg &lt;&lt; a_number;
 6: if (!client->call("otherClientId",
 7:                   "anObject/aChildOject",
 8:                   "readAnIntAndAnswer(int)",
             // signature of method to handle data and answer
 9:                   data,                      // sent data
10:                   reply_type,
             // type of data contained in the answer
11:                   reply_data);         // the answer
12:   kdDebug &lt;&lt; "Calling over DCOP failed!" &lt;&lt; endl;
13: else {
14:   QDataStream answer(reply_data, IO_ReadOnly);
15:   if (reply_type == "Qstring") {
16:     QString result;
17:     answer >> result;
18:     this->doSomething(result);
19:   } else
20:     kdDebug &lt;&lt; "Calling over DCOP succeeded,\
             but the answer had wrong type!" &lt;&lt; endl;<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPClient call() method</tertiary></indexterm>
</programlisting>
</example>
<para>Use of wildcards(broadcasting) isn't allowed with the <literal>DCOPClient::call()</literal> method because the communication is established from peer to peer. In other words, the originator client waits for exactly one answer. Of course, this can be a problem when peer clients are registered with the server by identifiers different from their name (for example, clients registered with the form <emphasis><literal>appname</literal></emphasis><literal>-</literal><emphasis><literal>pid</literal></emphasis>). Yet, the server gains heuristic capabilities that allow use of generic identifiers. This way, <literal>DCOPClient::call()</literal> can use a generic but sensible name (for example, <literal>"konqueror"</literal>). The server will pick up and establish connection with the first available instance from the group of clients whose identifiers are matching the generic name (for example, <literal>"konqueror-NNN"</literal>, where <literal>"NNN"</literal> are operating system's process identifiers, or PIDs).<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>call() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>call() method</secondary></indexterm><indexterm><primary>call() method</primary></indexterm><indexterm><primary>methods</primary><secondary>call()</secondary></indexterm></para>
</section>
<section id="ch13lev3sec3">
<title>Analyze and Take Action</title>
<para>The<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>process() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>process() method</secondary></indexterm><indexterm><primary>process() method</primary></indexterm><indexterm><primary>methods</primary><secondary>process()</secondary></indexterm> previous two sections described how a DCOP client can generate DCOP messages. These messages are sent over communication channels that the client establishes with the DCOP server during the initial phases (<literal>attach()</literal>, <literal>registerAs()</literal>). The server is only expected to pass the message over to the designated recipient&mdash;only this client knows how to process the transmitted data.</para>
<para>A client gains reception abilities through the inheritance of a special class provided by the DCOP mechanism. This usually means that a receiving client uses multiple inheritance:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>It inherits its normal parent; for example, a <literal>QWidget</literal>, a <literal>KCModule</literal>, or a <literal>KApplication</literal> class.</para></listitem>
<listitem><para>It inherits the <literal>DCOPObject</literal> class available in the DCOP API.</para></listitem></itemizedlist>
<para>A sample implementation is shown in <link linkend="ch13list06">Listing 13.6</link>.</para>
<example role="codelisting" label="13.6" id="ch13list06">
<title>Simple Object that Implements DCOP Processing<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>object that implements DCOP processing</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File asmartwidget.h
------------------------------------------------
 1: #include &lt;qwidget.h>
 2: #include &lt;qlabel.h>
 3: #include &lt;qlayout.h>
 4: #include &lt;dcopobject.h>
 5:
 6: class ASmartWidget : public QWidget, public DCOPObject {
 7:
 8: protected:
 9:   QLabel *l_front;
10:
11: public:
12:   ASmartWidget(const char* name);
13:
14:   bool setFront(QString&amp;);
15:   QString&amp; front() { return l_front->text();};
16:
17: protected:
18:   bool process(const QCString &amp;fun,  // the function to be called
19:                const QByteArray &amp;data,
                             // data passed to the function
20:                QCString &amp;reply_type, // indicate what type has
                             // the reply data
21:                QByteArray &amp;reply_data);// the answer (reply data)
22:
23: };<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>process() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>process() method</secondary></indexterm><indexterm><primary>process() method</primary></indexterm><indexterm><primary>methods</primary><secondary>process()</secondary></indexterm><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>object that implements DCOP processing</tertiary></indexterm>

File asmartwidget.cpp
------------------------------------------------
 1: #include &lt;qbitarray.h>
 2: #include &lt;qdatastream.h>
 3:
 4: ASmartWidget::ASmartWidget(const char* name):
 5:   QWidget(name),
 6:   DCOPObject() {
 7:
 8:     QVBoxLayout *lay = new QVBoxLayout (this, 10, 10);
 9:     l_front = new QLabel(this, "Hello, I'm a smart widget);
10:     lay->addWidget (front);
11:
12:   }
13:
14: bool ASmartWidget::setFront(QString&amp; l) {
15:   // a bit of data processing - eventually filter contents of l
16:   if (l.find("smart") != -1) {
17:     l_front->setText( l );
18:     return true;
19:   } else
20:     return false;
21: }
22:
23: bool ASmartWidget::process(const QCString &amp;fun,
                     const QByteArray &amp;data,
24:                            QCString &amp;reply_type,
                     QByteArray &amp;reply_data) {
25:
26:   if (fun == "setFront(QString&amp;)") {
27:     QDataStream arg(data, IO_ReadOnly);
28:     QString&amp; atext;
29:     arg >> atext;
30:     bool result = setFront(atext);
31:
32:     QDataStream answer(reply_data, IO_WriteOnly);
33:    answer &lt;&lt; result;
34:     reply_type = "bool";
35:     return true;
36:   } else {
37:       kdDebug &lt;&lt; "Processing DCOP call failed. Function unknown!"
            &lt;&lt; endl;
38:       return false;
39:   }
40: }<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>object that implements DCOP processing</tertiary></indexterm>
</programlisting>
</example>
<para>The<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>process() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>process() method</secondary></indexterm><indexterm><primary>process() method</primary></indexterm><indexterm><primary>methods</primary><secondary>process()</secondary></indexterm> preceding code is very easy to understand and even easier to use, in combination with what you learned already about <literal>DCOPClient::send()</literal> and <literal>DCOPClient::call()</literal>. It is straightforward to make the preceding class a member of a proper KDE application, start this application, and then from another DCOP client, issue a <literal>send()</literal> of the form</para>
<informalexample>
<programlisting linenumbering="unnumbered">
client->send("someApplication",
             "AsmartWidget",
             "setFront(QString&amp;)",
             QString("To be smart is not enough"));
</programlisting>
</informalexample>
<para>This action will make your small widget acknowledge its human-like limitations.</para>
<para>As previously mentioned, a <literal>DCOPObject::process()</literal> method becomes part of an object's interface through inheritance of the <literal>DCOPObject</literal> class. The programmer needs to ensure inheritance and implementation for each and every object of his application that has to offer DCOP reception capabilities. Yet, it is possible to build DCOP call processing mechanisms directly at an application-wide level. Two ways of achieving this are explained here.</para>
<para>The <literal>setDefaultObject()</literal><indexterm><primary>setDefaultObject() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setDefaultObject()</secondary></indexterm> method accepts one unique parameter, a <literal>QCString</literal> that denominates the object that receives and processes all application-wide DCOP calls. Its pair method, <literal>DCOPClient::defaultObject()</literal>, returns a <literal>QCString</literal> with the name of this special object member of the application.</para>
<para>The API of the class <literal>DCOPClient</literal> also offers a <literal>DCOPClient::process()</literal> method. In the initial phases of the development of the DCOP technology, the <literal>process()</literal> capabilities were achieved by an application through inheritance from the <literal>DCOPClient</literal> class. The <literal>DCOPClient::process()</literal> method has the same definition as the <literal>DCOPObject::process()</literal> method. It offers a second method of implementation for application-wide DCOP call processing. Developers should prefer the use of <literal>DCOPObject</literal> or <literal>DCOPObjectProxy</literal> classes for this purpose, however.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>process() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>process() method</secondary></indexterm><indexterm><primary>process() method</primary></indexterm><indexterm><primary>methods</primary><secondary>process()</secondary></indexterm></para>
</section>
<section id="ch13lev3sec4">
<title>Longer Calls Become Transactions</title>
<para>Time <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm>is an important component of communications processes. This affirmation is obviously valid in the real world (information about a large storm heading to Bill's house has no value for Bill if it arrives after the storm has already calmed). And it remains valid, while gaining strong connotations, in the programming world. There are two aspects in the involvement of time in process communication:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Conjuncture&mdash;Events have to occur at the right moment (proper handling of erratic events is mandatory).</para></listitem>
<listitem><para>Duration&mdash;Events have to behave in a smart way in relation to the time needed for them to be transmitted and/or processed.</para></listitem></itemizedlist>
<para>The first aspect is less important at this point in the discussion. In relation to the duration of events, the DCOP mechanism needs some explanation. As presented in the previous sections, the <literal>DCOPClient::call()</literal> is a blocking method. Its use implies awareness of GUI refresh issues and effective event loop treatments, as well as concerns related to the continuous processing of DCOP calls.</para>
<para>Fortunately, things are made easy by methods provided by the <literal>DCOPClient</literal> class. The family of <emphasis>transaction methods</emphasis> enlists the following:<indexterm><primary>beginTransaction() method</primary></indexterm><indexterm><primary>methods</primary><secondary>beginTransaction()</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
DCOPClientTransaction* DCOPClient::beginTransaction()

Q_INT32                DCOPClient::transactionId()

void
DCOPClient::endTransaction(DCOPClientTransaction* newTr,<indexterm><primary>endTransaction() method</primary></indexterm><indexterm><primary>methods</primary><secondary>endTransaction()</secondary></indexterm>
                        //a handle of the negociated transaction
                           QCString&amp; reply_type,
                        // data type and data stream that were not
                           QDataStream&amp; reply_data)
// not available as an immediate answer to a call
</programlisting>
</informalexample>
<para>The signatures shown in the code are implying that a transaction lives like an object of type class <literal>DCOPClientTransaction</literal> (defined and implemented in the DCOP API). The transaction identifier is an integer declared with the platform-independent type macros offered by the Qt library.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm></para>
<para>Understanding the functionality offered by these methods is straightforward, as exemplified by the following code. Assume that the method of our humanly smart widget, which changed the text on the front label, executes a time-consuming filtering operation instead of simply detecting the word <quote>smart</quote> in the input. The implementation of our class needs to be changed as shown in <link linkend="ch13list07">Listing 13.7</link></para>
<example role="codelisting" label="13.7" id="ch13list07">
<title>DCOP Processing with Transactions<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>processing with transactions</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File asmartwidget.h
------------------------------------------------
 1: #include &lt;qwidget.h>
 2: #include &lt;qlabel.h>
 3: #include &lt;qlayout.h>
 4: #include &lt;dcopclient.h>
 5: #include &lt;dcopobject.h>
 6:
 7: class ASmartWidget : public QWidget, public DCOPObject {
 8: Q_OBJECT
 9:
10: protected:
11:   QLabel *l_front;
12:
13: public:
14:   ASmartWidget(const char* name);
15:
16:   void changeFront(DCOPClientTransaction*, QString&amp;);
17:   QString&amp; front() { return l_front->text();};
18:
19: public slots:
20:   void frontIsChanged(DCOPClientTransaction* ,
                  QByteArray&amp;, QDataStream &amp;);
21:
22:<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>processing with transactions</tertiary></indexterm>
23: protected:
24:   bool process(const QCString &amp;fun,   // the function to be called
25:                const QByteArray &amp;data,
                              // data passed to the function
26:                QCString &amp;reply_type,  // indicate what type has
                            // the reply data
27:                QByteArray &amp;reply_data);// the answer (reply data)
28:
29: };

File asmartwidget.cpp
------------------------------------------------
 1: #include &lt;qbitarray.h>
 2: #include &lt;qdatastream.h>
 3:
 4: ASmartWidget::ASmartWidget(const char* name):
 5:   QWidget(name),
 6:   DCOPObject() {
 7:
 8:     QVBoxLayout *lay = new QVBoxLayout (this, 10, 10);
 9:     l_front = new QLabel(this, "Hello, I'm a smart widget);
10:     lay->addWidget (front);
11:
12:   }
13:
14: void ASmartWidget::changeFront(DCOPClientTransaction* aTransaction,
                         DCOPQString&amp; l) {
15:
16:   bool succeeded = false;
17:
18:   // time consuming data processing -
19:   //    complex filter and cruncher for the contents of l
20:   // for (&hellip;) {
21:   // &hellip;
22:   // }<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>processing with transactions</tertiary></indexterm>
23:
24:   if (l.find('smart') != -1) { // or other interesting condition
25:     l_front->setText( l );
26:     succeeded = true;
27:   } else
28:     succeeded = false;
29:
30:   frontIsChanged(aTransaction, succeeded);
31: }
32:
33: bool ASmartWidget::process(const QCString &amp;fun,
                     const QByteArray &amp;data,
34:                            QCString &amp;reply_type,
                      QByteArray &amp;reply_data) {
35:
36:   if (fun == "setFront(QString&amp;)") {
37:
38:     DCOPClientTransaction *myTransaction;
39:     newTransaction = kapp->dcopClient()->beginTransaction();
40:
41:     QDataStream arg(data, IO_ReadOnly);
42:     QString&amp; atext;
43:     arg >> atext;
44:
45:     Q_INT32 trId = kapp->dcopClient()->transactionId();
                // trId == 0 if no transaction
46:     if (trId) {
47:       changeFront(newTransaction, atext);
48:      kdDebug &lt;&lt; "Transaction " &lt;&lt; trId &lt;&lt; " established!" &lt;&lt; endl;
49:       return true;
50      } else {
51:       kdDebug &lt;&lt; "Processing DCOP call failed.\
                No transaction accepted!" &lt;&lt; endl;
52:       return false;
53:
54:   } else {<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>processing with transactions</tertiary></indexterm>
55:       kdDebug &lt;&lt; "Processing DCOP call failed. Function unknown!"
            &lt;&lt; endl;
56:       return false;
57: }
58:
59: void ASmartWidget::frontIsChanged(DCOPClientTransaction* aTransaction,
60:    bool data) {
61:   QByteArray reply_data;
62:   QDataStream answer(reply_data, IO_WriteOnly);
63:   answer &lt;&lt; data;
64:   QCString reply_type = "bool";
65:   kapp->dcopClient()->endTransaction(aTransaction,
                             reply_type, reply_data);
66:
67: }<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>processing with transactions</tertiary></indexterm>
</programlisting>
</example>
<para>This example makes clear that the transaction methods have a proper usage only inside the implementation of the <literal>DCOPObject::process()</literal> method. Using transactions is obviously more complex and a bit heavier, both in terms of programming and resource usage (more DCOP communication traffic). Of course, transactions can also generate complex puzzles of application functionality and usability. When a <literal>call()</literal> can be answered with a transaction, all assumptions about the linearity of caller's functioning are wrong. On the other side, the main reason for the existence of <emphasis>transaction methods</emphasis> is to allow implementations of non-blocking DCOP calls. Consequently, attention and consideration in the use of transactions is advised.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>transactions</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>transactions</secondary></indexterm><indexterm><primary>transactions (DCOP)</primary></indexterm></para>
<note role="tip">
<para>Another tool referring to blocking calls is the signal <literal>DCOPClient::blockUserInput(bool)</literal>. <indexterm><primary>blockUserInput() method</primary></indexterm><indexterm><primary>methods</primary><secondary>blockUserInput()</secondary></indexterm>This signal is automatically used by <literal>KApplication</literal> to block (parameter is true) or release (parameter is false) the graphical interface while the client waits for an answer to a DCOP call. The programmer doesn't normally have a use for manually emitting this signal.</para>
</note>
</section>
<section id="ch13lev3sec5">
<title>Handling the Connection</title>
<para>An <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>detach() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>detach() method</secondary></indexterm><indexterm><primary>detach() method</primary></indexterm><indexterm><primary>methods</primary><secondary>detach()</secondary></indexterm>attached client can cut all communication with the DCOP server by detaching itself. This operation is achieved through a call to the <literal>DCOPClient::detach()</literal> method. Such a call is automatically performed during the client's normal stop (during the call of client's main destructor). A manual call is also allowed.</para>
<para>Situations may occur in which the connection with the DCOP server has to be deactivated temporarily. For example, when the user is prompted to decide upon a DCOP related situation, the program can halt communication for a while using the <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>suspend() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>suspend() method</secondary></indexterm><indexterm><primary>suspend() method</primary></indexterm><indexterm><primary>methods</primary><secondary>suspend()</secondary></indexterm>method <literal>DCOPClient::suspend()</literal>. If the user's decision allows for continuing, the program calls <indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>resume() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>resume() method</secondary></indexterm><indexterm><primary>resume() method</primary></indexterm><indexterm><primary>methods</primary><secondary>resume()</secondary></indexterm><literal>DCOPClient::resume()</literal> to reestablish the communication. The developer has to pay attention to the fact that suspending the connection for a relatively long time might be a bad idea. If other clients are attempting to perform <literal>call()</literal> connections to the currently suspended application, they will hang (see the section<link linkend="ch13lev2sec4"><quote>Using <literal>send()</literal>, <literal>call()</literal>, <literal>process()</literal>, and Friends,</quote></link> earlier in the chapter).</para>
</section>
</section>
<section id="ch13lev2sec5">
<title>Automated Elegance&mdash;dcopIDL</title>
<para>The<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm> preceding section discussed how to proceed for a manual implementation of DCOP capabilities in a KDE application. As already mentioned, an automated way of developing DCOP support exists. To this purpose, the DCOP authors created a set of IDL compiling tools: <literal>dcopidl</literal> and <literal>dcopidl2cpp</literal>. These compilers make use of a special syntax of header files to generate standard encapsulation methods for the DCOP messaging. A new iteration of part of the smart widget code will help illustrate this (see <link linkend="ch13list08">Listing 13.8</link>).</para>
<example role="codelisting" label="13.8" id="ch13list08">
<title>Using <literal>dcopidl</literal><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>dcopidl</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File asmartwidget.h
------------------------------------------------
 1: #include &lt;qwidget.h>
 2: #include &lt;qlabel.h>
 3: #include &lt;qlayout.h>
 4: #include &lt;dcopobject.h>
 5:
 6: class ASmartWidget : public QWidget, public DCOPObject {
 7: K_DCOP
 8: Q_OBJECT
 9:
10: protected:
11:   QLabel *l_front;
12:
13: public:
14:   ASmartWidget(const char* name);
15
16:   QString&amp; front() { return l_front->text();};
17:
18: k_dcop:
19:   bool changeFront(QString&amp; l);
20:
21: };
 File: asmartwidget,cpp<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm><indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>dcopidl</tertiary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm>
-----------------------------------
 1:  #include &lt;qbitarray.h>
 2:  #include &lt;qdatastream.h>
 3:  #include "asmartwidget.h"
 4:
 5:  ASmartWidget::ASmartWidget(const char* name)
 6:    : QWidget(0, name),
 7:      DCOPObject()
 8:    {
 9:      QVBoxLayout *lay = new QVBoxLayout (this, 10, 10);
10:      l_front = new QLabel(this, "Hello, I'm a smart widget");
11:      lay->addWidget (l_front);
12:    }
13:
14:  bool ASmartWidget::changeFront(const QString&amp; l) {
15:
16:    bool succeeded = false;
17:
18:    if (l.find("smart") != -1) { // or other interesting condition
19:      l_front->setText( l );
20:      succeeded = true;
21:    } else
22:      succeeded = false;
23:
24:    return succeeded;
25:  }<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>dcopidl</tertiary></indexterm>
</programlisting>
</example>
<para>When comparing <link linkend="ch13list08">Listing 13.8</link> with the code shown in <link linkend="ch13list07">Listing 13.7</link>, the simplifications of using DCOP provided by the <literal>dcopidl</literal> mechanism become evident. The asmartwidget.cpp file is simplified accordingly (no need to implement the <literal>::process()</literal> method). New elements to pay attention to in this last code example appear in lines 7, 18, and 19.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm></para>
<para><literal>K_DCOP</literal> (line 7) is a preprocessor macro that helps the <literal>dcopidl</literal> compiler to decide that the <literal>ASmartWidget</literal> class has to be processed with respect to DCOP functionalities.</para>
<para>The construct <literal>k_dcop:</literal> present on line 18 is similar to standard C++ scope delimiters (<literal>public</literal>, <literal>private</literal>, <literal>protected</literal>) and helps the <literal>dcopidl</literal> compiler to detect the methods that will gain DCOP messaging envelopes. All methods entailed between a <literal>k_dcop:</literal> label and any other valid C++ or Qt delimiters will be included in the DCOP interface of the current object.</para>
<para>Finally, it's important to note that the <literal>QString</literal> parameter (line 19) of the <literal>changeFront()</literal> method has assigned an explicit name. A rule of use for the <literal>dcopidl</literal> compiler is that, while the C++ standard allows anonymous method parameters, <emphasis>all parameters in DCOP-enabled methods need explicit names</emphasis>.</para>
<para>Suppose you create a KDE application having <literal>ASmartWidget</literal> as its main widget(see <link linkend="ch13list09">Listing 13.9</link>).<indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm></para>
<example role="codelisting" label="13.9" id="ch13list09">
<title>A Typical Application that Uses DCOP<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>typical application that uses DCOP</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File myapp.cpp
-------------------------------
 1: #include &lt;kapp.h>
 2: #include &lt;dcopclient.h>
 3: #include "asmartwidget.h"
 4:
 5: int main(int nargs, char** argv) {
 6:
 7:   KApplication* a = new KApplication(nargs, argv, "myapp");
 8:   ASmartWidget* asw = new ASmartWidget("smart");
 9:   a->setMainWidget(asw);
10:
11:   client = a.dcopClient();
12:   client.attach();
13:   client.registerAs("myapp");
14:
15:   return a.exec();
16: }<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>typical application that uses DCOP</tertiary></indexterm>
</programlisting>
</example>
<para>Line 13 shows that your application (as all applications built to receive and process DCOP messages) needs a non-anonymous registration with the <literal>dcopserver</literal>.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm></para>
<para>With the help of a little Makefile magic (described in the following section) and with heavy use of the <literal>dcopidl</literal> tools, the application will be compiled with built-in DCOP functionality. The tools will automatically generate a few files:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>asmartwidget.kidl is a helper file containing XML code generated by the dcopidl tool.</para></listitem>
<listitem><para>asmartwidget_skel.cpp is a skeleton file, in which the <literal>dcopidl2cpp</literal> tool writes the autogenerated <literal>::process()</literal> method needed to envelop the DCOP enabled methods picked up by processing of the header file.</para></listitem>
<listitem><para>asmartwidget_stub.h is an autogenerated header file that will be installed with the KDE system and then included in DCOP clients willing to use the DCOP interface that myapp offers.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm></para></listitem></itemizedlist>
<para>A stub file can be also written by hand. <link linkend="ch13list10">Listing 13.10</link> is a live example, extracted from the KDE 2 desktop panel, Kicker:<indexterm><primary>stub files (DCOP)</primary></indexterm></para>
<example role="codelisting" label="13.10" id="ch13list10">
<title>Example of a Handmade Stub File<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>handmade stub file</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #ifndef KICKER_INTERFACE_H
 2: #define KICKER_INTERFACE_H
 3:
 4: #include &lt;dcopobject.h>
 5:
 6: class KickerInterface : virtual public DCOPObject
 7: {
 8:    K_DCOP
 9:
10:    k_dcop:
11:
12:        virtual void configure() = 0;
13: };
14:
15: #endif // Included this file.<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>handmade stub file</tertiary></indexterm>
</programlisting>
</example>
<para>A DCOP client that wants to communicate via DCOP with the new smarter widget has only to include the published interface file (asmartwidget_stub.h). An example of the implementation of such a client is shown in <link linkend="ch13list11">Listing 13.11</link>.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm></para>
<example role="codelisting" label="13.11" id="ch13list11">
<title>DCOP Client Using the Automatically Generated Interface of Another DCOP Client<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>client using stub interface</tertiary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm></title>
<programlisting linenumbering="numbered">
File aclient.cpp
---------------------------------
 1: #include &lt;kapp.h>
 2: #include &lt;dcopclient.h>
 3: #include "asmartwidget_stub.h"
 4:
 5: int main( int argc, char** argv )
 6: {
 7:   // client doesn't need GUI hence set fourth parameter to false
 8:   KApplication app( argc, argv, "autoclient", false);
 9:
10:   app.dcopClient()->attach();
11:
12:   ASmartWidget_stub iface( "myapp", "AsmartWidget" );
                    // automatically generated class
13:   iface.changeFront(QString("Now this is really smart!"));
14: }<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>client using stub interface</tertiary></indexterm><indexterm><primary>stub files (DCOP)</primary></indexterm>
</programlisting>
</example>
<para>Line 12 in <link linkend="ch13list11">Listing 13.11</link> exemplifies the use of the automatically generated <quote>stub</quote> interface. This type of usage is visibly more convenient than the manual definitions of <literal>send()</literal>, <literal>call()</literal>, and <literal>process()</literal> on both developed clients. The advantages become especially evident with large programming projects. Using the <literal>dcopidl</literal> compiler proved to be compelling enough that most KDE applications&mdash;which initially used manual DCOP interface implementations&mdash;were recently rewritten to employ this easier and better programming technique.</para>
<para>Looking at how things are prepared for the use of the <literal>dcopidl</literal> tools might raise the question of how does the compiler realize the difference between a method to be treated as a <literal>send()</literal> and one that will be a <literal>call()</literal>. The specification of the <literal>dcopidl</literal> tools provides the developer with the ASYNC pseudotype. ASYNC is a precompiler macro that translates to the valid C++ type <literal>void</literal>. The developer writes ASYNC in the header file defining the DCOP interface, in front of the definition of methods that are expected to be treated as <literal>send()</literal> methods. The <literal>dcopidl</literal> tools will interpret this marker at precompilation and invest the marked method with proper non-blocking implementations.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>dcopIDL</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>dcopIDL</secondary></indexterm><indexterm><primary>dcopIDL</primary></indexterm><indexterm><primary>compilers</primary><secondary>dcopidl</secondary></indexterm></para>
</section>
<section id="ch13lev2sec6">
<title>Makefile Magic</title>
<para>In<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>makefile rules</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>makefile rules</secondary></indexterm><indexterm><primary>makefiles</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm> order for the automated DCOP support to be built in to an application, use of proper <literal>make</literal> rules is needed. A few specific additions will aid the compilation of the preceding examples when using the <literal>dcopidl</literal> tools:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>A rule is needed to generate the .kidl file.</para></listitem>
<listitem><para>Another rule will help create the _skel.cpp, _stub.h, and _stub.cpp files.</para></listitem>
<listitem><para>The generated _skel.cpp (and eventually _stub.cpp) source needs to be compiled.</para></listitem></itemizedlist>
<para>Of course, the usual details related to normal project management have to be taken care of. A Makefile example is shown in <link linkend="ch13list12">Listing 13.12</link>.</para>
<example role="codelisting" label="13.12" id="ch13list12">
<title>Specific Makefile Rules Needed for the DCOP Mechanism<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>makefile rules</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1:  QTDIR = /home/ctibirna/kde/2_0/qt-copy
 2:  CXXFLAGS = -I${QTDIR}/include -I${KDEDIR}/include -I.
 3:  LDFLAGS =  -L${QTDIR}/lib -L${KDEDIR}/lib -L/usr/X11R6/lib
 4:  LDADD = -ldl -lqt -lICE
 5:
 6:  all: autoclient myapp
 7:
 8:  autoclient : asmartwidget_stub.o aclient.o
 9:          g++ asmartwidget_stub.o aclient.o $(LDFLAGS) $(LDADD) -o  autoclient
10:
11:  myapp      : aswmartwidget.o asmartwidget_skel.o asmartwidget_moc.o  myapp.o
12:         g++ myapp.o asmartwidget.o asmartwidget_skel.o asmartwidget_moc.o\
13:           $(LDFLAGS) $(LDADD) -o myapp
14:
15:  .cpp.o:
16:          g++ $(CXXFLAGS) -c $&lt;
17:
18:  asmartwidget.kidl: asmartwidget.h
19:        dcopidl asmartwidget.h > asmartwidget.kidl || rm -f  asmartwidget.kidl
20:  asmartwidget_moc.cpp: asmartwidget.h
21:          ${QTDIR}/bin/moc asmartwidget.h -o asmartwidget_moc.cpp
22:  asmartwidget_skel.cpp: asmartwidget.kidl
23:        dcopidl2cpp asmartwidget.kidl
24:  asmartwidget_stub.cpp: asmartwidget.kidl
25:
26:  clean :
27:          rm -f *.o *_moc.cpp *_skel.* *_stub.* *.kidl myapp autoclient<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>makefile rules</tertiary></indexterm>
</programlisting>
</example>
<para>The use of the standard KDE development environment makes the issue of the Makefile rules much simpler thanks to the autodetection and autogeneration of makefiles used there. Simply adding the name of the _skel.cpp file to be generated and compiled to the list of the other compilable source files is enough.<indexterm><primary>DCOP</primary><secondary>programming interface</secondary><tertiary>makefile rules</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>programming interface</tertiary></indexterm><indexterm><primary>programming interface (DCOP)</primary><secondary>makefile rules</secondary></indexterm><indexterm><primary>makefiles</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
</section>
</section>
<section id="ch13lev1sec6">
<title>Developer Concerns and Tools in DCOP</title>
<para>At this point in the journey of learning DCOP, most of the necessary notions and principles have been presented. You should be able to add DCOP functionality to your existing KDE code. The appropriation of the information presented in the preceding sections hopefully offers a good foundation. A wealth of concrete DCOP usage examples are provided in the standard KDE code.</para>
<para>The remaining sections attempt to provide a fast reference to deeper technical details related to DCOP.</para>
<section id="ch13lev2sec7">
<title>Stay Informed</title>
<para>The<indexterm><primary>DCOP</primary><secondary>API tools</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary></indexterm> team of developers focusing on the KDE's communication protocol technology has made a number of additions to the standard DCOP API designed to make the protocol more informative and even easier to use.</para>
<para>Because DCOP makes use of a server that has to run permanently, willing DCOP clients can be enabled to access an important amount of information about their peers running at a given moment on the desktop. The functionalities offered by the peers are also made publicly available. Following is a list of DCOP API tools that will extract and report this kind of information. The presentation offered here for each of the tools is brief. For a complete description of their programming interface, the API documentation available at <ulink url="http://developer.kde.org">http://developer.kde.org</ulink> is the authoritative resource.</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>isRegistered()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>isRegistered() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>isRegistered() method</secondary></indexterm><indexterm><primary>isRegistered() method</primary></indexterm><indexterm><primary>methods</primary><secondary>isRegistered()</secondary></indexterm>Returns a boolean value stating whether the current client is already registered with the DCOP server. This method is particularly useful when using DCOP in KPart applications. More details are provided near the end of this section.</para></listitem>
<listitem><para><literal>isApplicationRegistered()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>isApplicationRegistered() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>isApplicationRegistered() method</secondary></indexterm><indexterm><primary>isApplicationRegistered() method</primary></indexterm><indexterm><primary>methods</primary><secondary>isApplicationRegistered()</secondary></indexterm>Accepts a <literal>QCString</literal> parameter containing the identifier of a remote DCOP client. Returns a true boolean value if an application with the given identifier is registered with the DCOP server.</para></listitem>
<listitem><para><literal>registeredApplications()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>registeredApplications() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>registeredApplications() method</secondary></indexterm><indexterm><primary>registeredApplications() method</primary></indexterm><indexterm><primary>methods</primary><secondary>registeredApplications()</secondary></indexterm>Returns a list of identifiers for all applications registered with the DCOP server.</para></listitem>
<listitem><para><literal>remoteObjects()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>remoteObjects() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>remoteObjects() method</secondary></indexterm><indexterm><primary>remoteObjects() method</primary></indexterm><indexterm><primary>methods</primary><secondary>remoteObjects()</secondary></indexterm>Given the identifier of a remote DCOP client as a parameter, returns a list of all DCOP-enabled objects in that client.</para></listitem>
<listitem><para><literal>remoteInterfaces()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>remoteInterfaces() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>remoteInterfaces() method</secondary></indexterm><indexterm><primary>remoteInterfaces() method</primary></indexterm><indexterm><primary>methods</primary><secondary>remoteInterfaces()</secondary></indexterm>Returns the list of DCOP interfaces that a client implements. The clients that use automatic DCOP interface generation (the <literal>dcopidl</literal> tools) have at least a <literal>DCOPObject</literal> interface declared. The data provided by this method has no functional role, but only an informative one.</para></listitem>
<listitem><para><literal>remoteFunctions()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>remoteFunctions() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>remoteFunctions() method</secondary></indexterm><indexterm><primary>remoteFunctions() method</primary></indexterm><indexterm><primary>methods</primary><secondary>remoteFunctions()</secondary></indexterm>Requires an application identifier and an object signature as parameters and returns the list of methods accessible through DCOP for the designated hierarchy.</para></listitem>
<listitem><para><literal>findObject()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>findObject() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>findObject() method</secondary></indexterm><indexterm><primary>findObject() method</primary></indexterm><indexterm><primary>methods</primary><secondary>findObject()</secondary></indexterm>This method is a complex tool that was particularly useful before the heuristic mechanisms were added to the <literal>DCOPClient::call()</literal> method. It takes as parameters a trial client identifier, a trial object signature, and a few other optional parameters. The real identifier and the signature of the DCOP hierarchy (application/object1/object2/&hellip;) that answered the request properly are returned as references. The method returns a false boolean value if no matching client is found. This is a potentially blocking method (in other words, its execution time could be long enough to hinder the user interface activity). It is possible to counter the effects of blocking by setting a true boolean value to the <literal>useEventLoop</literal> parameter that the method accepts.</para></listitem>
<listitem><para><literal>senderId()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>senderId() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>senderId() method</secondary></indexterm><indexterm><primary>senderId() method</primary></indexterm><indexterm><primary>methods</primary><secondary>senderId()</secondary></indexterm>Returns the DCOP identifier of the last peer with which the current client had communication. This is potentially particularly powerful and useful information.</para></listitem>
<listitem><para><literal>socket()</literal>&mdash;<indexterm><primary>DCOP</primary><secondary>API tools</secondary><tertiary>socket() method</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>API tools</tertiary></indexterm><indexterm><primary>API tools (DCOP)</primary><secondary>socket() method</secondary></indexterm><indexterm><primary>socket() method</primary></indexterm><indexterm><primary>methods</primary><secondary>socket()</secondary></indexterm>Returns a number that identifies the ICEConnection socket over which communication is established with the DCOP server.</para></listitem></itemizedlist>
</section>
<section id="ch13lev2sec8">
<title>Referencing DCOP Objects</title>
<para>Another <indexterm><primary>DCOP</primary><secondary>message redirection technology (referencing)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>message redirection technology (referencing)</tertiary></indexterm><indexterm><primary>message redirection technology (referencing)</primary></indexterm><indexterm><primary>referencing (message redirection technology)</primary></indexterm>powerful functionality added recently to the DCOP API is represented by the message redirection technology (also called referencing). A normal DCOP client can create and use <literal>DCOPRef</literal> <indexterm><primary>DCOPRef objects</primary></indexterm><indexterm><primary>objects</primary><secondary>DCOPRef</secondary></indexterm>objects. The role of this type of objects is to provide a reference to an object made public over DCOP by a remote client. The identifier of the remote client as well as the signature of the receptor object can be indicated at the creation or at any other moment in the life of the <literal>DCOPRef</literal> object. It might not be immediately obvious what role the DCOP object references in the general desktop communication landscape are playing. An example will help for a better understanding. <emphasis>KDesktop</emphasis> is an application that offers the KDE user control over the background of the computer screen, usually referred to as the <emphasis>desktop</emphasis>. KDesktop manages the following:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The desktop icons and icon operations (for example, Alignment)</para></listitem>
<listitem><para>Drag-and-drop operations on the desktop</para></listitem>
<listitem><para>The <quote>Trash</quote></para></listitem>
<listitem><para>The <quote>AutoStart</quote> functionality</para></listitem>
<listitem><para>The desktop's contextual menus</para></listitem>
<listitem><para>Wallpapers</para></listitem>
<listitem><para>Screensavers</para></listitem></itemizedlist>
<para>Apart from this set of obvious responsibilities, KDesktop is also charged with the hidden capability of providing the user with the necessary means for remote control of these desktop resources. As a consequence, KDesktop became one of the most important beneficiaries of the DCOP technology. In accordance with the object-oriented programming philosophy, the stretch of functionalities KDesktop controls required modularization. Thus, the control over wallpapers and the handling of screensavers is passed on to modules. Yet, it is logical to have DCOP control over <emphasis>all</emphasis> KDesktop functionalities published to the DCOP <quote>community</quote> of applications from KDesktop. Because the wallpaper handling module (named KBackground) and the screen locking engine have their own DCOP interfaces, the general DCOP interface of KDesktop is designed as shown in <link linkend="ch13list13">Listing 13.13</link>.<indexterm><primary>DCOP</primary><secondary>message redirection technology (referencing)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>message redirection technology (referencing)</tertiary></indexterm><indexterm><primary>message redirection technology (referencing)</primary></indexterm><indexterm><primary>referencing (message redirection technology)</primary></indexterm><indexterm><primary>DCOPRef objects</primary></indexterm><indexterm><primary>objects</primary><secondary>DCOPRef</secondary></indexterm></para>
<example role="codelisting" label="13.13" id="ch13list13">
<title>Example of DCOPRef Usage<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPRef usage</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File KDesktopIface.h (from the real KDE-2.0 code base)
------------------------------------------------------
 1: #ifndef __KDesktopIface_h__
 2: #define __KDesktopIface_h__
 3:
 4: #include &lt;qstringlist.h>
 5: #include &lt;dcopobject.h>
 6: #include &lt;dcopref.h>
 7:
 8: class KDesktopIface : virtual public DCOPObject
 9: {
10:   K_DCOP
11: public:
12:
13: k_dcop:
14:   virtual void rearrangeIcons() = 0;
15:   virtual void rearrangeIcons( bool bAsk ) = 0;
16:   virtual void lineupIcons() = 0;
17:   virtual void selectIconsInRect( int x, int y, int dx, int dy ) = 0;
18:   virtual void selectAll() = 0;
19:   virtual void unselectAll() = 0;
20:   virtual QStringList selectedURLs() = 0;
21:   virtual void configure() = 0;
22:   virtual void popupExecuteCommand() = 0;
23:   virtual DCOPRef background() = 0;
24:   virtual DCOPRef screenSaver() = 0;
25: };
26:
26: #endif

File desktop.h (from the real KDE-2.0 code base)
------------------------------------------------
.
96:  virtual DCOPRef background()
     { return DCOPRef( "kdesktop", "KBackgroundIface" ); }
97:  virtual DCOPRef screenSaver()
     { return DCOPRef( "kdesktop", "KScreensaverIface" ); }
.
.
.<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOPRef usage</tertiary></indexterm>
</programlisting>
</example>
<para>The relevant lines are, of course, 23 and 24 in KDesktopIface.h and the clipped lines from desktop.h. At the level of the client's DCOPObject representation, this results in the addition of objects named <quote>KBackgroundIface</quote> and <quote>KScreensaverIface</quote> to the rest of the (normally built) DCOP interface of KDesktop. These objects allow, as expected, remote control over functionalities of the background engine and the screen locking engine. The automatically generated DCOP interfaces of these modules are defined independently. For a thorough understanding of the topic of DCOP object referencing, you may prefer to peruse the source code of the KDesktop application.<indexterm><primary>DCOP</primary><secondary>message redirection technology (referencing)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>message redirection technology (referencing)</tertiary></indexterm><indexterm><primary>message redirection technology (referencing)</primary></indexterm><indexterm><primary>referencing (message redirection technology)</primary></indexterm><indexterm><primary>DCOPRef objects</primary></indexterm><indexterm><primary>objects</primary><secondary>DCOPRef</secondary></indexterm></para>
</section>
<section id="ch13lev2sec9">
<title>Signals and Slots Through the DCOP Server</title>
<para>KDE<indexterm><primary>DCOP</primary><secondary>signals and slots</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>signals and slots</tertiary></indexterm><indexterm><primary>signals (DCOP)</primary></indexterm><indexterm><primary>slots (DCOP)</primary></indexterm> developers are very familiar with the concepts of <emphasis>signals and slots</emphasis> intensively used by the Qt library, the basement on which KDE is built. Very powerful and particularly useful concepts, the signals and slots play an important role in the elegance and the ease of use of the Qt toolkit. The DCOP API contains the implementation of a similar mechanism. In addition to the <quote>strong</quote> bindings offered by the <literal>DCOPClient::send()</literal> and <literal>DCOPClient::call()</literal> methods, DCOPSignals provide what can be depicted as <quote>weak</quote> or <quote>flexible</quote> bindings. The mildly experienced Qt programmer will be able to appropriate the principle of DCOPsignals easily. The equivalents of Qt's <literal>QObject::connect()</literal>, <literal>QObject::disconnect()</literal>, and <literal>QObject::emit()</literal> methods are conveniently named <indexterm><primary>connectDCOPSignal() method</primary></indexterm><indexterm><primary>methods</primary><secondary>connectDCOPSignal()</secondary></indexterm><literal>DCOPClient::connectDCOPSignal()</literal>, <indexterm><primary>disconnectDCOPSignal() method</primary></indexterm><indexterm><primary>methods</primary><secondary>disconnectDCOPSignal()</secondary></indexterm><literal>DCOPClient::disconnectDCOPSignal()</literal>, and <indexterm><primary>emitDCOPSignal() method</primary></indexterm><indexterm><primary>methods</primary><secondary>emitDCOPSignal()</secondary></indexterm><literal>DCOPClient::emitDCOPSignal()</literal>. They use roughly similar functioning principles too. There are two noticeable differences between the implementation of Qt's signals and slots and the implementation of KDE's over-DCOP signals and slots:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Data has to be encapsulated into a proper <literal>QByteArray</literal>/<literal>QDataStream</literal> envelope when passed over a DCOP signal-slot connection from a <literal>DCOPClient::emitDCOPSignal()</literal> method call.</para></listitem>
<listitem><para>In order to have proper control over-DCOP signal/slot connections, a supplementary method from the DCOPClient API has to be invoked before actually using them. This method is <literal>DCOPClient::setNotifications()</literal> <indexterm><primary>setNotifications() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setNotifications()</secondary></indexterm>and has to be called after establishing all wanted connections, but before issuing the first DCOP signal emit.</para></listitem>
<listitem><para>There are a few predefined, convenient signals, built in to the <literal>DCOPClient</literal> class:<indexterm><primary>DCOP</primary><secondary>signals and slots</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>signals and slots</tertiary></indexterm><indexterm><primary>signals (DCOP)</primary></indexterm><indexterm><primary>slots (DCOP)</primary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The signal <literal>DCOPClient::applicationRegistered()</literal> is emitted automatically at the moment a client uses the <literal>attach()</literal> method.</para></listitem>
<listitem><para>Its counterpart, <literal>DCOPClient::applicationRemoved()</literal>, is emitted when a <literal>detach()</literal> call is performed (this usually happens when the client quits functioning).<indexterm><primary>DCOP</primary><secondary>signals and slots</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>signals and slots</tertiary></indexterm><indexterm><primary>signals (DCOP)</primary></indexterm><indexterm><primary>slots (DCOP)</primary></indexterm></para></listitem></itemizedlist>
</listitem></itemizedlist>
</section>
<section id="ch13lev2sec10">
<title>DCOP with an Embedded KPart</title>
<para>DCOP <indexterm><primary>DCOP</primary><secondary>embedded K instances</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>embedded KPart instances</tertiary></indexterm><indexterm><primary>embedded KPart instances</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>KParts</primary><secondary>embedded</secondary><tertiary>DCOP (Desktop Communication Protocol)</tertiary></indexterm>and KParts are the technologies KDE is using to comply with the modern requirements of software modularization. Both technologies are convenient for building reusable objects and, when used together, they open large opportunities for creatively minded developers. This section attempts to draw attention to the somewhat delicate aspect of programming modules using both the embedding and the communication technologies at once.</para>
<para>There is nothing that prevents an embeddable KPart from gaining DCOP functionality. The developer needs to write in his KPart the usual code meant to create the DCOP client object, to attach it to the server, and then to register it so that the duplex communication can be enabled. Yet, it is important to note that the embedding application, which will host the DCOP client KPart, may also be a DCOP client before the embedding occurs. In consequence, caution is required. <link linkend="ch13list14">Listing 13.14</link> is a small example of proper DCOP client registration code as provided in the KWrite editor KPart.</para>
<example role="codelisting" label="13.14" id="ch13list14">
<title>DCOP within a KPart<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOP within KPart</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File kwview.cpp (from the real KDE-2.0 code base)
------------------------------------------------
.
.
1527:   DCOPClient *client = kapp->dcopClient();
1528:   if (!client->isRegistered())  // just in case we're embedded
1529:   {
1530:     client->attach();
1531:     client->registerAs("kwrite");
1532:   }
.
.
</programlisting>
</example>
<para>The need for such code comes from the fact that attempting to register an embedded KPart instance while the embedding application is already registered with the DCOP server will modify (with unpredictable consequences) the identity of the embedding application on the DCOP client names pool.<indexterm><primary>DCOP</primary><secondary>embedded KPart instances</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>embedded KPart instances</tertiary></indexterm><indexterm><primary>embedded KPart instances</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>KParts</primary><secondary>embedded</secondary><tertiary>DCOP (Desktop Communication Protocol)</tertiary></indexterm></para>
<para>The solution to this problem is based on a simple but brilliant idea:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>The DCOP client object is created using the normal instantiation method.</para></listitem>
<listitem><para>Prior to all attaching and registering attempts, a check with the DCOP server is performed in order to learn whether a legitimate registration is already available.</para></listitem>
<listitem><para>If the embedding application is already registered, then the embedded KPart instance learns that proper registration exists, hence it doesn't need to register itself anymore.</para></listitem>
<listitem><para>If the embedding application doesn't exhibit DCOP functionality, then the KPart instance needs to register properly.</para></listitem></itemizedlist>
<para>A question becomes evident: <emphasis>How does the embedded KPart instance acquire proper visibility in the DCOP <quote>community</quote> when the embedding application is already registered?</emphasis> Indeed, the embedded KPart instance needs a working registration with the server so that it can receive DCOP calls from the peer clients. The little secret resides in proper usage of <literal>DCOPRef</literal> objects previously presented. At embedding time, the embedding application creates <literal>DCOPRef</literal> objects for the DCOP objects that an embedded KPart instance makes public. For example, as a result of this behavior, a Konqueror DCOP client with an embedded KWrite view part, observed from the exterior, will appear to provide a reunion of Konqueror-specific and KWrite-specific DCOP object interfaces.<indexterm><primary>DCOP</primary><secondary>embedded KPart instances</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>embedded KPart instances</tertiary></indexterm><indexterm><primary>embedded KPart instances</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm><indexterm><primary>KParts</primary><secondary>embedded</secondary><tertiary>DCOP (Desktop Communication Protocol)</tertiary></indexterm></para>
</section>
<section id="ch13lev2sec11">
<title>Performance and Overhead</title>
<para>DCOP <indexterm><primary>DCOP</primary><secondary>performance and overhead</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>performance and overhead</tertiary></indexterm><indexterm><primary>performance</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm>presently plays a central role in the KDE desktop. Also, the history of the KDE project recorded rather painful CORBA experiences, therefore the concerns about performance, resource usage, and overhead related to the intensive usage of the protocol are legitimate. Fortunately, KDE team members performed a few instrumental tests. Also, many hundreds of developers and alpha/beta testers assured rather intensive normal usage testing during many months. This section enlists a collection of significant results, courtesy of KDE developers Preston Brown, Matthias Ettrich, David Faure, Waldo Bastian, and Kurt Granroth.</para>
<para>Concerning performance, numbers regarding the useful message exchanges between peers are of interest. Consider, for example, two clients only, passing messages between them by the mediation of the DCOP server.</para>
<para>Usual desktop computers (popular processors running at frequencies of around 300 MHz) are credited with allowing 1500 to 2000 usual DCOP messages per second. Usual DCOP messages consist of rather small amounts of data (1 to 5 Kbytes). The two clients aren't able to saturate the capabilities of the server. Adding two more clients determines the augmentation of the maximal counts with about 40%.</para>
<para>In order to put these numbers in context, we have to observe that the MICO implementation of CORBA provides results of about 900 hits on a same type of computer. Also note that usual IPC/RPC implementations are credited with a maximum of 3000 hits per second. As a conclusion, DCOP is fast enough for the practical needs of modern desktop environment software.<indexterm><primary>DCOP</primary><secondary>performance and overhead</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>performance and overhead</tertiary></indexterm><indexterm><primary>performance</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
<para>The disadvantages associated with DCOP appear evident, though, when trying to transfer large amounts of data between clients. The explication resides in the fact that the operation of data copying always has to be performed twice (first from the sender client to the DCOP server, then from the server to the receptor). This issue is known to the KDE developers. The proposed solution consists of implementing shared memory backend usage for such large data transfers. The design of the current DCOP implementation would easily allow for such an enhancement. It is worth mentioning that Stefan Westerfeld, member of the KDE Multimedia team, designed and implemented a communication protocol adapted to the needs of multimedia applications. His protocol (named MCOP, as you will learn about in <link linkend="ch14">Chapter 14, <quote>Multimedia</quote></link>) is similar in functionality to DCOP but allows for asynchronous, fast transfers of the large amounts of data specific to this particular field (video and audio streams, for example). This technology is also actively used in the current version of KDE (2.0) under the form of the network-transparent, composition-capable, KDE audio technology and server (named aRts and <literal>artsd</literal> respectively).</para>
<para>DCOP, as all other computer technologies, will need to use memory and processing power in order to do something useful. For the case in discussion, the memory usage is required by the operation of equipping a normal KDE <literal>KApplication</literal> object with a functional DCOP client data and live code structures. According to preliminary measurements performed by KDE developers, this memory overhead amounts to about 100 Kbytes per application. When measuring startup time delays that might be introduced by using DCOP in a usual KDE application, these delays are too small for the observer to detect them from the statistical variation.</para>
<para>It is thus obvious that performance and overhead aren't hindering issues with DCOP. Yet, the developers are carefully observing these and are striving to keep DCOP's impact on normal use of the KDE software as small as possible.<indexterm><primary>DCOP</primary><secondary>performance and overhead</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>performance and overhead</tertiary></indexterm><indexterm><primary>performance</primary><secondary>DCOP (Desktop Communication Protocol)</secondary></indexterm></para>
</section>
</section>
<section id="ch13lev1sec7">
<title>DCOP Use in KDE 2.0&mdash;A Few Examples</title>
<para>Perhaps that the most exciting thing about the DCOP technology is the amazingly effective way in which its use speeds up the KDE development by many orders of magnitude. The team of KDE developers made insistent attempts to use a traditional CORBA implementation as a technological basis for the accomplishment of a project's interprocess communication needs. It is now generally accepted that this was a conceptual error. One of the central reasons of this humble acceptance is exactly the outcome of the greatly successful DCOP/KParts experiment.</para>
<para>DCOP was introduced in general use in KDE's development only days after its inception. This was possible thanks to its brilliant technological simplicity and to the sound conceptual principles employed. The authors acknowledged to have been surprised by the extent to which the members of the development team currently use DCOP in all categories of KDE code. Following are a few examples of such usage.</para>
<section id="ch13lev2sec12">
<title><literal>KUniqueApplication</literal></title>
<para>One<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary></indexterm> visibly weak point of the KDE 1 API was the lack of an easy-to-use programming technique that would have allowed the creation of <emphasis>unique applications</emphasis>. The term unique applications designates a special category of programs that don't need to&mdash;or must not&mdash;exist in more than one running instance at a time in a distinct active desktop environment session. This problem is solved in the current iteration of KDE. A special class named <literal>KUniqueApplication</literal> exists now. This inherits the central <literal>KApplication</literal> class. The unique application concept defines special requirements:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Detecting whether previously running instances of the same application exists.</para></listitem>
<listitem><para>Communication with the previously running instance.</para></listitem>
<listitem><para>Limited control of the previously running instance.</para></listitem></itemizedlist>
<para>These are all achieved by proper use of the DCOP technology.</para>
<para>A simplified description of the way a <literal>KUniqueApplication</literal> functions follows:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>At construction, a DCOP client is automatically created and then attached to the DCOP server.</para></listitem>
<listitem><para>The current instance of the application tries to detect whether a previously running instance of itself exists:<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>If no previous instance exists, a proper  registration with DCOP server is automatically performed and the application proceeds with its  normal functioning.</para></listitem>
<listitem><para>If a previous instance exists, command-line parameters (and eventually programmed messages)  are passed to a special method of the object and then this instance immediately quits.</para></listitem></itemizedlist>
</listitem></itemizedlist>
<para>Typical usage of this class is simple. There are two aspects that require attention.</para>
<para>First, the existence of a previously running instance is checked by the use of the <literal>KUniqueApplication::start()</literal> method, which is statically defined. It is recommended that you take advantage of the static definition of this method; that is, call it <emphasis>before</emphasis> the proper construction of the main object (of type <literal>KUniqueApplication</literal>). This way, fewer resources are used during startup if a previous instance already exists. Startup times are reduced by 40% in such a case. These ideas are exemplified in many places in the real KDE 2.0 code base (many applications are built as <literal>KUniqueApplication</literal>s). <link linkend="ch13list15">Listing 13.15</link> offers such an exemplification as extracted from the International Keyboard application.<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary><tertiary>startup</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary><secondary>startup</secondary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary><tertiary>startup</tertiary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary><tertiary>startup</tertiary></indexterm></para>
<example role="codelisting" label="13.15" id="ch13list15">
<title>A <literal>KUniqueApplication</literal> has a Special Way of Starting<indexterm><primary>listings</primary><secondary>DCOP</secondary><tertiary>DCOP within KPart</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>starting</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File: kikbd/main.cpp (from real KDE-2.0 base code)
--------------------------------------------------
.
.
16:   KAboutData about("kikbd", I18N_NOOP("International Keyboard Selector"),
17:                    "2.0", I18N_NOOP("Run time selector for keyboard layout"
18:                                 "on the desktop or on individual windows"),
19:                    0, " 1998-2000 Alexander Budnik, Cristian Tibirna",
20:                    "","http://devel-home.kde.org/~kikbd");
21:   about.addAuthor("Cristian Tibirna", I18N_NOOP("Current maintainer"),
22:                   "tibirna@kde.org");
23:   about.addAuthor("Alexander Budnik", I18N_NOOP("Original author"));
24:   about.addCredit("Dimitrios Bouras", I18N_NOOP("Bug fixing"));
25:
26:   KCmdineArgs::init(argc, argv, &amp;about);
27:
28:   static KCmdLineOptions opts[] =
29:   {
30:     {"rotate", "change the keyboard layout programmatically", 0};
31:     {"reconfig", "read again the configuration,
          probably on kcmkikbd's demand", 0};
32:   };
33:
34:   KCmdLineArgs::addCmdLineOptions( opts );
35:
36:   KiKbdApplication::addCmdLineOptions();
37:   if (!KiKbdApplication::start())
38:     exit(0);
39:   KiKbdApplication appl();
40:   appl.exec();
.
.<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary><tertiary>startup</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary><secondary>startup</secondary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary><tertiary>startup</tertiary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary><tertiary>startup</tertiary></indexterm>
</programlisting>
</example>
<para>Second, when you want to pass command-line arguments to a previously running instance of the application, you must reimplement the <literal>KUniqueApplication::newInstance()</literal> method. The automatically created DCOP client passes the parameters over the desktop communication protocol from the new instance to the previously existing one (the master). The <literal>DCOPObject::process()</literal> method of the master implicitly calls the special <literal>newInstance()</literal> method and passes to it a string list containing the said command-line arguments, as exemplified in the <link linkend="ch13list16">Listing 13.16</link>.<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary><tertiary>passing command-line parameters</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary><secondary>passing command-line parameters</secondary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary><tertiary>passing command-line parameters</tertiary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary><tertiary>passing command-line parameters</tertiary></indexterm></para>
<example role="codelisting" label="13.16" id="ch13list16">
<title>A <literal>KuniqueApplication</literal> has a Special Way of Passing Command-Line Parameters to Predecessors<indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>passing command-line parameters</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
File: kikbd/kikbd.cpp (from real KDE-2.0 base code)
--------------------------------------------------
.
.
151: int KiKbdApplication::newInstance () {
152:
153:   kdDebug(1420) &lt;&lt; "Parse cmdline args" &lt;&lt; endl;
154:   KCmdLineArgs *params = KCmdLineArgs::parsedArgs();
155:   if(params->isSet("reconfig")) {
156:     kdDebug(1420) &lt;&lt; "Remotely trigger loadConfig" &lt;&lt; endl;
157:     QTimer::singleShot(configDelay, this, SLOT(askReloadConfig()));
158:     ::exit(0);
159:   }
160:   if(params->isSet("rotate")) {
161:     kdDebug(1420) &lt;&lt; "Remotely trigger rotateKeymap" &lt;&lt; endl;
162:     QTimer::singleShot(configDelay, this, SLOT(askRotateKeyMap()));
163:     ::exit(0);
164:   }
165:
166:   params->clear();
167:
167:   //CT if it comes up to here, it's either that the params are wrong or
168:   //    that there weren't params. Either is wrong.
169:   kdDebug(1420) &lt;&lt; "Warn for bad use" &lt;&lt; endl;
170:   KMessageBox::sorry(0,
171:              i18n("Only one instance of the international keyboard "
172:               "configuration\ncan run at a given moment."),
173:              i18n("Already running"));
174:   ::exit(0);
175:
176: }
.
.<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary><tertiary>passing command-line parameters</tertiary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary><secondary>passing command-line parameters</secondary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary><tertiary>passing command-line parameters</tertiary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary><tertiary>passing command-line parameters</tertiary></indexterm><indexterm><primary>listings</primary><secondary>KUniqueApplication</secondary><tertiary>passing command-line parameters</tertiary></indexterm>
</programlisting>
</example>
<para>Important components of the typical KDE desktop session are making use of the <literal>KUniqueApplication</literal> paradigm:<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary></indexterm></para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>KDesktop</para></listitem>
<listitem><para>Kicker (the KDE desktop panel)</para></listitem>
<listitem><para>KMenuEdit (the menu editor used for Kicker)</para></listitem>
<listitem><para>Klipper (KDE's enhanced clipboard manager)</para></listitem>
<listitem><para>KMail</para></listitem></itemizedlist>
<para>These are all excellent examples for a proper use of the KUniqueApplication technology.<indexterm><primary>DCOP</primary><secondary>KUniqueApplication example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KUniqueApplication example</tertiary></indexterm><indexterm><primary>KUniqueApplication class</primary></indexterm><indexterm><primary>classes</primary><secondary>KUniqueApplication</secondary></indexterm><indexterm><primary>unique applications</primary><secondary>KUniqueApplication example</secondary></indexterm></para>
</section>
<section id="ch13lev2sec13">
<title><literal>KNotify</literal></title>
<para>Another<indexterm><primary>DCOP</primary><secondary>KNotify example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KNotify example</tertiary></indexterm><indexterm><primary>KNotify class</primary></indexterm><indexterm><primary>classes</primary><secondary>KNotify</secondary></indexterm> important improvement brought by KDE 2 code base over what KDE 1 offered is the new system notifications mechanism. In a very simplified presentation, KNotify (the KDE system notifications mechanism) is constituted from a client API and an events server (running on the desktop under the name <literal>knotify</literal>). Every application that wants to use the system notifications needs simply to import the <literal>KNotifyClient</literal> namespace provided in the KDE libraries. Configuring events is noticeably easy (a control center module is available). There are a few types of notifications associated with an event: sounds, dialog boxes, and log file entries. The actual contents of these notifications is also configurable.</para>
<para>The notifications server remains permanently active on the desktop and is in close relation with KDE's multimedia server (<literal>artsd</literal>). The communication between clients using the KNotify mechanisms and the notifications server is once again greatly facilitated by DCOP.</para>
<para>For an easy understanding of how to implement event notifications in a KDE application, it might be useful to examine the source code of KDE's window manager, kwin (especially the files kwin/events.cpp and kwin/eventsrc).<indexterm><primary>DCOP</primary><secondary>KNotify example</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KNotify example</tertiary></indexterm><indexterm><primary>KNotify class</primary></indexterm><indexterm><primary>classes</primary><secondary>KNotify</secondary></indexterm></para>
</section>
<section id="ch13lev2sec14">
<title>Little Jewels: <literal>dcop</literal> and <literal>kdcop</literal></title>
<para><literal>dcop</literal> and <literal>kdcop</literal> are perhaps some of the most surprising examples of powerful usage of the desktop communications protocol. These two little tools were born during the prolific coding session that took place in Trysil, Norway, around the middle of 2000. They are amazingly capable and make use of the latest functionalities added to the DCOP API: the information mining methods (see the section <link linkend="ch13lev2sec7"><quote>Stay Informed</quote></link> earlier in this chapter).</para>
<para>These two tools enable the user to browse in real time the composition of the DCOP object pool, and even invoke functions provided in the public DCOP interfaces.</para>
<para><literal>dcop</literal>, <indexterm><primary>DCOP</primary><secondary>dcop (shell client)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>dcop (shell client)</tertiary></indexterm><indexterm><primary>dcop (DCOP shell client)</primary></indexterm><indexterm><primary>clients</primary><secondary>dcop (DCOP shell client)</secondary></indexterm>or the <emphasis>DCOP shell</emphasis> client, is a command-line tool. <link linkend="ch13list17">Listing 13.17</link> is a short session using <literal>dcop</literal>.</para>
<example role="codelisting" label="13.17" id="ch13list17">
<title>A Desktop at the Fingertip<indexterm><primary>listings</primary><secondary>dcop</secondary></indexterm></title>
<programlisting linenumbering="unnumbered">
]:~> <emphasis role="strong">dcop &mdash;help</emphasis>
Usage: dcop [ application [object [function [arg1] [arg2] [arg3] &hellip; ] ] ]
]:~> <emphasis role="strong">dcop</emphasis>
]:~> <emphasis role="strong">dcop kdesktop</emphasis>
]:~> <emphasis role="strong">dcop kdesktop KScreensaverIface</emphasis>
]:~> <emphasis role="strong">dcop kdesktop KScreensaverIface save</emphasis>
</programlisting>
</example>
<para>Enjoy!</para>
<para><literal>kdcop</literal><indexterm><primary>DCOP</primary><secondary>kdcop (shell client)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>kdcop (shell client)</tertiary></indexterm><indexterm><primary>kdcop (DCOP shell client)</primary></indexterm><indexterm><primary>clients</primary><secondary>kdcop (DCOP shell client)</secondary></indexterm> is the counterpart of <literal>dcop</literal> but with a graphical interface. The DCOP objects hierarchy is equally easy to explore or to exploit from kdcop's graphic console (see <link linkend="ch13fig02">Figure 13.2</link>).<indexterm><primary>DCOP</primary><secondary>dcop (shell client)</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>dcop (shell client)</tertiary></indexterm><indexterm><primary>dcop (DCOP shell client)</primary></indexterm><indexterm><primary>clients</primary><secondary>dcop (DCOP shell client)</secondary></indexterm></para>
<figure label="13.2" id="ch13fig02">
<title>The <literal>kdcop</literal> tool.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/13fig02.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
</section>
<section id="ch13lev2sec15">
<title>Neighbors in Visit&mdash;dcopc, XMLRPC, and Bindings</title>
<para>DCOP benefits from an open-minded design that avoids to a large extent the use of specific KDE technologies. Yet, DCOP itself is inherently a KDE technology. Its authors are hoping, though, that DCOP will be equally well adopted outside KDE's code base. Reasons for such hopes are the elegance of the basic principles used, as well as the great convenience and performance gains that DCOP provides.</para>
<para>Along these lines, members of the KDE developer team created a fairly large collection of bindings around the DCOP programming interface.</para>
<para><emphasis>dcopc</emphasis><indexterm><primary>DCOP</primary><secondary>dcopc interface</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>dcopc interface</tertiary></indexterm><indexterm><primary>dcopc interface</primary></indexterm> is a fully functional interface to DCOP written in the C language by <indexterm><primary>Hausmann, Simon</primary></indexterm>Simon Hausmann and<indexterm><primary>Hemsley, Rik</primary></indexterm> Rik Hemsley. It is available from the KDE project's code base and is intended for programmers willing to write applications with DCOP enhancements in plain C. This effort was at the time of this writing in a development phase, but very near completion.</para>
<para><emphasis>KXMLRPC</emphasis> <indexterm><primary>DCOP</primary><secondary>KXMLRPC interface</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KXMLRPC interface</tertiary></indexterm><indexterm><primary>KXMLRPC interface</primary></indexterm>is written by <indexterm><primary>Granroth, Kurt</primary></indexterm>Kurt Granroth and is an interfacing solution between DCOP and the popular XML-based remote procedure call technology. <indexterm><primary>XML-RPC</primary></indexterm>XML-RPC gained a lot of attention in the past few years from developers of computing solutions for heterogeneous platforms.</para>
<para>The greatest benefit that derives from having a bridge from DCOP to XML-RPC is the flexibility in scripting KDE. Almost all important programming languages of modern times (Python, Java, Perl) are offering an XML-RPC implementation.</para>
<para>One of the most interesting successes of binding DCOP with XML-RPC is the gained capability of controlling a KDE desktop remotely, even from a Macintosh computer or from a handheld computer (during the tests, a functional Python implementation was used on the Macintosh as a source of XML-RPC commands).</para>
<para>This is made possible by the fact that the described binding mechanism provides a lightweight server for XML-RPC on each KDE desktop&mdash;very similar to a simple http server. This server is capable of receiving XML-RPC messages and acts as a DCOP client in the meantime. Proper security and authentication mechanisms are implemented in this server.</para>
<para>More details about XML-RPC are available at <ulink url="http://helma.org/lists/listinfo/xmlrpc">http://helma.org/lists/listinfo/xmlrpc</ulink>.<indexterm><primary>Web sites</primary><secondary>XML-RPC</secondary></indexterm><indexterm><primary>DCOP</primary><secondary>KXMLRPC interface</secondary></indexterm><indexterm><primary>protocols</primary><secondary>DCOP</secondary><tertiary>KXMLRPC interface</tertiary></indexterm><indexterm><primary>KXMLRPC interface</primary></indexterm><indexterm><primary>XML-RPC</primary></indexterm></para>
<para><emphasis>DCOP bindings</emphasis><indexterm><primary>DCOP</primary></indexterm> for Python were also developed recently by Torben Weis. They are currently available as a proof of concept but they already show a strong potential.</para>
</section>
</section>
<section id="ch13lev1sec8">
<title>Summary</title>
<para>DCOP is a young technology born from the necessity of providing modern interprocess communication tools to KDE.</para>
<para>Although introduced recently, the technology became popular among KDE developers very fast. Presently DCOP is largely used in many parts of the main KDE code base.</para>
<para>DCOP provides flexibility and power, yet the resource usage remains very limited. New developers that start using DCOP in their applications will need only a minimal learning effort investment.</para>
<para>Together with KParts, DCOP provides the key to a proper modularization of the standard UNIX desktop applications.</para>
</section>
</chapter>
