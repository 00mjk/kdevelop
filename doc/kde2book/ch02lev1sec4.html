<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>GUI Elements</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="A Simple KDE Application"
HREF="ch02.html"/><LINK
REL="PREVIOUS"
TITLE="KDE Application Structure"
HREF="ch02lev1sec3.html"/><LINK
REL="NEXT"
TITLE="Programming Conventions"
HREF="ch02lev1sec5.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch02lev1sec3.html"
>Prev</A
> <A
HREF="ch02lev1sec5.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch02lev1sec4"
>2.4. GUI Elements</A
></H1
><P
><TT
CLASS="literal"
>KSimpleApp</TT
> minimally uses each of the four widgets that are managed by <TT
CLASS="literal"
>KTMainWindow</TT
>. They are all created and configured in the <TT
CLASS="literal"
>KSimpleApp</TT
> constructor, shown in <A
HREF="ch02lev1sec4.html#ch02list05"
>Listing 2.5</A
>.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch02list05"
></A
><P
><B
>Example 2.5. ksimpleapp.cpp: The Class Definition File for <TT
CLASS="literal"
>KSimpleApp</TT
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; 1: #include &lt;qlabel.h&gt;
   3&nbsp; 2:
   4&nbsp; 3: #include &lt;kstdaccel.h&gt;
   5&nbsp; 4: #include &lt;kiconloader.h&gt;
   6&nbsp; 5: #include &lt;kmenubar.h&gt;
   7&nbsp; 6: #include &lt;kapp.h&gt;
   8&nbsp; 7: #include &lt;kaction.h&gt;
   9&nbsp; 8:
  10&nbsp; 9: #include "ksimpleapp.moc"
  11&nbsp;10:
  12&nbsp;11: KSimpleApp::KSimpleApp (const char *name) :
  13&nbsp;12:   KTMainWindow (name)
  14&nbsp;13: {
  15&nbsp;14:   KAction *reposition =
  16&nbsp;15:     new KAction ("&amp;Reposition Text", QIconSet(BarIcon ("idea")),
  17&nbsp;16:             CTRL+Key_R, this, SLOT (slotRepositionText()),
  18&nbsp;17:             this);
  19&nbsp;18:   KAction *quit =
  20&nbsp;19:     new KAction ("&amp;Quit", KStdAccel::quit(), kapp,
  21&nbsp;20:             SLOT (closeAllWindows()), this);
  22&nbsp;21:
  23&nbsp;22:   QPopupMenu *filemenu = new QPopupMenu;
  24&nbsp;23:   reposition-&gt;plug (filemenu);
  25&nbsp;24:   filemenu-&gt;insertSeparator();
  26&nbsp;25:   quit-&gt;plug (filemenu);
  27&nbsp;26:
  28&nbsp;27:   menuBar()-&gt;insertItem ("&amp;File", filemenu);
  29&nbsp;28:
  30&nbsp;29:   reposition-&gt;plug(toolBar());
  31&nbsp;30:
  32&nbsp;31:   statusBar()-&gt;message ("Ready!");
  33&nbsp;32:
  34&nbsp;33:   text = new QLabel ("Hello!", this);
  35&nbsp;34:   text-&gt;setBackgroundColor (Qt::white);
  36&nbsp;35:   alignment [0] = QLabel::AlignLeft | QLabel::AlignVCenter;
  37&nbsp;36:   alignment [1] = QLabel::AlignHCenter | QLabel::AlignVCenter;
  38&nbsp;37:   alignment [2] = QLabel::AlignRight | QLabel::AlignVCenter;
  39&nbsp;38:   indexalignment = 0;
  40&nbsp;39:
  41&nbsp;40:   text-&gt;setAlignment (alignment [indexalignment]);
  42&nbsp;41:   setView (text);
  43&nbsp;42:
  44&nbsp;43: }
  45&nbsp;44:
  46&nbsp;45: void
  47&nbsp;46: KSimpleApp::slotRepositionText ()
  48&nbsp;47: {
  49&nbsp;48:   indexalignment = (indexalignment+1)%3;
  50&nbsp;49:   text-&gt;setAlignment (alignment[indexalignment]);
  51&nbsp;50:
  52&nbsp;51:   statusBar()-&gt;message ("Repositioned text in content area", 1000);
  53&nbsp;52: }</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>A <TT
CLASS="literal"
>QLabel</TT
>, a widget that displays some static text&#8212;<SPAN
CLASS="QUOTE"
>"Hello!"</SPAN
> in this case&#8212;is created on line 33 and forms the content area. That is, <TT
CLASS="literal"
>QLabel</TT
> plays the role of <TT
CLASS="literal"
>KMyContent</TT
> in <A
HREF="ch02lev1sec3.html#ch02fig03"
>Figure 2.3</A
>. The menubar contains a File menu with two entries:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Reposition Text&#8212;Cycles through three positions of the text: left, center, and right.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Quit&#8212;Exits the application.</P
></LI
></UL
><P
>The toolbar contains one button that performs the same function as Reposition Text. The statusbar says <SPAN
CLASS="QUOTE"
>"Ready!"</SPAN
> when the program first starts and then displays a message whenever the user repositions the text. Thus, <TT
CLASS="literal"
>KSimpleApp</TT
> demonstrates how to set up each of the four widgets you'll need to create a user interface for a KDE application: <TT
CLASS="literal"
>KToolbar</TT
>, <TT
CLASS="literal"
>KStatusBar</TT
>, <TT
CLASS="literal"
>KMenuBar</TT
>, and the content area widget. <A
HREF="ch02lev1sec4.html#ch02fig05"
>Figure 2.5</A
> is a screen shot of <TT
CLASS="literal"
>KSimpleApp</TT
>.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch02fig05"
></A
><P
><B
>Figure 2.5. <TT
CLASS="literal"
>KSimpleApp</TT
> demonstrates basic usage of important KDE widgets: <TT
CLASS="literal"
>KMenuBar</TT
>, <TT
CLASS="literal"
>KToolBar</TT
>, and <TT
CLASS="literal"
>KStatusBar</TT
>.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/02fig05.gif"
></IMG
></P
></DIV
><HR/></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch02lev2sec7"
>2.4.1. The Menubar</A
></H2
><P
>Before constructing the menubar, you need to create a <TT
CLASS="literal"
>QPopupMenu</TT
> for each of the pull-down menus. In <TT
CLASS="literal"
>KSimpleApp</TT
> you create one <TT
CLASS="literal"
>QPopupMenu</TT
> for the File menu.</P
><P
>Line 23 adds the entry <SPAN
CLASS="QUOTE"
>"Reposition"</SPAN
> Text to the File menu.</P
><P
>The object <TT
CLASS="literal"
>reposition</TT
>, used on line 23 and created on lines 14&#8211;17 is an action (an instance of <TT
CLASS="literal"
>KAction</TT
>). It holds all of the information needed to create a menu entry or toolbar entry (see the next section, <SPAN
CLASS="QUOTE"
>"The Toolbar"</SPAN
>). Actions are a convenient way of packaging application functions with the user interaction needed to describe and activate them. (<TT
CLASS="literal"
>KActions</TT
> are discussed further in <A
HREF="ch05.html"
>Chapter 5, <SPAN
CLASS="QUOTE"
>"KDE User Interface Compliance."</SPAN
></A
>) Lines 14&#8211;17, for example,</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;KAction *reposition =
   3&nbsp;     new KAction ("&amp;Reposition" Text, QIconSet(BarIcon ("idea")),
   4&nbsp;:               CTRL+Key_R, this, SLOT (slotRepositionText()),
   5&nbsp;                this);
   6&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The ampersand before the letter R makes it so that when the menu is visible, the user can press R to activate this menu entry. This feature is made known to the user by the widget by underlining the R.</P
><P
>The constants <TT
CLASS="literal"
>CTRL</TT
> and <TT
CLASS="literal"
>Key_R</TT
> are defined in qnamespace.h. Here they indicate that the <TT
CLASS="literal"
>Ctrl+R</TT
> key combination will activate this menu entry whenever it is pressed by the user. These key combinations, called accelerators, allow the user to bypass the menubar/toolbar interface and access commonly used functions with simple keystrokes.</P
><P
>The icon, specified by <TT
CLASS="literal"
>QIconSet(BarIcon ("idea"))</TT
> (a light bulb), will be placed to the left of the menu entry. (see <A
HREF="ch02lev1sec4.html#ch02fig06"
>Figure 2.6</A
>). When a function appears on the toolbar (as this one does, see the next section, <SPAN
CLASS="QUOTE"
>"The Toolbar"</SPAN
>), it should also appear as an entry in the menubar with the same toolbar icon next to the entry. This makes the correspondence between the two functions clearer to the user. The class <TT
CLASS="literal"
>QIconSet</TT
> takes the icon specified by <TT
CLASS="literal"
>BarIcon("idea")</TT
> and creates different icons that might be needed by the GUI: a large icon, a small icon, and grayed-out <SPAN
CLASS="QUOTE"
>"disabled"</SPAN
>-look icons. This is all taken care of by the libraries with no further necessary interaction.</P
><P
>The other two parameters to the <TT
CLASS="literal"
>KAction</TT
> constructor: <TT
CLASS="literal"
>this</TT
> and <TT
CLASS="literal"
>SLOT (slotRepositionText())</TT
> indicate that the method <TT
CLASS="literal"
>slotRepositionText()</TT
>, which is a member of this instance of <TT
CLASS="literal"
>KSimpleApp,</TT
> should be called whenever this action is activated. The details of just how such a feat can be accomplished&#8212;that feat being to call a method in a specific <I
CLASS="emphasis"
>instance</I
> of a class seemingly arbitrarily&#8212;is discussed in <A
HREF="ch03.html"
>Chapter 3</A
>. For now, note that this is accomplished with the Qt <I
CLASS="emphasis"
>signal/slot</I
> mechanism.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch02fig06"
></A
><P
><B
>Figure 2.6. You should place the same icon (a light bulb in this example) in the menubar as is used in the toolbar so that the user knows these are two ways of performing the same function.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/02fig06.gif"
></IMG
></P
></DIV
><HR/></DIV
><P
>The next line</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;filemenu-&gt;insertSeparator();
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>appends a horizontal line to the pop-up menu. This is not an active GUI element; it simply serves to separate groups of functions. The KDE GUI design guidelines require this to be placed before the next entry in the menu, which is Quit. (These guidelines are discussed in <A
HREF="ch07.html"
>Chapter 7</A
>.)</P
><DIV
CLASS="note"
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="note.png"
HSPACE="5"
ALT="Note"/></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Use standard names for standard menu entries (<A
HREF="ch07.html"
>Chapter 7</A
> has details). Important: Quit is the last entry on the File menu, not Exit!</P
></TD
></TR
></TABLE
></DIV
><P
>The second argument passed to the <TT
CLASS="literal"
>KAction</TT
> constructor when creating the Quit entry on lines 18-20 is <TT
CLASS="literal"
>KStdKeys::quit()</TT
>, which is a static method of <TT
CLASS="literal"
>KStdAccel</TT
> that returns the default accelerator key combination for the Quit action. All applications should have a Quit entry in the File menu, and Quit should always be associated with the accelerator key returned by <TT
CLASS="literal"
>KStdAccel::quit()</TT
>. Using the same names and accelerators in all applications provides consistency, enabling the user to <SPAN
CLASS="QUOTE"
>"Learn once and use everywhere"</SPAN
> common application functions.</P
><P
>Notice that I use the <TT
CLASS="literal"
>new</TT
> operator to create a <TT
CLASS="literal"
>QPopupMenu</TT
>. This allows the object to survive even after you leave the current scope (that is, the <TT
CLASS="literal"
>KSimpleApp</TT
> constructor) so that it can continue to be accessed by the menubar. An object created in the following way:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;QPopupMenu filemenu;
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>would be deleted after the constructor finished. It is deleted automatically, so you can forget about it unless you want to make changes to it later on.</P
><DIV
CLASS="note"
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="note.png"
HSPACE="5"
ALT="Note"/></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Create your widgets with <TT
CLASS="literal"
>new</TT
>. They will be deleted by their parents, so you won't need to delete them.</P
></TD
></TR
></TABLE
></DIV
><P
>Finally place the pop-up menu you created on the menubar with</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;menuBar()-&gt;insertItem ("&amp;File", filemenu);
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
><TT
CLASS="literal"
>menuBar()</TT
>creates a <TT
CLASS="literal"
>KMenuBar</TT
> widget the first time it is called. <TT
CLASS="literal"
>KTMainWindow</TT
> is also responsible for deleting the <TT
CLASS="literal"
>KMenuBar</TT
> when it is no longer needed.</P
><P
>This is the simplest method of handling a menubar. It is also possible to create a <TT
CLASS="literal"
>KMenuBar</TT
> yourself and tell <TT
CLASS="literal"
>KTMainWindow</TT
> to use it by calling</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;void setMenu (KMenuBar *menuBar)
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This can be useful if you need to switch to a new menubar.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch02lev2sec7"/></TD
></TR
><ANNOTATION
NAME="ch02lev2sec7"
TITLE="The Menubar"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch02lev2sec8"
>2.4.2. The Toolbar</A
></H2
><P
>To place a button on the toolbar, use a <TT
CLASS="literal"
>plug()</TT
> method just as you did with the menubar. The first call to <TT
CLASS="literal"
>toolBar()</TT
> creates an instance of <TT
CLASS="literal"
>KToolBar</TT
>. This class is deleted by <TT
CLASS="literal"
>KTMainWindow</TT
> when it is no longer needed.</P
><P
>On line 29 you call <TT
CLASS="literal"
>reposition-&gt;plug(toolBar())</TT
> to put the light bulb icon on a button on the toolbar.</P
><P
>A short help text string, called a tooltip is associated with each toolbar button. It appears when the mouse cursor is placed over a button and left still for about a second. The string <SPAN
CLASS="QUOTE"
>"Reposition Text"</SPAN
>, specified in the action definition (lines 14&#8211;17), is the tooltip string for this button.</P
><P
>You can put any widget you like on the toolbar&#8212;not just buttons. Two commonly used widgets, a line editor and a combo box (such as the URL-entry box with pull-down history used in a Web browser), are supported directly by <TT
CLASS="literal"
>KToolBar</TT
> via <TT
CLASS="literal"
>insertLined()</TT
> and <TT
CLASS="literal"
>insertCombo()</TT
>, but you can use <TT
CLASS="literal"
>insertWidget()</TT
> to add any widget you like.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch02lev2sec8"/></TD
></TR
><ANNOTATION
NAME="ch02lev2sec8"
TITLE="The Toolbar"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch02lev2sec9"
>2.4.3. The Status Line</A
></H2
><P
>The status line, or statusbar, is created and deleted by <TT
CLASS="literal"
>KTMainWindow</TT
> in the same manner as the menubar and toolbar. Your first call to <TT
CLASS="literal"
>statusBar()</TT
>:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;statusBar()-&gt;message ("Ready!");
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>creates an instance of <TT
CLASS="literal"
>KStatusBar</TT
> and puts the message <SPAN
CLASS="QUOTE"
>"Ready!"</SPAN
> at the bottom of the window on the status line.</P
><P
>Like <TT
CLASS="literal"
>KToolBar</TT
>, you can place any widget on the status line by using the method <TT
CLASS="literal"
>KStatusBar::insertWidget()</TT
>. This might be used for displaying a progress bar or an LED-style status indicator, for example.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch02lev2sec9"/></TD
></TR
><ANNOTATION
NAME="ch02lev2sec9"
TITLE="The Status Line"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch02lev1sec4"/></TD
></TR
><ANNOTATION
NAME="ch02lev1sec4"
TITLE="GUI Elements"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch02lev1sec3.html"
>Prev</A
> <A
HREF="ch02lev1sec5.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>