<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>A First Glance at Writing Modules</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="Multimedia"
HREF="ch14.html"/><LINK
REL="PREVIOUS"
TITLE="Multimedia"
HREF="ch14.html"/><LINK
REL="NEXT"
TITLE="MCOP"
HREF="ch14lev1sec3.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch14.html"
>Prev</A
> <A
HREF="ch14lev1sec3.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch14lev1sec2"
>14.2. A First Glance at Writing Modules</A
></H1
><P
>The way you work when writing MCOP-aware objects is normally the following:</P
><OL
COMPACT="COMPACT"
TYPE="1"
><LI
><P
>Write an interface definition in the IDL language; for instance, example_add.idl.</P
></LI
><LI
><P
>Pass that definition through <TT
CLASS="literal"
>mcopidl.</TT
> You get example_add.cc and example_add.h files.</P
></LI
><LI
><P
>Write an implementation for the interfaces you've declared, as C++ class deriving from the <TT
CLASS="literal"
>_skel</TT
> classes.</P
></LI
><LI
><P
>Register that implementation with <TT
CLASS="literal"
>REGISTER_IMPLEMENTATION.</TT
></P
></LI
><LI
><P
>Maybe write a .mcopclass file.</P
></LI
></OL
><P
>After that, everybody can use the things you do.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec2"
>14.2.1. Step 1&#8212;Write an Interface Definition in the IDL Language</A
></H2
><P
>One important concept in MCOP is that classes are not important, interfaces are. To show a simple example, when you write a small module that simply adds two audio streams, it could have the following interface:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;// example_add.idl
   3&nbsp;
   4&nbsp;#include &lt;artsflow.idl&gt;
   5&nbsp;
   6&nbsp;interface Example_ADD : Arts::SynthModule {
   7&nbsp;    in audio stream invalue1, invalue2;
   8&nbsp;    out audio stream result;
   9&nbsp;};
  10&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>You describe interfaces like that in the MCOP IDL files. These lines mean: there is an interface in which two audio streams are flowing in, and one audio stream is flowing out.</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch14fig03"
></A
><P
><B
>Figure 14.3. The <TT
CLASS="literal"
>Example_ADD</TT
> interface.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/14fig03.gif"
></IMG
></P
></DIV
><HR/></DIV
><P
>For people who use this interface, this is all they need to know. They don't need to know how addition takes place. They don't need to know what language this was implemented in. They don't need to know anything except the definitions in the interface.</P
><P
>Let's do a line-by-line walk-through to see what is happening here:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;#include &lt;artsflow.idl&gt;
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Because the <TT
CLASS="literal"
>SynthModule</TT
> interface (which you use later) is declared in artsflow.idl, you need to include it. All aRts components are declared inside the <TT
CLASS="literal"
>Arts</TT
> namespace, so you have to prefix it with <TT
CLASS="literal"
>Arts::</TT
>. I'll never explicitly mention this prefix in the text when discussing interfaces.</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;interface Example_ADD : Arts::SynthModule
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>This tells the MCOP IDL compiler to create an interface that implements everything that <TT
CLASS="literal"
>SynthModule</TT
> does, as well as its own methods, attributes, and streams. (So it derives from <TT
CLASS="literal"
>SynthModule.</TT
>) MCOP supports multiple inheritance as well as single inheritance. Interfaces that don't specify anything automatically derive from <TT
CLASS="literal"
>Object</TT
>. Interfaces that have streams (like our interface) should always inherit <TT
CLASS="literal"
>SynthModule</TT
> (or a derived class).</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;in audio stream invalue1, invalue2;
   3&nbsp;out audio stream outvalue;
   4&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Here you add streams to the interface. These streams are the normal type of audio stream supported by MCOP. They are <I
CLASS="emphasis"
>synchronous</I
>, which means that every time our <TT
CLASS="literal"
>Example_ADD</TT
> module gets 200 samples (or any other amount), all streams are involved. The scheduler takes care that the 200 samples are available for both input ports, <TT
CLASS="literal"
>invalue1</TT
> and <TT
CLASS="literal"
>invalue2</TT
>. It then calls the <TT
CLASS="literal"
>calculateBlock</TT
> method and tells it to calculate 200 samples and expects that it will generate exactly 200 samples of outvalue output. Synchronous streaming is the fastest and most easy-to-use variant of streaming, and it makes sense for most modules.</P
><P
>If, on the other hand, you think of a MIDI stream (that comes from a keyboard), things are different. The module wouldn't be able to guarantee that exactly the number of requested samples can be generated by <TT
CLASS="literal"
>calculateBlock;</TT
> if the scheduler requests, <SPAN
CLASS="QUOTE"
>"Please give me 40 events,"</SPAN
> how could it do that when the person playing the keyboard isn't playing fast enough? For now, you have our synchronous streams; I'll talk more about the alternative model later.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec2"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec2"
TITLE="Step 1&#8212;Write an Interface Definition in the IDL Language"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec3"
>14.2.2. Step 2&#8212;Pass That Definition Through <TT
CLASS="literal"
>mcopidl</TT
></A
></H2
><P
>If you have put all that into a file called example_add.idl, you can invoke <TT
CLASS="literal"
>mcopidl</TT
>:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;$ <I
CLASS="emphasis"
>mcopidl -I$KDEDIR/include/arts example_add.idl</I
>
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The <TT
CLASS="literal"
>-I</TT
> flag adds a path to look for includes. If you don't have KDEDIR set to the position where KDE 2.0 is installed, you may have to use something explicit like the following, instead:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;-I/usr/local/kde-2.0/include/arts
   3&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The IDL compiler now creates example_add.cc and example_add.h, which will be used later to implement and access the new <TT
CLASS="literal"
>Example_ADD</TT
> module.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec3"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec3"
TITLE="Step 2&#8212;Pass That Definition Through mcopidl"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec4"
>14.2.3. Step 3&#8212;Write an Implementation for the Interfaces You've Declared</A
></H2
><P
><A
HREF="ch14lev1sec2.html#ch14list02"
>Listing 14.2</A
> shows how to implement adding the sound.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch14list02"
></A
><P
><B
>Example 14.2. Implementing the <TT
CLASS="literal"
>Example_ADD</TT
> Interface</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; 1: // example_add_impl.cc
   3&nbsp; 2:
   4&nbsp; 3: #include "example_add.h"
   5&nbsp; 4: #include "stdsynthmodule.h"
   6&nbsp; 5:
   7&nbsp; 6: class Example_ADD_impl
   8&nbsp; 7:               :public Example_ADD_skel, Arts::StdSynthModule
   9&nbsp; 8: {
  10&nbsp; 9: public:
  11&nbsp;10:     void calculateBlock(unsigned long samples)
  12&nbsp;11:     {
  13&nbsp;12:         unsigned long i;
  14&nbsp;13:         for(i=0;i &lt; samples;i++)
  15&nbsp;14:             result[i] = invalue1[i] + invalue2[i];
  16&nbsp;15:     }
  17&nbsp;16: };
  18&nbsp;17:
  19&nbsp;18: REGISTER_IMPLEMENTATION(Example_ADD_impl);
  20&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>As you can see, you derive from the skeleton class for the interface (which was generated by the <TT
CLASS="literal"
>mcopidl</TT
> compiler). You also include the corresponding example_add.h (line 3). The other class you derive from is <TT
CLASS="literal"
>StdSynthModule</TT
> because this contains some empty implementations of <TT
CLASS="literal"
>SynthModule</TT
> methods that you often don't need to override.</P
><P
>Finally, consider the <TT
CLASS="literal"
>calculateBlock</TT
> method (line 10). This gets called whenever the module should process a block of audio data. The <TT
CLASS="literal"
>samples</TT
> parameter tells the function how many samples to process. It is guaranteed that they are available at the corresponding pointers.</P
><P
>Invisible to you (generated from the <TT
CLASS="literal"
>mcopidl</TT
> compiler), the streams have become the following declarations in the <TT
CLASS="literal"
>Example_ADD_skel</TT
> class (you inherit from that):</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;// variables for streams
   3&nbsp;float *invalue1;                  // incoming stream
   4&nbsp;float *invalue2;                  // incoming stream
   5&nbsp;float *result;                    // outgoing stream
   6&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>So the task of <TT
CLASS="literal"
>calculateBlock</TT
> is easy:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Take the data at the incoming streams and process them (use exactly <TT
CLASS="literal"
>samples</TT
> values).</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Write the output to the outgoing streams (also exactly <TT
CLASS="literal"
>samples</TT
>). You must fill them; if you don't have anything to write (for instance, because you are getting that data from the Internet, and the Internet isn't fast enough to give you enough data), write 0.0 at least.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Do not modify the pointer itself. You may see this occasionally in some sources, but it isn't allowed any longer.</P
></LI
></UL
><P
>As you see, the code is really easy to read.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec4"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec4"
TITLE="Step 3&#8212;Write an Implementation for the Interfaces You've Declared"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec5"
>14.2.4. Step 4&#8212;Register That Implementation with <TT
CLASS="literal"
>REGISTER_IMPLEMENTATION</TT
></A
></H2
><P
>Finally, <TT
CLASS="literal"
>REGISTER_IMPLEMENTATION</TT
> is used to tell the MCOP object system that you have implemented an interface (you see this in the source under step 3). This has the following background: the objects you implement should be usable from programs that don't even know that such objects exists. For instance, <TT
CLASS="literal"
>artsbuilder</TT
> will be a program that visually connects objects to larger graphs. Of course, it makes sense that your <TT
CLASS="literal"
>Example_ADD</TT
> implementation can be used from <TT
CLASS="literal"
>artsbuilder</TT
>, without <TT
CLASS="literal"
>artsbuilder</TT
> knowing much about it.</P
><P
>Thus, <TT
CLASS="literal"
>artsbuilder</TT
> can't simply call a constructor (because you would need to link <TT
CLASS="literal"
>artsbuilder</TT
> to the class you just wrote and have a .h-file with the class definition, and so on). Instead, the <TT
CLASS="literal"
>REGISTER_IMPLEMENTATION</TT
> macro defines a class that knows how to create one of your <TT
CLASS="literal"
>Example_ADD</TT
> objects. If you then put only this in a shared library, the component can be used as a plug-in by applications that don't know anything about it.</P
><P
>This also means that you shouldn't need to have a header file in most cases, because MCOP provides ways to create an <TT
CLASS="literal"
>Example_ADD</TT
> implementation without knowing that an <TT
CLASS="literal"
>Example_ADD_impl</TT
> class exists.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec5"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec5"
TITLE="Step 4&#8212;Register That Implementation with REGISTER_IMPLEMENTATION"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec6"
>14.2.5. Step 5&#8212;Maybe Write a .mcopclass File</A
></H2
><P
>I'll talk about this in the section <SPAN
CLASS="QUOTE"
>"Using the Effect."</SPAN
> If you compile this in a libtool shared library libexample_add.la, you could write something like this in a file $KDEDIR/lib/Example_ADD.mcopclass:</P
><P
>That way, the MCOP dynamic library-loading mechanism would know that whenever you want to create an <TT
CLASS="literal"
>Example_ADD</TT
> implementation, it could load the library. You'll do this later.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec6"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec6"
TITLE="Step 5&#8212;Maybe Write a .mcopclass File"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch14lev2sec7"
>14.2.6. How to Use the New Module</A
></H2
><P
>So you've written a module (<A
HREF="ch14lev1sec2.html#ch14list03"
>Listing 14.3</A
>). Now, how do you use it?</P
><DIV
CLASS="example"
><HR/><A
NAME="ch14list03"
></A
><P
><B
>Example 14.3. Using an <TT
CLASS="literal"
>Example_ADD</TT
> Module</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; 1: // example_add_test.cc
   3&nbsp; 2:
   4&nbsp; 3: #include "connect.h"
   5&nbsp; 4: #include "example_add.h"
   6&nbsp; 5: #include "artsflow.h"
   7&nbsp; 6:
   8&nbsp; 7: using namespace Arts;
   9&nbsp; 8:
  10&nbsp; 9: void main()
  11&nbsp;10: {
  12&nbsp;11:     // create a MCOP dispatcher (always do this)
  13&nbsp;12:     Dispatcher dispatcher;
  14&nbsp;13:
  15&nbsp;14:     Synth_FREQUENCY freq1, freq2;    // some objects
  16&nbsp;15:     Synth_WAVE_SIN sin1, sin2;
  17&nbsp;16:     Synth_MUL mul;
  18&nbsp;17:     Example_ADD add;
  19&nbsp;18:     Synth_PLAY play;
  20&nbsp;19:
  21&nbsp;20:     // setup a 440Hz sin and connect it to the add
  22&nbsp;21:     setValue(freq1,440.0);
  23&nbsp;22:     connect(freq1,sin1);
  24&nbsp;23:     connect(sin1,add,"invalue1");
  25&nbsp;24:
  26&nbsp;25:     // setup a 880Hz sin and connect it to the add
  27&nbsp;26:     setValue(freq2,880.0);
  28&nbsp;27:     connect(freq2,sin2);
  29&nbsp;28:     connect(sin2,add,"invalue2");
  30&nbsp;29:
  31&nbsp;30:     // multiply everything with 0.5 (=&gt; no clipping)
  32&nbsp;31:     connect(add,result,mul,invalue1);
  33&nbsp;32:     setValue(mul,invalue2,0.5);
  34&nbsp;33:
  35&nbsp;34:     // connect the output to the play module
  36&nbsp;35:     connect(mul,play,"invalue_left");
  37&nbsp;36:     connect(mul,play,"invalue_right");
  38&nbsp;37:
  39&nbsp;38:     // start all modules
  40&nbsp;39:     freq1.start(); freq2.start(); sin1.start();
  41&nbsp;40:     sin2.start(); mul.start(); add.start(); play.start();
  42&nbsp;41:
  43&nbsp;42:     dispatcher.run();
  44&nbsp;43: }
  45&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>You can compile it (with some tweaking if you have no <TT
CLASS="literal"
>KDEDIR</TT
> set) with the following:</P
><DIV
CLASS="informalexample"
><HR/><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;$ <I
CLASS="emphasis"
>gcc -o example_add_test example_add_test.cc example_add.cc</I
>
   3&nbsp;<I
CLASS="emphasis"
>example_add_impl.cc -I$KDEDIR/include/arts</I
>
   4&nbsp;<I
CLASS="emphasis"
>-L$KDEDIR/lib -lmcop -lartsflow_idl -lartsflow -ldl</I
>
   5&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>As you'll hear, it adds the sound just nicely. The resulting graph used here looks like <A
HREF="ch14lev1sec2.html#ch14fig04"
>Figure 14.4</A
>:</P
><DIV
CLASS="figure"
><HR/><A
NAME="ch14fig04"
></A
><P
><B
>Figure 14.4. Flow graph for <A
HREF="ch14lev1sec2.html#ch14list03"
>Listing 14.3</A
>.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="graphics/14fig04.gif"
></IMG
></P
></DIV
><HR/></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev2sec7"/></TD
></TR
><ANNOTATION
NAME="ch14lev2sec7"
TITLE="How to Use the New Module"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch14lev1sec2"/></TD
></TR
><ANNOTATION
NAME="ch14lev1sec2"
TITLE="A First Glance at Writing Modules"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch14.html"
>Prev</A
> <A
HREF="ch14lev1sec3.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>