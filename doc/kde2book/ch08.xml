<chapter label="8" role="chapter" id="ch08">
<title>Using Dialog Boxes</title>
<para><emphasis>by Espen Sand</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In This Chapter</title>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec1">Getting Started with the Dialog Widgets</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec2">Dialog Layout the Simple Way</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec3">Dialog Modality&mdash;Modal or Modeless Dialogs</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec4">KDE User-Interface Library (kdeui)</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec5">Dialog Style and <literal>KDialogBase</literal></link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec6">A Larger Example: The Option Dialog in KEdit</link></emphasis></para></listitem>
<listitem><para><emphasis role="strong"><link linkend="ch08lev1sec7">User Interface Design Rules for Dialogs</link></emphasis></para></listitem>
</itemizedlist>
</highlights>
<para>A dialog<indexterm><primary>dialog boxes</primary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary></indexterm><indexterm><primary>widgets</primary><secondary>dialog widgets</secondary><see>dialog boxes</see></indexterm><indexterm><primary>GUIs</primary><secondary>widgets</secondary><tertiary>dialog widgets</tertiary><see>dialog boxes</see></indexterm> is a very important part of an application. If the dialogs are not well-designed or suited for their task, the usefulness of the application is often greatly reduced. This chapter describes how to successfully create dialogs that are easy to use, that have a distinct KDE look and feel, and that are simple to develop and later extend and maintain by the developer. The KDE interface library (kdeui) contains several building blocks and widgets that, combined with the regular widgets and layout managers of the Qt library, provide you with what you need to get an optimal result. I emphasize the use of a framework widget named <literal>KDialogBase</literal>. The use of the <literal>KDialogBase</literal> class greatly simplifies dialog writing because it takes care of much of the tedious work that has to be repeated for every dialog you make.</para>
<para>Although several interface builders are available that can create dialogs for you (see <link linkend="ch18">Chapter 18, <quote>The KDevelop IDE: The Integrated Development Enviroment for KDE</quote></link>), the KDE interface library widgets are designed to simplify a hand-coded design process. In addition, they automatically give your dialogs the look and feel recommended by the KDE style guide, which is available on the Web page: <ulink url="http://developer.kde.org/documentation/standards/kde/style/basics">http://developer.kde.org/documentation/standards/kde/style/basics</ulink>. Several examples illustrate how to use these basic widgets.<indexterm><primary>dialog boxes</primary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary></indexterm></para>
<section id="ch08lev1sec1">
<title>Getting Started with the Dialog Widgets</title>
<para>Let's<indexterm><primary>dialog boxes</primary><secondary>simple example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>simple example</tertiary></indexterm> start with an example. <link linkend="ch08fig01">Figure 8.1</link> shows a very simple dialog that is used in the standard KDE hex editor&mdash;KHexEdit. The code in <link linkend="ch08list01">Listing 8.1</link> shows how the dialog class is derived from <literal>KDialogBase</literal>. Most of the initialization of <literal>KDialogBase</literal> class takes place in the constructor of that class. The class definition is normally placed in a separate header file, but for simplicity it is shown here together with the regular code.</para>
<figure label="8.1" id="ch08fig01">
<title>This dialog is used to display the number of bytes currently selected in KHexEdit's editor window. The value is printed in decimal and hexadecimal.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/08fig01.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="8.1" id="ch08list01">
<title>Simplified Listing of the <literal>SelectDialog</literal> Dialog Class<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>SelectDialog class</tertiary></indexterm><indexterm><primary>SelectDialog class</primary></indexterm><indexterm><primary>classes</primary><secondary>SelectDialog</secondary></indexterm></title>
<programlisting linenumbering="numbered">
1: class SelectDialog : public KDialogBase
2: {
3:   Q_OBJECT
4:
5:   public:
6:     SelectDialog( QWidget *parent=0, const char *name=0,
7:       bool modal=false );
8:     ~SelectDialog( void );
9:
10:   private:
11:     void setSelectionSize( uint selectionSize );
12:
13:   private:
14:     QLineEdit *mSelectSizeEdit;
15:     uint mSelectionSize;
16: };
17:<indexterm><primary>dialog boxes</primary><secondary>simple example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>simple example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>SelectDialog class</tertiary></indexterm><indexterm><primary>SelectDialog class</primary></indexterm><indexterm><primary>classes</primary><secondary>SelectDialog</secondary></indexterm>
18: SelectDialog::SelectDialog( QWidget *parent, const char *name,
19:                             bool modal )
20:   :KDialogBase( parent, name, modal, i18n("Select Indicator"),
21:                 Cancel, Cancel )
22: {
23:   QWidget *page = new QWidget(this);
24:   CHECK_PTR( page );
25:   setMainWidget( page );
26:
27:   QVBoxLayout *topLayout = new QVBoxLayout( page, 0, spacingHint() );
28:   CHECK_PTR( page );
29:
30:   QLabel *label = new QLabel( i18n("Selection size [bytes]:"), page );
31:   CHECK_PTR( label );
32:   topLayout->addWidget( label );
33:
34:   mSelectSizeEdit = new QLineEdit( page );
35:   CHECK_PTR( mSelectSizeEdit );
36:   mSelectSizeEdit->setMinimumWidth( fontMetrics().maxWidth()*17 );
37:   mSelectSizeEdit->setFocusPolicy( QWidget::NoFocus );
38:   topLayout->addWidget( mSelectSizeEdit );
39:
40:   topLayout->addStretch(10);
41:
42:   setSelectionSize(0);
43: }
44:
45: SelectDialog::~SelectDialog()
46: {
47: }
48:
49: void
50: SelectDialog::setSelectionSize( uint selectionSize )
51: {
52:   mSelectionSize = selectionSize;
53:   QString msg;
54:
55:   msg.sprintf( "%08u, %04x:%04x", mSelectionSize, mSelectionSize>>16,
56:                mSelectionSize&amp;0x0000FFFF );
57:   mSelectSizeEdit->setText( msg );
58: }
59:
60: // The dialog used as the main application window
61:
62: #include &lt;kcmdlineargs.h>
63: int main( int argc, char **argv )
64: {
65:   KCmdLineArgs::init(argc, argv, "khexedit", 0, 0);
66:   KApplication app;
67:   SelectDialog *dialog = new SelectDialog();
68:   dialog->show();
69:   int result = app.exec();
70:   return( result );
71: }<indexterm><primary>dialog boxes</primary><secondary>simple example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>simple example</tertiary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>SelectDialog class</tertiary></indexterm><indexterm><primary>SelectDialog class</primary></indexterm><indexterm><primary>classes</primary><secondary>SelectDialog</secondary></indexterm>
</programlisting>
</example>
<para>The <literal>KDialogBase</literal> widget is described in more detail in the section <link linkend="ch08lev2sec3"><quote>Building Blocks (Manager Widgets)</quote></link> later in this chapter. Notice the signature of the constructor on line 18. These are the arguments you should at least provide when making a dialog. Note as well that in the class definition (line 6), the argument has been assigned default values. The values shown in the code are the most commonly used in KDE and Qt code and is in many respects assumed to be the standard implementation. The <literal>parent</literal> widget is the widget around which the dialog is centered. Normally, you use the top-level widget or your application as the parent of a dialog. The dialog will then be positioned in the center of your main application window. If the <literal>parent</literal> is 0 (null), the dialog is centered with respect to the desktop. The <literal>name</literal> is the name of the dialog widget. It should not be used for the dialog title string (often called the caption) because it is not of type <literal>QString</literal> (the Unicode string class). The <literal>name</literal> is used to identify the widget during development and is very handy if you need to dump a widget hierarchy. You can safely assign 0 to the <literal>name</literal> if you don't need it. The last argument, <literal>modal</literal>, determines the modality of the dialog. See the section <link linkend="ch08lev1sec3"><quote>Dialog Modality&mdash;Modal or Modeless Dialogs</quote></link> later in this chapter for an extended description and a description of the implications of modal and modeless dialog behavior.<indexterm><primary>dialog boxes</primary><secondary>simple example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>simple example</tertiary></indexterm></para>
</section>
<section id="ch08lev1sec2">
<title>Dialog Layout the Simple Way</title>
<para>When<indexterm><primary>dialog boxes</primary></indexterm> you have decided what components are needed in the dialog to accomplish the intended task, place them in such a way that the usage is intuitive for the end user. Any widget can be placed in a dialog by defining its <emphasis>x</emphasis> and <emphasis>y</emphasis> coordinates with respect to the upper-left corner of the parent widget, along with the width and height. This must be repeated for each and every widget in the dialog. In theory, this is straightforward, but in practical life several complicating factors exist:</para>
<orderedlist numeration="arabic" continuation="restarts" spacing="compact">
<listitem><para>What to do when a dialog is resized? Which widgets should stretch and how much, and which remain fixed in size?</para></listitem>
<listitem><para>How much work is required when you suddenly need to add one or more widgets or perhaps remove another? This may require completely new layout code and can take considerable time to finish for complex dialogs.</para></listitem>
<listitem><para>What extra complexity do you have to add to your code to handle font and font-size changes? Remember that the users may prefer another font and/or font-size than you.</para></listitem>
<listitem><para>How easy is it, in general, to support label strings and text that have no predictable size? This is the case for KDE applications that need to support multiple languages.</para></listitem>
</orderedlist>
<para>The<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>manual geometry strategy (dialog boxes)</primary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm> remedy to all these problems is to use the <literal>QLayout</literal> classes to manage the widgets. The widgets' size, stretchability, and position with respect to the others are easily controlled this way. <link linkend="ch08list02">Listing 8.2</link> contains the same constructor using old-style manual placement (OldDialog) and the <literal>QLayout</literal>-based (NewDialog). The difference should easily convince you to use the <literal>QLayout</literal> classes and the <literal>KDialogBase</literal> widget class to manage the widgets, because you no longer have to use the <literal>setGeometry</literal><emphasis>()</emphasis> calls. What would you have to do in OldDialog if the string length of the first QLabel got longer or another font size should be used? Try to add a new label below the first one in the OldDialog. <link linkend="ch08fig02">Figure 8.2</link> shows what the dialog looks like when it is based on QLayouts.<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>QLayout classes</primary><secondary>code example</secondary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary><tertiary>code example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm></para>
<example role="codelisting" label="8.2" id="ch08list02">
<title>The Difference Between the Old Style (Manual) Geometry Strategy and the New Based on <literal>QLayouts</literal><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>manual geometry strategy and QLayouts classes</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: OldDialog::OldDialog( QWidget *parent, const char *name, bool modal )
2:   : QDialog( parent, name, modal )
3: {
4:   setCaption( i18n("Update Frequency") );
5:
6:   QLabel *label = new QLabel( this, "label" );
7:   label->setGeometry( 16, 24, 180, 24 );
8:   label->setText( i18n("Update frequency in seconds:") );
9:
10:   QScrollBar *scrollbar = new QScrollBar( this, "scrollbar" );
11:   scrollbar->setGeometry( 24, 48, 160, 16 );
12:   scrollbar->setOrientation( QScrollBar::Horizontal );
13:
14:   QLCDNumber *lcdNumber = QLCDNumber( this, "lcdnumber" );
15:   lcdNumber->setGeometry( 192, 32, 72, 32 );
16:   lcdNumber->setSmallDecimalPoint( false );
17:   lcdNumber->setNumDigits( 5 );
18:   lcdNumber->setMode( QLCDNumber::DEC );
19:
20:   QPushButton *okPushButton = new QPushButton( this, "ok" );
21:   okPushButton->setGeometry( 32, 120, 80, 24 );
22:   okPushButton->setText( i18n("&amp;OK") );
23:
24:   QPushButton *cancelPushButton = new QPushButton( this, "PushButton_2" );
25:   cancelPushButton->setGeometry( 176, 120, 80, 24 );
26:   cancelPushButton->setText( i18n("&amp;Cancel") );
27:<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>manual geometry strategy (dialog boxes)</primary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>QLayout classes</primary><secondary>code example</secondary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary><tertiary>code example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>manual geometry strategy and QLayouts classes</tertiary></indexterm>
28:   resize( 288, 168 );
29:
30:   connect( scrollbar, SIGNAL(valueChanged(int)),
31:      lcdNumber, SLOT(display(int)) );
32:   connect( okPushButton, SIGNAL(clicked()), this, SLOT(accept()) );
33:   connect( cancelPushButton, SIGNAL(clicked()), this, SLOT(reject()) );
34: }
35:
36: NewDialog::NewDialog( QWidget *parent, const char* name, bool modal )
37:   : KDialogBase( parent, name, modal, i18n("Update Frequency"),
38:      Ok|Cancel, Ok )
39: {
40:   QWidget *page = new QWidget( this );
41:   setMainWidget(page);
42:
43:   QVBoxLayout *topLayout = new QVBoxLayout( page, 0, spacingHint() );
44:   QHBoxLayout *hlay = new QHBoxLayout( topLayout );
45:   QVBoxLayout *vlay = new QVBoxLayout( hlay, 10 );
46:
47:   QLabel *label2 = new QLabel( page, "label1" );
48:   label->setText( i18n("Update frequency in seconds:") );
49:   vlay->addWidget( label );
50:
51:   //
52:   // It is very simple to add a new label here.
53:   //
54:   //QLabel *label2 = new QLabel( page, "label2" );
55:   //label2->setText( i18n("A new label text") );
56:   //vlay->addWidget( label2 );
57:
58:   QScrollBar *scrollbar = QScrollBar( page, "scrollbar" );
59:   scrollbar->setOrientation( QScrollBar::Horizontal );
60:   vlay->addWidget( scrollbar );
61:
62:   QLCDNumber *lcdNumber = QLCDNumber( page, "lcdnumber" );
63:   lcdNumber->setSmallDecimalPoint( false );
64:   lcdNumber->setNumDigits( 3 );
65:   lcdNumber->setMode( QLCDNumber::DEC );
66:   hlay->addWidget( lcdNumber, 0 );
67:
68:   connect( scrollbar, SIGNAL(valueChanged(int)),
69:      lcdNumber, SLOT(display(int)) );
70: }<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>manual geometry strategy (dialog boxes)</primary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>manual placement</tertiary></indexterm><indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>QLayout classes</primary><secondary>code example</secondary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary><tertiary>code example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>manual geometry strategy and QLayouts classes</tertiary></indexterm>
</programlisting>
</example>
<figure label="8.2" id="ch08fig02">
<title>The appearance of the dialog that is implemented in the second constructor of <link linkend="ch08list02">Listing 8.2</link>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/08fig02.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>A <literal>QLayout</literal> can be vertically oriented (<literal>QVBoxLayout</literal>), horizontally oriented (<literal>QHBoxLayout</literal>) or be a grid layout (<literal>QGridLayout</literal>). The Qt layout mechanism is to some extent described in <link linkend="ch04">Chapter 4, <quote>Creating Custom KDE Widgets.</quote></link> Therefore, in the following section, some problems that often appear when writing dialogs are described.<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm><indexterm><primary>QLayout classes</primary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QLayout classes</tertiary></indexterm></para>
<note role="normal">
<para>You can also define your own custom layout managers, but that is outside the scope of this chapter.</para>
</note>
<para>The first important thing you must know is that there can be only one layout manager per widget. This constraint does not prevent you <indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>nested layouts</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>nested layouts</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>nested layouts</tertiary></indexterm><indexterm><primary>nested layouts (dialog boxes)</primary></indexterm>from nesting layouts. As <link linkend="ch08list02">Listing 8.2</link> illustrates, a layout can be inserted into a parent layout, thus becoming a child layout. On line 43, <literal>topLayout</literal> is the parent of the horizontal layout <literal>hlay</literal>, which, in turn, is the parent of the vertical layout <literal>vlay</literal>.</para>
<para>The second constraint you must know is that a widget that is managed by a layout (a parent or a child layout) must be a child widget of the same widget that contains the layout manager. This can been seen in <link linkend="ch08list02">Listing 8.2</link> on lines 58&ndash;60, where <literal>scrollbar</literal> is a child of <literal>page</literal> and is managed by <literal>vlay,</literal> which is a grandchild layout of <literal>topLayout</literal>.</para>
<para>A <indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>hierarchies of layouts</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>hierarchies of layouts</tertiary></indexterm><indexterm><primary>QLayout classes</primary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>hierarchies of layouts</tertiary></indexterm>widget that is managed by a layout manager can itself contain its own layout manager. Thus you can create a hierarchy of layouts and widgets of any desired complexity. <link linkend="ch08list03">Listing 8.3</link> shows how the Goto dialog of KHexEdit is using a frame with a title that groups the toggle buttons. The <literal>group</literal> widget is managed by the <literal>topLayout</literal> manager and contains the <literal>gbox</literal> layout. <link linkend="ch08fig03">Figure 8.3</link> shows the appearance of this dialog.<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>CGotoDialog example</primary><secondary>layout</secondary></indexterm></para>
<example role="codelisting" label="8.3" id="ch08list03">
<title>The <literal>CGotoDialog</literal> Class Uses the <literal>KDialogBase</literal> Class Somewhat Differently from What Has Been Shown Earlier<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog class example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1:  class CGotoDialog : public KDialogBase
2: {
3:   Q_OBJECT
4:
5:   public:
6:     CGotoDialog( QWidget *parent=0, const char *name=0,
7:                  bool modal=false );
8:     ~CGotoDialog();
9:     void defaultFocus();
10:
11:   protected slots:
12:     virtual void slotOk();
13:
14:   signals:
15:     void gotoOffset( uint offset, uint bit, bool fromCursor,
16:                      bool forward );
17:
18:   private:
19:     QComboBox *mComboBox;
20:     QCheckBox *mCheckBackward;
21:     QCheckBox *mCheckFromCursor;
22:     QCheckBox *mCheckVisible;
23: };
24:
25: CGotoDialog::CGotoDialog( QWidget *parent, const char *name, bool modal )
26:   :KDialogBase( Plain, i18n("Goto Offset"), Ok|Cancel, Ok, parent, name,
27:     modal )
28: {
29:   QVBoxLayout *topLayout = new QVBoxLayout( plainPage(), 0,
30:                                             spacingHint() );
31:   CHECK_PTR(topLayout);
32: <indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>CGotoDialog example</primary><secondary>layout</secondary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog class example</tertiary></indexterm>
33:   QVBoxLayout *vbox = new QVBoxLayout( topLayout );
34:   CHECK_PTR(vbox);
35:
36:   mComboBox = new QComboBox( true, plainPage() );
37:   CHECK_PTR(mComboBox);
38:   mComboBox->setMaxCount( 10 );
39:   mComboBox->setInsertionPolicy( QComboBox::AtTop );
40:   mComboBox->setMinimumWidth( fontMetrics().maxWidth()*17 );
41:
42:   QLabel *label = new QLabel( mComboBox, i18n("O&amp;ffset:"), plainPage() );
43:   CHECK_PTR(label);
44:
45:   vbox->addWidget( label );
46:   vbox->addWidget( mComboBox );
47:
48:   QButtonGroup *group = new QButtonGroup( i18n("Options"), plainPage() );
49:   CHECK_PTR(group);
50:   topLayout->addWidget( group, 10 ); // Only the group will be resized
51:
52:   QGridLayout *gbox = new QGridLayout( group, 4, 2, spacingHint() );
53:   CHECK_PTR(gbox);
54:   gbox->addRowSpacing( 0, fontMetrics().lineSpacing() );
55:   mCheckFromCursor = new QCheckBox( i18n("&amp;From cursor"), group );
56:   CHECK_PTR(mCheckFromCursor);
57:   gbox->addWidget( mCheckFromCursor, 1, 0 );
58:   mCheckBackward = new QCheckBox( i18n("&amp;Backwards"), group );
59:   CHECK_PTR(mCheckBackward);
60:   gbox->addWidget( mCheckBackward, 1, 1 );
61:   mCheckVisible = new QCheckBox( i18n("&amp;Stay visible"), group );
62:   CHECK_PTR(mCheckVisible);
63:   gbox->addWidget( mCheckVisible, 2, 0 );
64:   gbox->setRowStretch( 3, 10 ); // Eat up all extra space when resized.
65:   mCheckVisible->setChecked( true );
66:
67:   defaultFocus();
68: }
69:
70: CGotoDialog::~CGotoDialog()
71: {
72: }
73:<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>CGotoDialog example</primary><secondary>layout</secondary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog class example</tertiary></indexterm>
74: void
75: CGotoDialog::defaultFocus()
76: {
77:   mComboBox->setFocus();
78: }
79:
80: void
81: CGotoDialog::slotOk()
82: {
83:   uint offset;
84:   bool success = stringToOffset( mComboBox->currentText(), offset );
85:   if( success == false )
86:   {
87:     return;
88:   }
89:
90:   if( mCheckVisible->isChecked() == false )
91:   {
92:     hide();
93:   }
94:   emit gotoOffset( offset, 7, mCheckFromCursor->isChecked(),
95:        mCheckBackward->isChecked() == true ? false : true );
96: }
97:
98: // The dialog used as the main application window
99: #include &amp;lt;kcmdlineargs.h>
100: int main( int argc, char **argv )
101: {
102:   KCmdLineArgs::init(argc, argv, "khexedit", 0, 0);
103:   KApplication app;
104:   CGotoDialog *dialog = new CGotoDialog;
105:   dialog->show();
106:   int result = app.exec();
107:   return result;
108: }<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog example</tertiary></indexterm><indexterm><primary>CGotoDialog example</primary><secondary>layout</secondary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>CGotoDialog class example</tertiary></indexterm>
</programlisting>
</example>
<para>As can be seen from <link linkend="ch08list03">Listing 8.3</link>, the Plain mode in the constructor instructs <literal>KDialogBase</literal> to create a main widget by itself. This widget is returned by <literal>plainPage()</literal> and serves as the parent widget for all layouts and other widgets. A little&mdash;but important&mdash;trick is used in <link linkend="ch08list03">Listing 8.3</link> as well. On line 54, notice the <literal>fontMetrics().lineSpacing()</literal>. It reserves space so that the uppermost child widget (the From Cursor toggle button) of the frame does not obscure the title string. Never make this spacing by using a fixed integer value. It will work with the font that you use, but when the users of your application change the font size, it will break. The <literal>fontMetrics().lineSpacing()</literal> returns a value that depends on the font. This seems to be a missing feature in the Qt library code, so future versions of the Qt library may not require this workaround.</para>
<figure label="8.3" id="ch08fig03">
<title>The Goto dialog of <link linkend="ch08list03">Listing 8.3</link>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/08fig03.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>The <indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>QVBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>QHBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>layout managers</primary><secondary>creating internally</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm>method of first creating a widget and then the layout for each and every widget that needs it can be cumbersome if it has to be repeated for many widgets. To simplify this, the Qt library contains two widgets, <literal>QVBox</literal> and <literal>QHBox</literal>, which create the layout manager internally. These are intended for simple layouts. The widget children of a <literal>QVBox</literal> widget are placed vertically, and the children of <literal>QHBox</literal> widget are placed next to each other. A <literal>QVBox</literal> widget itself can, of course, be managed by a layout. <link linkend="ch08list04">Listing 8.4</link> shows the constructor of <link linkend="ch08list03">Listing 8.3</link> but uses a <literal>QVBox</literal> instead of a layout. You make only one layout yourself in this example.</para>
<example role="codelisting" label="8.4" id="ch08list04">
<title>The <literal>CGotoDialog</literal> Class Using a <literal>QVBox</literal> Widget to Do the Geometry Management<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>QVBox widget for geometry management</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: CGotoDialog::CGotoDialog( QWidget *parent, const char *name, bool modal )
2:   :KDialogBase( Plain, i18n("Goto Offset"), Ok|Cancel, Ok, parent, name,
3:         modal )
4: {
5:    QVBoxLayout *topLayout = new QVBoxLayout(plainPage(), 0, spacingHint());
6:    CHECK_PTR(topLayout);
7:
8:    QVBox *topBox = new QVBox( plainPage() );
9:    CHECK_PTR(topBox);
10:   topBox->setSpacing( spacingHint() );
11:   topLayout->addWidget( topBox );
12:
13:   QLabel *label = new QLabel( i18n("O&amp;ffset:"), topBox );
14:   CHECK_PTR(label);
15:
16:   mComboBox = new QComboBox( true, topBox );
17:   CHECK_PTR(mComboBox);
18:   mComboBox->setMaxCount( 10 );
19:   mComboBox->setInsertionPolicy( QComboBox::AtTop );
20:   mComboBox->setMinimumWidth( fontMetrics().maxWidth()*17 );
21:   label->setBuddy(mComboBox); // To get the underlining to work
22:<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>QVBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>QHBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>layout managers</primary><secondary>creating internally</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm>
23:   QButtonGroup *group = new QButtonGroup( i18n("Options"), topBox );
24:   CHECK_PTR(group);
25:
26:   QGridLayout *gbox = new QGridLayout( group, 4, 2, spacingHint() );
27:   CHECK_PTR(gbox);
28:   gbox->addRowSpacing( 0, fontMetrics().lineSpacing() );
29:   mCheckFromCursor = new QCheckBox( i18n("&amp;From cursor"), group );
30:   CHECK_PTR(mCheckFromCursor);
31:   gbox->addWidget( mCheckFromCursor, 1, 0 );
32:   mCheckBackward = new QCheckBox( i18n("&amp;Backwards"), group );
33:   CHECK_PTR(mCheckBackward);
34:   gbox->addWidget( mCheckBackward, 1, 1 );
35:   mCheckVisible = new QCheckBox( i18n("&amp;Stay visible"), group );
36:   CHECK_PTR(mCheckVisible);
37:   gbox->addWidget( mCheckVisible, 2, 0 );
38:   gbox->setRowStretch( 3, 10 ); // Eat up all extra space when resized.
39:   mCheckVisible->setChecked( true );
40:
41:   defaultFocus();
42: }<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>QVBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>QHBox widget</primary><secondary>layout managers, creating</secondary></indexterm><indexterm><primary>layout managers</primary><secondary>creating internally</secondary><tertiary>QVBox/QHBox widgets</tertiary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>QVBox widget for geometry management</tertiary></indexterm>
</programlisting>
</example>
<para>You should keep several design issues in mind when using <literal>QLayouts</literal>. The following list can be considered a checklist:<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>QLayout classes</primary><secondary>design issues</secondary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>design guidelines</primary><secondary>dialog boxes</secondary><tertiary>layout issues</tertiary></indexterm></para>
<orderedlist numeration="arabic" continuation="restarts" spacing="compact">
<listitem><para>What spacing and margin values do you use in the <literal>QLayouts</literal>? Make sure you use the same values for spacing and margins for all dialogs you make, because this makes the overall appearance much better. Never use hard-coded values. Define constants in a common header file and use them without exception. As indicated in <link linkend="ch08list03">Listing 8.3</link>, dialogs derived from <literal>KDialogBase</literal> have access to a <literal>spacingHint()</literal> and (not shown) a <literal>marginHint()</literal> method. These provide the values you need. Note: Normally you can ignore the <literal>marginHint()</literal> because this is reserved for the space between the dialog edge and the outermost widget. The <literal>KDialogBase</literal> takes care of setting up this space internally.</para></listitem>
<listitem><para>Should your dialog be resizable? In most cases, there is no reason to not allow resizing. This means that a dialog can be made larger than the default minimum size, but never smaller. The default minimum size is automatically computed by the <literal>QLayouts</literal> just before the dialog becomes visible. A dialog that contains editable fields or lists should always be resizable, whereas dialogs that contain widgets that require a long time to resize should perhaps be fixed. The <literal>KDialogBase</literal> class contains one method,<indexterm><primary>disableResize() method</primary></indexterm><indexterm><primary>methods</primary><secondary>disableResize()</secondary></indexterm> <literal>disableResize()</literal>, which prevents the dialog from being resized. It must be called just before <literal>show()</literal> or <literal>exec()</literal>. The default behavior of <literal>KDialogBase</literal> is to allow resizing.</para></listitem>
<listitem><para>Which widgets in your dialog are stretchable? When you add a widget to a layout with <literal>addWidget(&hellip;)</literal>, you can also specify a stretch factor. The widget with the biggest stretch factor is resized the most when the layout is resized. Normally, list widgets and multiline edit widgets should be at least stretchable vertically, and anything containing an edit field should be horizontally stretchable. You can also set an empty space to be stretchable. This is done in <link linkend="ch08list04">Listing 8.4</link> on line 38.</para></listitem>
<listitem><para>How does your dialog look when you change the length of the strings? Always test with both short and long strings for the various labels and so on. You will then locate potential problems long before a translation is being made or before a modification of an original string is made.<indexterm><primary>dialog boxes</primary><secondary>layout</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>layout</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>QLayout classes</primary><secondary>design issues</secondary></indexterm><indexterm><primary>classes</primary><secondary>QLayout</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>geometry management (widgets)</primary><secondary>dialog boxes</secondary><tertiary>design issues</tertiary></indexterm><indexterm><primary>design guidelines</primary><secondary>dialog boxes</secondary><tertiary>layout issues</tertiary></indexterm></para></listitem>
</orderedlist>
</section>
<section id="ch08lev1sec3">
<title>Dialog Modality&mdash;Modal or Modeless Dialogs</title>
<para>A dialog<indexterm><primary>dialog boxes</primary></indexterm> can be used in two ways. Basically, it either blocks access (by mouse or keyboard) to any other parts if an application while visible, or it does not impose any restrictions to what the user can do. The first approach is known as <emphasis>modal dialog behavior</emphasis>, and the second is <emphasis>modeless dialog behavior</emphasis>.</para>
<para>The<indexterm><primary>dialog boxes</primary><secondary>modal</secondary><tertiary>advantages/disadvantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modal</tertiary></indexterm><indexterm><primary>modal dialog boxes</primary><secondary>advantages/disadvantages</secondary></indexterm><indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>advantages/disadvantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>advantages/disadvantages</secondary></indexterm> decision when to use a modal or modeless dialog depends very much on the dialog itself and on what the purpose of the dialog is. At one extreme: In a situation where you cannot do any useful work until a decision has been made and the dialog has been closed, you can safely go for a modal dialog. A file selector is a typical example and is often implemented as a modal dialog. At the opposite end of the scale, a search dialog is modeless in most cases. Modeless dialogs introduce greater flexibility for end users because they are not forced to work in a specific pattern decided by the developer. The cost for the greater flexibility is that the code required to make a modeless dialog work as intended can be somewhat more complicated. However, if it is possible, you will normally get a better result using modeless dialogs. The standard KDE file selector can be used as a modeless dialog, and a dialog derived from the <literal>KDialogBase</literal> class can be either modal or modeless.<indexterm><primary>dialog boxes</primary><secondary>modal</secondary><tertiary>advantages/disadvantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modal</tertiary></indexterm><indexterm><primary>modal dialog boxes</primary><secondary>advantages/disadvantages</secondary></indexterm><indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>advantages/disadvantages</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>advantages/disadvantages</secondary></indexterm></para>
<para>For a developer, the main differences between modal and modeless dialogs are how the dialog becomes visible and how it can transfer information&mdash;that is, the dialog settings&mdash;to the rest of the program. <link linkend="ch08list05">Listing 8.5</link> illustrates how the KDE color selector is used as a modal dialog. It is modal because the last argument is <literal>true</literal> (line 4 in <link linkend="ch08list05">Listing 8.5</link>). Every modal dialog must use <literal>QDialog::exec()</literal>.<indexterm><primary>exec() method</primary><secondary>QDialog class</secondary></indexterm><indexterm><primary>methods</primary><secondary>exec()</secondary><tertiary>QDialog class</tertiary></indexterm> This is a method that starts the dialog and returns the result only after the dialog is once again hidden. The <literal>QDialog::exec()</literal> on line 8 blocks access to any other part of the program but the dialog while it is active.<indexterm><primary>dialog boxes</primary><secondary>modal</secondary><tertiary>modal dialog located on the stack</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modal</tertiary></indexterm><indexterm><primary>modal dialog boxes</primary><secondary>modal dialog located on the stack</secondary></indexterm></para>
<example role="codelisting" label="8.5" id="ch08list05">
<title>A Modal Dialog Located on the Stack<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>modal dialog located on the stack</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: int
 2: getColor( QColor &amp;theColor, QWidget *parent )
 3: {
 4:    KColorDialog dialog( parent, "colordialog", true );
 5:    if( theColor.isValid() )
 6:    {
 7:       dialog.setColor( theColor );
 8:    }
 9:    int result = dialog.exec();
10:    if( result == Accepted )
11:    {
12:       theColor = dialog.color();
13:    }
14:    return result;
15: }
</programlisting>
</example>
<para>The dialog state is in this case collected by the <literal>color()</literal> method. Note that since the dialog object is stored on the stack, the dialog is automatically destroyed when the function returns. A modal dialog does not have to be located at the stack while it is in use. Many developers prefer the implementation shown in <link linkend="ch08list06">Listing 8.6</link>. This can be a very important design decision if the dialog object is so large that a stack overflow could otherwise occur. Make sure that the dialog object is removed from memory (as shown on line 20) before the function returns. Otherwise, you will have a memory leak (bug) in your program.<indexterm><primary>dialog boxes</primary><secondary>modal</secondary><tertiary>modal dialog allocated from the heap</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modal</tertiary></indexterm><indexterm><primary>modal dialog boxes</primary><secondary>modal dialog allocated from the heap</secondary></indexterm></para>
<example role="codelisting" label="8.6" id="ch08list06">
<title>A Modal Dialog Allocated from the Heap<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>modal dialog allocated from the heap</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: int
 2: getColor( QColor &amp;theColor, QWidget *parent )
 3: {
 4:    KColorDialog *dialog = new KColorDialog( parent, "colordialog", true );
 5:    if( dialog == 0 )
 6:    {
 7:       return Rejected; // Rejected is a constant defined in QDialog
 8:    }
 9:
10:    if( theColor.isValid() )
11:    {
12:       dialog->setColor( theColor );
13:    }
14:    int result = dialog->exec();
15:    if( result == Accepted )
16:    {
17:       theColor = dialog->color();
18:    }
19:
20:    delete dialog; // Important to avoid memory leaks
21:   
22:    return result;
23: }
</programlisting>
</example>
<para>When you want to use a modeless dialog, you have to do two things. First, you must allocate the dialog object from the heap (with new); second, you must make it visible with <literal>show()</literal>. When you call <literal>show()</literal> on a dialog, the method starts the dialog and then returns immediately, not waiting for the dialog to be hidden. To avoid a memory leak, you must now store the pointer as well so that you can release the memory occupied by the dialog code when the dialog is no longer needed. <link linkend="ch08list07">Listing 8.7</link> shows how the <literal>CGotoDialog</literal> dialog class (see <link linkend="ch08list03">Listing 8.3</link>) of KHexEdit is used as a modeless dialog.<indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>CGotoDialog class example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>CGotoDialog class example</secondary></indexterm><indexterm><primary>CGotoDialog class</primary><secondary>modeless dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>CGotoDialog</secondary><tertiary>modeless dialog box</tertiary></indexterm></para>
<example role="codelisting" label="8.7" id="ch08list07">
<title>A Modeless Dialog<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>modeless dialog example</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: CHexEditorWidget::CHexEditorWidget()
 2: {
 3:   mGotoDialog = 0;
 4: }
 5:
 6: CHexEditorWidget::~CHexEditorWidget()
 7: {
 8:   delete mGotoDialog;
 9: }
10:
11: void
12: CHexEditorWidget::gotoOffset()
13: {
14:   if( mGotoDialog == 0 )
15:   {
16:     mGotoDialog = new CGotoDialog( topLevelWidget(), "goto", false );
17:     if( mGotoDialog == 0 )
18:     {
19:       return;
20:     }
21:     connect( mGotoDialog, SIGNAL(gotoOffset( uint, uint, bool, bool )),
22:            mHexView, SLOT(gotoOffset( uint, uint, bool, bool )) );
23:   }
24:   mGotoDialog->show();
25: }
</programlisting>
</example>
<para>The <literal>mGotoDialog</literal> is a pointer stored in the <literal>CHexEditorWidget</literal> class, and it is initialized to 0 in the constructor and deleted in the destructor of <literal>CHexEditorWidget</literal>. The first time the dialog is used, it is first allocated (line 16) and next started ( with <literal>show()</literal> on line 24). Then, the next time it is used, it is only started. The <literal>gotoOffset()</literal> function returns immediately after the dialog has been started.</para>
<para>When a dialog is modeless, other parts of a program have to be notified when the dialog settings are ready to be used. Because the <literal>show()</literal> returns immediately, the dialog must emit a signal to indicate that the data is ready. In <link linkend="ch08list07">Listing 8.7</link>, the <literal>gotoOffset(&hellip;)</literal> signal of the <literal>CGotoDialog</literal> class is emitted for this purpose.<indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>CGotoDialog class example</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>CGotoDialog class example</secondary></indexterm><indexterm><primary>CGotoDialog class</primary><secondary>modeless dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>CGotoDialog</secondary><tertiary>modeless dialog box</tertiary></indexterm></para>
<section id="ch08lev2sec1">
<title>Removal of Modeless Dialogs</title>
<para>How<indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>removing from memory</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>removing from memory</secondary></indexterm><indexterm><primary>removing</primary><secondary>modeless dialog boxes</secondary></indexterm><indexterm><primary>memory</primary><secondary>modeless dialog boxes, removing from</secondary></indexterm> and when can modeless dialogs be removed from memory? First, you must store a pointer to the allocated dialog object. The memory can be released only when the dialog is no longer needed (hidden). This can be done when one of these two criteria is met:</para>
<orderedlist numeration="arabic" continuation="restarts" spacing="compact">
<listitem><para>The application terminates or the parent widget is destroyed.</para></listitem>
<listitem><para>The dialog becomes hidden or is closed.</para></listitem>
</orderedlist>
<para>Option 1 is by far the simplest and is, perhaps, the best way to handle a modeless dialog. It has the advantage that you can easily hide and redisplay a dialog on the same position on the screen (which many users prefer) without extra coding. The biggest disadvantage is that it remains in memory even when it is not visible. Normally, this is done as with the dialog in <link linkend="ch08list07">Listing 8.7</link>. The dialog object is destroyed in the destructor of the object that stores the pointer to the dialog.</para>
<para>Option 2 can be the best option if your dialog can be created quickly or is rarely used. However, if it takes a long time to prepare and set up the dialog and its contents, or if it is a lightweight dialog (uses little memory) or is used frequently, this may not be the best option.</para>
<para>You should never delete the dialog from within the dialog code itself. This means that <literal>delete this</literal> is never a safe way to do it, unless you know exactly what you do and how the library code you use works. <link linkend="ch08list08">Listing 8.8</link> illustrates a dangerous attempt to release the memory the Goto dialog has allocated when the Cancel button has been activated.</para>
<example role="codelisting" label="8.8" id="ch08list08">
<title>This Can Make Your Code Buggy!<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>modeless dialogs, removing from memory</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: void
2: CGotoDialog::slotCancel()
3: {
4:   hide();       // Ok, will hide the dialog
5:   delete this;  // Bad!
6: }
</programlisting>
</example>
<para>The problem with this code is that the slot is connected to a signal in the Cancel button. Remember this: When a signal is emitted from an object, it returns only after every slot method it is connected to has finished. If one of these destroys the dialog and thereby the button itself, anything can happen on the return&mdash;and perhaps even before that&mdash;because the internal variables of the button object are no longer valid. The real danger is that it can sometimes work and sometimes it can cause a segmentation fault later.<indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>removing from memory</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>removing from memory</secondary></indexterm><indexterm><primary>removing</primary><secondary>modeless dialog boxes</secondary></indexterm><indexterm><primary>memory</primary><secondary>modeless dialog boxes, removing from</secondary></indexterm></para>
<para>To simplify the destruction procedure, the <literal>KDialogBase</literal> class emits a signal, <literal>KDialogBase::hidden()</literal>, whenever it receives a <literal>QHideEvent</literal> (becomes hidden). You can use this signal to start the destruction process. However, the same restriction applies to the slot function you used to connect to the <literal>hidden()</literal> signal in the previous example with the Cancel button. One common solution to avoiding this problem is to activate a one-shot timer with a zero delay. This is a safe method because even with a delay equal to zero, the timer function can be executed only when the program again runs in the main event loop. This can happen only after the signal has returned. <link linkend="ch08list09">Listing 8.9</link> shows how a modeless option dialog in KJots is destroyed this way. KJots is a KDE utility application that is used to manage short text notes.<indexterm><primary>dialog boxes</primary><secondary>modeless</secondary><tertiary>removing from memory</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>modeless</tertiary></indexterm><indexterm><primary>modeless dialog boxes</primary><secondary>removing from memory</secondary></indexterm><indexterm><primary>removing</primary><secondary>modeless dialog boxes</secondary></indexterm><indexterm><primary>memory</primary><secondary>modeless dialog boxes, removing from</secondary></indexterm></para>
<example role="codelisting" label="8.9" id="ch08list09">
<title>A Secure Way to Remove a Modeless Dialog Object from Memory After It Has Been Hidden<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>modeless dialogs, removing from memory</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: void
2: KJotsMain::configure()
3: {
4:   if( mOptionDialog == 0 )
5:   {
6:     mOptionDialog = new ConfigureDialog( topLevelWidget(), 0, false );
7:     if( mOptionDialog == 0 )
8:     {
9:       return;
10:     }
11:     connect( mOptionDialog, SIGNAL(hidden()),this,SLOT(configureHide()));
12:     connect( mOptionDialog, SIGNAL(valueChanged()),
13:                 this, SLOT(updateConfiguration()) );
14:   }
15:   mOptionDialog->show();
16: }
17:
18: void
19: KJotsMain::configureHide()
20: {
21:   QTimer::singleShot( 0, this, SLOT(configureDestroy()) ); // Zero delay
22: }
23:
24: void
25: KJotsMain::configureDestroy()
26: {
27:   if( mOptionDialog != 0 &amp;&amp; mOptionDialog->isVisible() == false )
28:   {
29:     delete mOptionDialog;
30:     mOptionDialog = 0;
31:   }
32: }
</programlisting>
</example>
<para>If you think this was a tedious method, then <literal>KDialogBase</literal> can help you with this as well. There is a function named <literal>KDialogBase::delayedDestruct()</literal> that automates the destruction process. This function will do a <literal>delete this</literal> but in a controlled fashion. You can call this function from the slots that normally hide the dialog. Note however that if you have stored a pointer to the dialog object outside the class as in <link linkend="ch08list09">Listing 8.9</link>, then this pointer becomes a dangerous dangling pointer once the dialog has destroyed itself. You can solve this problem by using the Qt <literal>QGuardedPtr</literal> class to protect the external pointer.</para>
</section>
</section>
<section id="ch08lev1sec4">
<title>KDE User-Interface Library (kdeui)</title>
<para>Before you start designing a new dialog <indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary></indexterm><indexterm><primary>kdeui (KDE user-interface library</primary></indexterm><indexterm><primary>user-interface library</primary><see>kdeui (KDE user-interface library)</see></indexterm><indexterm><primary>KDE user-interface library</primary><see>kdeui</see></indexterm>or a widget that is intended to be used in a dialog or elsewhere, make sure it has not already been made by someone else. The KDE user-interface library (kdeui) is a collection of widgets that extends the functionality of the standard Qt widget set. Generally, widgets have been added to the kdeui because the functionality they provide is not present in the Qt widget library. Another reason is that the widget code would otherwise be duplicated in many applications, and because the widgets support the KDE look and feel for issues such as dialog titles, margins, and keyboard accelerators to the interface.</para>
<section id="ch08lev2sec2">
<title>Ready-to-Use Dialogs</title>
<para>The <indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>read-to-use dialog boxes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>dialog boxes</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>dialog boxes</secondary></indexterm>most commonly used ready-to-use dialogs are the following:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>File selector (<literal>KFileDialog</literal>)&mdash;This dialog is actually not in kdeui but is in its own library.</para></listitem>
<listitem><para>Font selector (<literal>KFontDialog</literal>).</para></listitem>
<listitem><para>Keyboard bindings selector (<literal>KKeyDialog</literal>).</para></listitem>
<listitem><para>Color selector (<literal>KColorDialog</literal>).</para></listitem>
<listitem><para>Icon selector (<literal>KIconLoaderDialog</literal>).</para></listitem>
<listitem><para>Single line input dialog with browsing capability (<literal>KLineEditDlg</literal>).</para></listitem>
<listitem><para>Message boxes for warning, error, and information (<literal>KMessageBox</literal>).</para></listitem>
</itemizedlist>
<para>Some of these dialogs have counterparts in the Qt library that can be used for the same task. The reason for this duality is that the KDE versions match better with the accepted KDE style guidelines. Use the KDE version when in doubt because it will improve your program's compliance with the KDE-style-guide recommendations.<indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>read-to-use dialog boxes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>dialog boxes</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>dialog boxes</secondary></indexterm></para>
<para>If there is a dialog that serves your requirements, then use it instead of making your own! The benefits are several: The users don't have to learn a new dialog and how it works; you save a lot of time; and most of the dialogs are really easy to use, as <link linkend="ch08list10">Listing 8.10</link> illustrates. The code uses the font selector to pick a font and install it in the widget.</para>
<example role="codelisting" label="8.10" id="ch08list10">
<title>Using a Dialog from the kdeui Library<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>dialog from kdeui library</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: void
2: Editor::selectFont()
3: {
4:   QFont fnt = font();        // Get current font
5:   KFontDialog::getFont(fnt); // Select a new, default is current font
6:   setFont(fnt);              // Install new font
7: }
</programlisting>
</example>
<para>Nevertheless, if you decide that you really need a dialog or a widget that is similar to an existing one, but one with an extended feature set, you should not hesitate to contact the author of the code and ask whether your requirements can be fulfilled by improving the current dialog. If you can provide code that can be merged into the existing library code without breaking compatibility, your chances for acceptance increase.<indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>read-to-use dialog boxes</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>dialog boxes</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>dialog boxes</secondary></indexterm></para>
<note role="normal">
<para>You should also know that a widget or dialog that is used by several applications or that is generally useful might be incorporated into the library.</para>
</note>
</section>
<section id="ch08lev2sec3">
<title>Building Blocks (Manager Widgets)</title>
<para>The<indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>manager widgets</secondary></indexterm><indexterm><primary>manager widgets (kdeui)</primary></indexterm><indexterm><primary>widgets</primary><secondary>manager widgets (kdeui)</secondary></indexterm> kdeui library provides some very important manager widgets that you must know when you make a dialog. This will greatly simplify your task and make maintaining a lot easier. The <literal>KDialogBase</literal> class has already been mentioned. Here is a short summary:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>KButtonBox</literal>&mdash;<indexterm><primary>KButtonBox manager widget</primary></indexterm>Manages a set of action buttons. You can add as many buttons as you want, and the widget will position and resize them as required. To use this widget, you must specify the text and the accelerators of the buttons. An example showing how the <literal>KButtonBox</literal> can be used is in <link linkend="ch08list11">Listing 8.11</link>. Note that if you derive your dialog from the <literal>KDialogBase</literal> class, the buttons will be prepared automatically as other examples have shown.</para></listitem>
</itemizedlist>
<example role="codelisting" label="8.11" id="ch08list11">
<title>Usage of <literal>KButtonBox</literal> in a Dialog<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>KButtonBox in a dialog</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
1: MyDialog::MyDialog( QWidget *parent, const char *name, bool modal)
2:  : KDialog( parent, name, modal )
3:{
4:  QVBoxLayout *topLayout = new QVBoxLayout( this, marginHint(),
5:    spacingHint() );
6:  CHECK_PTR( topLayout );
7:
8:  // Main body of the dialog is not shown here, just the button
9:  // box
10:
11:  KButtonBox *bbox = new KButtonBox( this, KButtonBox::HORIZONTAL,
12:    0, spacingHint() );
13:  CHECK_PTR( bbox );
14:  topLayout->addWidget( bbox );
15:
16:  buttonBox->addStretch();
17: QPushButton *ok = bbox->addButton( i18n("&amp;Ok"), false );
18:  QPushButton *cancel = bbox->addButton( i18n("&amp;Cancel"), false );
19:  buttonBox->layout();
20:  ok->setDefault( true );
21:  connect( ok , SIGNAL(clicked()), this, SLOT(accept()) );
22:  connect( cancel , SIGNAL(clicked()), this, SLOT(reject()) );
23:}<indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>manager widgets</secondary></indexterm><indexterm><primary>manager widgets (kdeui)</primary></indexterm><indexterm><primary>widgets</primary><secondary>manager widgets (kdeui)</secondary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>KButtonBox in a dialog</tertiary></indexterm><indexterm><primary>KButtonBox manager widget</primary></indexterm>
</programlisting>
</example>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para><literal>KJanusWidget</literal>&mdash;This<indexterm><primary>KJanusWidget manager widget</primary></indexterm> is a widget that provides a number of faces (thereby the name) or layouts. Depending on how it is initialized, it can display widgets in a tabbed fashion, in a paged tree list in a paged icon list, or on a single page. Its main use is as an internal widget in <literal>KDialogBase</literal>, but it can be used as a standalone widget as well. <link linkend="ch08fig04">Figure 8.4</link> shows a <literal>KJanusWidget</literal> widget in <literal>Tabbed</literal> mode.</para></listitem>
<listitem><para><literal>KDialog</literal><indexterm><primary>KDialog manager widget</primary></indexterm> (derived from <literal>QDialog</literal>)&mdash;This dialog widget provides resources that give you easy access to global properties concerning style settings. At the moment, you can get access to the spacing and margin sizes you should use between widgets in your dialog and a redefined <literal>setCaption()</literal> so that your dialog uses the proper dialog title style. If your code uses these methods, any change in the future (for example, a new margin setting as a part of a theme selection) will automatically be used in your dialog as well. See <link linkend="ch08list11">Listing 8.11</link> for a typical example on how to use a <literal>KDialog</literal> dialog widget.</para></listitem>
<listitem><para><literal>KDialogBase</literal><indexterm><primary>KDialogBase manager widget</primary></indexterm> (derived from <literal>KDialog</literal>)&mdash;This is a dialog frame widget. It is designed to take care of a lot of work that you would otherwise spend much time getting right for each dialog you create. It provides access to the resources of <literal>KDialog</literal>; it takes care of the action buttons; it draws a separator above the buttons (if you tell it to do so); it resizes itself automatically to fit the contents when shown; and it uses the <literal>KJanusWidget</literal> to support various dialog types. The philosophy is that you only need to worry about the contents of the dialog that performs your specific task.<indexterm><primary>dialog boxes</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>kdeui (KDE user-interface library)</tertiary></indexterm><indexterm><primary>libraries</primary><secondary>kdeui (KDE user-interface library)</secondary><tertiary>manager widgets</tertiary></indexterm><indexterm><primary>kdeui (KDE user-interface library)</primary><secondary>manager widgets</secondary></indexterm><indexterm><primary>manager widgets (kdeui)</primary></indexterm><indexterm><primary>widgets</primary><secondary>manager widgets (kdeui)</secondary></indexterm></para></listitem>
</itemizedlist>
</section>
</section>
<section id="ch08lev1sec5">
<title>Dialog Style and <literal>KDialogBase</literal></title>
<para>Dialog<indexterm><primary>dialog boxes</primary><secondary>KDialogBase class</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KDialogBase class</tertiary></indexterm><indexterm><primary>KDialogBase class</primary></indexterm><indexterm><primary>classes</primary><secondary>KDialogBase</secondary></indexterm> appearance is an important topic when you are designing a dialog. The best design rule is simply to think first and to select the components that are best suited for the task. A quick sketch on a piece of paper to show how the dialog should look is helpful.</para>
<para>The <literal>KDialogBase</literal> class has itself been designed to simplify dialog creation. It provides you with the framework that you will need every time you design a dialog. This includes standardized action buttons, an optional button separator above these buttons, methods that give you the margin and spacing you should use, and automatic dialog title creation that complies with the KDE style guide. If you use the class properly, <literal>KDialogBase</literal> makes sure that a certain style is enforced. This is important from an end-user perspective because the more familiar a dialog is, the easier it is to use it. The <literal>KDialogBase</literal> class simplifies the design process; the time you need to spend on coding and later maintaining it will be reduced. For example, as indicated in the previous code listings using <literal>KDialogBase</literal>, you define what kind of action buttons you want to display, but the <literal>KDialogBase</literal> dialog code decides where the buttons should be placed, what text and accelerators they should display, and the margins, the spacing, and the order. The <literal>KDialogBase</literal> class provides a number of predefined action buttons. A list of the available ones follows. The list order decides the order in which they are displayed.<indexterm><primary>dialog boxes</primary><secondary>KDialogBase class</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KDialogBase class</tertiary></indexterm><indexterm><primary>KDialogBase class</primary></indexterm><indexterm><primary>classes</primary><secondary>KDialogBase</secondary></indexterm></para>
<note role="tip">
<para>Even though you should normally use the standard text and assign your special purpose actions to the <literal>UserN</literal> buttons, it is still possible to override the default text and accelerators by using the KDialogBase::setButtonText(&hellip;) method.<indexterm><primary>setButtonText() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setButtonText()</secondary></indexterm></para>
</note>
<para>The action button order is defined by the current KDE style. When this chapter was written, no format style had been defined, but <literal>KDialogBase</literal> uses what has become a standard button order:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
Help,Default,User3,User2,User1,Ok,Apply|Try,Cancel|Close
</programlisting>
</informalexample>
<para>The <literal>|</literal> sign indicates that <literal>Apply</literal> and <literal>Try</literal> cannot be present at the same time, nor <literal>Cancel</literal> and <literal>Close</literal>. A stretchable space will be added to the right of the Default button. You must add your own text and accelerators to the user-definable buttons.<indexterm><primary>dialog boxes</primary><secondary>KDialogBase class</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KDialogBase class</tertiary></indexterm><indexterm><primary>KDialogBase class</primary></indexterm><indexterm><primary>classes</primary><secondary>KDialogBase</secondary></indexterm></para>
<para><link linkend="ch08fig04">Figure 8.4</link> illustrates the stretchable space and custom button texts as shown in a typical print dialog box. <link linkend="ch08list12">Listing 8.12</link> shows the constructor signature that makes the dialog.</para>
<example role="codelisting" label="8.12" id="ch08list12">
<title>Setting the Text of User-Definable Action Buttons in the Constructor</title>
<programlisting linenumbering="numbered">
1: CPrinterDialog::CPrinterDialog( QWidget *parent, char *name, bool modal )
2:   :KDialogBase( Tabbed, i18n("Print Document"),
3:    Help|User2|User1|Cancel, User1, parent, name, modal, false,
4:    i18n("&amp;Print"), i18n("Pre&amp;view") ),
5: {
6:   // The code has been removed in this example.
7: }
</programlisting>
</example>
<figure label="8.4" id="ch08fig04">
<title>Usage of user-definable action buttons and stretchable space between them. The dialog itself is based on the <literal>KDialogBase</literal> class in Tabbed mode.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/08fig04.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<para>The default button layout area is at the bottom of the dialog. The buttons are then, as you have seen, placed horizontally on a line in this area. However, it is possible to place the buttons vertically at the right edge area of the dialog as well. To accomplish this, tell <literal>KDialogBase</literal> to do so by using the function <literal>KDialogBase:: setButtonBoxOrientation(int orientation)</literal>in the constructor of your dialog. The <literal>orientation</literal> argument shall then be <literal>Vertical</literal>.</para>
<para>For each button, the <literal>KDialogBase</literal> class provides a slot and a signal. The Apply button, when activated, executes the <literal>KDialogBase::slotApply()</literal>, which, in turn, emits the <literal>KDialogBase::applyClicked()</literal> signal. Every slot method is a virtual method; therefore, you can override it with your own slot method. This was done in <link linkend="ch08list03">Listing 8.3</link> where the original <literal>slotOk()</literal> was replaced. Note: The signal will not be emitted if you replace the default slot. Each button has a slot (for example, <literal>slotHelp()</literal>, <literal>slotUser2()</literal>) and a signal (for example, <literal>helpClicked()</literal>, <literal>user2Clicked()</literal>).<indexterm><primary>dialog boxes</primary><secondary>KDialogBase class</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KDialogBase class</tertiary></indexterm><indexterm><primary>KDialogBase class</primary></indexterm><indexterm><primary>classes</primary><secondary>KDialogBase</secondary></indexterm></para>
<para>You can deduce from <link linkend="ch08list12">Listing 8.12</link> and <link linkend="ch08fig04">Figure 8.4</link> that the dialog title string is modified before it is displayed in the window manager (WM) field. The <literal>KDialogBase</literal> class code does this according to the KDE-style-guide recommendation. The style is dependent on a global setting, which the user can change, so generally, you should not assume anything about the format of the displayed text.</para>
<note role="tip">
<para>This can be overridden for those rare cases where you need a determinable title layout. Use <literal>KDialogBase::setPlainCaption()</literal> in this case.<indexterm><primary>setPlainCaption() method</primary></indexterm><indexterm><primary>methods</primary><secondary>setPlainCaption()</secondary></indexterm></para>
</note>
<para>Note that KDE does not depend on a specific window manager. There is actually no guarantee that the active window manager will show the title (although this is by far the most common behavior). Therefore, you should not depend on the title for the dialog box function. The title is not the place to print a help string.</para>
<para>Generally, you should not be dependent on the window manager at all. It is there for convenience. Never make a dialog box that cannot be closed or hidden without using a Close button normally provided by the window manager. Most window managers in Linux/UNIX are highly configurable, and your target user may have a window manager preference that you have not anticipated. For example, the standard window manager for the KDE 1.x versions could be configured to turn off all decorations. Some people will do that.<indexterm><primary>dialog boxes</primary><secondary>KDialogBase class</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KDialogBase class</tertiary></indexterm><indexterm><primary>KDialogBase class</primary></indexterm><indexterm><primary>classes</primary><secondary>KDialogBase</secondary></indexterm></para>
</section>
<section id="ch08lev1sec6">
<title>A Larger Example: The Option Dialog in KEdit</title>
<para>This <indexterm><primary>dialog boxes</primary><secondary>KEdit Option dialog example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KEdit Option dialog example</tertiary></indexterm><indexterm><primary>KEdit</primary><secondary>Option dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>KEdit</secondary><tertiary>Option dialog box</tertiary></indexterm><indexterm><primary>Option dialog box (KEdit)</primary></indexterm>section describes a real, and quite big, dialog&mdash;the Option dialog of KEdit. It is based on the <literal>KDialogBase</literal> class used in <literal>IconList</literal> mode. <link linkend="ch08fig05">Figure 8.5</link> shows what this dialog looks like. This way of representing data is effective when you want to keep the number of dialog boxes to a minimum.</para>
<para>It may seem complicated to make such a dialog, but in fact it is very easy. As a bonus, it is also easy to add or remove a page without interfering with the rest of the code. <link linkend="ch08list13">Listing 8.13</link> shows how the dialog code is partitioned. A good technique is to deal with each page of the dialog in a separate function or even as a separate class. The first approach is used here. This way, you keep the code clean and easy to understand. The <literal>setupColorPage()</literal> method starting on Line 105 creates the color page. The method <literal>KdialogBase::addPage(&hellip;)</literal> prepares the page and returns the top level widget of the page. An icon list layout is selected by specifying <literal>IconList</literal> in the <literal>KDialogBase</literal> constructor. If you change the flag to <literal>Tabbed</literal> or <literal>IconList,</literal> the dialog will switch to a tabbed or a tree list shaped dialog respectively. This feature is especially useful when you make a dialog in <literal>Tabbed</literal> mode, but after a while realize that too many tabs are present in the dialog (the Qt library does not support multiple rows of tabs). You can then easily switch to a <literal>TreeList</literal> or <literal>IconList</literal> layout by changing only the flag. The <literal>KDialogBase</literal> class will take care of the rest; no redesign is required.<indexterm><primary>dialog boxes</primary><secondary>KEdit Option dialog example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KEdit Option dialog example</tertiary></indexterm><indexterm><primary>KEdit</primary><secondary>Option dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>KEdit</secondary><tertiary>Option dialog box</tertiary></indexterm><indexterm><primary>Option dialog box (KEdit)</primary></indexterm></para>
<figure label="8.5" id="ch08fig05">
<title>The KEdit Option dialog. The dialog is based on the <literal>KDialogBase</literal> class in <literal>IconList</literal> mode.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/08fig05.gif" format="GIF"/>
</imageobject>
</mediaobject>
</figure>
<example role="codelisting" label="8.13" id="ch08list13">
<title>The KEdit Dialog Code, Somewhat Simplified<indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>KEdit dialog code</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
  1:
  2: class COptionDialog : public KDialogBase
  3: {
  4:   Q_OBJECT
  5:
  6:   public:
  7:     enum Page
  8:     {
  9:       page_font = 0,
 10:       page_color,
 11:       page_spell,
 12:       page_misc,
 13:       page_max
 14:     };
 15:
 16:     COptionDialog( QWidget *parent = 0, char *name = 0, bool modal = false );
 17:     ~COptionDialog();
 18:
 19:     void setFont( const SFontState &amp;font );
 20:     void setColor( const SColorState &amp;color );
 21:     void setSpell( const SSpellState &amp;spell );
 22:     void setMisc( const SMiscState &amp;misc );
 23:     void setState( const SOptionState &amp;state );
 24:
 25:   public slots:
 26:
 27:     virtual void slotDefault();
 28:     virtual void slotOk();
 29:     virtual void slotApply();
 30:
 31:   private:
 32:     struct SFontWidgets
 33:     {
 34:       KFontChooser *chooser;
 35:     };
 36:
 37:     struct SColorWidgets
 38:     {
 39:       KColorButton *fgColor;
 40:       KColorButton *bgColor;
 41:     };
 42:
 43:     struct SSpellWidgets
 44:     {
 45:       KSpellConfig *config;
 46:     };
 47:
 48:     struct SMiscWidgets
 49:     {
 50:       QComboBox *wrapCombo;
 51:       QLabel    *wrapLabel;
 52:       QLineEdit *wrapInput;
 53:       QCheckBox *backupCheck;
 54:       QLineEdit *mailInput;
 55:     };
 56:
 57:   private slots:
 58:     void wrapMode( int mode );
 59:
 60:   private:
 61:     void setupFontPage();
 62:     void setupColorPage();
 63:     void setupSpellPage();
 64:     void setupMiscPage();
 65:
 66:   signals:
 67:     void fontChoice( const SFontState &amp;font );
 68:     void colorChoice( const SColorState &amp;color );
 69:     void spellChoice( const SSpellState &amp;spell );
 70:     void miscChoice( const SMiscState &amp;misc );
 71:
 72:   private:
 73:     SOptionState   mState;
 74:     SColorWidgets  mColor;
 75:     SFontWidgets   mFont;
 76:     SSpellWidgets  mSpell;
 77:     SMiscWidgets   mMisc;
 78: };
 79:
 80:
 81:
 82:
 83:
 84: COptionDialog::COptionDialog( QWidget *parent, char *name, bool modal )
 85:   :KDialogBase( Iconist, i18n("Options"), Help|Default|Apply|Ok|Cancel,
 86:          Ok, parent, name, modal, true )
 87: {
 88:   setHelp( "kedit/index.html", QString::null ); // When Help is pressed
 89:
 90:   setupFontPage();
 91:   setupColorPage();
 92:   setupSpellPage();
 93:   setupMiscPage();
 94: }
 95:
 96: COptionDialog::~COptionDialog()
 97: {
 98: }
 99:
100:
101: void
102: COptionDialog::setupFontPage()
103: {
104:   QVBox *page = addVBoxPage( i18n("Font"),
105:     i18n("Editor font" ), UserIcon("fonts") );
106:   mFont.chooser = new KFontChooser( page, "font", false, QStringList(),
107:     false, 6 );
108:   mFont.chooser->setSampleText( i18n("KEdit editor font") );
109: }
110:
111:
112: void
113: COptionDialog::setupColorPage()
114: {
115:   QFrame *page = addPage( i18n("Color"), i18n("Text color in editor area"),
116:     UserIcon("colors") );
117:   QVBoxLayout *topLayout = new QVBoxLayout( page, 0, spacingHint() );
118:   if( topLayout == 0 ) { return; }
119:
120:   QGridLayout *gbox = new QGridLayout( 2, 2 );
121:   topLayout->addLayout(gbox);
122:
123:   QLabel *label;
124:   mColor.fgColor = new KColorButton( page );
125:   mColor.bgColor = new KColorButton( page );
126:   label = new QLabel( mColor.fgColor, "Foreground color", page );
127:   label = new QLabel( mColor.bgColor, "Background color", page );
128:
129:   gbox->addWidget( label, 0, 0 );
130:   gbox->addWidget( label, 1, 0 );
131:   gbox->addWidget( mColor.fgColor, 0, 1 );
132:   gbox->addWidget( mColor.bgColor, 1, 1 );
133:
134:   topLayout->addStretch(10);
135: }
136:
137:
138: void
139: COptionDialog::setupSpellPage()
140: {
141:   QFrame *page = addPage( i18n("Spelling"), i18n("Spell checker behaviour"),
142:     SmallIcon("spell") );
143:   QVBoxLayout *topLayout = new QVBoxLayout( page, 0, spacingHint() );
144:   if( topLayout == 0 ) { return; }
145:
146:   mSpell.config = new KSpellConfig( page, "spell");
147:   topLayout->addWidget( mSpell.config );
148:
149:   topLayout->addStretch(10);
150: }
151:
152:
153: void
154: COptionDialog::setupMiscPage()
155: {
156:   QFrame *page = addPage( i18n("Miscellaneous"), i18n("Various properties"),
157:     UserIcon("misc") );
158:   QVBoxLayout *topLayout = new QVBoxLayout( page, 0, spacingHint() );
159:   if( topLayout == 0 ) { return; }
160:
161:   QGridLayout *gbox = new QGridLayout( 5, 2 );
162:   topLayout->addLayout( gbox );
163:
164:   QString text;
165:
166:   text = i18n("Word Wrap");
167:   QLabel *label = new QLabel( text, page, "wraplabel" );
168:   gbox->addWidget( label, 0, 0 );
169:   QStringList wrapList;
170:   wrapList.append( i18n("Disable wrapping") );
171:   wrapList.append( i18n("Let editor width decide") );
172:   wrapList.append( i18n("At specified column") );
173:   mMisc.wrapCombo = new QComboBox( false, page );
174:   connect(mMisc.wrapCombo,SIGNAL(activated(int)),this,SLOT (wrapMode(int)));
175:   mMisc.wrapCombo->insertStringList( wrapList );
176:   gbox->addWidget( mMisc.wrapCombo, 0, 1 );
177:
178:   text = i18n("Wrap Column");
179:   mMisc.wrapLabel = new QLabel( text, page, "wrapcolumn" );
180:   gbox->addWidget( mMisc.wrapLabel, 1, 0 );
181:   mMisc.wrapInput = new QLineEdit( page, "values" );
182:   mMisc.wrapInput->setMinimumWidth( fontMetrics().maxWidth()*10 );
183:   gbox->addWidget( mMisc.wrapInput, 1, 1 );
184:
185:   gbox->addRowSpacing( 2, spacingHint()*2 ); 
186:
187:   text = i18n("Make backup when saving a file");
188:   mMisc.backupCheck = new QCheckBox( text, page, "backup" );
189:   gbox->addMultiCellWidget( mMisc.backupCheck, 3, 3, 0, 1 );
190:
191:   mMisc.mailInput = new QLineEdit( page, "mailcmd" );
192:   mMisc.mailInput->setMinimumWidth(fontMetrics().maxWidth()*10);
193:   text = i18n("Mail Command");
194:   label = new QLabel( text, page,mailcmdlabel );
195:   gbox->addWidget( label, 4, 0 );
196:   gbox->addWidget( mMisc.mailInput, 4, 1 );
197:
198:   topLayout->addStretch(10);
199: }
200:
201:
202: void
203: COptionDialog::wrapMode( int mode )
204: {
205:   bool state = mode == 2 ? true : false;
206:   mMisc.wrapInput->setEnabled( state );
207:   mMisc.wrapLabel->setEnabled( state );
208: }
209:
210:
211: void
212: COptionDialog::slotOk()
213: {
214:   slotApply();
215:   accept();
216: }
217:
218:
219: void
220: COptionDialog::slotApply()
221: {
222:   switch( activePageIndex() )
223:   {
224:     case page_font:
225:       mState.font.font = mFont.chooser->font();
226:       emit fontChoice( mState.font );
227:     break;
228:
229:     case page_color:
230:       mState.color.textFg = mColor.fgColor->color();
231:       mState.color.textBg = mColor.bgColor->color();
232:       emit colorChoice( mState.color );
233:     break;
234:
235:     case page_spell:
236:       mState.spell.config = *mSpell.config;
237:       emit spellChoice( mState.spell );
238:     break;
239:
240:     case page_misc:
241:       mState.misc.wrapMode    = mMisc.wrapCombo->currentItem();
242:       mState.misc.backupCheck = mMisc.backupCheck->isChecked();
243:       mState.misc.wrapColumn  = mMisc.wrapInput->text().toInt();
244:       mState.misc.mailCommand = mMisc.mailInput->text();
245:       emit miscChoice( mState.misc );
246:     break;
247:   }
248: }
249:
250:
251: void
252: COptionDialog::slotDefault()
253: {
254:   //
255:   // The constructors store the default settings.
256:   //
257:   switch( activePageIndex() )
258:   {
259:     case page_font:
260:       setFont( SFontState() );
261:     break;
262:
263:     case page_color:
264:       setColor( SColorState() );
265:     break;
266:
267:     case page_spell:
268:       setSpell( SSpellState() );
269:     break;
270:
271:     case page_misc:
272:       setMisc( SMiscState() );
273:     break;
274:   }
275: }
276:
277:
278: void
279: COptionDialog::setFont( const SFontState &amp;font )
280: {
281:   mState.font = font;
282:   mFont.chooser->setFont( font.font, false );
283: }
284:
285:
286: void
287: COptionDialog::setColor( const SColorState &amp;color )
288: {
289:   mState.color = color;
290:   mColor.fgColor->setColor( color.textFg );
291:   mColor.bgColor->setColor( color.textBg );
292: }
293:
294:
295: void
296: COptionDialog::setSpell( const SSpellState &amp;spell )
297: {
298:   *mSpell.config = spell.config;
299: }
300:
301:
302: void
303: COptionDialog::setMisc( const SMiscState &amp;misc )
304: {
305:   mState.misc = misc;
306:   mMisc.wrapCombo->setCurrentItem( misc.wrapMode );
307:   mMisc.wrapInput->setText( QString().setNum(misc.wrapColumn) );
308:   mMisc.backupCheck->setChecked( misc.backupCheck );
309:   mMisc.mailInput->setText( misc.mailCommand );
310:   wrapMode( mMisc.wrapCombo->currentItem() );
311: }
312:
313:
314: void
315: COptionDialog::setState( const SOptionState &amp;state )
316: {
317:   setFont( state.font );
318:   setColor( state.color );
319:   setSpell( state.spell );
320:   setMisc( state.misc );
321: }
322:
323:
324: // The dialog used as the main application window
325: #include &amp;lt;kcmdlineargs.h>
326: int main( int argc, char **argv )
327: {
328:   KCmdLineArgs::init(argc, argv, "kedit", 0, 0);
329:   KApplication app;
330:   COptionDialog *dialog = new COptionDialog():
331:   dialog->show();
332:   int result = app.exec();
333:   return( result );
334: }<indexterm><primary>dialog boxes</primary><secondary>KEdit Option dialog example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KEdit Option dialog example</tertiary></indexterm><indexterm><primary>KEdit</primary><secondary>Option dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>KEdit</secondary><tertiary>Option dialog box</tertiary></indexterm><indexterm><primary>Option dialog box (KEdit)</primary></indexterm><indexterm><primary>listings</primary><secondary>dialog boxes</secondary><tertiary>KEdit dialog code</tertiary></indexterm>
</programlisting>
</example>
<para>In the constructor, the path to the Help file is set. If you have specified a Help button, you should make sure the help path is defined. If you do not specify a path, the PC bell will make a short alarm when the user activates the Help button. You can disable (gray out) any button by using the <literal>KDialogBase::enableButton(&hellip;)</literal> method. Notice how the <literal>spacingHint()</literal> function is used everywhere to get identical spacing as on line 117. You never have to worry again that the spacing use the same value as well.</para>
<para>The dialog has embedded a regular font selector widget in the Font page starting on line 101. This is the same widget that is used in the font selector dialog. By doing it this way, the user has one less dialog to remember while the familiar font selector interface remains intact but embedded into a larger dialog. The interface becomes easier to understand and remember.</para>
<para>The kind of dialog boxes that contain many settings should always include a Default button. When activated, this button resets the dialog settings of the displayed page to the default hard-coded settings. By having this kind of feature, you will get more satisfied users. Many people are reluctant to try the available options because they are afraid to <quote>destroy</quote> the program. By providing a way to reset any settings to a known state, this fear will often vanish.<indexterm><primary>dialog boxes</primary><secondary>KEdit Option dialog example</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>KEdit Option dialog example</tertiary></indexterm><indexterm><primary>KEdit</primary><secondary>Option dialog box</secondary></indexterm><indexterm><primary>classes</primary><secondary>KEdit</secondary><tertiary>Option dialog box</tertiary></indexterm><indexterm><primary>Option dialog box (KEdit)</primary></indexterm></para>
</section>
<section id="ch08lev1sec7">
<title>User Interface Design Rules for Dialogs</title>
<para>When <indexterm><primary>dialog boxes</primary><secondary>design guidelines</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>design guidelines</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>design guidelines</tertiary></indexterm><indexterm><primary>design guidelines</primary><secondary>dialog boxes</secondary></indexterm>you are going to design a dialog, you should follow several rules to obtain a successful result. Some rules are listed next:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Never make the dialog contents so large that you need scrollbars to manage it. You can always partition the contents into pages of a tabbed dialog or other paged dialog types. This does not exclude lists and editor widgets inside a dialog. These components need scrollbars, but never make a dialog with 100 pushbuttons.</para></listitem>
<listitem><para>Never make a menu or a toolbar in the dialog. Menus and toolbars belong to the top level program window. The dialog should be as simple as possible and contain only action buttons (for example, OK, Cancel, Apply) that do something with the selected setting of a dialog.</para></listitem>
<listitem><para>Use existing widgets whenever possible when you design a dialog. Remember that users need to spend time learning a new interface. You should not make their task more difficult. Most likely, they are already familiar with standard graphical user-interface components and know what to expect from them.</para></listitem>
<listitem><para>Make the interface as simple as possible. Collect related widgets inside a rectangular frame with a title, or use a horizontal or vertical line to indicate what belongs to what. Never use too many frames or lines. Placing every widget in a dialog inside one big frame makes no sense; rather, it just wastes screen real estate.</para></listitem>
<listitem><para>Avoid using colors to indicate a state or a setting. Using text instead is almost always a better solution (assuming that your target users can read). Colors can have different meanings in different cultures and some people even lack the ability to differentiate between certain colors, such as green and red. Do not exclude those users from your potential user base. Stop is better than red.</para></listitem>
</itemizedlist>
<para>If you are interested in more information on how to do it right and how to do it wrong, visit the <indexterm><primary>Interface Hall of Shame Web site</primary></indexterm><indexterm><primary>Web sites</primary><secondary>Interface Hall of Shame</secondary></indexterm>Interface Hall of Shame on the Web, <ulink url="http://www.iarchitect.com/mshame.htm">http://www.iarchitect.com/mshame.htm</ulink>, and learn from mistakes other developers have already made. You don't have to reinvent others' mistakes.<indexterm><primary>dialog boxes</primary><secondary>design guidelines</secondary></indexterm><indexterm><primary>GUIs</primary><secondary>dialog boxes</secondary><tertiary>design guidelines</tertiary></indexterm><indexterm><primary>layout</primary><secondary>dialog boxes</secondary><tertiary>design guidelines</tertiary></indexterm><indexterm><primary>design guidelines</primary><secondary>dialog boxes</secondary></indexterm></para>
</section>
<section id="ch08lev1sec8">
<title>Summary</title>
<para>The KDialogBase dialog class will simplify and speed up your work when you design dialogs. The class supports common dialog layouts such as a tabbed, icon list and tree list shapes as well a blank (or empty) shape that you can use for whatever you need.</para>
<para>Try to make a dialog modeless if you think this will make the work simpler for the user. It can be a bit harder to implement a modeless dialog but you should always care about your user first. Some dialogs, such as a file selector can be modal.</para>
<para>The KDE user interface library (kdeui) contains a number of ready to use dialogs and widgets. Use them! Your users expect to see familiar dialogs for standard tasks such as selecting a font. Use the freely available source code. Look at other programs and don't be shy about copying the code fragments that fit you needs, as long as you do what the license of that programs tells you to do and you credit their authors. But, to make good dialogs, you must nevertheless try to understand why and how. Non optimal solutions, errors, and potential bugs are located more easily this way.</para>
</section>
<section id="ch08lev1sec9">
<title>Exercises</title>
<para>See <link linkend="ap-c">Appendix C, <quote>Answers</quote></link>, for the exercise answers.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch08que01"><para><link linkend="ch08ans01">Make a dialog box that can be used to compose and send an email message. The dialog box must contain vertically aligned <quote>From:</quote>, <quote>To:</quote>, <quote>Cc:</quote>, and <quote>Subject:</quote> labels each with a line edit widget to the right. The line edit widgets shall be able to display at least 20 characters regardless of the font size. Beneath the labels, add a multiline edit widget that uses the rest of the available space in the dialog box. The dialog box should have the following action buttons at the bottom: Address&Prime;, <quote>Send</quote>, and <quote>Cancel</quote></link>.</para></question>
</qandaentry>
<qandaentry>
<question id="ch08que02"><para><link linkend="ch08ans02">Change the dialog box so that it no longer contains the <quote>Address</quote> action button. Add a <quote>Help</quote> button instead. Add pushbuttons labeled <quote>Choose&hellip;</quote> to the right of the line edit widgets belonging to the <quote>To:</quote> and <quote>Cc:</quote> fields</link>.</para></question>
</qandaentry>
</qandaset>
</section>
</chapter>
