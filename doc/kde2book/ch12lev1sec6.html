<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Making a Part Available Using Shared Libraries</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="Creating and Using Components (KParts)"
HREF="ch12.html"/><LINK
REL="PREVIOUS"
TITLE="Creating a Part"
HREF="ch12lev1sec5.html"/><LINK
REL="NEXT"
TITLE="Creating a KParts Application"
HREF="ch12lev1sec7.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch12lev1sec5.html"
>Prev</A
> <A
HREF="ch12lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch12lev1sec6"
>12.6. Making a Part Available Using Shared Libraries</A
></H1
><P
>You 
			
			
			know how to create a part now. But currently, it can be used only by linking directly to its code. Although this is enough in some cases, such as KWrite's part embedded by KWrite itself, it is much more flexible to provide dynamic linking to the library containing the part. This is not directly related to <TT
CLASS="literal"
>KParts</TT
>, but it is necessary to make it possible for any application to use the part.</P
><P
>The first step is to compile the part in a shared library, which is really simple using <TT
CLASS="literal"
>automake</TT
>. The relevant portion of Makefile.am is shown in <A
HREF="ch12lev1sec6.html#ch12list08"
>Listing 12.8</A
>
			
			
			
			
		</P
><DIV
CLASS="example"
><HR/><A
NAME="ch12list08"
></A
><P
><B
>Example 12.8. Extract from <TT
CLASS="literal"
>Makefile.am
					
					
					
					
				</TT
>
			</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;lib_LTLIBRARIES = libnotepad.la
   3&nbsp;libnotepad_la_SOURCES = notepad_part.cpp notepad_factory.cpp
   4&nbsp;libnotepad_la_LIBADD = $(LIB_KFILE) $(LIB_KPARTS)
   5&nbsp;libnotepad_la_LDFLAGS = $(all_libraries) $(KDE_PLUGIN)
   6&nbsp;METASOURCES = AUTO
   7&nbsp;				
   8&nbsp;				
   9&nbsp;				
  10&nbsp;			</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>Your part is now available in a shared library, but this is not enough. You must provide a way for anybody opening that library dynamically to create a part. This is done using a factory, derived from KLibFactory, which you'll do in the class <TT
CLASS="literal"
>NotepadFactory</TT
>. An application willing to open a shared library dynamically uses the class <TT
CLASS="literal"
>KLibLoader</TT
>, which takes care of locating the library, opening it, and calling an initialization function&#8212;here <TT
CLASS="literal"
>init_libnotepad()</TT
>. This function creates a <TT
CLASS="literal"
>NotepadFactory</TT
> and returns it to <TT
CLASS="literal"
>KLibLoader</TT
>, which can then call the <TT
CLASS="literal"
>create</TT
> method on the factory. This means that all you need to do in the library itself is define <TT
CLASS="literal"
>init_libnotepad()</TT
> and the <TT
CLASS="literal"
>NotepadFactory</TT
>.</P
><P
>The header for the factory is the one shown in <A
HREF="ch12lev1sec6.html#ch12list09"
>Listing 12.9</A
>.
			
			
			
			
			
			
		</P
><DIV
CLASS="example"
><HR/><A
NAME="ch12list09"
></A
><P
><B
>Example 12.9. notepad_factory.h: Header File for NotepadFactory
				
				
				
				
			</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; 1: #include &lt;klibloader.h&gt;
   3&nbsp; 2: class KInstance;
   4&nbsp; 3: class KAboutData;
   5&nbsp; 4: class NotepadFactory: public KLibFactory
   6&nbsp; 5: {
   7&nbsp; 6:   Q_OBJECT
   8&nbsp; 7: public:
   9&nbsp; 8:   NotepadFactory( QObject * parent = 0, const char * name = 0 );
  10&nbsp; 9:   ~NotepadFactory();
  11&nbsp;10:
  12&nbsp;11:   // reimplemented from KLibFactory
  13&nbsp;12:   virtual QObject * create( QObject * parent = 0, const char * name = 0,
  14&nbsp;13:         const char * classname = "QObject",
  15&nbsp;14:         const QStringList &amp;args = QStringList());
  16&nbsp;15:
  17&nbsp;16:   static KInstance * instance();
  18&nbsp;17:
  19&nbsp;18: private:
  20&nbsp;19:  static KInstance * s_instance;
  21&nbsp;20:  static KAboutData * s_about;
  22&nbsp;21: };
  23&nbsp;				
  24&nbsp;				
  25&nbsp;				
  26&nbsp;				
  27&nbsp;			</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>As required by KLibFactory, your factory implements the <TT
CLASS="literal"
>create</TT
> method, which creates a <TT
CLASS="literal"
>Notepad</TT
> part and sets it to read/write mode or read-only mode, depending on whether the <TT
CLASS="literal"
>classname</TT
> is <TT
CLASS="literal"
>KParts::ReadWritePart</TT
> or <TT
CLASS="literal"
>KParts::ReadOnlyPart</TT
>.
			
			
			
			
			
			
		</P
><P
>It also features a static instance, which is used in the part, instead of creating your own instance for each part. It is static because usually there is only one instance per library.</P
><P
>This means the code of <TT
CLASS="literal"
>notepad_part.cpp</TT
> should be modified to call <TT
CLASS="literal"
>setInstance( NotepadFactory::instance() );</TT
> instead of creating its own instance.</P
><P
>The implementation for the NotepadFactory is shown in <A
HREF="ch12lev1sec6.html#ch12list10"
>Listing 12.10</A
>.
			
			
			
			
			
			
		</P
><DIV
CLASS="example"
><HR/><A
NAME="ch12list10"
></A
><P
><B
>Example 12.10. notepad_factory.cpp: NotepadFactory Implementation
				
				
				
				
			</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp; 1: #include "notepad_factory.h"
   3&nbsp; 2:
   4&nbsp; 3: #include &lt;klocale.h&gt;
   5&nbsp; 4: #include &lt;kstddirs.h&gt;
   6&nbsp; 5: #include &lt;kinstance.h&gt;
   7&nbsp; 6: #include &lt;kaboutdata.h&gt;
   8&nbsp; 7:
   9&nbsp; 8: #include "notepad_part.h"
  10&nbsp; 9:
  11&nbsp;10: extern "C"
  12&nbsp;11: {
  13&nbsp;12:     void* init_libnotepad()
  14&nbsp;13:     {
  15&nbsp;14:     return new NotepadFactory;
  16&nbsp;15:     }
  17&nbsp;16: };
  18&nbsp;17:
  19&nbsp;18: KInstance* NotepadFactory::s_instance = 0L;
  20&nbsp;19: KAboutData* NotepadFactory::s_about = 0L;
  21&nbsp;20:
  22&nbsp;21: NotepadFactory::NotepadFactory( QObject* parent, const char* name )
  23&nbsp;22:     : KLibFactory( parent, name )
  24&nbsp;23: {
  25&nbsp;24: }
  26&nbsp;				
  27&nbsp;				
  28&nbsp;				
  29&nbsp;				
  30&nbsp;				
  31&nbsp;				
  32&nbsp;				
  33&nbsp;				
  34&nbsp;				
  35&nbsp;				
  36&nbsp;				
  37&nbsp;25:
  38&nbsp;26: NotepadFactory::~NotepadFactory()
  39&nbsp;27: {
  40&nbsp;28:   delete s_instance;
  41&nbsp;29:   s_instance = 0L;
  42&nbsp;30:   delete s_about;
  43&nbsp;31: }
  44&nbsp;32:
  45&nbsp;33: QObject* NotepadFactory::create( QObject* parent, const char* name,
  46&nbsp;34:                                 const char* classname, const QStringList&amp;)
  47&nbsp;35: {
  48&nbsp;36:   if ( parent &amp;&amp;!parent-&gt;inherits("QWidget") )
  49&nbsp;37:   {
  50&nbsp;38:     kdError() &lt;&lt; "NotepadFactory: parent does not inherit QWidget" &lt;&lt; endl;
  51&nbsp;39:     return 0L;
  52&nbsp;40:   }
  53&nbsp;41:
  54&nbsp;42:   NotepadPart* part = new NotepadPart( (QWidget*) parent, name );
  55&nbsp;43:   // readonly ?
  56&nbsp;44:   if (QCString(classname) == "KParts::ReadOnlyPart")
  57&nbsp;45:      part-&gt;setReadWrite(false);
  58&nbsp;46:
  59&nbsp;47:   // otherwise, it has to be readwrite
  60&nbsp;48:   else if (QCString(classname) != "KParts::ReadWritePart")
  61&nbsp;49:   {
  62&nbsp;50:     kdError() &lt;&lt; "classname isn't ReadOnlyPart nor ReadWritePart !" &lt;&lt; endl;
  63&nbsp;51:     return 0L;
  64&nbsp;52:   }
  65&nbsp;53:
  66&nbsp;54:   emit objectCreated( part );
  67&nbsp;55:   return part;
  68&nbsp;56: }
  69&nbsp;57:
  70&nbsp;58: KInstance* NotepadFactory::instance()
  71&nbsp;59: {
  72&nbsp;60:   if( !s_instance )
  73&nbsp;61:   {
  74&nbsp;62:     s_about = new KAboutData( "notepadpart",
  75&nbsp;63:                               I18N_NOOP( "Notepad" ), "2.0pre" );
  76&nbsp;64:     s_instance = new KInstance( s_about );
  77&nbsp;65:   }
  78&nbsp;66:   return s_instance;
  79&nbsp;67: }
  80&nbsp;68:
  81&nbsp;69: #include "notepad_factory.moc"
  82&nbsp;				
  83&nbsp;				
  84&nbsp;				
  85&nbsp;				
  86&nbsp;				
  87&nbsp;				
  88&nbsp;				
  89&nbsp;				
  90&nbsp;				
  91&nbsp;				
  92&nbsp;				
  93&nbsp;			</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The implementation is a bit long but contains nothing complex. Basically, you define the function that is the entry point of the library, <TT
CLASS="literal"
>init_libnotepad()</TT
>. It needs to be linked as a C function to avoid C++ name mangling. C linkage means that the symbol in the library will match the function name.</P
><P
>Then you define the <TT
CLASS="literal"
>NotepadFactory</TT
>. The <TT
CLASS="literal"
>create</TT
> method checks that the parent is a widget because this is needed for your part (remember, you create your widget with the parent widget given as an argument to the constructor). After creating the part, it has to emit <TT
CLASS="literal"
>objectCreated</TT
> so that the library loader can do a proper reference counting; it automatically unloads the library after all objects created from it have been destroyed.</P
><P
>The <TT
CLASS="literal"
>instance()</TT
> method returns the static instance, creating it first, if necessary. To create an instance, I recommend that you give it a <TT
CLASS="literal"
>KAboutData</TT
> pointer. This gives some information about the instance representing the library (here an instance name, a translatable description of it, and a version number). You can add a lot more information in the <TT
CLASS="literal"
>KAboutData</TT
> object, such as authors, home page, and bug-report address. See the documentation for details.</P
><P
>The standard KDE dialogs such as the Bug Report Dialog and the About Dialog use the data stored in <TT
CLASS="literal"
>KAboutData</TT
> to show information about the current program, but in the future they will probably be improved to show information about the active part as well, which can have completely different About data from the application.</P
><DIV
CLASS="note"
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="note.png"
HSPACE="5"
ALT="Note"/></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>KParts provides a factory base class, <TT
CLASS="literal"
>KParts::Factory</TT
>, which enhances KlibFactory by making it possible to have a parent for the widget different from the parent for the part. It also takes care of loading the translation message catalog for the newly created part. Look in kparts/factory.h for more on this.</P
></TD
></TR
></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch12lev1sec6"/></TD
></TR
><ANNOTATION
NAME="ch12lev1sec6"
TITLE="Making a Part Available Using Shared Libraries"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch12lev1sec5.html"
>Prev</A
> <A
HREF="ch12lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>