<chapter label="2" role="chapter" id="ch02">
<title>A Simple KDE Application</title>
<para><emphasis>by David Sweet</emphasis></para>
<highlights>
<itemizedlist mark="bullet" spacing="compact">
<title>In This Chapter</title>
<listitem><para><link linkend="ch02lev1sec1"><emphasis role="strong">The Linux/UNIX Programmer's Desktop</emphasis></link></para></listitem>
<listitem><para><link linkend="ch02lev1sec2"><emphasis role="strong">Compiling a KDE Program</emphasis></link></para></listitem>
<listitem><para><link linkend="ch02lev1sec3"><emphasis role="strong">KDE Application Structure</emphasis></link></para></listitem>
<listitem><para><link linkend="ch02lev1sec4"><emphasis role="strong">GUI Elements</emphasis></link></para></listitem>
<listitem><para><link linkend="ch02lev1sec5"><emphasis role="strong">Programming Conventions</emphasis></link></para></listitem>
</itemizedlist>
</highlights>
<para>The<indexterm><primary>programs</primary></indexterm> goal of the KDE project is to create a set of desktop applications that share a common user interface. To this end, the KDE developers have created a set of C++ classes that help you get the KDE look and feel with minimal effort. You create a KDE-style application by deriving the KDE class <literal>KTMainWindow</literal> and using the event loop (discussed in <link linkend="ch03">Chapter 3, <quote>The Qt Toolkit</quote></link>) in the class <literal>KApplication</literal>. These classes will handle look-and-feel issues that are common to most KDE applications, leaving you free to focus on programming the tasks unique to your application.</para>
<section id="ch02lev1sec1">
<title>The Linux/UNIX Programmer's Desktop</title>
<para>Now <indexterm><primary>programs</primary></indexterm>is a good time to collect the tools you will need for developing KDE software. At the very least, you need an editor to edit your source code and a way to access the C++ compiler. Optionally, you may also want to use a debugger to make the debugging of your code more efficient.</para>
<section id="ch02lev2sec1">
<title>Necessities for Editing Code</title>
<para>Several<indexterm><primary>programs</primary><secondary>text editors</secondary></indexterm><indexterm><primary>editors</primary></indexterm><indexterm><primary>text editors</primary></indexterm> editors are available for Linux/UNIX systems. Two popular ones are vi and emacs. If you are familiar with UNIX, you will be familiar with these programs. For those of you who are new to UNIX: vi<indexterm><primary>vi editor</primary></indexterm> is a simple text editor with a unique, sometimes difficult, interface. It would not be familiar if you are used to a Macintosh- or Windows-based source-code editor. <indexterm><primary>emacs editor</primary></indexterm>emacs is somewhat more familiar and has a very powerful LISP-based macro language.</para>
<para>If you want a more modern-feeling editor, you could try kfte or kwrite. <indexterm><primary>kfte editor</primary></indexterm>kfte is a full-fledged source-code editor. <indexterm><primary>kwrite editor</primary></indexterm>kwrite is a simpler, general text editor, but it does provide a key-mapping more familiar to Macintosh/Windows users and syntax highlighting for C++ (as well as for other file types).</para>
<para>The KDE taskbar is very helpful in a bare-bones programming environment such as I am describing here. If you are editing several source-code files at once (and in separate windows) the title of each window is listed in the taskbar. Clicking that taskbar button opens and/or raises that window and gives it the focus.</para>
<para>To make the taskbar a little more useful, you should set the title of your window to be the name of the file you are editing. If you are using emacs, for example, you can type <emphasis role="strong"><literal>emacs filename -T title</literal></emphasis> to set the title of the emacs window (see <link linkend="ch02fig01">Figure 2.1</link>). kwrite and kfte set their window titles automatically.<indexterm><primary>programs</primary><secondary>text editors</secondary></indexterm><indexterm><primary>editors</primary></indexterm><indexterm><primary>text editors</primary></indexterm></para>
<figure label="2.1" id="ch02fig01">
<title>It is helpful to have an editor display the filename first in the caption.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig01.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
</section>
<section id="ch02lev2sec2">
<title>Debuggers Available for Linux</title>
<para>The <indexterm><primary>debuggers</primary></indexterm><indexterm><primary>programs</primary><secondary>debuggers</secondary></indexterm>debugger that is probably already installed on your system is called gdb<indexterm><primary>gdb (GNU debugger)</primary></indexterm><indexterm><primary>GNU debugger (gdb)</primary></indexterm>, the GNU debugger. It is a command-line based utility that allows you to set breakpoints, step through programs, and view the contents of program variables.</para>
<para>GUI debuggers are also available. kdbg<indexterm><primary>kdgb debugger</primary></indexterm> is a KDE front end to gdb. It gives a friendly, intuitive interface to gdb, which makes learning the tool much easier. It is available from <ulink url="http://members.telecom.at/johsixt/kdbg.html">http://members.telecom.at/johsixt/kdbg.html</ulink>. Another GUI debugger, although not KDE-based, is DDD.<indexterm><primary>DDD debugger</primary></indexterm> It is known for its capability to display program data in graphical format, including trees and plots of array data. It is available from <ulink url="http://www.cs.tu-bs.de/softech/ddd/">http://www.cs.tu-bs.de/softech/ddd/</ulink>.<indexterm><primary>debuggers</primary></indexterm><indexterm><primary>programs</primary><secondary>debuggers</secondary></indexterm></para>
</section>
</section>
<section id="ch02lev1sec2">
<title>Compiling a KDE Program</title>
<para>I am <indexterm><primary>programs</primary><secondary>compiling</secondary></indexterm><indexterm><primary>compiling programs</primary></indexterm>discussing compiling early on so that you may begin programming immediately. I hope that you will key in the source code that is presented, compile it, and play with it as you read. (You can also download the source code from the web site, but typing it in yourself will help familiarize you with class names and conventions that you may miss even in a careful reading.) The concepts that are presented will be clearer to you if you are programming them while you read.</para>
<para>The source code presented in <link linkend="ch02list01">Listing 2.1</link> is an example of a C++ program that depends on the KDE and Qt libraries. <literal>khello</literal> is a simple application that says <quote>Hello!</quote><indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>example</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>example</secondary></indexterm><indexterm><primary>khello program</primary><secondary>compiling</secondary></indexterm></para>
<example role="codelisting" label="2.1" id="ch02list01">
<title><literal>khello</literal> is a Simple KDE Application that Says <quote>Hello!</quote><indexterm><primary>listings</primary><secondary>khello program</secondary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qstring.h>
 2: #include &lt;kapp.h>
 3: #include &lt;klined.h>
 4:
 5: int main (int argc, char *argv[])
 6: {
 7: KApplication khello (argc, argv, "khello");
 8: KLineEdit *helloeditor = new KLineEdit (0);
 9: QString hellostring ("Hello!");
10: helloeditor->setText (hellostring);
11: helloeditor->show();
12:
13: khello.setMainWidget (helloeditor);
14: return khello.exec();<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>example</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>example</secondary></indexterm><indexterm><primary>khello program</primary><secondary>compiling</secondary></indexterm></programlisting>
</example>
<para>To compile this code, you first need to set the environment variables<indexterm><primary>KDEDIR environment variable</primary></indexterm><indexterm><primary>environment variables</primary><secondary>KDEDIR</secondary></indexterm><indexterm><primary>variables</primary><secondary>environment variables</secondary><tertiary>KDEDIR</tertiary></indexterm> <literal>KDEDIR</literal> and <literal>QTDIR</literal>. <literal>KDEDIR</literal> should be set to the path where KDE was installed. This is usually /opt/kde, but it is /usr on a Red Hat 6.x system. <indexterm><primary>QTDIR environment variable</primary></indexterm><indexterm><primary>environment variables</primary><secondary>QTDIR</secondary></indexterm><indexterm><primary>variables</primary><secondary>environment variables</secondary><tertiary>QTDIR</tertiary></indexterm><literal>QTDIR</literal> may be /usr/local/lib, /usr/lib, or some other directory. The command to set environment variables differs from shell to shell. If you are using <literal>bash</literal>, for example, type</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">QTDIR=/usr/local/lib</emphasis>
<emphasis role="strong">KDEDIR=/opt/kde</emphasis></programlisting>
</informalexample>
<para>If you are using <literal>tcsh</literal>, type</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">setenv QTDIR /usr/local/lib</emphasis>
<emphasis role="strong">setenv KDEDIR /opt/kde</emphasis>
</programlisting>
</informalexample>
<para>On typical systems, the command to compile the source code given in <link linkend="ch02list01">Listing 2.1</link> is</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++  khello.cpp -I$KDEDIR/include -I$QTDIR/include</emphasis>
&middot;      <emphasis role="strong">L$KDEDIR/lib -L$QTDIR/lib -lkdeui -lkdecore -ldl -lqt</emphasis>
</programlisting>
</informalexample>
<para>On<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>g++ compiler</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>g++ compiler</secondary></indexterm><indexterm><primary>g++ compiler</primary></indexterm> a Red Hat 6.x system, the Qt header files are in /usr/include/qt, and the libraries are in /usr/lib, which is checked by g++ by default. You should compile the program using the following command on a Red Hat 6.x system:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++  khello.cpp -I$KDEDIR/include</emphasis>
&middot;       <emphasis role="strong">I/usr/include/qt -L$KDEDIR/lib -lkdeui -lkdecore -ldl -lqt</emphasis>
</programlisting>
</informalexample>
<para>The compiler is the GNU C++ compiler, g++. khello.cpp is the name of the source-code file. <link linkend="ch02list01">Listing 2.1</link> shows that khello.cpp includes header files from the Qt (qlabel.h) and KDE (kapp.h and klined.h) library distributions.</para>
<para>The <literal>-I</literal> option tells g++ in what directory to look for header files. The <literal>-L</literal> option tells where, in addition to standard directories, to look for libraries.</para>
<informalexample>
<programlisting linenumbering="unnumbered">
<emphasis role="strong">g++  khello.cpp -I$KDEDIR/include -I$QTDIR/include</emphasis>
       <emphasis role="strong">L$KDEDIR/lib -L$QTDIR/lib -lkdecore &ndash;lkdeui</emphasis>
</programlisting>
</informalexample>
<para>khello uses classes from the Qt library and from the KDE libraries libkdecore and libkdeui. The <literal>-l</literal> option specifies which libraries (in addition to default libraries, such as libc) to link to khello.</para>
<para>khello is shown in <link linkend="ch02fig02">Figure 2.2</link>. Its window contains only a line editor with the text <quote>Hello!</quote> in it. You can edit the text and click the close button (the X in the upper-right corner of the window) when you are through.<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>g++ compiler</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>g++ compiler</secondary></indexterm><indexterm><primary>g++ compiler</primary></indexterm></para>
<figure label="2.2" id="ch02fig02">
<title>khello is a simple KDE application that says <quote>Hello!</quote></title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig02.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<section id="ch02lev2sec3">
<title>Using <literal>make</literal></title>
<para>The<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>make utility</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>make utility</secondary></indexterm><indexterm><primary>make utility</primary></indexterm><indexterm><primary>utilities</primary><secondary>make</secondary></indexterm> development process usually consists of the following steps:</para>
<orderedlist numeration="arabic" continuation="restarts" spacing="compact">
<listitem><para>Edit the source code.</para></listitem>
<listitem><para>Compile it.</para></listitem>
<listitem><para>Test the program.</para></listitem></orderedlist>
<para>To minimize the overhead involved in compilation&mdash;especially on large projects&mdash;you can use the <literal>make</literal> utility. <literal>make</literal> will</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Execute compilation commands, which can often be much longer than the one presented previously.</para></listitem>
<listitem><para>Compile only the files that need recompiling. This can save a lot of time when a project consists of more than one file.</para></listitem></itemizedlist>
<para>By examining source files, <literal>make</literal> determines which files need recompiling; it checks whether the source files are newer than the object files that they get compiled to and whether the file depends on other files (such as header files) that have been updated. The drawback to using <literal>make</literal> is that it takes time to describe how the files in your project depend on each other. To see why this is necessary, consider a project that has a source file called mysource.cpp, which <literal>#includes</literal> a header called myheader.h. If you change mysource.cpp, you want it to be recompiled the next time you execute <literal>make</literal>. You also want it recompiled if you make any changes to myheader.h, because ultimately, myheader.h becomes part of mysource.cpp. You will see in <link linkend="ch16">Chapter 16, <quote>Packaging and Distributing Code,</quote></link> how the standard KDE packaging automates the process of creating a <literal>Makefile</literal>.<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>make utility</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>make utility</secondary></indexterm><indexterm><primary>make utility</primary></indexterm><indexterm><primary>utilities</primary><secondary>make</secondary></indexterm></para>
<para>Listing<indexterm><primary>Makefiles</primary></indexterm><indexterm><primary>files</primary><secondary>Makefiles</secondary></indexterm> 2.2 gives the <literal>Makefile</literal> used for compiling Listings 2.3&ndash;2.5. This listings are the source code KSimpleApp, a simple KDE application. You should place all four of these files in the same directory and type <emphasis role="strong"><literal>make</literal></emphasis> to compile the code and create an executable named <literal>ksimpleapp</literal>. When keying in the <literal>Makefile</literal>, you need to set the variables <literal>QTINC</literal>, <literal>KDEINC</literal>, <literal>QTLIB</literal>, and <literal>KDELIB</literal> to their correct values. Sample assignments of these variables are given in <link linkend="ch02list02">Listing 2.2</link>, lines 1&ndash;4.Variable assignment in makefiles works the same as you might have guessed from looking at <link linkend="ch02list02">Listing 2.2</link>:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
VARIABLE = <emphasis>value</emphasis>
</programlisting>
</informalexample>
<para>For more information about <literal>make</literal>, see the man page (i.e., type <emphasis role="strong"><literal>man make</literal></emphasis>).<indexterm><primary>programs</primary><secondary>compiling</secondary><tertiary>make utility</tertiary></indexterm><indexterm><primary>compiling programs</primary><secondary>make utility</secondary></indexterm><indexterm><primary>make utility</primary></indexterm><indexterm><primary>utilities</primary><secondary>make</secondary></indexterm></para>
<para>From this point in the book, I won't present any more <literal>Makefiles</literal>. You can adapt this <literal>Makefile</literal> to compile later source code, or find prepared <literal>Makefiles</literal> with the source code on the World Wide Web support site.</para>
<example role="codelisting" label="2.2" id="ch02list02">
<title>The <literal>Makefile</literal> Used as Input to the <literal>make</literal> Utility to Compile Listings 2.3&ndash;2.5<indexterm><primary>Makefiles</primary><secondary>example of</secondary></indexterm><indexterm><primary>files</primary><secondary>Makefiles</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>listings</primary><secondary>Makefiles</secondary><tertiary>example of</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: QTINC = -I$(QTDIR)/include
 2: KDEINC = -I$(KDEDIR)/include
 3: QTLIB = -L$(QTDIR)/lib
 4: KDELIB = -L$(KDEDIR)/lib
 5: QTBIN = $(QTDIR)/bin
 6:
 7:  ksimpleapp : ksimpleapp.o main.o
 8:     g++ $(QTLIB) $(KDELIB) -lkdeui -lkdecore -lqt -ldl \
         main.o ksimpleapp.o -o ksimpleapp
 9:
10:  main.o : main.cpp
11:    g++ -c $(QTINC) $(KDEINC) main.cpp
12:
13:  ksimpleapp.moc : ksimpleapp.h
14:  $(QTBIN)/moc ksimpleapp.h > ksimpleapp.moc
15:
16:  ksimpleapp.o : ksimpleapp.cpp ksimpleapp.moc
17:    g++ -c $(QTINC) $(KDEINC) ksimpleapp.cpp<indexterm><primary>Makefiles</primary><secondary>example of</secondary></indexterm><indexterm><primary>files</primary><secondary>Makefiles</secondary><tertiary>example of</tertiary></indexterm><indexterm><primary>listings</primary><secondary>Makefiles</secondary><tertiary>example of</tertiary></indexterm></programlisting>
</example>
</section>
</section>
<section id="ch02lev1sec3">
<title>KDE Application Structure</title>
<para>The<indexterm><primary>programs</primary><secondary>structure of</secondary></indexterm><indexterm><primary>applications</primary><see>programs</see></indexterm> structure of a typical KDE application is shown in <link linkend="ch02fig03">Figure 2.3</link>. <literal>KApplication</literal> is a class that provides low-level KDE application services, and <literal>KTMainWindow</literal> serves as a programmer-friendly base class for your main application window, <literal>KMyMainWindow</literal>. The classes <literal>KMenuBar</literal>, <literal>KToolBar</literal>, and <literal>KStatusBar</literal> are created, positioned, and resized by <literal>KTMainWindow</literal>, but you customize them from within <literal>KMyMainWindow</literal>. Many possibilities exist for the form of <literal>KMyContent</literal>. This widget is positioned and resized by <literal>KTMainWindow</literal> and otherwise maintained by <literal>KMyMainWindow</literal>. All these widgets ultimately interact with the user through the class <literal>KApplication</literal>. <literal>KApplication</literal> dispatches event messages that signal, for example, keypresses or mouse clicks to all the widgets used by an application.<indexterm><primary>programs</primary><secondary>structure of</secondary></indexterm></para>
<figure label="2.3" id="ch02fig03">
<title>You derive your application from <literal>KTMainWindow</literal>, shown here as KMyMainWindow, and add a menubar, a toolbar, a status line, and a widget of your choice (or creation) for the content area.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig03.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<section id="ch02lev2sec4">
<title><literal>KApplication</literal></title>
<para><literal>KApplication</literal> <indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>KApplication class</tertiary></indexterm><indexterm><primary>KApplication class</primary></indexterm><indexterm><primary>classes</primary><secondary>KApplication</secondary></indexterm>receives messages from X, the underlying windowing system, and distributes them to the widgets in your application. It gives access to fonts, desktop style options, and processes some KDE-standard command line options. It also provides access to the session-management features of KWin, although you generally do not need to use these because <literal>KTMainWindow</literal> offers a higher-level session management API.</para>
</section>
<section id="ch02lev2sec5">
<title><literal>KTMainWindow</literal></title>
<para>Listings<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>KTMainWindow class</tertiary></indexterm><indexterm><primary>KTMainWindow class</primary></indexterm><indexterm><primary>classes</primary><secondary>KTMainWindow</secondary></indexterm> 2.3&ndash;2.5 present a simple KDE application: KSimpleApp.</para>
<example role="codelisting" label="2.3" id="ch02list03">
<title>ksimpleapp.h: The Class Declaration File for <literal>KSimpleApp</literal>, the Main Widget of the Application <literal>ksimpleapp</literal><indexterm><primary>KSimpleApp program</primary><secondary>ksimpleapp.h class declaration</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KSimpleApp example</tertiary></indexterm><indexterm><primary>ksimpleapp.h class declaration (KSimpleApp program)</primary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>ksimpleapp.h class declaration</tertiary></indexterm><indexterm><primary>class declarations</primary><see>declaring widget classes</see></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;ktmainwindow.h>
 2:
 3: class QLabel;
 4:
 5: /**
 6:  * This is a simple KDE application.
 7:  *
 8:  * @author David Sweet &lt;dsweet@kde.org>
 9:  **/
10: class KSimpleApp : public KTMainWindow
11: {
12:  Q_OBJECT
13:
14:  public:
15:   /**
16:    * Create the widget.
17:    **/
18:   KSimpleApp (const char *name=0);
19:
20:   public slots:
21:     /**
22:      * Reposition the text in the context area.  The user will
23:      *  cycle through:  left, center, and right.
24:      **/
25:     void slotRepositionText();
26:
27:  private:
28:   QLabel *text;
29:   int alignment [3], indexalignment;
30: };<indexterm><primary>KSimpleApp program</primary><secondary>ksimpleapp.h class declaration</secondary></indexterm><indexterm><primary>declaring</primary><secondary>widget classes</secondary><tertiary>KSimpleApp example</tertiary></indexterm><indexterm><primary>ksimpleapp.h class declaration (KSimpleApp program)</primary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>ksimpleapp.h class declaration</tertiary></indexterm></programlisting>
</example>
<para>The file ksimpleapp.h contains the class declaration for the class <literal>KSimpleApp</literal>. This class is the equivalent of <literal>KMyMainWindow</literal> in <link linkend="ch02fig03">Figure 2.3</link> and thus is derived from <literal>KTMainWindow</literal>.<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>KTMainWindow class</tertiary></indexterm><indexterm><primary>KTMainWindow class</primary></indexterm><indexterm><primary>classes</primary><secondary>KTMainWindow</secondary></indexterm></para>
<para>The <literal>KSimpleApp</literal> widget shows how to use <literal>KTMainWindow</literal> to create a document-centric application. A<indexterm><primary>document-centric programs</primary></indexterm><indexterm><primary>programs</primary><secondary>document-centric</secondary></indexterm> document-centric application contains a menubar, a toolbar, a statusbar, and a content area. These elements can be seen in <link linkend="ch02fig04">Figure 2.4</link>, which shows a screen shot of KWrite, a text-editing utility included with KDE. KWrite is an example of a document-centric application.</para>
<figure label="2.4" id="ch02fig04">
<title>KWrite offers a prototype KDE-style, document-centric application.</title> 
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig04.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>The content area in this case contains the document being edited. In general, the content area contains a view of the document being worked on, but the concept of <quote>document</quote> is extended to include images, Web pages, scientific plots, file-manager views, or whatever data the application deals with.</para>
<para>The menubar, toolbar, and statusbar widgets are created, positioned, and deleted by <literal>KTMainWindow</literal>. The menubar contains the familiar File, Edit, and other pull-down menu headings. The toolbar shows icon buttons that provide quick access to frequently used menu entries. The statusbar displays short messages and state indicators that let the user know what tasks the application is performing and that give extended information about UI objects or document elements.</para>
<para><literal>KTMainWindow</literal> also implements basic session management. The session manager, as implemented by KWin saves the state of the desktop when the user logs out, and it re-creates it at the next login. This means that each application that was running at logout should be restarted in a window that has the same position and size and that contains the document that was being edited. <literal>KTMainWindow</literal> takes care of positioning and sizing your application's window when <literal>kwm</literal> restores it. You will see in <link linkend="ch07">Chapter 7, <quote>Further KDE Compliance,</quote></link> how to save additional information such as the contents of the document that was being edited when the user logged out.<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>KTMainWindow class</tertiary></indexterm><indexterm><primary>KTMainWindow class</primary></indexterm><indexterm><primary>classes</primary><secondary>KTMainWindow</secondary></indexterm></para>
</section>
<section id="ch02lev2sec6">
<title>A Typical <literal>main()</literal> Function</title>
<para><link linkend="ch02list04">Listing<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KSimpleApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KSimpleApp</tertiary></indexterm> 2.4</link> contains a <literal>main()</literal> function that is typical for a KDE application. It is short because the real work is done in the class you derive from <literal>KTMainWindow</literal> (<literal>KSimpleApp</literal> in this case). It creates an instance of <literal>KApplication</literal>, an instance of <literal>KSimpleApp</literal>, and it passes control to the instance <literal>KApplication</literal>.</para>
<example role="codelisting" label="2.4" id="ch02list04">
<title>main.cpp: The <literal>main()</literal> Function for <literal>KSimpleApp</literal><indexterm><primary>KSimpleApp program</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>main() method</tertiary></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;kapp.h>
 2:
 3: #include "ksimpleapp.h"
 4:
 5: int
 6: main (int argc, char *argv[])
 7: {
 8:   KApplication kapplication (argc, argv, "ksimpleapp");
 9:
10:   if (kapplication.isRestored())
11:       RESTORE(KSimpleApp)
12:   else
13:   {
14:     KSimpleApp *ksimpleapp = new KSimpleApp;
15:     ksimpleapp->show();
16:   }
17:
18:   return kapplication.exec();
19: }<indexterm><primary>KSimpleApp program</primary><secondary>main() method</secondary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>main() method</tertiary></indexterm></programlisting>
</example>
<para>The <literal>KApplication</literal> constructor needs <literal>argc</literal> and <literal>argv</literal> so that it can process command-line options. <link linkend="ch02table01">Table 2.1</link> is a list of options that are processed by all KDE applications and removed from <literal>argc</literal>/<literal>argv</literal> after the constructor is called:<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KSimpleApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KSimpleApp</tertiary></indexterm></para>
<table id="ch02table01" frame="topbot" label="2.1">
<title>Options Processed by All KDE Applications</title>
<tgroup cols="2" align="left" rowsep="0" colsep="0">
<colspec colname="c1"/>
<colspec colname="c2"/>
<thead valign="top">
<row rowsep="1">
<entry><emphasis>Option</emphasis></entry>
<entry><emphasis>Action</emphasis></entry></row>
</thead>
<tbody valign="top">
<row>
<entry><literal>caption</literal> <emphasis><literal>caption_name</literal></emphasis></entry>
<entry>Tells <literal>KApplication</literal> to use <emphasis><literal>caption_name</literal></emphasis> as the titlebar text.</entry></row>
<row>
<entry><literal>icon</literal> <emphasis><literal>icon_name</literal></emphasis></entry>
<entry>Specifies which file to use as the application icon.</entry></row>
<row>
<entry><literal>miniicon</literal> <emphasis><literal>miniicon_name</literal></emphasis></entry>
<entry>Specifies which file to use as the application miniicon. This icon is placed in the upper-left corner of the application window.</entry></row>
<row>
<entry><literal>restore</literal></entry>
<entry>Indicates that the application has been started by the session manager.</entry></row>
</tbody>
</tgroup>
</table>
<para>You may process the remaining command-line options however you want.</para>
<para>The last option to the <literal>KApplication</literal> constructor is the name of the application. This name serves as the default caption as well as the name of the icon and of the miniicon. In this case, as is generally the case, no icon or miniicon name was specified in the command line. This causes <literal>KApplication</literal> to look for the default icon file for this application, ksimpleapp.png, (.png is used to denote files Portable Network Graphics (PNG) format) in the standard icon and miniicon directories. Of course, in this example you have not created an icon file for the KSimpleApp, so the file will not be found and a generic icon will be used instead. (The standard locations of icons and other resources are discussed in <link linkend="ch16">Chapter 16</link>.)<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KSimpleApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KSimpleApp</tertiary></indexterm></para>
<para>If your application has been started by the session manager, <literal>KApplication::isRestored()</literal>, as used on line 9 of <link linkend="ch02list04">Listing 2.4</link>, will return <literal>true</literal>. In this case, use the <literal>RESTORE</literal> macro, defined in ktmainwindow.h, to create <literal>KSimpleApp</literal>. Creating <literal>KSimpleApp</literal> in this way will place the window, the menubar and the toolbars where the user left them at logout. (Note that the menubar and toolbars can be positioned by the user. Try right-clicking the textured vertical bar to the left of the menubar. You are offered the following options for positioning the menubar: <literal>Left</literal>, <literal>Top</literal>, <literal>Right</literal>, <literal>Bottom</literal>, <literal>Float</literal>, and <literal>Flat</literal>.)</para>
<para>If your application was started normally&mdash;that is, by the user and not by the session manager&mdash; you create a new instance of <literal>KSimpleApp</literal> and make it visible with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
KSimpleApp *ksimpleapp = new KSimpleApp;
ksimpleapp->show();
</programlisting>
</informalexample>
<para>The <literal>show()</literal> <indexterm><primary>show() method</primary></indexterm><indexterm><primary>methods</primary><secondary>show()</secondary></indexterm>method does not actually show the window. The window will be shown after you enter the event loop with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
kapplication->exec();
</programlisting>
</informalexample>
<para>In this method, all the events received from X, such as window move, resize, paint events, mouse-move events, button-press events, and keypress events will be dispatched to the appropriate KDE/Qt widget classes. This loop exits when the last window is closed. At this time, your program should not expect to have a user interface and should terminate.<indexterm><primary>programs</primary><secondary>structure of</secondary><tertiary>main() method</tertiary></indexterm><indexterm><primary>main() method</primary><secondary>KSimpleApp</secondary></indexterm><indexterm><primary>methods</primary><secondary>main()</secondary><tertiary>KSimpleApp</tertiary></indexterm></para>
</section>
</section>
<section id="ch02lev1sec4">
<title>GUI Elements</title>
<para><literal>KSimpleApp</literal> <indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>creating/configuring</tertiary></indexterm>minimally uses each of the four widgets that are managed by <literal>KTMainWindow</literal>. They are all created and configured in the <literal>KSimpleApp</literal> constructor, shown in <link linkend="ch02list05">Listing 2.5</link>.</para>
<example role="codelisting" label="2.5" id="ch02list05">
<title>ksimpleapp.cpp: The Class Definition File for <literal>KSimpleApp</literal><indexterm><primary>KSimpleApp program</primary><secondary>ksimpleapp.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KSimpleApp example</tertiary></indexterm><indexterm><primary>ksimpleapp.cpp class definition (KSimpleApp program)</primary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>ksimpleapp.cpp class definition</tertiary></indexterm><indexterm><primary>class definitions</primary><see>defining widget classes</see></indexterm></title>
<programlisting linenumbering="numbered">
 1: #include &lt;qlabel.h>
 2:
 3: #include &lt;kstdaccel.h>
 4: #include &lt;kiconloader.h>
 5: #include &lt;kmenubar.h>
 6: #include &lt;kapp.h>
 7: #include &lt;kaction.h>
 8:
 9: #include "ksimpleapp.moc"
10:
11: KSimpleApp::KSimpleApp (const char *name) :
12:   KTMainWindow (name)
13: {
14:   KAction *reposition =
15:     new KAction ("&amp;Reposition Text", QIconSet(BarIcon ("idea")),
16:             CTRL+Key_R, this, SLOT (slotRepositionText()),
17:             this);
18:   KAction *quit =
19:     new KAction ("&amp;Quit", KStdAccel::quit(), kapp,
20:             SLOT (closeAllWindows()), this);
21:
22:   QPopupMenu *filemenu = new QPopupMenu;
23:   reposition->plug (filemenu);
24:   filemenu->insertSeparator();
25:   quit->plug (filemenu);
26:
27:   menuBar()->insertItem ("&amp;File", filemenu);
28:
29:   reposition->plug(toolBar());
30:
31:   statusBar()->message ("Ready!");
32:
33:   text = new QLabel ("Hello!", this);
34:   text->setBackgroundColor (Qt::white);
35:   alignment [0] = QLabel::AlignLeft | QLabel::AlignVCenter;
36:   alignment [1] = QLabel::AlignHCenter | QLabel::AlignVCenter;
37:   alignment [2] = QLabel::AlignRight | QLabel::AlignVCenter;
38:   indexalignment = 0;
39:
40:   text->setAlignment (alignment [indexalignment]);
41:   setView (text);
42:
43: }
44:
45: void
46: KSimpleApp::slotRepositionText ()
47: {
48:   indexalignment = (indexalignment+1)%3;
49:   text->setAlignment (alignment[indexalignment]);
50:
51:   statusBar()->message ("Repositioned text in content area", 1000);
52: }<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>creating/configuring</tertiary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>ksimpleapp.cpp class definition</secondary></indexterm><indexterm><primary>defining</primary><secondary>widget classes</secondary><tertiary>KSimpleApp example</tertiary></indexterm><indexterm><primary>ksimpleapp.cpp class definition (KSimpleApp program)</primary></indexterm><indexterm><primary>listings</primary><secondary>KSimpleApp program</secondary><tertiary>ksimpleapp.cpp class definition</tertiary></indexterm></programlisting>
</example>
<para>A <literal>QLabel</literal>, a widget that displays some static text&mdash;<quote>Hello!</quote> in this case&mdash;is created on line 33 and forms the content area. That is, <literal>QLabel</literal> plays the role of <literal>KMyContent</literal> in <link linkend="ch02fig03">Figure 2.3</link>. The menubar contains a File menu with two entries:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><para>Reposition Text&mdash;Cycles through three positions of the text: left, center, and right.</para></listitem>
<listitem><para>Quit&mdash;Exits the application.</para></listitem></itemizedlist>
<para>The toolbar contains one button that performs the same function as Reposition Text. The statusbar says <quote>Ready!</quote> when the program first starts and then displays a message whenever the user repositions the text. Thus, <literal>KSimpleApp</literal> demonstrates how to set up each of the four widgets you'll need to create a user interface for a KDE application: <literal>KToolbar</literal>, <literal>KStatusBar</literal>, <literal>KMenuBar</literal>, and the content area widget. <link linkend="ch02fig05">Figure 2.5</link> is a screen shot of <literal>KSimpleApp</literal>.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>creating/configuring</tertiary></indexterm></para>
<figure label="2.5" id="ch02fig05">
<title><literal>KSimpleApp</literal> demonstrates basic usage of important KDE widgets: <literal>KMenuBar</literal>, <literal>KToolBar</literal>, and <literal>KStatusBar</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig05.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<section id="ch02lev2sec7">
<title>The Menubar</title>
<para>Before<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>menubars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>menubars</primary><secondary>creating</secondary></indexterm><indexterm><primary>navigation</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>menubar</secondary></indexterm> constructing the menubar, you need to create a <literal>QPopupMenu</literal> for each of the pull-down menus. In <literal>KSimpleApp</literal> you create one <literal>QPopupMenu</literal> for the File menu.</para>
<para>Line 23 adds the entry <quote>Reposition</quote> Text to the File menu.</para>
<para>The object <literal>reposition</literal>, used on line 23 and created on lines 14&ndash;17 is an action (an instance of <literal>KAction</literal>). It holds all of the information needed to create a menu entry or toolbar entry (see the next section, <quote>The Toolbar</quote>). Actions are a convenient way of packaging application functions with the user interaction needed to describe and activate them. (<literal>KActions</literal> are discussed further in <link linkend="ch05">Chapter 5, <quote>KDE User Interface Compliance.</quote></link>) Lines 14&ndash;17, for example,</para>
<informalexample>
<programlisting linenumbering="unnumbered">
KAction *reposition =
     new KAction ("&amp;Reposition" Text, QIconSet(BarIcon ("idea")),
:               CTRL+Key_R, this, SLOT (slotRepositionText()),
                this);
</programlisting>
</informalexample>
<para>The<indexterm><primary>ampersand (&amp;)</primary></indexterm><indexterm><primary>&amp;</primary><secondary>(ampersand)</secondary></indexterm> ampersand before the letter R makes it so that when the menu is visible, the user can press R to activate this menu entry. This feature is made known to the user by the widget by underlining the R.</para>
<para>The constants <literal>CTRL</literal> and <literal>Key_R</literal> are defined in qnamespace.h. Here they indicate that the <literal>Ctrl+R</literal> key combination will activate this menu entry whenever it is pressed by the user. These key combinations, called accelerators, allow the user to bypass the menubar/toolbar interface and access commonly used functions with simple keystrokes.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>menubars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>menubars</primary><secondary>creating</secondary></indexterm><indexterm><primary>navigation</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>menubar</secondary></indexterm></para>
<para>The icon, specified by <literal>QIconSet(BarIcon ("idea"))</literal> (a light bulb), will be placed to the left of the menu entry. (see <link linkend="ch02fig06">Figure 2.6</link>). When a function appears on the toolbar (as this one does, see the next section, <quote>The Toolbar</quote>), it should also appear as an entry in the menubar with the same toolbar icon next to the entry. This makes the correspondence between the two functions clearer to the user. The class <literal>QIconSet</literal> takes the icon specified by <literal>BarIcon("idea")</literal> and creates different icons that might be needed by the GUI: a large icon, a small icon, and grayed-out <quote>disabled</quote>-look icons. This is all taken care of by the libraries with no further necessary interaction.</para>
<para>The other two parameters to the <literal>KAction</literal> constructor: <literal>this</literal> and <literal>SLOT (slotRepositionText())</literal> indicate that the method <literal>slotRepositionText()</literal>, which is a member of this instance of <literal>KSimpleApp,</literal> should be called whenever this action is activated. The details of just how such a feat can be accomplished&mdash;that feat being to call a method in a specific <emphasis>instance</emphasis> of a class seemingly arbitrarily&mdash;is discussed in <link linkend="ch03">Chapter 3</link>. For now, note that this is accomplished with the Qt <emphasis>signal/slot</emphasis> mechanism.</para>
<figure label="2.6" id="ch02fig06">
<title>You should place the same icon (a light bulb in this example) in the menubar as is used in the toolbar so that the user knows these are two ways of performing the same function.</title>
<mediaobject>
<imageobject>
<imagedata fileref="graphics/02fig06.gif" format="GIF"/></imageobject>
</mediaobject>
</figure>
<para>The next line</para>
<informalexample>
<programlisting linenumbering="unnumbered">
filemenu->insertSeparator();
</programlisting>
</informalexample>
<para>appends a horizontal line to the pop-up menu. This is not an active GUI element; it simply serves to separate groups of functions. The KDE GUI design guidelines require this to be placed before the next entry in the menu, which is Quit. (These guidelines are discussed in <link linkend="ch07">Chapter 7</link>.)</para>
<note role="normal">
<para>Use standard names for standard menu entries (<link linkend="ch07">Chapter 7</link> has details). Important: Quit is the last entry on the File menu, not Exit!</para></note>
<para>The second argument passed to the <literal>KAction</literal> constructor when creating the Quit entry on lines 18-20 is <literal>KStdKeys::quit()</literal>, which is a static method of <literal>KStdAccel</literal> that returns the default accelerator key combination for the Quit action. All applications should have a Quit entry in the File menu, and Quit should always be associated with the accelerator key returned by <literal>KStdAccel::quit()</literal>. Using the same names and accelerators in all applications provides consistency, enabling the user to <quote>Learn once and use everywhere</quote> common application functions.</para>
<para>Notice that I use the <literal>new</literal> operator to create a <literal>QPopupMenu</literal>. This allows the object to survive even after you leave the current scope (that is, the <literal>KSimpleApp</literal> constructor) so that it can continue to be accessed by the menubar. An object created in the following way:</para>
<informalexample>
<programlisting linenumbering="unnumbered">
QPopupMenu filemenu;
</programlisting>
</informalexample>
<para>would be deleted after the constructor finished. It is deleted automatically, so you can forget about it unless you want to make changes to it later on.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>menubars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>menubars</primary><secondary>creating</secondary></indexterm><indexterm><primary>navigation</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>menubar</secondary></indexterm></para>
<note role="tip">
<para>Create your widgets with <literal>new</literal>. They will be deleted by their parents, so you won't need to delete them.</para>
</note>
<para>Finally place the pop-up menu you created on the menubar with</para>
<informalexample>
<programlisting linenumbering="unnumbered">
menuBar()->insertItem ("&amp;File", filemenu);
</programlisting>
</informalexample>
<para><literal>menuBar()</literal>creates a <literal>KMenuBar</literal> widget the first time it is called. <literal>KTMainWindow</literal> is also responsible for deleting the <literal>KMenuBar</literal> when it is no longer needed.</para>
<para>This is the simplest method of handling a menubar. It is also possible to create a <literal>KMenuBar</literal> yourself and tell <literal>KTMainWindow</literal> to use it by calling</para>
<informalexample>
<programlisting linenumbering="unnumbered">
void setMenu (KMenuBar *menuBar)
</programlisting>
</informalexample>
<para>This can be useful if you need to switch to a new menubar.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>menubars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>menubars</primary><secondary>creating</secondary></indexterm><indexterm><primary>navigation</primary><secondary>menubars</secondary><tertiary>creating</tertiary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>menubar</secondary></indexterm></para>
</section>
<section id="ch02lev2sec8">
<title>The Toolbar</title>
<para>To <indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>toolbars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>toolbars</secondary></indexterm><indexterm><primary>toolbars</primary></indexterm><indexterm><primary>navigation</primary><secondary>toolbars</secondary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>toolbar</secondary></indexterm>place a button on the toolbar, use a <literal>plug()</literal> method just as you did with the menubar. The first call to <literal>toolBar()</literal> <indexterm><primary>tooBar() method</primary></indexterm><indexterm><primary>methods</primary><secondary>toolBar()</secondary></indexterm>creates an instance of <literal>KToolBar</literal>. This class is deleted by <literal>KTMainWindow</literal> when it is no longer needed.</para>
<para>On line 29 you call <literal>reposition->plug(toolBar())</literal> to put the light bulb icon on a button on the toolbar.</para>
<para>A short help text string, called a tooltip is associated with each toolbar button. It appears when the mouse cursor is placed over a button and left still for about a second. The string <quote>Reposition Text</quote>, specified in the action definition (lines 14&ndash;17), is the tooltip string for this button.</para>
<para>You can put any widget you like on the toolbar&mdash;not just buttons. Two commonly used widgets, a line editor and a combo box (such as the URL-entry box with pull-down history used in a Web browser), are supported directly by <literal>KToolBar</literal> via <literal>insertLined()</literal> and <literal>insertCombo()</literal>, but you can use <literal>insertWidget()</literal> to add any widget you like.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>toolbars</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>toolbars</secondary></indexterm><indexterm><primary>toolbars</primary></indexterm><indexterm><primary>navigation</primary><secondary>toolbars</secondary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>toolbar</secondary></indexterm></para>
</section>
<section id="ch02lev2sec9">
<title>The Status Line</title>
<para>The <indexterm><primary>KSimpleApp program</primary><secondary>status line</secondary></indexterm><indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>status lines</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>status limes</secondary></indexterm><indexterm><primary>status lines</primary></indexterm>status line, or statusbar, is created and deleted by <literal>KTMainWindow</literal> in the same manner as the menubar and toolbar. Your first call to <literal>statusBar()</literal>:<indexterm><primary>statusBar() method</primary></indexterm><indexterm><primary>methods</primary><secondary>statusBar()</secondary></indexterm></para>
<informalexample>
<programlisting linenumbering="unnumbered">
statusBar()->message ("Ready!");
</programlisting>
</informalexample>
<para>creates an instance of <literal>KStatusBar</literal> and puts the message <quote>Ready!</quote> at the bottom of the window on the status line.</para>
<para>Like <literal>KToolBar</literal>, you can place any widget on the status line by using the method <literal>KStatusBar::insertWidget()</literal>. This might be used for displaying a progress bar or an LED-style status indicator, for example.<indexterm><primary>programs</primary><secondary>GUI elements</secondary><tertiary>status lines</tertiary></indexterm><indexterm><primary>GUIs</primary><secondary>status limes</secondary></indexterm><indexterm><primary>status lines</primary></indexterm><indexterm><primary>KSimpleApp program</primary><secondary>status line</secondary></indexterm></para>
</section>
</section>
<section id="ch02lev1sec5">
<title>Programming Conventions</title>
<para>KDE developers follow certain conventions when they write KDE source code. The conventions dictate naming and documentation styles. Following them will help other developers to work with your code more easily. It will even help you. For example, you won't have to look up names of methods as often because the conventions make the names easier to remember.</para>
<section id="ch02lev2sec10">
<title>Naming Conventions</title>
<para>KDE <indexterm><primary>programs</primary><secondary>programming conventions</secondary><tertiary>naming conventions</tertiary></indexterm><indexterm><primary>programming conventions</primary><secondary>naming conventions</secondary></indexterm><indexterm><primary>naming conventions</primary></indexterm><indexterm><primary>classes</primary><secondary>naming conventions</secondary></indexterm>class names begin with a capital <literal>K</literal>. The first letter of each word making up the class name is also capitalized. For example, you used <literal>KSimpleApp</literal> as your class name in the code in Listings 2.3&ndash;2.5. Note that Qt class names follow a similar convention, but they all start with a capital <literal>Q</literal>.</para>
<para>The names <indexterm><primary>methods</primary><secondary>naming conventions</secondary></indexterm>of methods begin with a lowercase letter, but the first letter of each successive word is capitalized. For example, the method <literal>setBackgroundColor()</literal>, used in the constructor for <literal>KSimpleApp</literal>, is named with this convention. It is a Qt method (a member of <literal>QWidget</literal>) and follows the convention, as do all Qt methods.</para>
<para>Class and method names usually consist of one or more whole words or common abbreviations (such as <quote>App</quote> for application in the name <literal>KSimpleApp</literal>). Whole word names are easier to remember and make for more readable code.</para>
<para>Conventions<indexterm><primary>files</primary><secondary>naming conventions</secondary></indexterm> are also used for filenames. Header files containing class definitions are given the name of the class, except that all letters are kept lowercase. The extension .h is used. Source files containing class definitions also use an all-lowercase version of the class name and carry the extension .cpp.</para>
<para>Prototypical examples of the naming conventions are collected in <link linkend="ch02table02">Table 2.2</link>.</para>
<table id="ch02table02" frame="topbot" label="2.2">
<title>KDE Naming Conventions</title>
<tgroup cols="2" align="left" rowsep="0" colsep="0">
<colspec colname="c1"/>
<colspec colname="c2"/>
<thead valign="top">
<row rowsep="1">
<entry><emphasis>Type</emphasis></entry>
<entry><emphasis>Prototype</emphasis></entry></row>
</thead>
<tbody valign="top">
<row>
<entry>Class</entry>
<entry>KMyGreatClass</entry>
</row>
<row>
<entry>Method</entry>
<entry>myUsefulMethod</entry></row>
<row>
<entry>Class declaration file</entry>
<entry>kmygreatclass.h</entry></row>
<row>
<entry>Class description file</entry>
<entry>kmygreatclass.cpp<indexterm><primary>programs</primary><secondary>programming conventions</secondary><tertiary>naming conventions</tertiary></indexterm><indexterm><primary>programming conventions</primary><secondary>naming conventions</secondary></indexterm><indexterm><primary>naming conventions</primary></indexterm></entry></row>
</tbody>
</tgroup>
</table>
</section>
<section id="ch02lev2sec11">
<title>Class Documentation</title>
<para>It <indexterm><primary>programs</primary><secondary>programming conventions</secondary><tertiary>class documentation</tertiary></indexterm><indexterm><primary>programming conventions</primary><secondary>class documentation</secondary></indexterm><indexterm><primary>classes</primary><secondary>documentation</secondary></indexterm><indexterm><primary>documentation</primary></indexterm>is important to document the public interfaces to your classes so that others may make use of them in their programs when hacking at your code. You should also document the protected interface so that derivation is easier. <link linkend="ch02list03">Listing 2.3</link> gives examples of the class documentation style. If the documentation is given in the comments in this form, it can be interpreted by a script called <literal>kdoc</literal>, which can create attractive, standalone documentation. <literal>kdoc</literal>-style documentation is covered in depth in <link linkend="ch15">Chapter 15, <quote>Creating Documentation.</quote></link></para>
</section>
</section>
<section id="ch02lev1sec6">
<title>Summary</title>
<para>In this chapter you learned how to compile a KDE program; you created a simple application; and you were introduced to some KDE programming conventions.</para>
<para>The compilation process can be greatly simplified by using the <literal>make</literal> utility. It allows you to start the compiler by just typing <emphasis role="strong"><literal>make</literal></emphasis> at the command line instead of long strings of compiler options. It also saves time because only modified source code&mdash;and the code that depends on it&mdash;is recompiled.</para>
<para>Although the application you created was a simple one, it demonstrates most of the classes and methods that you need to know about to get the look and feel of a KDE-compliant application. Some UI design standards were discussed and will be expanded upon later.</para>
<para>It is important to follow the KDE naming conventions and to document your code. It will help both you and other developers to understand and modify your code.</para>
</section>
<section id="ch02lev1sec7">
<title>Exercises</title>
<para>Answers to the exercises can be found in <link linkend="ap-c">Appendix C, <quote>Answers</quote></link>.</para>
<qandaset defaultlabel="number">
<qandaentry>
<question id="ch02que01"><para><link linkend="ch02ans01">Referring to the KDE class documentation for <literal>KToolBar</literal>, modify <literal>KSimpleApp</literal> to include a line editor on the toolbar.</link></para></question>
</qandaentry>
<qandaentry>
<question id="ch02que02"><para><link linkend="ch02ans02">Modify <literal>KSimpleApp</literal> to put a <literal>QMultiLineEdit</literal> widget in the content area instead of a <literal>QLabel</literal>. Replace all the references to the Reposition Text function with a function that clears the widget. You will need to refer to the Qt class documentation for <literal>QMultiLineEdit</literal>.</link></para></question></qandaentry>
</qandaset>
</section>
</chapter>
