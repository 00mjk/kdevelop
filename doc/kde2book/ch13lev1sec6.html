<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Developer Concerns and Tools in DCOP</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"/><LINK
REL="HOME"
TITLE="KDE 2.0 Development"
HREF="index.html"/><LINK
REL="UP"
TITLE="DCOP&#8212;Desktop Communication Protocol"
HREF="ch13.html"/><LINK
REL="PREVIOUS"
TITLE="Description of DCOP's Programming Interface"
HREF="ch13lev1sec5.html"/><LINK
REL="NEXT"
TITLE="DCOP Use in KDE 2.0&#8212;A Few Examples"
HREF="ch13lev1sec7.html"/><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"/><LINK
REL="stylesheet"
HREF="kde-common.css"
TYPE="text/css"/><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"/><META
HTTP-EQUIV="Content-Language"
CONTENT="en"/><LINK
REL="stylesheet"
HREF="kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"/><LINK
REL="stylesheet"
HREF="kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"/></HEAD
><BODY
CLASS="section"
LINK="#336699"
VLINK="#336699"
ALINK="#336699"
BGCOLOR="#FFFFFF"
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch13lev1sec5.html"
>Prev</A
> <A
HREF="ch13lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H1
CLASS="section"
><A
NAME="ch13lev1sec6"
>13.6. Developer Concerns and Tools in DCOP</A
></H1
><P
>At this point in the journey of learning DCOP, most of the necessary notions and principles have been presented. You should be able to add DCOP functionality to your existing KDE code. The appropriation of the information presented in the preceding sections hopefully offers a good foundation. A wealth of concrete DCOP usage examples are provided in the standard KDE code.</P
><P
>The remaining sections attempt to provide a fast reference to deeper technical details related to DCOP.</P
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch13lev2sec7"
>13.6.1. Stay Informed</A
></H2
><P
>The team of developers focusing on the KDE's communication protocol technology has made a number of additions to the standard DCOP API designed to make the protocol more informative and even easier to use.</P
><P
>Because DCOP makes use of a server that has to run permanently, willing DCOP clients can be enabled to access an important amount of information about their peers running at a given moment on the desktop. The functionalities offered by the peers are also made publicly available. Following is a list of DCOP API tools that will extract and report this kind of information. The presentation offered here for each of the tools is brief. For a complete description of their programming interface, the API documentation available at <A
HREF="http://developer.kde.org"
TARGET="_top"
>http://developer.kde.org</A
> is the authoritative resource.</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>isRegistered()</TT
>&#8212;Returns a boolean value stating whether the current client is already registered with the DCOP server. This method is particularly useful when using DCOP in KPart applications. More details are provided near the end of this section.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>isApplicationRegistered()</TT
>&#8212;Accepts a <TT
CLASS="literal"
>QCString</TT
> parameter containing the identifier of a remote DCOP client. Returns a true boolean value if an application with the given identifier is registered with the DCOP server.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>registeredApplications()</TT
>&#8212;Returns a list of identifiers for all applications registered with the DCOP server.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>remoteObjects()</TT
>&#8212;Given the identifier of a remote DCOP client as a parameter, returns a list of all DCOP-enabled objects in that client.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>remoteInterfaces()</TT
>&#8212;Returns the list of DCOP interfaces that a client implements. The clients that use automatic DCOP interface generation (the <TT
CLASS="literal"
>dcopidl</TT
> tools) have at least a <TT
CLASS="literal"
>DCOPObject</TT
> interface declared. The data provided by this method has no functional role, but only an informative one.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>remoteFunctions()</TT
>&#8212;Requires an application identifier and an object signature as parameters and returns the list of methods accessible through DCOP for the designated hierarchy.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>findObject()</TT
>&#8212;This method is a complex tool that was particularly useful before the heuristic mechanisms were added to the <TT
CLASS="literal"
>DCOPClient::call()</TT
> method. It takes as parameters a trial client identifier, a trial object signature, and a few other optional parameters. The real identifier and the signature of the DCOP hierarchy (application/object1/object2/&#8230;) that answered the request properly are returned as references. The method returns a false boolean value if no matching client is found. This is a potentially blocking method (in other words, its execution time could be long enough to hinder the user interface activity). It is possible to counter the effects of blocking by setting a true boolean value to the <TT
CLASS="literal"
>useEventLoop</TT
> parameter that the method accepts.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>senderId()</TT
>&#8212;Returns the DCOP identifier of the last peer with which the current client had communication. This is potentially particularly powerful and useful information.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
><TT
CLASS="literal"
>socket()</TT
>&#8212;Returns a number that identifies the ICEConnection socket over which communication is established with the DCOP server.</P
></LI
></UL
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev2sec7"/></TD
></TR
><ANNOTATION
NAME="ch13lev2sec7"
TITLE="Stay Informed"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch13lev2sec8"
>13.6.2. Referencing DCOP Objects</A
></H2
><P
>Another powerful functionality added recently to the DCOP API is represented by the message redirection technology (also called referencing). A normal DCOP client can create and use <TT
CLASS="literal"
>DCOPRef</TT
> objects. The role of this type of objects is to provide a reference to an object made public over DCOP by a remote client. The identifier of the remote client as well as the signature of the receptor object can be indicated at the creation or at any other moment in the life of the <TT
CLASS="literal"
>DCOPRef</TT
> object. It might not be immediately obvious what role the DCOP object references in the general desktop communication landscape are playing. An example will help for a better understanding. <I
CLASS="emphasis"
>KDesktop</I
> is an application that offers the KDE user control over the background of the computer screen, usually referred to as the <I
CLASS="emphasis"
>desktop</I
>. KDesktop manages the following:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>The desktop icons and icon operations (for example, Alignment)</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Drag-and-drop operations on the desktop</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>The <SPAN
CLASS="QUOTE"
>"Trash"</SPAN
></P
></LI
><LI
STYLE="list-style-type: disc"
><P
>The <SPAN
CLASS="QUOTE"
>"AutoStart"</SPAN
> functionality</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>The desktop's contextual menus</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Wallpapers</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Screensavers</P
></LI
></UL
><P
>Apart from this set of obvious responsibilities, KDesktop is also charged with the hidden capability of providing the user with the necessary means for remote control of these desktop resources. As a consequence, KDesktop became one of the most important beneficiaries of the DCOP technology. In accordance with the object-oriented programming philosophy, the stretch of functionalities KDesktop controls required modularization. Thus, the control over wallpapers and the handling of screensavers is passed on to modules. Yet, it is logical to have DCOP control over <I
CLASS="emphasis"
>all</I
> KDesktop functionalities published to the DCOP <SPAN
CLASS="QUOTE"
>"community"</SPAN
> of applications from KDesktop. Because the wallpaper handling module (named KBackground) and the screen locking engine have their own DCOP interfaces, the general DCOP interface of KDesktop is designed as shown in <A
HREF="ch13lev1sec6.html#ch13list13"
>Listing 13.13</A
>.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch13list13"
></A
><P
><B
>Example 13.13. Example of DCOPRef Usage</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;File KDesktopIface.h (from the real KDE-2.0 code base)
   3&nbsp;------------------------------------------------------
   4&nbsp; 1: #ifndef __KDesktopIface_h__
   5&nbsp; 2: #define __KDesktopIface_h__
   6&nbsp; 3:
   7&nbsp; 4: #include &lt;qstringlist.h&gt;
   8&nbsp; 5: #include &lt;dcopobject.h&gt;
   9&nbsp; 6: #include &lt;dcopref.h&gt;
  10&nbsp; 7:
  11&nbsp; 8: class KDesktopIface : virtual public DCOPObject
  12&nbsp; 9: {
  13&nbsp;10:   K_DCOP
  14&nbsp;11: public:
  15&nbsp;12:
  16&nbsp;13: k_dcop:
  17&nbsp;14:   virtual void rearrangeIcons() = 0;
  18&nbsp;15:   virtual void rearrangeIcons( bool bAsk ) = 0;
  19&nbsp;16:   virtual void lineupIcons() = 0;
  20&nbsp;17:   virtual void selectIconsInRect( int x, int y, int dx, int dy ) = 0;
  21&nbsp;18:   virtual void selectAll() = 0;
  22&nbsp;19:   virtual void unselectAll() = 0;
  23&nbsp;20:   virtual QStringList selectedURLs() = 0;
  24&nbsp;21:   virtual void configure() = 0;
  25&nbsp;22:   virtual void popupExecuteCommand() = 0;
  26&nbsp;23:   virtual DCOPRef background() = 0;
  27&nbsp;24:   virtual DCOPRef screenSaver() = 0;
  28&nbsp;25: };
  29&nbsp;26:
  30&nbsp;26: #endif
  31&nbsp;
  32&nbsp;File desktop.h (from the real KDE-2.0 code base)
  33&nbsp;------------------------------------------------
  34&nbsp;.
  35&nbsp;96:  virtual DCOPRef background()
  36&nbsp;     { return DCOPRef( "kdesktop", "KBackgroundIface" ); }
  37&nbsp;97:  virtual DCOPRef screenSaver()
  38&nbsp;     { return DCOPRef( "kdesktop", "KScreensaverIface" ); }
  39&nbsp;.
  40&nbsp;.
  41&nbsp;.
  42&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The relevant lines are, of course, 23 and 24 in KDesktopIface.h and the clipped lines from desktop.h. At the level of the client's DCOPObject representation, this results in the addition of objects named <SPAN
CLASS="QUOTE"
>"KBackgroundIface"</SPAN
> and <SPAN
CLASS="QUOTE"
>"KScreensaverIface"</SPAN
> to the rest of the (normally built) DCOP interface of KDesktop. These objects allow, as expected, remote control over functionalities of the background engine and the screen locking engine. The automatically generated DCOP interfaces of these modules are defined independently. For a thorough understanding of the topic of DCOP object referencing, you may prefer to peruse the source code of the KDesktop application.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev2sec8"/></TD
></TR
><ANNOTATION
NAME="ch13lev2sec8"
TITLE="Referencing DCOP Objects"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch13lev2sec9"
>13.6.3. Signals and Slots Through the DCOP Server</A
></H2
><P
>KDE developers are very familiar with the concepts of <I
CLASS="emphasis"
>signals and slots</I
> intensively used by the Qt library, the basement on which KDE is built. Very powerful and particularly useful concepts, the signals and slots play an important role in the elegance and the ease of use of the Qt toolkit. The DCOP API contains the implementation of a similar mechanism. In addition to the <SPAN
CLASS="QUOTE"
>"strong"</SPAN
> bindings offered by the <TT
CLASS="literal"
>DCOPClient::send()</TT
> and <TT
CLASS="literal"
>DCOPClient::call()</TT
> methods, DCOPSignals provide what can be depicted as <SPAN
CLASS="QUOTE"
>"weak"</SPAN
> or <SPAN
CLASS="QUOTE"
>"flexible"</SPAN
> bindings. The mildly experienced Qt programmer will be able to appropriate the principle of DCOPsignals easily. The equivalents of Qt's <TT
CLASS="literal"
>QObject::connect()</TT
>, <TT
CLASS="literal"
>QObject::disconnect()</TT
>, and <TT
CLASS="literal"
>QObject::emit()</TT
> methods are conveniently named <TT
CLASS="literal"
>DCOPClient::connectDCOPSignal()</TT
>, <TT
CLASS="literal"
>DCOPClient::disconnectDCOPSignal()</TT
>, and <TT
CLASS="literal"
>DCOPClient::emitDCOPSignal()</TT
>. They use roughly similar functioning principles too. There are two noticeable differences between the implementation of Qt's signals and slots and the implementation of KDE's over-DCOP signals and slots:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Data has to be encapsulated into a proper <TT
CLASS="literal"
>QByteArray</TT
>/<TT
CLASS="literal"
>QDataStream</TT
> envelope when passed over a DCOP signal-slot connection from a <TT
CLASS="literal"
>DCOPClient::emitDCOPSignal()</TT
> method call.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>In order to have proper control over-DCOP signal/slot connections, a supplementary method from the DCOPClient API has to be invoked before actually using them. This method is <TT
CLASS="literal"
>DCOPClient::setNotifications()</TT
> and has to be called after establishing all wanted connections, but before issuing the first DCOP signal emit.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>There are a few predefined, convenient signals, built in to the <TT
CLASS="literal"
>DCOPClient</TT
> class:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>The signal <TT
CLASS="literal"
>DCOPClient::applicationRegistered()</TT
> is emitted automatically at the moment a client uses the <TT
CLASS="literal"
>attach()</TT
> method.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Its counterpart, <TT
CLASS="literal"
>DCOPClient::applicationRemoved()</TT
>, is emitted when a <TT
CLASS="literal"
>detach()</TT
> call is performed (this usually happens when the client quits functioning).</P
></LI
></UL
></LI
></UL
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev2sec9"/></TD
></TR
><ANNOTATION
NAME="ch13lev2sec9"
TITLE="Signals and Slots Through the DCOP Server"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch13lev2sec10"
>13.6.4. DCOP with an Embedded KPart</A
></H2
><P
>DCOP and KParts are the technologies KDE is using to comply with the modern requirements of software modularization. Both technologies are convenient for building reusable objects and, when used together, they open large opportunities for creatively minded developers. This section attempts to draw attention to the somewhat delicate aspect of programming modules using both the embedding and the communication technologies at once.</P
><P
>There is nothing that prevents an embeddable KPart from gaining DCOP functionality. The developer needs to write in his KPart the usual code meant to create the DCOP client object, to attach it to the server, and then to register it so that the duplex communication can be enabled. Yet, it is important to note that the embedding application, which will host the DCOP client KPart, may also be a DCOP client before the embedding occurs. In consequence, caution is required. <A
HREF="ch13lev1sec6.html#ch13list14"
>Listing 13.14</A
> is a small example of proper DCOP client registration code as provided in the KWrite editor KPart.</P
><DIV
CLASS="example"
><HR/><A
NAME="ch13list14"
></A
><P
><B
>Example 13.14. DCOP within a KPart</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>   1&nbsp;
   2&nbsp;File kwview.cpp (from the real KDE-2.0 code base)
   3&nbsp;------------------------------------------------
   4&nbsp;.
   5&nbsp;.
   6&nbsp;1527:   DCOPClient *client = kapp-&gt;dcopClient();
   7&nbsp;1528:   if (!client-&gt;isRegistered())  // just in case we're embedded
   8&nbsp;1529:   {
   9&nbsp;1530:     client-&gt;attach();
  10&nbsp;1531:     client-&gt;registerAs("kwrite");
  11&nbsp;1532:   }
  12&nbsp;.
  13&nbsp;.
  14&nbsp;</PRE
></TD
></TR
></TABLE
><HR/></DIV
><P
>The need for such code comes from the fact that attempting to register an embedded KPart instance while the embedding application is already registered with the DCOP server will modify (with unpredictable consequences) the identity of the embedding application on the DCOP client names pool.</P
><P
>The solution to this problem is based on a simple but brilliant idea:</P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>The DCOP client object is created using the normal instantiation method.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Prior to all attaching and registering attempts, a check with the DCOP server is performed in order to learn whether a legitimate registration is already available.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>If the embedding application is already registered, then the embedded KPart instance learns that proper registration exists, hence it doesn't need to register itself anymore.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>If the embedding application doesn't exhibit DCOP functionality, then the KPart instance needs to register properly.</P
></LI
></UL
><P
>A question becomes evident: <I
CLASS="emphasis"
>How does the embedded KPart instance acquire proper visibility in the DCOP <SPAN
CLASS="QUOTE"
>"community"</SPAN
> when the embedding application is already registered?</I
> Indeed, the embedded KPart instance needs a working registration with the server so that it can receive DCOP calls from the peer clients. The little secret resides in proper usage of <TT
CLASS="literal"
>DCOPRef</TT
> objects previously presented. At embedding time, the embedding application creates <TT
CLASS="literal"
>DCOPRef</TT
> objects for the DCOP objects that an embedded KPart instance makes public. For example, as a result of this behavior, a Konqueror DCOP client with an embedded KWrite view part, observed from the exterior, will appear to provide a reunion of Konqueror-specific and KWrite-specific DCOP object interfaces.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev2sec10"/></TD
></TR
><ANNOTATION
NAME="ch13lev2sec10"
TITLE="DCOP with an Embedded KPart"/></TABLE
></DIV
><DIV
CLASS="section"
><TABLE
WIDTH="100%"
CELLPADDING="0"
CELLSPACING="0"
BORDER="0"
ALIGN="CENTER"
><TR
><TD
WIDTH="90%"
><H2
CLASS="section"
><A
NAME="ch13lev2sec11"
>13.6.5. Performance and Overhead</A
></H2
><P
>DCOP presently plays a central role in the KDE desktop. Also, the history of the KDE project recorded rather painful CORBA experiences, therefore the concerns about performance, resource usage, and overhead related to the intensive usage of the protocol are legitimate. Fortunately, KDE team members performed a few instrumental tests. Also, many hundreds of developers and alpha/beta testers assured rather intensive normal usage testing during many months. This section enlists a collection of significant results, courtesy of KDE developers Preston Brown, Matthias Ettrich, David Faure, Waldo Bastian, and Kurt Granroth.</P
><P
>Concerning performance, numbers regarding the useful message exchanges between peers are of interest. Consider, for example, two clients only, passing messages between them by the mediation of the DCOP server.</P
><P
>Usual desktop computers (popular processors running at frequencies of around 300 MHz) are credited with allowing 1500 to 2000 usual DCOP messages per second. Usual DCOP messages consist of rather small amounts of data (1 to 5 Kbytes). The two clients aren't able to saturate the capabilities of the server. Adding two more clients determines the augmentation of the maximal counts with about 40%.</P
><P
>In order to put these numbers in context, we have to observe that the MICO implementation of CORBA provides results of about 900 hits on a same type of computer. Also note that usual IPC/RPC implementations are credited with a maximum of 3000 hits per second. As a conclusion, DCOP is fast enough for the practical needs of modern desktop environment software.</P
><P
>The disadvantages associated with DCOP appear evident, though, when trying to transfer large amounts of data between clients. The explication resides in the fact that the operation of data copying always has to be performed twice (first from the sender client to the DCOP server, then from the server to the receptor). This issue is known to the KDE developers. The proposed solution consists of implementing shared memory backend usage for such large data transfers. The design of the current DCOP implementation would easily allow for such an enhancement. It is worth mentioning that Stefan Westerfeld, member of the KDE Multimedia team, designed and implemented a communication protocol adapted to the needs of multimedia applications. His protocol (named MCOP, as you will learn about in <A
HREF="ch14.html"
>Chapter 14, <SPAN
CLASS="QUOTE"
>"Multimedia"</SPAN
></A
>) is similar in functionality to DCOP but allows for asynchronous, fast transfers of the large amounts of data specific to this particular field (video and audio streams, for example). This technology is also actively used in the current version of KDE (2.0) under the form of the network-transparent, composition-capable, KDE audio technology and server (named aRts and <TT
CLASS="literal"
>artsd</TT
> respectively).</P
><P
>DCOP, as all other computer technologies, will need to use memory and processing power in order to do something useful. For the case in discussion, the memory usage is required by the operation of equipping a normal KDE <TT
CLASS="literal"
>KApplication</TT
> object with a functional DCOP client data and live code structures. According to preliminary measurements performed by KDE developers, this memory overhead amounts to about 100 Kbytes per application. When measuring startup time delays that might be introduced by using DCOP in a usual KDE application, these delays are too small for the observer to detect them from the statistical variation.</P
><P
>It is thus obvious that performance and overhead aren't hindering issues with DCOP. Yet, the developers are carefully observing these and are striving to keep DCOP's impact on normal use of the KDE software as small as possible.</P
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev2sec11"/></TD
></TR
><ANNOTATION
NAME="ch13lev2sec11"
TITLE="Performance and Overhead"/></TABLE
></DIV
></TD
><TD
WIDTH="10%"
VALIGN="BOTTOM"
ALIGN="CENTER"
><ANNMARK
NAME="ch13lev1sec6"/></TD
></TR
><ANNOTATION
NAME="ch13lev1sec6"
TITLE="Developer Concerns and Tools in DCOP"/></TABLE
></DIV
><DIV
ALIGN="RIGHT"
CLASS="NAVBAR"
><P
><A
HREF="ch13lev1sec5.html"
>Prev</A
> <A
HREF="ch13lev1sec7.html"
>Next</A
> <A
HREF="index.html"
>Table of Contents</A
></P
></DIV
><HR
WIDTH="100%"
SIZE="2"
ALIGN="CENTER"
NOSHADE="NOSHADE"/></BODY
></HTML
>