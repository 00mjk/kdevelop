<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - String Input Conversions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_189.html">previous</A>, <A HREF="libc_191.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC197" HREF="libc_toc.html#TOC197">String Input Conversions</A></H3>

<P>
This section describes the <CODE>scanf</CODE> input conversions for reading
string and character values: <SAMP>`%s'</SAMP>, <SAMP>`%['</SAMP>, and <SAMP>`%c'</SAMP>.

</P>
<P>
You have two options for how to receive the input from these
conversions:

</P>

<UL>
<LI>

Provide a buffer to store it in.  This is the default.  You
should provide an argument of type <CODE>char *</CODE>.

<STRONG>Warning:</STRONG> To make a robust program, you must make sure that the
input (plus its terminating null) cannot possibly exceed the size of the
buffer you provide.  In general, the only way to do this is to specify a
maximum field width one less than the buffer size.  <STRONG>If you
provide the buffer, always specify a maximum field width to prevent
overflow.</STRONG>

<LI>

Ask <CODE>scanf</CODE> to allocate a big enough buffer, by specifying the
<SAMP>`a'</SAMP> flag character.  This is a GNU extension.  You should provide
an argument of type <CODE>char **</CODE> for the buffer address to be stored
in.  See section <A HREF="libc_191.html#SEC198">Dynamically Allocating String Conversions</A>.
</UL>

<P>
The <SAMP>`%c'</SAMP> conversion is the simplest: it matches a fixed number of
characters, always.  The maximum field with says how many characters to
read; if you don't specify the maximum, the default is 1.  This
conversion doesn't append a null character to the end of the text it
reads.  It also does not skip over initial whitespace characters.  It
reads precisely the next <VAR>n</VAR> characters, and fails if it cannot get
that many.  Since there is always a maximum field width with <SAMP>`%c'</SAMP>
(whether specified, or 1 by default), you can always prevent overflow by
making the buffer long enough.

</P>
<P>
The <SAMP>`%s'</SAMP> conversion matches a string of non-whitespace characters.
It skips and discards initial whitespace, but stops when it encounters
more whitespace after having read something.  It stores a null character
at the end of the text that it reads.

</P>
<P>
For example, reading the input:

</P>

<PRE>
 hello, world
</PRE>

<P>
with the conversion <SAMP>`%10c'</SAMP> produces <CODE>" hello, wo"</CODE>, but
reading the same input with the conversion <SAMP>`%10s'</SAMP> produces
<CODE>"hello,"</CODE>.

</P>
<P>
<STRONG>Warning:</STRONG> If you do not specify a field width for <SAMP>`%s'</SAMP>,
then the number of characters read is limited only by where the next
whitespace character appears.  This almost certainly means that invalid
input can make your program crash--which is a bug.

</P>
<P>
To read in characters that belong to an arbitrary set of your choice,
use the <SAMP>`%['</SAMP> conversion.  You specify the set between the <SAMP>`['</SAMP>
character and a following <SAMP>`]'</SAMP> character, using the same syntax used
in regular expressions.  As special cases:

</P>

<UL>
<LI>

A literal <SAMP>`]'</SAMP> character can be specified as the first character
of the set.

<LI>

An embedded <SAMP>`-'</SAMP> character (that is, one that is not the first or
last character of the set) is used to specify a range of characters.

<LI>

If a caret character <SAMP>`^'</SAMP> immediately follows the initial <SAMP>`['</SAMP>,
then the set of allowed input characters is the everything <EM>except</EM>
the characters listed.
</UL>

<P>
The <SAMP>`%['</SAMP> conversion does not skip over initial whitespace
characters.

</P>
<P>
Here are some examples of <SAMP>`%['</SAMP> conversions and what they mean:

</P>
<DL COMPACT>

<DT><SAMP>`%25[1234567890]'</SAMP>
<DD>
Matches a string of up to 25 digits.

<DT><SAMP>`%25[][]'</SAMP>
<DD>
Matches a string of up to 25 square brackets.

<DT><SAMP>`%25[^ \f\n\r\t\v]'</SAMP>
<DD>
Matches a string up to 25 characters long that doesn't contain any of
the standard whitespace characters.  This is slightly different from
<SAMP>`%s'</SAMP>, because if the input begins with a whitespace character,
<SAMP>`%['</SAMP> reports a matching failure while <SAMP>`%s'</SAMP> simply discards the
initial whitespace.

<DT><SAMP>`%25[a-z]'</SAMP>
<DD>
Matches up to 25 lowercase characters.
</DL>

<P>
One more reminder: the <SAMP>`%s'</SAMP> and <SAMP>`%['</SAMP> conversions are
<STRONG>dangerous</STRONG> if you don't specify a maximum width or use the
<SAMP>`a'</SAMP> flag, because input too long would overflow whatever buffer you
have provided for it.  No matter how long your buffer is, a user could
supply input that is longer.  A well-written program reports invalid
input with a comprehensible error message, not with a crash.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_189.html">previous</A>, <A HREF="libc_191.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
