<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Macro Definitions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_10.html">previous</A>, <A HREF="libc_12.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC11" HREF="libc_toc.html#TOC11">Macro Definitions of Functions</A></H3>
<P>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>

</P>
<P>
If we describe something as a function in this manual, it may have a
macro definition as well.  This normally has no effect on how your
program runs--the macro definition does the same thing as the function
would.  In particular, macro equivalents for library functions evaluate
arguments exactly once, in the same way that a function call would.  The
main reason for these macro definitions is that sometimes they can
produce an inline expansion that is considerably faster than an actual
function call.

</P>
<P>
Taking the address of a library function works even if it is also
defined as a macro.  This is because, in this context, the name of the
function isn't followed by the left parenthesis that is syntactically
necessary to recognize a macro call.

</P>
<P>
You might occasionally want to avoid using the macro definition of a
function--perhaps to make your program easier to debug.  There are
two ways you can do this:

</P>

<UL>
<LI>

You can avoid a macro definition in a specific use by enclosing the name
of the function in parentheses.  This works because the name of the
function doesn't appear in a syntactic context where it is recognizable
as a macro call.

<LI>

You can suppress any macro definition for a whole source file by using
the <SAMP>`#undef'</SAMP> preprocessor directive, unless otherwise stated
explicitly in the description of that facility.
</UL>

<P>
For example, suppose the header file <TT>`stdlib.h'</TT> declares a function
named <CODE>abs</CODE> with

</P>

<PRE>
extern int abs (int);
</PRE>

<P>
and also provides a macro definition for <CODE>abs</CODE>.  Then, in:

</P>

<PRE>
#include &#60;stdlib.h&#62;
int f (int *i) { return abs (++*i); }
</PRE>

<P>
the reference to <CODE>abs</CODE> might refer to either a macro or a function.
On the other hand, in each of the following examples the reference is
to a function and not a macro.

</P>

<PRE>
#include &#60;stdlib.h&#62;
int g (int *i) { return (abs) (++*i); }

#undef abs
int h (int *i) { return abs (++*i); }
</PRE>

<P>
Since macro definitions that double for a function behave in
exactly the same way as the actual function version, there is usually no
need for any of these methods.  In fact, removing macro definitions usually
just makes your program slower.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_10.html">previous</A>, <A HREF="libc_12.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
