<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Streams and Cookies</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_206.html">previous</A>, <A HREF="libc_208.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC214" HREF="libc_toc.html#TOC214">Custom Streams and Cookies</A></H4>
<P>
<A NAME="IDX943"></A>

</P>
<P>
Inside every custom stream is a special object called the <STRONG>cookie</STRONG>.
This is an object supplied by you which records where to fetch or store
the data read or written.  It is up to you to define a data type to use
for the cookie.  The stream functions in the library never refer
directly to its contents, and they don't even know what the type is;
they record its address with type <CODE>void *</CODE>.

</P>
<P>
To implement a custom stream, you must specify <EM>how</EM> to fetch or
store the data in the specified place.  You do this by defining
<STRONG>hook functions</STRONG> to read, write, change "file position", and close
the stream.  All four of these functions will be passed the stream's
cookie so they can tell where to fetch or store the data.  The library
functions don't know what's inside the cookie, but your functions will
know.

</P>
<P>
When you create a custom stream, you must specify the cookie pointer,
and also the four hook functions stored in a structure of type
<CODE>cookie_io_functions_t</CODE>.

</P>
<P>
These facilities are declared in <TT>`stdio.h'</TT>.
<A NAME="IDX944"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>cookie_io_functions_t</B>
<DD><A NAME="IDX945"></A>
This is a structure type that holds the functions that define the
communications protocol between the stream and its cookie.  It has
the following members:

</P>
<DL COMPACT>

<DT><CODE>cookie_read_function_t *read</CODE>
<DD>
This is the function that reads data from the cookie.  If the value is a
null pointer instead of a function, then read operations on this stream
always return <CODE>EOF</CODE>.

<DT><CODE>cookie_write_function_t *write</CODE>
<DD>
This is the function that writes data to the cookie.  If the value is a
null pointer instead of a function, then data written to the stream is
discarded.

<DT><CODE>cookie_seek_function_t *seek</CODE>
<DD>
This is the function that performs the equivalent of file positioning on
the cookie.  If the value is a null pointer instead of a function, calls
to <CODE>fseek</CODE> or <CODE>fseeko</CODE> on this stream can only seek to
locations within the buffer; any attempt to seek outside the buffer will
return an <CODE>ESPIPE</CODE> error.

<DT><CODE>cookie_close_function_t *close</CODE>
<DD>
This function performs any appropriate cleanup on the cookie when
closing the stream.  If the value is a null pointer instead of a
function, nothing special is done to close the cookie when the stream is
closed.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> FILE * <B>fopencookie</B> <I>(void *<VAR>cookie</VAR>, const char *<VAR>opentype</VAR>, cookie_io_functions_t <VAR>io-functions</VAR>)</I>
<DD><A NAME="IDX946"></A>
This function actually creates the stream for communicating with the
<VAR>cookie</VAR> using the functions in the <VAR>io-functions</VAR> argument.
The <VAR>opentype</VAR> argument is interpreted as for <CODE>fopen</CODE>;
see section <A HREF="libc_158.html#SEC165">Opening Streams</A>.  (But note that the "truncate on
open" option is ignored.)  The new stream is fully buffered.

</P>
<P>
The <CODE>fopencookie</CODE> function returns the newly created stream, or a null
pointer in case of an error.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_206.html">previous</A>, <A HREF="libc_208.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
