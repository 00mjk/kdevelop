<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Keeping the state</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_80.html">previous</A>, <A HREF="libc_82.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC81" HREF="libc_toc.html#TOC81">Representing the state of the conversion</A></H3>

<P>
<A NAME="IDX528"></A>
In the introduction of this chapter it was said that certain character
sets use a <STRONG>stateful</STRONG> encoding.  I.e., the encoded values depend in
some way on the previous bytes in the text.

</P>
<P>
Since the conversion functions allow converting a text in more than one
step we must have a way to pass this information from one call of the
functions to another.

</P>
<P>
<DL>
<DT><U>Data type:</U> <B>mbstate_t</B>
<DD><A NAME="IDX529"></A>
<A NAME="IDX530"></A>
A variable of type <CODE>mbstate_t</CODE> can contain all the information
about the <STRONG>shift state</STRONG> needed from one call to a conversion
function to another.

</P>
<P>
<A NAME="IDX531"></A>
This type is defined in <TT>`wchar.h'</TT>.  It got introduced in the second
amendment to ISO C89.
</DL>

</P>
<P>
To use objects of this type the programmer has to define such objects
(normally as local variables on the stack) and pass a pointer to the
object to the conversion functions.  This way the conversion function
can update the object if the current multibyte character set is
stateful.

</P>
<P>
There is no specific function or initializer to put the state object in
any specific state.  The rules are that the object should always
represent the initial state before the first use and this is achieved by
clearing the whole variable with code such as follows:

</P>

<PRE>
{
  mbstate_t state;
  memset (&#38;state, '\0', sizeof (state));
  /* from now on <VAR>state</VAR> can be used.  */
  ...
}
</PRE>

<P>
When using the conversion functions to generate output it is often
necessary to test whether the current state corresponds to the initial
state.  This is necessary, for example, to decide whether or not to emit
escape sequences to set the state to the initial state at certain
sequence points.  Communication protocols often require this.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>mbsinit</B> <I>(const mbstate_t *<VAR>ps</VAR>)</I>
<DD><A NAME="IDX532"></A>
This function determines whether the state object pointed to by <VAR>ps</VAR>
is in the initial state or not.  If <VAR>ps</VAR> is a null pointer or the
object is in the initial state the return value is nonzero.  Otherwise
it is zero.

</P>
<P>
<A NAME="IDX533"></A>
This function was introduced in the second amendment to ISO C89 and
is declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
Code using this function often looks similar to this:

</P>

<PRE>
{
  mbstate_t state;
  memset (&#38;state, '\0', sizeof (state));
  /* Use <VAR>state</VAR>.  */
  ...
  if (! mbsinit (&#38;state))
    {
      /* Emit code to return to initial state.  */
      const char empty[] = "";
      const char **srcp = &#38;empty;
      wcsrtombs (outbuf, &#38;srcp, outbuflen, &#38;state);
    }
  ...
}
</PRE>

<P>
The code to emit the escape sequence to get back to the initial state is
interesting.  The <CODE>wcsrtombs</CODE> function can be used to determine the
necessary output code (see section <A HREF="libc_83.html#SEC83">Converting Multibyte and Wide Character Strings</A>).  Please note that on
GNU systems it is not necessary to perform this extra action for the
conversion from multibyte text to wide character text since the wide
character encoding is not stateful.  But there is nothing mentioned in
any standard which prohibits making <CODE>wchar_t</CODE> using a stateful
encoding.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_80.html">previous</A>, <A HREF="libc_82.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
