<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Hash Search Function</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_123.html">previous</A>, <A HREF="libc_125.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC131" HREF="libc_toc.html#TOC131">The <CODE>hsearch</CODE> function.</A></H2>

<P>
The functions mentioned so far in this chapter are searching in a sorted
or unsorted array.  There are other methods to organize information
which later should be searched.  The costs of insert, delete and search
differ.  One possible implementation is using hashing tables.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>hcreate</B> <I>(size_t <VAR>nel</VAR>)</I>
<DD><A NAME="IDX709"></A>
The <CODE>hcreate</CODE> function creates a hashing table which can contain at
least <VAR>nel</VAR> elements.  There is no possibility to grow this table so
it is necessary to choose the value for <VAR>nel</VAR> wisely.  The used
methods to implement this function might make it necessary to make the
number of elements in the hashing table larger than the expected maximal
number of elements.  Hashing tables usually work inefficient if they are
filled 80% or more.  The constant access time guaranteed by hashing can
only be achieved if few collisions exist.  See Knuth's "The Art of
Computer Programming, Part 3: Searching and Sorting" for more
information.

</P>
<P>
The weakest aspect of this function is that there can be at most one
hashing table used through the whole program.  The table is allocated
in local memory out of control of the programmer.  As an extension the
GNU C library provides an additional set of functions with an reentrant
interface which provide a similar interface but which allow to keep
arbitrarily many hashing tables.

</P>
<P>
It is possible to use more than one hashing table in the program run if
the former table is first destroyed by a call to <CODE>hdestroy</CODE>.

</P>
<P>
The function returns a non-zero value if successful.  If it return zero
something went wrong.  This could either mean there is already a hashing
table in use or the program runs out of memory.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>hdestroy</B> <I>(void)</I>
<DD><A NAME="IDX710"></A>
The <CODE>hdestroy</CODE> function can be used to free all the resources
allocated in a previous call of <CODE>hcreate</CODE>.  After a call to this
function it is again possible to call <CODE>hcreate</CODE> and allocate a new
table with possibly different size.

</P>
<P>
It is important to remember that the elements contained in the hashing
table at the time <CODE>hdestroy</CODE> is called are <EM>not</EM> freed by this
function.  It is the responsibility of the program code to free those
strings (if necessary at all).  Freeing all the element memory is not
possible without extra, separately kept information since there is no
function to iterate through all available elements in the hashing table.
If it is really necessary to free a table and all elements the
programmer has to keep a list of all table elements and before calling
<CODE>hdestroy</CODE> s/he has to free all element's data using this list.
This is a very unpleasant mechanism and it also shows that this kind of
hashing tables is mainly meant for tables which are created once and
used until the end of the program run.
</DL>

</P>
<P>
Entries of the hashing table and keys for the search are defined using
this type:

</P>
<P>
<DL>
<DT><U>Data type:</U> <B>struct ENTRY</B>
<DD><A NAME="IDX711"></A>
Both elements of this structure are pointers to zero-terminated strings.
This is a limiting restriction of the functionality of the
<CODE>hsearch</CODE> functions.  They can only be used for data sets which use
the NUL character always and solely to terminate the records.  It is not
possible to handle general binary data.

</P>
<DL COMPACT>

<DT><CODE>char *key</CODE>
<DD>
Pointer to a zero-terminated string of characters describing the key for
the search or the element in the hashing table.
<DT><CODE>char *data</CODE>
<DD>
Pointer to a zero-terminated string of characters describing the data.
If the functions will be called only for searching an existing entry
this element might stay undefined since it is not used.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> ENTRY * <B>hsearch</B> <I>(ENTRY <VAR>item</VAR>, ACTION <VAR>action</VAR>)</I>
<DD><A NAME="IDX712"></A>
To search in a hashing table created using <CODE>hcreate</CODE> the
<CODE>hsearch</CODE> function must be used.  This function can perform simple
search for an element (if <VAR>action</VAR> has the <CODE>FIND</CODE>) or it can
alternatively insert the key element into the hashing table, possibly
replacing a previous value (if <VAR>action</VAR> is <CODE>ENTER</CODE>).

</P>
<P>
The key is denoted by a pointer to an object of type <CODE>ENTRY</CODE>.  For
locating the corresponding position in the hashing table only the
<CODE>key</CODE> element of the structure is used.

</P>
<P>
The return value depends on the <VAR>action</VAR> parameter value.  If it is
<CODE>FIND</CODE> the value is a pointer to the matching element in the
hashing table or <CODE>NULL</CODE> if no matching element exists.  If
<VAR>action</VAR> is <CODE>ENTER</CODE> the return value is only <CODE>NULL</CODE> if the
programs runs out of memory while adding the new element to the table.
Otherwise the return value is a pointer to the element in the hashing
table which contains newly added element based on the data in <VAR>key</VAR>.
</DL>

</P>
<P>
As mentioned before the hashing table used by the functions described so
far is global and there can be at any time at most one hashing table in
the program.  A solution is to use the following functions which are a
GNU extension.  All have in common that they operate on a hashing table
which is described by the content of an object of the type <CODE>struct
hsearch_data</CODE>.  This type should be treated as opaque, none of its
members should be changed directly.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>hcreate_r</B> <I>(size_t <VAR>nel</VAR>, struct hsearch_data *<VAR>htab</VAR>)</I>
<DD><A NAME="IDX713"></A>
The <CODE>hcreate_r</CODE> function initializes the object pointed to by
<VAR>htab</VAR> to contain a hashing table with at least <VAR>nel</VAR> elements.
So this function is equivalent to the <CODE>hcreate</CODE> function except
that the initialized data structure is controlled by the user.

</P>
<P>
This allows to have more than once hashing table at one time.  The
memory necessary for the <CODE>struct hsearch_data</CODE> object can be
allocated dynamically.

</P>
<P>
The return value is non-zero if the operation were successful.  if the
return value is zero something went wrong which probably means the
programs runs out of memory.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>hdestroy_r</B> <I>(struct hsearch_data *<VAR>htab</VAR>)</I>
<DD><A NAME="IDX714"></A>
The <CODE>hdestroy_r</CODE> function frees all resources allocated by the
<CODE>hcreate_r</CODE> function for this very same object <VAR>htab</VAR>.  As for
<CODE>hdestroy</CODE> it is the programs responsibility to free the strings
for the elements of the table.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>hsearch_r</B> <I>(ENTRY <VAR>item</VAR>, ACTION <VAR>action</VAR>, ENTRY **<VAR>retval</VAR>, struct hsearch_data *<VAR>htab</VAR>)</I>
<DD><A NAME="IDX715"></A>
The <CODE>hsearch_r</CODE> function is equivalent to <CODE>hsearch</CODE>.  The
meaning of the first two arguments is identical.  But instead of
operating on a single global hashing table the function works on the
table described by the object pointed to by <VAR>htab</VAR> (which is
initialized by a call to <CODE>hcreate_r</CODE>).

</P>
<P>
Another difference to <CODE>hcreate</CODE> is that the pointer to the found
entry in the table is not the return value of the functions.  It is
returned by storing it in a pointer variables pointed to by the
<VAR>retval</VAR> parameter.  The return value of the function is an integer
value indicating success if it is non-zero and failure if it is zero.
In the latter case the global variable <VAR>errno</VAR> signals the reason for
the failure.

</P>
<DL COMPACT>

<DT><CODE>ENOMEM</CODE>
<DD>
The table is filled and <CODE>hsearch_r</CODE> was called with an so far
unknown key and <VAR>action</VAR> set to <CODE>ENTER</CODE>.
<DT><CODE>ESRCH</CODE>
<DD>
The <VAR>action</VAR> parameter is <CODE>FIND</CODE> and no corresponding element
is found in the table.
</DL>
</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_123.html">previous</A>, <A HREF="libc_125.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
