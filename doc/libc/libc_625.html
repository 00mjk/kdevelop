<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Null Pointer Constant</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_624.html">previous</A>, <A HREF="libc_626.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC633" HREF="libc_toc.html#TOC633">Null Pointer Constant</A></H2>
<P>
<A NAME="IDX3230"></A>

</P>
<P>
The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type <CODE>void
*</CODE>.  The preferred way to write a null pointer constant is with
<CODE>NULL</CODE>.

</P>
<P>
<DL>
<DT><U>Macro:</U> void * <B>NULL</B>
<DD><A NAME="IDX3231"></A>
This is a null pointer constant.
</DL>

</P>
<P>
You can also use <CODE>0</CODE> or <CODE>(void *)0</CODE> as a null pointer
constant, but using <CODE>NULL</CODE> is cleaner because it makes the purpose
of the constant more evident.

</P>
<P>
If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won't know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_624.html">previous</A>, <A HREF="libc_626.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
