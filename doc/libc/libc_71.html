<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Finding Tokens in a String</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_70.html">previous</A>, <A HREF="libc_72.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC71" HREF="libc_toc.html#TOC71">Finding Tokens in a String</A></H2>

<P>
<A NAME="IDX470"></A>
<A NAME="IDX471"></A>
<A NAME="IDX472"></A>
It's fairly common for programs to have a need to do some simple kinds
of lexical analysis and parsing, such as splitting a command string up
into tokens.  You can do this with the <CODE>strtok</CODE> function, declared
in the header file <TT>`string.h'</TT>.
<A NAME="IDX473"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strtok</B> <I>(char *<VAR>newstring</VAR>, const char *<VAR>delimiters</VAR>)</I>
<DD><A NAME="IDX474"></A>
A string can be split into tokens by making a series of calls to the
function <CODE>strtok</CODE>.

</P>
<P>
The string to be split up is passed as the <VAR>newstring</VAR> argument on
the first call only.  The <CODE>strtok</CODE> function uses this to set up
some internal state information.  Subsequent calls to get additional
tokens from the same string are indicated by passing a null pointer as
the <VAR>newstring</VAR> argument.  Calling <CODE>strtok</CODE> with another
non-null <VAR>newstring</VAR> argument reinitializes the state information.
It is guaranteed that no other library function ever calls <CODE>strtok</CODE>
behind your back (which would mess up this internal state information).

</P>
<P>
The <VAR>delimiters</VAR> argument is a string that specifies a set of delimiters
that may surround the token being extracted.  All the initial characters
that are members of this set are discarded.  The first character that is
<EM>not</EM> a member of this set of delimiters marks the beginning of the
next token.  The end of the token is found by looking for the next
character that is a member of the delimiter set.  This character in the
original string <VAR>newstring</VAR> is overwritten by a null character, and the
pointer to the beginning of the token in <VAR>newstring</VAR> is returned.

</P>
<P>
On the next call to <CODE>strtok</CODE>, the searching begins at the next
character beyond the one that marked the end of the previous token.
Note that the set of delimiters <VAR>delimiters</VAR> do not have to be the
same on every call in a series of calls to <CODE>strtok</CODE>.

</P>
<P>
If the end of the string <VAR>newstring</VAR> is reached, or if the remainder of
string consists only of delimiter characters, <CODE>strtok</CODE> returns
a null pointer.
</DL>

</P>
<P>
<STRONG>Warning:</STRONG> Since <CODE>strtok</CODE> alters the string it is parsing,
you should always copy the string to a temporary buffer before parsing
it with <CODE>strtok</CODE>.  If you allow <CODE>strtok</CODE> to modify a string
that came from another part of your program, you are asking for trouble;
that string might be used for other purposes after <CODE>strtok</CODE> has
modified it, and it would not have the expected value.

</P>
<P>
The string that you are operating on might even be a constant.  Then
when <CODE>strtok</CODE> tries to modify it, your program will get a fatal
signal for writing in read-only memory.  See section <A HREF="libc_423.html#SEC430">Program Error Signals</A>.

</P>
<P>
This is a special case of a general principle: if a part of a program
does not have as its purpose the modification of a certain data
structure, then it is error-prone to modify the data structure
temporarily.

</P>
<P>
The function <CODE>strtok</CODE> is not reentrant.  See section <A HREF="libc_444.html#SEC451">Signal Handling and Nonreentrant Functions</A>, for
a discussion of where and why reentrancy is important.

</P>
<P>
Here is a simple example showing the use of <CODE>strtok</CODE>.

</P>

<PRE>
#include &#60;string.h&#62;
#include &#60;stddef.h&#62;

...

const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *token, *cp;

...

cp = strdupa (string);                /* Make writable copy.  */
token = strtok (cp, delimiters);      /* token =&#62; "words" */
token = strtok (NULL, delimiters);    /* token =&#62; "separated" */
token = strtok (NULL, delimiters);    /* token =&#62; "by" */
token = strtok (NULL, delimiters);    /* token =&#62; "spaces" */
token = strtok (NULL, delimiters);    /* token =&#62; "and" */
token = strtok (NULL, delimiters);    /* token =&#62; "punctuation" */
token = strtok (NULL, delimiters);    /* token =&#62; NULL */
</PRE>

<P>
The GNU C library contains two more functions for tokenizing a string
which overcome the limitation of non-reentrancy.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strtok_r</B> <I>(char *<VAR>newstring</VAR>, const char *<VAR>delimiters</VAR>, char **<VAR>save_ptr</VAR>)</I>
<DD><A NAME="IDX475"></A>
Just like <CODE>strtok</CODE>, this function splits the string into several
tokens which can be accessed by successive calls to <CODE>strtok_r</CODE>.
The difference is that the information about the next token is stored in
the space pointed to by the third argument, <VAR>save_ptr</VAR>, which is a
pointer to a string pointer.  Calling <CODE>strtok_r</CODE> with a null
pointer for <VAR>newstring</VAR> and leaving <VAR>save_ptr</VAR> between the calls
unchanged does the job without hindering reentrancy.

</P>
<P>
This function is defined in POSIX-1 and can be found on many systems
which support multi-threading.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strsep</B> <I>(char **<VAR>string_ptr</VAR>, const char *<VAR>delimiter</VAR>)</I>
<DD><A NAME="IDX476"></A>
This function is just <CODE>strtok_r</CODE> with the <VAR>newstring</VAR> argument
replaced by the <VAR>save_ptr</VAR> argument.  The initialization of the
moving pointer has to be done by the user.  Successive calls to
<CODE>strsep</CODE> move the pointer along the tokens separated by
<VAR>delimiter</VAR>, returning the address of the next token and updating
<VAR>string_ptr</VAR> to point to the beginning of the next token.

</P>
<P>
If the input string contains more than one character from
<VAR>delimiter</VAR> in a row <CODE>strsep</CODE> returns an empty string for each
pair of characters from <VAR>delimiter</VAR>.  This means that a program
normally should test for <CODE>strsep</CODE> returning an empty string before
processing it.

</P>
<P>
This function was introduced in 4.3BSD and therefore is widely available.
</DL>

</P>
<P>
Here is how the above example looks like when <CODE>strsep</CODE> is used.

</P>

<PRE>
#include &#60;string.h&#62;
#include &#60;stddef.h&#62;

...

const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *running;
char *token;

...

running = strdupa (string);
token = strsep (&#38;running, delimiters);    /* token =&#62; "words" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "separated" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "by" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "spaces" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "and" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "punctuation" */
token = strsep (&#38;running, delimiters);    /* token =&#62; "" */
token = strsep (&#38;running, delimiters);    /* token =&#62; NULL */
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_70.html">previous</A>, <A HREF="libc_72.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
