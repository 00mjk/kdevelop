<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Converting Strings</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_82.html">previous</A>, <A HREF="libc_84.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC83" HREF="libc_toc.html#TOC83">Converting Multibyte and Wide Character Strings</A></H3>

<P>
The functions described in the previous section only convert a single
character at a time.  Most operations to be performed in real-world
programs include strings and therefore the ISO C standard also
defines conversions on entire strings.  However, the defined set of
functions is quite limited, thus the GNU C library contains a few
extensions which can help in some important situations.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>mbsrtowcs</B> <I>(wchar_t *restrict <VAR>dst</VAR>, const char **restrict <VAR>src</VAR>, size_t <VAR>len</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX545"></A>
The <CODE>mbsrtowcs</CODE> function ("multibyte string restartable to wide
character string") converts an NUL terminated multibyte character
string at <CODE>*<VAR>src</VAR></CODE> into an equivalent wide character string,
including the NUL wide character at the end.  The conversion is started
using the state information from the object pointed to by <VAR>ps</VAR> or
from an internal object of <CODE>mbsrtowcs</CODE> if <VAR>ps</VAR> is a null
pointer.  Before returning the state object to match the state after the
last converted character.  The state is the initial state if the
terminating NUL byte is reached and converted.

</P>
<P>
If <VAR>dst</VAR> is not a null pointer the result is stored in the array
pointed to by <VAR>dst</VAR>, otherwise the conversion result is not
available since it is stored in an internal buffer.

</P>
<P>
If <VAR>len</VAR> wide characters are stored in the array <VAR>dst</VAR> before
reaching the end of the input string the conversion stops and <VAR>len</VAR>
is returned.  If <VAR>dst</VAR> is a null pointer <VAR>len</VAR> is never checked.

</P>
<P>
Another reason for a premature return from the function call is if the
input string contains an invalid multibyte sequence.  In this case the
global variable <CODE>errno</CODE> is set to <CODE>EILSEQ</CODE> and the function
returns <CODE>(size_t) -1</CODE>.

</P>

<P>
In all other cases the function returns the number of wide characters
converted during this call.  If <VAR>dst</VAR> is not null <CODE>mbsrtowcs</CODE>
stores in the pointer pointed to by <VAR>src</VAR> a null pointer (if the NUL
byte in the input string was reached) or the address of the byte
following the last converted multibyte character.

</P>
<P>
<A NAME="IDX546"></A>
This function was introduced in the second amendment to ISO C and is
declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
The definition of this function has one limitation which has to be
understood.  The requirement that <VAR>dst</VAR> has to be a NUL terminated
string provides problems if one wants to convert buffers with text.  A
buffer is normally no collection of NUL terminated strings but instead a
continuous collection of lines, separated by newline characters.  Now
assume a function to convert one line from a buffer is needed.  Since
the line is not NUL terminated the source pointer cannot directly point
into the unmodified text buffer.  This means, either one inserts the NUL
byte at the appropriate place for the time of the <CODE>mbsrtowcs</CODE>
function call (which is not doable for a read-only buffer or in a
multi-threaded application) or one copies the line in an extra buffer
where it can be terminated by a NUL byte.  Note that it is not in
general possible to limit the number of characters to convert by setting
the parameter <VAR>len</VAR> to any specific value.  Since it is not known
how many bytes each multibyte character sequence is in length one always
could do only a guess.

</P>
<P>
<A NAME="IDX547"></A>
There is still a problem with the method of NUL-terminating a line right
after the newline character which could lead to very strange results.
As said in the description of the <VAR>mbsrtowcs</VAR> function above the
conversion state is guaranteed to be in the initial shift state after
processing the NUL byte at the end of the input string.  But this NUL
byte is not really part of the text.  I.e., the conversion state after
the newline in the original text could be something different than the
initial shift state and therefore the first character of the next line
is encoded using this state.  But the state in question is never
accessible to the user since the conversion stops after the NUL byte
(which resets the state).  Most stateful character sets in use today
require that the shift state after a newline is the initial state--but
this is not a strict guarantee.  Therefore simply NUL terminating a
piece of a running text is not always an adequate solution and therefore
never should be used in generally used code.

</P>
<P>
The generic conversion interface (see section <A HREF="libc_89.html#SEC89">Generic Charset Conversion</A>)
does not have this limitation (it simply works on buffers, not
strings), and the GNU C library contains a set of functions which take
additional parameters specifying the maximal number of bytes which are
consumed from the input string.  This way the problem of
<CODE>mbsrtowcs</CODE>'s example above could be solved by determining the line
length and passing this length to the function.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>wcsrtombs</B> <I>(char *restrict <VAR>dst</VAR>, const wchar_t **restrict <VAR>src</VAR>, size_t <VAR>len</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX548"></A>
The <CODE>wcsrtombs</CODE> function ("wide character string restartable to
multibyte string") converts the NUL terminated wide character string at
<CODE>*<VAR>src</VAR></CODE> into an equivalent multibyte character string and
stores the result in the array pointed to by <VAR>dst</VAR>.  The NUL wide
character is also converted.  The conversion starts in the state
described in the object pointed to by <VAR>ps</VAR> or by a state object
locally to <CODE>wcsrtombs</CODE> in case <VAR>ps</VAR> is a null pointer.  If
<VAR>dst</VAR> is a null pointer the conversion is performed as usual but the
result is not available.  If all characters of the input string were
successfully converted and if <VAR>dst</VAR> is not a null pointer the
pointer pointed to by <VAR>src</VAR> gets assigned a null pointer.

</P>
<P>
If one of the wide characters in the input string has no valid multibyte
character equivalent the conversion stops early, sets the global
variable <CODE>errno</CODE> to <CODE>EILSEQ</CODE>, and returns <CODE>(size_t) -1</CODE>.

</P>
<P>
Another reason for a premature stop is if <VAR>dst</VAR> is not a null
pointer and the next converted character would require more than
<VAR>len</VAR> bytes in total to the array <VAR>dst</VAR>.  In this case (and if
<VAR>dest</VAR> is not a null pointer) the pointer pointed to by <VAR>src</VAR> is
assigned a value pointing to the wide character right after the last one
successfully converted.

</P>
<P>
Except in the case of an encoding error the return value of the function
is the number of bytes in all the multibyte character sequences stored
in <VAR>dst</VAR>.  Before returning the state in the object pointed to by
<VAR>ps</VAR> (or the internal object in case <VAR>ps</VAR> is a null pointer) is
updated to reflect the state after the last conversion.  The state is
the initial shift state in case the terminating NUL wide character was
converted.

</P>
<P>
<A NAME="IDX549"></A>
This function was introduced in the second amendment to ISO C and is
declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
The restriction mentions above for the <CODE>mbsrtowcs</CODE> function applies
also here.  There is no possibility to directly control the number of
input characters.  One has to place the NUL wide character at the
correct place or control the consumed input indirectly via the available
output array size (the <VAR>len</VAR> parameter).

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>mbsnrtowcs</B> <I>(wchar_t *restrict <VAR>dst</VAR>, const char **restrict <VAR>src</VAR>, size_t <VAR>nmc</VAR>, size_t <VAR>len</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX550"></A>
The <CODE>mbsnrtowcs</CODE> function is very similar to the <CODE>mbsrtowcs</CODE>
function.  All the parameters are the same except for <VAR>nmc</VAR> which is
new.  The return value is the same as for <CODE>mbsrtowcs</CODE>.

</P>
<P>
This new parameter specifies how many bytes at most can be used from the
multibyte character string.  I.e., the multibyte character string
<CODE>*<VAR>src</VAR></CODE> need not be NUL terminated.  But if a NUL byte is
found within the <VAR>nmc</VAR> first bytes of the string the conversion
stops here.

</P>
<P>
This function is a GNU extensions.  It is meant to work around the
problems mentioned above.  Now it is possible to convert buffer with
multibyte character text piece for piece without having to care about
inserting NUL bytes and the effect of NUL bytes on the conversion state.
</DL>

</P>
<P>
A function to convert a multibyte string into a wide character string
and display it could be written like this (this is not a really useful
example):

</P>

<PRE>
void
showmbs (const char *src, FILE *fp)
{
  mbstate_t state;
  int cnt = 0;
  memset (&#38;state, '\0', sizeof (state));
  while (1)
    {
      wchar_t linebuf[100];
      const char *endp = strchr (src, '\n');
      size_t n;

      /* Exit if there is no more line.  */
      if (endp == NULL)
        break;

      n = mbsnrtowcs (linebuf, &#38;src, endp - src, 99, &#38;state);
      linebuf[n] = L'\0';
      fprintf (fp, "line %d: \"%S\"\n", linebuf);
    }
}
</PRE>

<P>
There is no problem with the state after a call to <CODE>mbsnrtowcs</CODE>.
Since we don't insert characters in the strings which were not in there
right from the beginning and we use <VAR>state</VAR> only for the conversion
of the given buffer there is no problem with altering the state.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>wcsnrtombs</B> <I>(char *restrict <VAR>dst</VAR>, const wchar_t **restrict <VAR>src</VAR>, size_t <VAR>nwc</VAR>, size_t <VAR>len</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX551"></A>
The <CODE>wcsnrtombs</CODE> function implements the conversion from wide
character strings to multibyte character strings.  It is similar to
<CODE>wcsrtombs</CODE> but it takes, just like <CODE>mbsnrtowcs</CODE>, an extra
parameter which specifies the length of the input string.

</P>
<P>
No more than <VAR>nwc</VAR> wide characters from the input string
<CODE>*<VAR>src</VAR></CODE> are converted.  If the input string contains a NUL
wide character in the first <VAR>nwc</VAR> character to conversion stops at
this place.

</P>
<P>
This function is a GNU extension and just like <CODE>mbsnrtowcs</CODE> is
helps in situations where no NUL terminated input strings are available.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_82.html">previous</A>, <A HREF="libc_84.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
