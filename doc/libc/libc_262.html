<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Reading Attributes</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_261.html">previous</A>, <A HREF="libc_263.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC269" HREF="libc_toc.html#TOC269">Reading the Attributes of a File</A></H3>

<P>
To examine the attributes of files, use the functions <CODE>stat</CODE>,
<CODE>fstat</CODE> and <CODE>lstat</CODE>.  They return the attribute information in
a <CODE>struct stat</CODE> object.  All three functions are declared in the
header file <TT>`sys/stat.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>stat</B> <I>(const char *<VAR>filename</VAR>, struct stat *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1268"></A>
The <CODE>stat</CODE> function returns information about the attributes of the
file named by <VAR>filename</VAR> in the structure pointed at by <VAR>buf</VAR>.

</P>
<P>
If <VAR>filename</VAR> is the name of a symbolic link, the attributes you get
describe the file that the link points to.  If the link points to a
nonexistent file name, then <CODE>stat</CODE> fails, reporting a nonexistent
file.

</P>
<P>
The return value is <CODE>0</CODE> if the operation is successful, and <CODE>-1</CODE>
on failure.  In addition to the usual file name errors
(see section <A HREF="libc_153.html#SEC160">File Name Errors</A>, the following <CODE>errno</CODE> error conditions
are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>ENOENT</CODE>
<DD>
The file named by <VAR>filename</VAR> doesn't exist.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>stat64</CODE> since the LFS interface transparently
replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>stat64</B> <I>(const char *<VAR>filename</VAR>, struct stat64 *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1269"></A>
This function is similar to <CODE>stat</CODE> but it is also able to work on
file larger then @math{2^31} bytes on 32 bits systems.  To be able to do
this the result is stored in a variable of type <CODE>struct stat64</CODE> to
which <VAR>buf</VAR> must point.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>stat</CODE> and so transparently
replaces the interface for small files on 32 bits machines.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fstat</B> <I>(int <VAR>filedes</VAR>, struct stat *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1270"></A>
The <CODE>fstat</CODE> function is like <CODE>stat</CODE>, except that it takes an
open file descriptor as an argument instead of a file name.
See section <A HREF="libc_213.html#SEC220">Low-Level Input/Output</A>.

</P>
<P>
Like <CODE>stat</CODE>, <CODE>fstat</CODE> returns <CODE>0</CODE> on success and <CODE>-1</CODE>
on failure.  The following <CODE>errno</CODE> error conditions are defined for
<CODE>fstat</CODE>:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>filedes</VAR> argument is not a valid file descriptor.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>fstat64</CODE> since the LFS interface transparently
replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fstat64</B> <I>(int <VAR>filedes</VAR>, struct stat64 *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1271"></A>
This function is similar to <CODE>fstat</CODE> but it is prepared to work on
large files on 32 bits platforms.  For large files the file descriptor
<VAR>filedes</VAR> should be returned by <CODE>open64</CODE> or <CODE>creat64</CODE>.
The <VAR>buf</VAR> pointer points to a variable of type <CODE>struct stat64</CODE>
which is able to represent the larger values.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>fstat</CODE> and so transparently
replaces the interface for small files on 32 bits machines.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lstat</B> <I>(const char *<VAR>filename</VAR>, struct stat *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1272"></A>
The <CODE>lstat</CODE> function is like <CODE>stat</CODE>, except that it does not
follow symbolic links.  If <VAR>filename</VAR> is the name of a symbolic
link, <CODE>lstat</CODE> returns information about the link itself; otherwise,
<CODE>lstat</CODE> works like <CODE>stat</CODE>.  See section <A HREF="libc_256.html#SEC263">Symbolic Links</A>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>lstat64</CODE> since the LFS interface transparently
replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lstat64</B> <I>(const char *<VAR>filename</VAR>, struct stat64 *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX1273"></A>
This function is similar to <CODE>lstat</CODE> but it is also able to work on
file larger then @math{2^31} bytes on 32 bits systems.  To be able to do
this the result is stored in a variable of type <CODE>struct stat64</CODE> to
which <VAR>buf</VAR> must point.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>lstat</CODE> and so transparently
replaces the interface for small files on 32 bits machines.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_261.html">previous</A>, <A HREF="libc_263.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
