<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Encode Binary Data</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_71.html">previous</A>, <A HREF="libc_73.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC72" HREF="libc_toc.html#TOC72">Encode Binary Data</A></H2>

<P>
To store or transfer binary data in environments which only support text
one has to encode the binary data by mapping the input bytes to
characters in the range allowed for storing or transfering.  SVID
systems (and nowadays XPG compliant systems) provide minimal support for
this task.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>l64a</B> <I>(long int <VAR>n</VAR>)</I>
<DD><A NAME="IDX477"></A>
This function encodes a 32-bit input value using characters from the
basic character set.  It returns a pointer to a 6 character buffer which
contains an encoded version of <VAR>n</VAR>.  To encode a series of bytes the
user must copy the returned string to a destination buffer.  It returns
the empty string if <VAR>n</VAR> is zero, which is somewhat bizarre but
mandated by the standard.<BR>
<STRONG>Warning:</STRONG> Since a static buffer is used this function should not
be used in multi-threaded programs.  There is no thread-safe alternative
to this function in the C library.<BR>
<STRONG>Compatibility Note:</STRONG> The XPG standard states that the return
value of <CODE>l64a</CODE> is undefined if <VAR>n</VAR> is negative.  In the GNU
implementation, <CODE>l64a</CODE> treats its argument as unsigned, so it will
return a sensible encoding for any nonzero <VAR>n</VAR>; however, portable
programs should not rely on this.

</P>
<P>
To encode a large buffer <CODE>l64a</CODE> must be called in a loop, once for
each 32-bit word of the buffer.  For example, one could do something
like this:

</P>

<PRE>
char *
encode (const void *buf, size_t len)
{
  /* We know in advance how long the buffer has to be. */
  unsigned char *in = (unsigned char *) buf;
  char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
  char *cp = out;

  /* Encode the length. */
  /* Using `htonl' is necessary so that the data can be
     decoded even on machines with different byte order. */

  cp = mempcpy (cp, l64a (htonl (len)), 6);

  while (len &#62; 3)
    {
      unsigned long int n = *in++;
      n = (n &#60;&#60; 8) | *in++;
      n = (n &#60;&#60; 8) | *in++;
      n = (n &#60;&#60; 8) | *in++;
      len -= 4;
      if (n)
        cp = mempcpy (cp, l64a (htonl (n)), 6);
      else
            /* `l64a' returns the empty string for n==0, so we 
               must generate its encoding ("......") by hand. */
        cp = stpcpy (cp, "......");
    }
  if (len &#62; 0)
    {
      unsigned long int n = *in++;
      if (--len &#62; 0)
        {
          n = (n &#60;&#60; 8) | *in++;
          if (--len &#62; 0)
            n = (n &#60;&#60; 8) | *in;
        }
      memcpy (cp, l64a (htonl (n)), 6);
      cp += 6;
    }
  *cp = '\0';
  return out;
}
</PRE>

<P>
It is strange that the library does not provide the complete
functionality needed but so be it.

</P>
</DL>

<P>
To decode data produced with <CODE>l64a</CODE> the following function should be
used.

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>a64l</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX478"></A>
The parameter <VAR>string</VAR> should contain a string which was produced by
a call to <CODE>l64a</CODE>.  The function processes at least 6 characters of
this string, and decodes the characters it finds according to the table
below.  It stops decoding when it finds a character not in the table,
rather like <CODE>atoi</CODE>; if you have a buffer which has been broken into
lines, you must be careful to skip over the end-of-line characters.

</P>
<P>
The decoded number is returned as a <CODE>long int</CODE> value.
</DL>

</P>
<P>
The <CODE>l64a</CODE> and <CODE>a64l</CODE> functions use a base 64 encoding, in
which each character of an encoded string represents six bits of an
input word.  These symbols are used for the base 64 digits:

</P>
<P>
@multitable {xxxxx} {xxx} {xxx} {xxx} {xxx} {xxx} {xxx} {xxx} {xxx}
<LI>@tab 0 @tab 1 @tab 2 @tab 3 @tab 4 @tab 5 @tab 6 @tab 7

<LI>0      @tab <CODE>.</CODE> @tab <CODE>/</CODE> @tab <CODE>0</CODE> @tab <CODE>1</CODE>

                   @tab <CODE>2</CODE> @tab <CODE>3</CODE> @tab <CODE>4</CODE> @tab <CODE>5</CODE>
<LI>8      @tab <CODE>6</CODE> @tab <CODE>7</CODE> @tab <CODE>8</CODE> @tab <CODE>9</CODE>

                   @tab <CODE>A</CODE> @tab <CODE>B</CODE> @tab <CODE>C</CODE> @tab <CODE>D</CODE>
<LI>16     @tab <CODE>E</CODE> @tab <CODE>F</CODE> @tab <CODE>G</CODE> @tab <CODE>H</CODE>

                   @tab <CODE>I</CODE> @tab <CODE>J</CODE> @tab <CODE>K</CODE> @tab <CODE>L</CODE>
<LI>24     @tab <CODE>M</CODE> @tab <CODE>N</CODE> @tab <CODE>O</CODE> @tab <CODE>P</CODE>

                   @tab <CODE>Q</CODE> @tab <CODE>R</CODE> @tab <CODE>S</CODE> @tab <CODE>T</CODE>
<LI>32     @tab <CODE>U</CODE> @tab <CODE>V</CODE> @tab <CODE>W</CODE> @tab <CODE>X</CODE>

                   @tab <CODE>Y</CODE> @tab <CODE>Z</CODE> @tab <CODE>a</CODE> @tab <CODE>b</CODE>
<LI>40     @tab <CODE>c</CODE> @tab <CODE>d</CODE> @tab <CODE>e</CODE> @tab <CODE>f</CODE>

                   @tab <CODE>g</CODE> @tab <CODE>h</CODE> @tab <CODE>i</CODE> @tab <CODE>j</CODE>
<LI>48     @tab <CODE>k</CODE> @tab <CODE>l</CODE> @tab <CODE>m</CODE> @tab <CODE>n</CODE>

                   @tab <CODE>o</CODE> @tab <CODE>p</CODE> @tab <CODE>q</CODE> @tab <CODE>r</CODE>
<LI>56     @tab <CODE>s</CODE> @tab <CODE>t</CODE> @tab <CODE>u</CODE> @tab <CODE>v</CODE>

                   @tab <CODE>w</CODE> @tab <CODE>x</CODE> @tab <CODE>y</CODE> @tab <CODE>z</CODE>

This encoding scheme is not standard.  There are some other encoding
methods which are much more widely used (UU encoding, MIME encoding).
Generally, it is better to use one of these encodings.

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_71.html">previous</A>, <A HREF="libc_73.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
