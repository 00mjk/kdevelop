<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Working on Directory Trees</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_253.html">previous</A>, <A HREF="libc_255.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC261" HREF="libc_toc.html#TOC261">Working on Directory Trees</A></H2>
<P>
<A NAME="IDX1199"></A>
<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>

</P>
<P>
The functions to handle files in directories described so far allowed to
retrieve all the information in small pieces or process all files in a
directory (see <CODE>scandir</CODE>).  Sometimes it is useful to process whole
hierarchies of directories and the contained files.  The X/Open
specification define two functions to do this.  The simpler form is
derived from an early definition in System V systems and therefore
this function is available on SVID derived systems.  The prototypes and
required definitions can be found in the <TT>`ftw.h'</TT> header.

</P>
<P>
Both functions of this <CODE>ftw</CODE> family take as one of the arguments a
reference to a callback function.  The functions must be of these types.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>__ftw_func_t</B>
<DD><A NAME="IDX1202"></A>

</P>

<PRE>
int (*) (const char *, const struct stat *, int)
</PRE>

<P>
Type for callback functions given to the <CODE>ftw</CODE> function.  The first
parameter will contain a pointer to the filename, the second parameter
will point to an object of type <CODE>struct stat</CODE> which will be filled
for the file named by the first parameter.

</P>
<P>
The last parameter is a flag given more information about the current
file.  It can have the following values:

</P>
<DL COMPACT>

<DT><CODE>FTW_F</CODE>
<DD>
<A NAME="IDX1203"></A>
The current item is a normal file or files which do not fit into one of
the following categories.  This means especially special files, sockets
etc.
<DT><CODE>FTW_D</CODE>
<DD>
<A NAME="IDX1204"></A>
The current item is a directory.
<DT><CODE>FTW_NS</CODE>
<DD>
<A NAME="IDX1205"></A>
The <CODE>stat</CODE> call to fill the object pointed to by the second
parameter failed and so the information is invalid.
<DT><CODE>FTW_DNR</CODE>
<DD>
<A NAME="IDX1206"></A>
The item is a directory which cannot be read.
<DT><CODE>FTW_SL</CODE>
<DD>
<A NAME="IDX1207"></A>
The item is a symbolic link.  Since symbolic links are normally followed
seeing this value in a <CODE>ftw</CODE> callback function means the referenced
file does not exist.  The situation for <CODE>nftw</CODE> is different.

This value is only available if the program is compiled with
<CODE>_BSD_SOURCE</CODE> or <CODE>_XOPEN_EXTENDED</CODE> defined before including
the first header.  The original SVID systems do not have symbolic links.
</DL>

<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
type is in fact <CODE>__ftw64_func_t</CODE> since this mode also changes
<CODE>struct stat</CODE> to be <CODE>struct stat64</CODE>.
</DL>

</P>
<P>
For the LFS interface and the use in the function <CODE>ftw64</CODE> the
header <TT>`ftw.h'</TT> defines another function type.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>__ftw64_func_t</B>
<DD><A NAME="IDX1208"></A>

</P>

<PRE>
int (*) (const char *, const struct stat64 *, int)
</PRE>

<P>
This type is used just like <CODE>__ftw_func_t</CODE> for the callback
function, but this time called from <CODE>ftw64</CODE>.  The second parameter
to the function is this time a pointer to a variable of type
<CODE>struct stat64</CODE> which is able to represent the larger values.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>__nftw_func_t</B>
<DD><A NAME="IDX1209"></A>

</P>

<PRE>
int (*) (const char *, const struct stat *, int, struct FTW *)
</PRE>

<P>
<A NAME="IDX1210"></A>
<A NAME="IDX1211"></A>
The first three arguments have the same as for the <CODE>__ftw_func_t</CODE>
type.  A difference is that for the third argument some additional
values are defined to allow finer differentiation:
<DL COMPACT>

<DT><CODE>FTW_DP</CODE>
<DD>
The current item is a directory and all subdirectories have already been
visited and reported.  This flag is returned instead of <CODE>FTW_D</CODE> if
the <CODE>FTW_DEPTH</CODE> flag is given to <CODE>nftw</CODE> (see below).
<DT><CODE>FTW_SLN</CODE>
<DD>
The current item is a stale symbolic link.  The file it points to does
not exist.
</DL>

<P>
The last parameter of the callback function is a pointer to a structure
with some extra information as described below.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
type is in fact <CODE>__nftw64_func_t</CODE> since this mode also changes
<CODE>struct stat</CODE> to be <CODE>struct stat64</CODE>.
</DL>

</P>
<P>
For the LFS interface there is also a variant of this data type
available which has to be used with the <CODE>nftw64</CODE> function.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>__nftw64_func_t</B>
<DD><A NAME="IDX1212"></A>

</P>

<PRE>
int (*) (const char *, const struct stat64 *, int, struct FTW *)
</PRE>

<P>
This type is used just like <CODE>__nftw_func_t</CODE> for the callback
function, but this time called from <CODE>nftw64</CODE>.  The second parameter
to the function is this time a pointer to a variable of type
<CODE>struct stat64</CODE> which is able to represent the larger values.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct FTW</B>
<DD><A NAME="IDX1213"></A>
The contained information helps to interpret the name parameter and
gives some information about current state of the traversal of the
directory hierarchy.

</P>
<DL COMPACT>

<DT><CODE>int base</CODE>
<DD>
The value specifies which part of the filename argument given in the
first parameter to the callback function is the name of the file.  The
rest of the string is the path to locate the file.  This information is
especially important if the <CODE>FTW_CHDIR</CODE> flag for <CODE>nftw</CODE> was
set since then the current directory is the one the current item is
found in.
<DT><CODE>int level</CODE>
<DD>
While processing the directory the functions tracks how many directories
have been examine to find the current item.  This nesting level is
@math{0} for the item given starting item (file or directory) and is
incremented by one for each entered directory.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>ftw</B> <I>(const char *<VAR>filename</VAR>, __ftw_func_t <VAR>func</VAR>, int <VAR>descriptors</VAR>)</I>
<DD><A NAME="IDX1214"></A>
The <CODE>ftw</CODE> function calls the callback function given in the
parameter <VAR>func</VAR> for every item which is found in the directory
specified by <VAR>filename</VAR> and all directories below.  The function
follows symbolic links if necessary but does not process an item twice.
If <VAR>filename</VAR> names no directory this item is the only object
reported by calling the callback function.

</P>
<P>
The filename given to the callback function is constructed by taking the
<VAR>filename</VAR> parameter and appending the names of all passed
directories and then the local file name.  So the callback function can
use this parameter to access the file.  Before the callback function is
called <CODE>ftw</CODE> calls <CODE>stat</CODE> for this file and passes the
information up to the callback function.  If this <CODE>stat</CODE> call was
not successful the failure is indicated by setting the falg argument of
the callback function to <CODE>FTW_NS</CODE>.  Otherwise the flag is set
according to the description given in the description of
<CODE>__ftw_func_t</CODE> above.

</P>
<P>
The callback function is expected to return @math{0} to indicate that no
error occurred and the processing should be continued.  If an error
occurred in the callback function or the call to <CODE>ftw</CODE> shall return
immediately the callback function can return a value other than
@math{0}.  This is the only correct way to stop the function.  The
program must not use <CODE>setjmp</CODE> or similar techniques to continue the
program in another place.  This would leave the resources allocated in
the <CODE>ftw</CODE> function allocated.

</P>
<P>
The <VAR>descriptors</VAR> parameter to the <CODE>ftw</CODE> function specifies how
many file descriptors the <CODE>ftw</CODE> function is allowed to consume.
The more descriptors can be used the faster the function can run.  For
each level of directories at most one descriptor is used so that for
very deep directory hierarchies the limit on open file descriptors for
the process or the system can be exceeded.  Beside this the limit on
file descriptors is counted together for all threads in a multi-threaded
program and therefore it is always good too limit the maximal number of
open descriptors to a reasonable number.

</P>
<P>
The return value of the <CODE>ftw</CODE> function is @math{0} if all callback
function calls returned @math{0} and all actions performed by the
<CODE>ftw</CODE> succeeded.  If some function call failed (other than calling
<CODE>stat</CODE> on an item) the function return @math{-1}.  If a callback
function returns a value other than @math{0} this value is returned as
the return value of <CODE>ftw</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is in fact <CODE>ftw64</CODE>.  I.e., the LFS
interface transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>ftw64</B> <I>(const char *<VAR>filename</VAR>, __ftw64_func_t <VAR>func</VAR>, int <VAR>descriptors</VAR>)</I>
<DD><A NAME="IDX1215"></A>
This function is similar to <CODE>ftw</CODE> but it can work on filesystems
with large files since the information about the files is reported using
a variable of type <CODE>struct stat64</CODE> which is passed by reference to
the callback function.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is available under the name <CODE>ftw</CODE> and
transparently replaces the old implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>nftw</B> <I>(const char *<VAR>filename</VAR>, __nftw_func_t <VAR>func</VAR>, int <VAR>descriptors</VAR>, int <VAR>flag</VAR>)</I>
<DD><A NAME="IDX1216"></A>
The <CODE>nftw</CODE> functions works like the <CODE>ftw</CODE> functions.  It calls
the callback function <VAR>func</VAR> for all items it finds in the directory
<VAR>filename</VAR> and below.  At most <VAR>descriptors</VAR> file descriptors
are consumed during the <CODE>nftw</CODE> call.

</P>
<P>
The differences are that for one the callback function is of a different
type.  It is of type <CODE>struct FTW *</CODE> and provides the callback
functions the information described above.

</P>
<P>
The second difference is that <CODE>nftw</CODE> takes an additional fourth
argument which is @math{0} or a combination of any of the following
values, combined using bitwise OR.

</P>
<DL COMPACT>

<DT><CODE>FTW_PHYS</CODE>
<DD>
<A NAME="IDX1217"></A>
While traversing the directory symbolic links are not followed.  I.e.,
if this flag is given symbolic links are reported using the
<CODE>FTW_SL</CODE> value for the type parameter to the callback function.
Please note that if this flag is used the appearance of <CODE>FTW_SL</CODE> in
a callback function does not mean the referenced file does not exist.
To indicate this the extra value <CODE>FTW_SLN</CODE> exists.
<DT><CODE>FTW_MOUNT</CODE>
<DD>
<A NAME="IDX1218"></A>
The callback function is only called for items which are on the same
mounted filesystem as the directory given as the <VAR>filename</VAR>
parameter to <CODE>nftw</CODE>.
<DT><CODE>FTW_CHDIR</CODE>
<DD>
<A NAME="IDX1219"></A>
If this flag is given the current working directory is changed to the
directory containing the reported object before the callback function is
called.
<DT><CODE>FTW_DEPTH</CODE>
<DD>
<A NAME="IDX1220"></A>
If this option is given the function visits first all files and
subdirectories before the callback function is called for the directory
itself (depth-first processing).  This also means the type flag given to
the callback function is <CODE>FTW_DP</CODE> and not <CODE>FTW_D</CODE>.
</DL>

<P>
The return value is computed in the same way as for <CODE>ftw</CODE>.
<CODE>nftw</CODE> return @math{0} if no failure occurred in <CODE>nftw</CODE> and
all callback function call return values are also @math{0}.  For
internal errors such as memory problems @math{-1} is returned and
<VAR>errno</VAR> is set accordingly.  If the return value of a callback
invocation is nonzero this very same value is returned.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is in fact <CODE>nftw64</CODE>.  I.e., the LFS
interface transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>nftw64</B> <I>(const char *<VAR>filename</VAR>, __nftw64_func_t <VAR>func</VAR>, int <VAR>descriptors</VAR>, int <VAR>flag</VAR>)</I>
<DD><A NAME="IDX1221"></A>
This function is similar to <CODE>nftw</CODE> but it can work on filesystems
with large files since the information about the files is reported using
a variable of type <CODE>struct stat64</CODE> which is passed by reference to
the callback function.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is available under the name <CODE>nftw</CODE> and
transparently replaces the old implementation.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_253.html">previous</A>, <A HREF="libc_255.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
