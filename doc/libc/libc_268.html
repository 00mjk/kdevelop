<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Testing File Access</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_267.html">previous</A>, <A HREF="libc_269.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC275" HREF="libc_toc.html#TOC275">Testing Permission to Access a File</A></H3>
<P>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
<A NAME="IDX1333"></A>

</P>
<P>
When a program runs as a privileged user, this permits it to access
files off-limits to ordinary users--for example, to modify
<TT>`/etc/passwd'</TT>.  Programs designed to be run by ordinary users but
access such files use the setuid bit feature so that they always run
with <CODE>root</CODE> as the effective user ID.

</P>
<P>
Such a program may also access files specified by the user, files which
conceptually are being accessed explicitly by the user.  Since the
program runs as <CODE>root</CODE>, it has permission to access whatever file
the user specifies--but usually the desired behavior is to permit only
those files which the user could ordinarily access.

</P>
<P>
The program therefore must explicitly check whether <EM>the user</EM>
would have the necessary access to a file, before it reads or writes the
file.

</P>
<P>
To do this, use the function <CODE>access</CODE>, which checks for access
permission based on the process's <EM>real</EM> user ID rather than the
effective user ID.  (The setuid feature does not alter the real user ID,
so it reflects the user who actually ran the program.)

</P>
<P>
There is another way you could check this access, which is easy to
describe, but very hard to use.  This is to examine the file mode bits
and mimic the system's own access computation.  This method is
undesirable because many systems have additional access control
features; your program cannot portably mimic them, and you would not
want to try to keep track of the diverse features that different systems
have.  Using <CODE>access</CODE> is simple and automatically does whatever is
appropriate for the system you are using.

</P>
<P>
<CODE>access</CODE> is <EM>only</EM> only appropriate to use in setuid programs.
A non-setuid program will always use the effective ID rather than the
real ID.

</P>
<P>
<A NAME="IDX1334"></A>
The symbols in this section are declared in <TT>`unistd.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>access</B> <I>(const char *<VAR>filename</VAR>, int <VAR>how</VAR>)</I>
<DD><A NAME="IDX1335"></A>
The <CODE>access</CODE> function checks to see whether the file named by
<VAR>filename</VAR> can be accessed in the way specified by the <VAR>how</VAR>
argument.  The <VAR>how</VAR> argument either can be the bitwise OR of the
flags <CODE>R_OK</CODE>, <CODE>W_OK</CODE>, <CODE>X_OK</CODE>, or the existence test
<CODE>F_OK</CODE>.

</P>
<P>
This function uses the <EM>real</EM> user and group ID's of the calling
process, rather than the <EM>effective</EM> ID's, to check for access
permission.  As a result, if you use the function from a <CODE>setuid</CODE>
or <CODE>setgid</CODE> program (see section <A HREF="libc_556.html#SEC564">How an Application Can Change Persona</A>), it gives
information relative to the user who actually ran the program.

</P>
<P>
The return value is <CODE>0</CODE> if the access is permitted, and <CODE>-1</CODE>
otherwise.  (In other words, treated as a predicate function,
<CODE>access</CODE> returns true if the requested access is <EM>denied</EM>.)

</P>
<P>
In addition to the usual file name errors (see section <A HREF="libc_153.html#SEC160">File Name Errors</A>), the following <CODE>errno</CODE> error conditions are defined for
this function:

</P>
<DL COMPACT>

<DT><CODE>EACCES</CODE>
<DD>
The access specified by <VAR>how</VAR> is denied.

<DT><CODE>ENOENT</CODE>
<DD>
The file doesn't exist.

<DT><CODE>EROFS</CODE>
<DD>
Write permission was requested for a file on a read-only file system.
</DL>
</DL>

<P>
These macros are defined in the header file <TT>`unistd.h'</TT> for use
as the <VAR>how</VAR> argument to the <CODE>access</CODE> function.  The values
are integer constants.
<A NAME="IDX1336"></A>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>R_OK</B>
<DD><A NAME="IDX1337"></A>
Argument that means, test for read permission.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>W_OK</B>
<DD><A NAME="IDX1338"></A>
Argument that means, test for write permission.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>X_OK</B>
<DD><A NAME="IDX1339"></A>
Argument that means, test for execute/search permission.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>F_OK</B>
<DD><A NAME="IDX1340"></A>
Argument that means, test for existence of the file.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_267.html">previous</A>, <A HREF="libc_269.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
