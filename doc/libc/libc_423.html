<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Program Error Signals</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_422.html">previous</A>, <A HREF="libc_424.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC430" HREF="libc_toc.html#TOC430">Program Error Signals</A></H3>
<P>
<A NAME="IDX2437"></A>

</P>
<P>
The following signals are generated when a serious program error is
detected by the operating system or the computer itself.  In general,
all of these signals are indications that your program is seriously
broken in some way, and there's usually no way to continue the
computation which encountered the error.

</P>
<P>
Some programs handle program error signals in order to tidy up before
terminating; for example, programs that turn off echoing of terminal
input should handle program error signals in order to turn echoing back
on.  The handler should end by specifying the default action for the
signal that happened and then reraising it; this will cause the program
to terminate with that signal, as if it had not had a handler.
(See section <A HREF="libc_440.html#SEC447">Handlers That Terminate the Process</A>.)

</P>
<P>
Termination is the sensible ultimate outcome from a program error in
most programs.  However, programming systems such as Lisp that can load
compiled user programs might need to keep executing even if a user
program incurs an error.  These programs have handlers which use
<CODE>longjmp</CODE> to return control to the command level.

</P>
<P>
The default action for all of these signals is to cause the process to
terminate.  If you block or ignore these signals or establish handlers
for them that return normally, your program will probably break horribly
when such signals happen, unless they are generated by <CODE>raise</CODE> or
<CODE>kill</CODE> instead of a real error.

</P>
<P>
<A NAME="IDX2438"></A>
When one of these program error signals terminates a process, it also
writes a <STRONG>core dump file</STRONG> which records the state of the process at
the time of termination.  The core dump file is named <TT>`core'</TT> and is
written in whichever directory is current in the process at the time.
(On the GNU system, you can specify the file name for core dumps with
the environment variable <CODE>COREFILE</CODE>.)  The purpose of core dump
files is so that you can examine them with a debugger to investigate
what caused the error.

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGFPE</B>
<DD><A NAME="IDX2439"></A>
The <CODE>SIGFPE</CODE> signal reports a fatal arithmetic error.  Although the
name is derived from "floating-point exception", this signal actually
covers all arithmetic errors, including division by zero and overflow.
If a program stores integer data in a location which is then used in a
floating-point operation, this often causes an "invalid operation"
exception, because the processor cannot recognize the data as a
floating-point number.
<A NAME="IDX2440"></A>
<A NAME="IDX2441"></A>

</P>
<P>
Actual floating-point exceptions are a complicated subject because there
are many types of exceptions with subtly different meanings, and the
<CODE>SIGFPE</CODE> signal doesn't distinguish between them.  The <CITE>IEEE
Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985
and ANSI/IEEE Std 854-1987)</CITE>
defines various floating-point exceptions and requires conforming
computer systems to report their occurrences.  However, this standard
does not specify how the exceptions are reported, or what kinds of
handling and control the operating system can offer to the programmer.
</DL>

</P>
<P>
BSD systems provide the <CODE>SIGFPE</CODE> handler with an extra argument
that distinguishes various causes of the exception.  In order to access
this argument, you must define the handler to accept two arguments,
which means you must cast it to a one-argument function type in order to
establish the handler.  The GNU library does provide this extra
argument, but the value is meaningful only on operating systems that
provide the information (BSD systems and GNU systems).

</P>
<DL COMPACT>

<DT><CODE>FPE_INTOVF_TRAP</CODE>
<DD>
<A NAME="IDX2442"></A>
Integer overflow (impossible in a C program unless you enable overflow
trapping in a hardware-specific fashion).
<DT><CODE>FPE_INTDIV_TRAP</CODE>
<DD>
<A NAME="IDX2443"></A>
Integer division by zero.
<DT><CODE>FPE_SUBRNG_TRAP</CODE>
<DD>
<A NAME="IDX2444"></A>
Subscript-range (something that C programs never check for).
<DT><CODE>FPE_FLTOVF_TRAP</CODE>
<DD>
<A NAME="IDX2445"></A>
Floating overflow trap.
<DT><CODE>FPE_FLTDIV_TRAP</CODE>
<DD>
<A NAME="IDX2446"></A>
Floating/decimal division by zero.
<DT><CODE>FPE_FLTUND_TRAP</CODE>
<DD>
<A NAME="IDX2447"></A>
Floating underflow trap.  (Trapping on floating underflow is not
normally enabled.)
<DT><CODE>FPE_DECOVF_TRAP</CODE>
<DD>
<A NAME="IDX2448"></A>
Decimal overflow trap.  (Only a few machines have decimal arithmetic and
C never uses it.)
</DL>

<P>
<DL>
<DT><U>Macro:</U> int <B>SIGILL</B>
<DD><A NAME="IDX2449"></A>
The name of this signal is derived from "illegal instruction"; it
usually means your program is trying to execute garbage or a privileged
instruction.  Since the C compiler generates only valid instructions,
<CODE>SIGILL</CODE> typically indicates that the executable file is corrupted,
or that you are trying to execute data.  Some common ways of getting
into the latter situation are by passing an invalid object where a
pointer to a function was expected, or by writing past the end of an
automatic array (or similar problems with pointers to automatic
variables) and corrupting other data on the stack such as the return
address of a stack frame.

</P>
<P>
<CODE>SIGILL</CODE> can also be generated when the stack overflows, or when
the system has trouble running the handler for a signal.
</DL>
<A NAME="IDX2450"></A>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGSEGV</B>
<DD><A NAME="IDX2451"></A>
<A NAME="IDX2452"></A>
This signal is generated when a program tries to read or write outside
the memory that is allocated for it, or to write memory that can only be
read.  (Actually, the signals only occur when the program goes far
enough outside to be detected by the system's memory protection
mechanism.)  The name is an abbreviation for "segmentation violation".

</P>
<P>
Common ways of getting a <CODE>SIGSEGV</CODE> condition include dereferencing
a null or uninitialized pointer, or when you use a pointer to step
through an array, but fail to check for the end of the array.  It varies
among systems whether dereferencing a null pointer generates
<CODE>SIGSEGV</CODE> or <CODE>SIGBUS</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGBUS</B>
<DD><A NAME="IDX2453"></A>
This signal is generated when an invalid pointer is dereferenced.  Like
<CODE>SIGSEGV</CODE>, this signal is typically the result of dereferencing an
uninitialized pointer.  The difference between the two is that
<CODE>SIGSEGV</CODE> indicates an invalid access to valid memory, while
<CODE>SIGBUS</CODE> indicates an access to an invalid address.  In particular,
<CODE>SIGBUS</CODE> signals often result from dereferencing a misaligned
pointer, such as referring to a four-word integer at an address not
divisible by four.  (Each kind of computer has its own requirements for
address alignment.)

</P>
<P>
The name of this signal is an abbreviation for "bus error".
</DL>
<A NAME="IDX2454"></A>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGABRT</B>
<DD><A NAME="IDX2455"></A>
<A NAME="IDX2456"></A>
This signal indicates an error detected by the program itself and
reported by calling <CODE>abort</CODE>.  See section <A HREF="libc_510.html#SEC518">Aborting a Program</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGIOT</B>
<DD><A NAME="IDX2457"></A>
Generated by the PDP-11 "iot" instruction.  On most machines, this is
just another name for <CODE>SIGABRT</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGTRAP</B>
<DD><A NAME="IDX2458"></A>
Generated by the machine's breakpoint instruction, and possibly other
trap instructions.  This signal is used by debuggers.  Your program will
probably only see <CODE>SIGTRAP</CODE> if it is somehow executing bad
instructions.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGEMT</B>
<DD><A NAME="IDX2459"></A>
Emulator trap; this results from certain unimplemented instructions
which might be emulated in software, or the operating system's
failure to properly emulate them.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>SIGSYS</B>
<DD><A NAME="IDX2460"></A>
Bad system call; that is to say, the instruction to trap to the
operating system was executed, but the code number for the system call
to perform was invalid.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_422.html">previous</A>, <A HREF="libc_424.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
