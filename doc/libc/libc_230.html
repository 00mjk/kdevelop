<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Synchronizing AIO Operations</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_229.html">previous</A>, <A HREF="libc_231.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC237" HREF="libc_toc.html#TOC237">Getting into a Consistent State</A></H3>

<P>
When dealing with asynchronous operations it is sometimes necessary to
get into a consistent state.  This would mean for AIO that one wants to
know whether a certain request or a group of request were processed.
This could be done by waiting for the notification sent by the system
after the operation terminated but this sometimes would mean wasting
resources (mainly computation time).  Instead POSIX.1b defines two
functions which will help with most kinds of consistency.

</P>
<P>
The <CODE>aio_fsync</CODE> and <CODE>aio_fsync64</CODE> functions are only available
if in <TT>`unistd.h'</TT> the symbol <CODE>_POSIX_SYNCHRONIZED_IO</CODE> is
defined.

</P>
<P>
<A NAME="IDX1083"></A>
<DL>
<DT><U>Function:</U> int <B>aio_fsync</B> <I>(int <VAR>op</VAR>, struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1084"></A>
Calling this function forces all I/O operations operating queued at the
time of the function call operating on the file descriptor
<CODE>aiocbp-&#62;aio_fildes</CODE> into the synchronized I/O completion state
(see section <A HREF="libc_226.html#SEC233">Synchronizing I/O operations</A>).  The <CODE>aio_fsync</CODE> function return
immediately but the notification through the method described in
<CODE>aiocbp-&#62;aio_sigevent</CODE> will happen only after all requests for this
file descriptor terminated and the file is synchronized.  This also
means that requests for this very same file descriptor which are queued
after the synchronization request are not effected.

</P>
<P>
If <VAR>op</VAR> is <CODE>O_DSYNC</CODE> the synchronization happens as with a call
to <CODE>fdatasync</CODE>.  Otherwise <VAR>op</VAR> should be <CODE>O_SYNC</CODE> and
the synchronization happens as with <CODE>fsync</CODE>.

</P>
<P>
As long as the synchronization has not happened a call to
<CODE>aio_error</CODE> with the reference to the object pointed to by
<VAR>aiocbp</VAR> returns <CODE>EINPROGRESS</CODE>.  Once the synchronization is
done <CODE>aio_error</CODE> return @math{0} if the synchronization was not
successful.  Otherwise the value returned is the value to which the
<CODE>fsync</CODE> or <CODE>fdatasync</CODE> function would have set the
<CODE>errno</CODE> variable.  In this case nothing can be assumed about the
consistency for the data written to this file descriptor.

</P>
<P>
The return value of this function is @math{0} if the request was
successfully filed.  Otherwise the return value is @math{-1} and
<CODE>errno</CODE> is set to one of the following values:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
The request could not be enqueued due to temporary lack of resources.
<DT><CODE>EBADF</CODE>
<DD>
The file descriptor <CODE>aiocbp-&#62;aio_fildes</CODE> is not valid or not open
for writing.
<DT><CODE>EINVAL</CODE>
<DD>
The implementation does not support I/O synchronization or the <VAR>op</VAR>
parameter is other than <CODE>O_DSYNC</CODE> and <CODE>O_SYNC</CODE>.
<DT><CODE>ENOSYS</CODE>
<DD>
This function is not implemented.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_return64</CODE> since the LFS interface
transparently replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_fsync64</B> <I>(int <VAR>op</VAR>, struct aiocb64 *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1085"></A>
This function is similar to <CODE>aio_fsync</CODE> with the only difference
that the argument is a reference to a variable of type <CODE>struct
aiocb64</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_fsync</CODE> and so
transparently replaces the interface for small files on 32 bits
machines.
</DL>

</P>
<P>
Another method of synchronization is to wait until one or more requests of a
specific set terminated.  This could be achieved by the <CODE>aio_*</CODE>
functions to notify the initiating process about the termination but in
some situations this is not the ideal solution.  In a program which
constantly updates clients somehow connected to the server it is not
always the best solution to go round robin since some connections might
be slow.  On the other hand letting the <CODE>aio_*</CODE> function notify the
caller might also be not the best solution since whenever the process
works on preparing data for on client it makes no sense to be
interrupted by a notification since the new client will not be handled
before the current client is served.  For situations like this
<CODE>aio_suspend</CODE> should be used.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_suspend</B> <I>(const struct aiocb *const <VAR>list</VAR>[], int <VAR>nent</VAR>, const struct timespec *<VAR>timeout</VAR>)</I>
<DD><A NAME="IDX1086"></A>
When calling this function the calling thread is suspended until at
least one of the requests pointed to by the <VAR>nent</VAR> elements of the
array <VAR>list</VAR> has completed.  If any of the requests already has
completed at the time <CODE>aio_suspend</CODE> is called the function returns
immediately.  Whether a request has terminated or not is done by
comparing the error status of the request with <CODE>EINPROGRESS</CODE>.  If
an element of <VAR>list</VAR> is <CODE>NULL</CODE> the entry is simply ignored.

</P>
<P>
If no request has finished the calling process is suspended.  If
<VAR>timeout</VAR> is <CODE>NULL</CODE> the process is not waked until a request
finished.  If <VAR>timeout</VAR> is not <CODE>NULL</CODE> the process remains
suspended at as long as specified in <VAR>timeout</VAR>.  In this case
<CODE>aio_suspend</CODE> returns with an error.

</P>
<P>
The return value of the function is @math{0} if one or more requests
from the <VAR>list</VAR> have terminated.  Otherwise the function returns
@math{-1} and <CODE>errno</CODE> is set to one of the following values:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
None of the requests from the <VAR>list</VAR> completed in the time specified
by <VAR>timeout</VAR>.
<DT><CODE>EINTR</CODE>
<DD>
A signal interrupted the <CODE>aio_suspend</CODE> function.  This signal might
also be sent by the AIO implementation while signalling the termination
of one of the requests.
<DT><CODE>ENOSYS</CODE>
<DD>
The <CODE>aio_suspend</CODE> function is not implemented.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_suspend64</CODE> since the LFS interface
transparently replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_suspend64</B> <I>(const struct aiocb64 *const <VAR>list</VAR>[], int <VAR>nent</VAR>, const struct timespec *<VAR>timeout</VAR>)</I>
<DD><A NAME="IDX1087"></A>
This function is similar to <CODE>aio_suspend</CODE> with the only difference
that the argument is a reference to a variable of type <CODE>struct
aiocb64</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_suspend</CODE> and so
transparently replaces the interface for small files on 32 bits
machines.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_229.html">previous</A>, <A HREF="libc_231.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
