<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Common Usage</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_111.html">previous</A>, <A HREF="libc_113.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC116" HREF="libc_toc.html#TOC116">How to use the <CODE>catgets</CODE> interface</A></H3>

<P>
The <CODE>catgets</CODE> functions can be used in two different ways.  By
following slavishly the X/Open specs and not relying on the extension
and by using the GNU extensions.  We will take a look at the former
method first to understand the benefits of extensions.

</P>


<H4><A NAME="SEC117" HREF="libc_toc.html#TOC117">Not using symbolic names</A></H4>

<P>
Since the X/Open format of the message catalog files does not allow
symbol names we have to work with numbers all the time.  When we start
writing a program we have to replace all appearances of translatable
strings with something like

</P>

<PRE>
catgets (catdesc, set, msg, "string")
</PRE>

<P>
<VAR>catgets</VAR> is retrieved from a call to <CODE>catopen</CODE> which is
normally done once at the program start.  The <CODE>"string"</CODE> is the
string we want to translate.  The problems start with the set and
message numbers.

</P>
<P>
In a bigger program several programmers usually work at the same time on
the program and so coordinating the number allocation is crucial.
Though no two different strings must be indexed by the same tuple of
numbers it is highly desirable to reuse the numbers for equal strings
with equal translations (please note that there might be strings which
are equal in one language but have different translations due to
difference contexts).

</P>
<P>
The allocation process can be relaxed a bit by different set numbers for
different parts of the program.  So the number of developers who have to
coordinate the allocation can be reduced.  But still lists must be keep
track of the allocation and errors can easily happen.  These errors
cannot be discovered by the compiler or the <CODE>catgets</CODE> functions.
Only the user of the program might see wrong messages printed.  In the
worst cases the messages are so irritating that they cannot be
recognized as wrong.  Think about the translations for <CODE>"true"</CODE> and
<CODE>"false"</CODE> being exchanged.  This could result in a disaster.

</P>



<H4><A NAME="SEC118" HREF="libc_toc.html#TOC118">Using symbolic names</A></H4>

<P>
The problems mentioned in the last section derive from the fact that:

</P>

<OL>
<LI>

the numbers are allocated once and due to the possibly frequent use of
them it is difficult to change a number later.
<LI>

the numbers do not allow to guess anything about the string and
therefore collisions can easily happen.
</OL>

<P>
By constantly using symbolic names and by providing a method which maps
the string content to a symbolic name (however this will happen) one can
prevent both problems above.  The cost of this is that the programmer
has to write a complete message catalog file while s/he is writing the
program itself.

</P>
<P>
This is necessary since the symbolic names must be mapped to numbers
before the program sources can be compiled.  In the last section it was
described how to generate a header containing the mapping of the names.
E.g., for the example message file given in the last section we could
call the <CODE>gencat</CODE> program as follow (assume <TT>`ex.msg'</TT> contains
the sources).

</P>

<PRE>
gencat -H ex.h -o ex.cat ex.msg
</PRE>

<P>
This generates a header file with the following content:

</P>

<PRE>
#define SetTwoSet 0x2   /* u.msg:8 */

#define SetOneSet 0x1   /* u.msg:4 */
#define SetOnetwo 0x2   /* u.msg:6 */
</PRE>

<P>
As can be seen the various symbols given in the source file are mangled
to generate unique identifiers and these identifiers get numbers
assigned.  Reading the source file and knowing about the rules will
allow to predict the content of the header file (it is deterministic)
but this is not necessary.  The <CODE>gencat</CODE> program can take care for
everything.  All the programmer has to do is to put the generated header
file in the dependency list of the source files of her/his project and
to add a rules to regenerate the header of any of the input files
change.

</P>
<P>
One word about the symbol mangling.  Every symbol consists of two parts:
the name of the message set plus the name of the message or the special
string <CODE>Set</CODE>.  So <CODE>SetOnetwo</CODE> means this macro can be used to
access the translation with identifier <CODE>two</CODE> in the message set
<CODE>SetOne</CODE>.

</P>
<P>
The other names denote the names of the message sets.  The special
string <CODE>Set</CODE> is used in the place of the message identifier.

</P>
<P>
If in the code the second string of the set <CODE>SetOne</CODE> is used the C
code should look like this:

</P>

<PRE>
catgets (catdesc, SetOneSet, SetOnetwo,
         "   Message with ID \"two\", which gets the value 2 assigned")
</PRE>

<P>
Writing the function this way will allow to change the message number
and even the set number without requiring any change in the C source
code.  (The text of the string is normally not the same; this is only
for this example.)

</P>



<H4><A NAME="SEC119" HREF="libc_toc.html#TOC119">How does to this allow to develop</A></H4>

<P>
To illustrate the usual way to work with the symbolic version numbers
here is a little example.  Assume we want to write the very complex and
famous greeting program.  We start by writing the code as usual:

</P>

<PRE>
#include &#60;stdio.h&#62;
int
main (void)
{
  printf ("Hello, world!\n");
  return 0;
}
</PRE>

<P>
Now we want to internationalize the message and therefore replace the
message with whatever the user wants.

</P>

<PRE>
#include &#60;nl_types.h&#62;
#include &#60;stdio.h&#62;
#include "msgnrs.h"
int
main (void)
{
  nl_catd catdesc = catopen ("hello.cat", NL_CAT_LOCALE);
  printf (catgets (catdesc, SetMainSet, SetMainHello,
                   "Hello, world!\n"));
  catclose (catdesc);
  return 0;
}
</PRE>

<P>
We see how the catalog object is opened and the returned descriptor used
in the other function calls.  It is not really necessary to check for
failure of any of the functions since even in these situations the
functions will behave reasonable.  They simply will be return a
translation.

</P>
<P>
What remains unspecified here are the constants <CODE>SetMainSet</CODE> and
<CODE>SetMainHello</CODE>.  These are the symbolic names describing the
message.  To get the actual definitions which match the information in
the catalog file we have to create the message catalog source file and
process it using the <CODE>gencat</CODE> program.

</P>

<PRE>
$ Messages for the famous greeting program.
$quote "

$set Main
Hello "Hallo, Welt!\n"
</PRE>

<P>
Now we can start building the program (assume the message catalog source
file is named <TT>`hello.msg'</TT> and the program source file <TT>`hello.c'</TT>):

</P>

<PRE>
% gencat -H msgnrs.h -o hello.cat hello.msg
% cat msgnrs.h
#define MainSet 0x1     /* hello.msg:4 */
#define MainHello 0x1   /* hello.msg:5 */
% gcc -o hello hello.c -I.
% cp hello.cat /usr/share/locale/de/LC_MESSAGES
% echo $LC_ALL
de
% ./hello
Hallo, Welt!
%
</PRE>

<P>
The call of the <CODE>gencat</CODE> program creates the missing header file
<TT>`msgnrs.h'</TT> as well as the message catalog binary.  The former is
used in the compilation of <TT>`hello.c'</TT> while the latter is placed in a
directory in which the <CODE>catopen</CODE> function will try to locate it.
Please check the <CODE>LC_ALL</CODE> environment variable and the default path
for <CODE>catopen</CODE> presented in the description above.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_111.html">previous</A>, <A HREF="libc_113.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
