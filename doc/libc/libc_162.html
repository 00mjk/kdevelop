<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Line Input</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_161.html">previous</A>, <A HREF="libc_163.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC169" HREF="libc_toc.html#TOC169">Line-Oriented Input</A></H2>

<P>
Since many programs interpret input on the basis of lines, it's
convenient to have functions to read a line of text from a stream.

</P>
<P>
Standard C has functions to do this, but they aren't very safe: null
characters and even (for <CODE>gets</CODE>) long lines can confuse them.  So
the GNU library provides the nonstandard <CODE>getline</CODE> function that
makes it easy to read lines reliably.

</P>
<P>
Another GNU extension, <CODE>getdelim</CODE>, generalizes <CODE>getline</CODE>.  It
reads a delimited record, defined as everything through the next
occurrence of a specified delimiter character.

</P>
<P>
All these functions are declared in <TT>`stdio.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>getline</B> <I>(char **<VAR>lineptr</VAR>, size_t *<VAR>n</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX802"></A>
This function reads an entire line from <VAR>stream</VAR>, storing the text
(including the newline and a terminating null character) in a buffer
and storing the buffer address in <CODE>*<VAR>lineptr</VAR></CODE>.

</P>
<P>
Before calling <CODE>getline</CODE>, you should place in <CODE>*<VAR>lineptr</VAR></CODE>
the address of a buffer <CODE>*<VAR>n</VAR></CODE> bytes long, allocated with
<CODE>malloc</CODE>.  If this buffer is long enough to hold the line,
<CODE>getline</CODE> stores the line in this buffer.  Otherwise,
<CODE>getline</CODE> makes the buffer bigger using <CODE>realloc</CODE>, storing the
new buffer address back in <CODE>*<VAR>lineptr</VAR></CODE> and the increased size
back in <CODE>*<VAR>n</VAR></CODE>.
See section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>.

</P>
<P>
If you set <CODE>*<VAR>lineptr</VAR></CODE> to a null pointer, and <CODE>*<VAR>n</VAR></CODE>
to zero, before the call, then <CODE>getline</CODE> allocates the initial
buffer for you by calling <CODE>malloc</CODE>.

</P>
<P>
In either case, when <CODE>getline</CODE> returns,  <CODE>*<VAR>lineptr</VAR></CODE> is
a <CODE>char *</CODE> which points to the text of the line.

</P>
<P>
When <CODE>getline</CODE> is successful, it returns the number of characters
read (including the newline, but not including the terminating null).
This value enables you to distinguish null characters that are part of
the line from the null character inserted as a terminator.

</P>
<P>
This function is a GNU extension, but it is the recommended way to read
lines from a stream.  The alternative standard functions are unreliable.

</P>
<P>
If an error occurs or end of file is reached, <CODE>getline</CODE> returns
<CODE>-1</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>getdelim</B> <I>(char **<VAR>lineptr</VAR>, size_t *<VAR>n</VAR>, int <VAR>delimiter</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX803"></A>
This function is like <CODE>getline</CODE> except that the character which
tells it to stop reading is not necessarily newline.  The argument
<VAR>delimiter</VAR> specifies the delimiter character; <CODE>getdelim</CODE> keeps
reading until it sees that character (or end of file).

</P>
<P>
The text is stored in <VAR>lineptr</VAR>, including the delimiter character
and a terminating null.  Like <CODE>getline</CODE>, <CODE>getdelim</CODE> makes
<VAR>lineptr</VAR> bigger if it isn't big enough.

</P>
<P>
<CODE>getline</CODE> is in fact implemented in terms of <CODE>getdelim</CODE>, just
like this:

</P>

<PRE>
ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
  return getdelim (lineptr, n, '\n', stream);
}
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> char * <B>fgets</B> <I>(char *<VAR>s</VAR>, int <VAR>count</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX804"></A>
The <CODE>fgets</CODE> function reads characters from the stream <VAR>stream</VAR>
up to and including a newline character and stores them in the string
<VAR>s</VAR>, adding a null character to mark the end of the string.  You
must supply <VAR>count</VAR> characters worth of space in <VAR>s</VAR>, but the
number of characters read is at most <VAR>count</VAR> - 1.  The extra
character space is used to hold the null character at the end of the
string.

</P>
<P>
If the system is already at end of file when you call <CODE>fgets</CODE>, then
the contents of the array <VAR>s</VAR> are unchanged and a null pointer is
returned.  A null pointer is also returned if a read error occurs.
Otherwise, the return value is the pointer <VAR>s</VAR>.

</P>
<P>
<STRONG>Warning:</STRONG>  If the input data has a null character, you can't tell.
So don't use <CODE>fgets</CODE> unless you know the data cannot contain a null.
Don't use it to read files edited by the user because, if the user inserts
a null character, you should either handle it properly or print a clear
error message.  We recommend using <CODE>getline</CODE> instead of <CODE>fgets</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Deprecated function:</U> char * <B>gets</B> <I>(char *<VAR>s</VAR>)</I>
<DD><A NAME="IDX805"></A>
The function <CODE>gets</CODE> reads characters from the stream <CODE>stdin</CODE>
up to the next newline character, and stores them in the string <VAR>s</VAR>.
The newline character is discarded (note that this differs from the
behavior of <CODE>fgets</CODE>, which copies the newline character into the
string).  If <CODE>gets</CODE> encounters a read error or end-of-file, it
returns a null pointer; otherwise it returns <VAR>s</VAR>.

</P>
<P>
<STRONG>Warning:</STRONG> The <CODE>gets</CODE> function is <STRONG>very dangerous</STRONG>
because it provides no protection against overflowing the string
<VAR>s</VAR>.  The GNU library includes it for compatibility only.  You
should <STRONG>always</STRONG> use <CODE>fgets</CODE> or <CODE>getline</CODE> instead.  To
remind you of this, the linker (if using GNU <CODE>ld</CODE>) will issue a
warning whenever you use <CODE>gets</CODE>.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_161.html">previous</A>, <A HREF="libc_163.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
