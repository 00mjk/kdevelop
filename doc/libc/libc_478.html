<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Getopt Long Options</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_477.html">previous</A>, <A HREF="libc_479.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC485" HREF="libc_toc.html#TOC485">Parsing Long Options with <CODE>getopt_long</CODE></A></H3>

<P>
To accept GNU-style long options as well as single-character options,
use <CODE>getopt_long</CODE> instead of <CODE>getopt</CODE>.  This function is
declared in <TT>`getopt.h'</TT>, not <TT>`unistd.h'</TT>.  You should make every
program accept long options if it uses any options, for this takes
little extra work and helps beginners remember how to use the program.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct option</B>
<DD><A NAME="IDX2639"></A>
This structure describes a single long option name for the sake of
<CODE>getopt_long</CODE>.  The argument <VAR>longopts</VAR> must be an array of
these structures, one for each long option.  Terminate the array with an
element containing all zeros.

</P>
<P>
The <CODE>struct option</CODE> structure has these fields:

</P>
<DL COMPACT>

<DT><CODE>const char *name</CODE>
<DD>
This field is the name of the option.  It is a string.

<DT><CODE>int has_arg</CODE>
<DD>
This field says whether the option takes an argument.  It is an integer,
and there are three legitimate values: <CODE>no_argument</CODE>,
<CODE>required_argument</CODE> and <CODE>optional_argument</CODE>.

<DT><CODE>int *flag</CODE>
<DD>
<DT><CODE>int val</CODE>
<DD>
These fields control how to report or act on the option when it occurs.

If <CODE>flag</CODE> is a null pointer, then the <CODE>val</CODE> is a value which
identifies this option.  Often these values are chosen to uniquely
identify particular long options.

If <CODE>flag</CODE> is not a null pointer, it should be the address of an
<CODE>int</CODE> variable which is the flag for this option.  The value in
<CODE>val</CODE> is the value to store in the flag to indicate that the option
was seen.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>getopt_long</B> <I>(int <VAR>argc</VAR>, char **<VAR>argv</VAR>, const char *<VAR>shortopts</VAR>, struct option *<VAR>longopts</VAR>, int *<VAR>indexptr</VAR>)</I>
<DD><A NAME="IDX2640"></A>
Decode options from the vector <VAR>argv</VAR> (whose length is <VAR>argc</VAR>).
The argument <VAR>shortopts</VAR> describes the short options to accept, just as
it does in <CODE>getopt</CODE>.  The argument <VAR>longopts</VAR> describes the long
options to accept (see above).

</P>
<P>
When <CODE>getopt_long</CODE> encounters a short option, it does the same
thing that <CODE>getopt</CODE> would do: it returns the character code for the
option, and stores the options argument (if it has one) in <CODE>optarg</CODE>.

</P>
<P>
When <CODE>getopt_long</CODE> encounters a long option, it takes actions based
on the <CODE>flag</CODE> and <CODE>val</CODE> fields of the definition of that
option.

</P>
<P>
If <CODE>flag</CODE> is a null pointer, then <CODE>getopt_long</CODE> returns the
contents of <CODE>val</CODE> to indicate which option it found.  You should
arrange distinct values in the <CODE>val</CODE> field for options with
different meanings, so you can decode these values after
<CODE>getopt_long</CODE> returns.  If the long option is equivalent to a short
option, you can use the short option's character code in <CODE>val</CODE>.

</P>
<P>
If <CODE>flag</CODE> is not a null pointer, that means this option should just
set a flag in the program.  The flag is a variable of type <CODE>int</CODE>
that you define.  Put the address of the flag in the <CODE>flag</CODE> field.
Put in the <CODE>val</CODE> field the value you would like this option to
store in the flag.  In this case, <CODE>getopt_long</CODE> returns <CODE>0</CODE>.

</P>
<P>
For any long option, <CODE>getopt_long</CODE> tells you the index in the array
<VAR>longopts</VAR> of the options definition, by storing it into
<CODE>*<VAR>indexptr</VAR></CODE>.  You can get the name of the option with
<CODE><VAR>longopts</VAR>[*<VAR>indexptr</VAR>].name</CODE>.  So you can distinguish among
long options either by the values in their <CODE>val</CODE> fields or by their
indices.  You can also distinguish in this way among long options that
set flags.

</P>
<P>
When a long option has an argument, <CODE>getopt_long</CODE> puts the argument
value in the variable <CODE>optarg</CODE> before returning.  When the option
has no argument, the value in <CODE>optarg</CODE> is a null pointer.  This is
how you can tell whether an optional argument was supplied.

</P>
<P>
When <CODE>getopt_long</CODE> has no more options to handle, it returns
<CODE>-1</CODE>, and leaves in the variable <CODE>optind</CODE> the index in
<VAR>argv</VAR> of the next remaining argument.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_477.html">previous</A>, <A HREF="libc_479.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
