<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Signal Stack</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_466.html">previous</A>, <A HREF="libc_468.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC474" HREF="libc_toc.html#TOC474">Using a Separate Signal Stack</A></H2>

<P>
A signal stack is a special area of memory to be used as the execution
stack during signal handlers.  It should be fairly large, to avoid any
danger that it will overflow in turn; the macro <CODE>SIGSTKSZ</CODE> is
defined to a canonical size for signal stacks.  You can use
<CODE>malloc</CODE> to allocate the space for the stack.  Then call
<CODE>sigaltstack</CODE> or <CODE>sigstack</CODE> to tell the system to use that
space for the signal stack.

</P>
<P>
You don't need to write signal handlers differently in order to use a
signal stack.  Switching from one stack to the other happens
automatically.  (Some non-GNU debuggers on some machines may get
confused if you examine a stack trace while a handler that uses the
signal stack is running.)

</P>
<P>
There are two interfaces for telling the system to use a separate signal
stack.  <CODE>sigstack</CODE> is the older interface, which comes from 4.2
BSD.  <CODE>sigaltstack</CODE> is the newer interface, and comes from 4.4
BSD.  The <CODE>sigaltstack</CODE> interface has the advantage that it does
not require your program to know which direction the stack grows, which
depends on the specific machine and operating system.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct sigaltstack</B>
<DD><A NAME="IDX2596"></A>
This structure describes a signal stack.  It contains the following members:

</P>
<DL COMPACT>

<DT><CODE>void *ss_sp</CODE>
<DD>
This points to the base of the signal stack.

<DT><CODE>size_t ss_size</CODE>
<DD>
This is the size (in bytes) of the signal stack which <SAMP>`ss_sp'</SAMP> points to.
You should set this to however much space you allocated for the stack.

There are two macros defined in <TT>`signal.h'</TT> that you should use in
calculating this size:

<DL COMPACT>

<DT><CODE>SIGSTKSZ</CODE>
<DD>
<A NAME="IDX2597"></A>
This is the canonical size for a signal stack.  It is judged to be
sufficient for normal uses.

<DT><CODE>MINSIGSTKSZ</CODE>
<DD>
<A NAME="IDX2598"></A>
This is the amount of signal stack space the operating system needs just
to implement signal delivery.  The size of a signal stack <STRONG>must</STRONG>
be greater than this.

For most cases, just using <CODE>SIGSTKSZ</CODE> for <CODE>ss_size</CODE> is
sufficient.  But if you know how much stack space your program's signal
handlers will need, you may want to use a different size.  In this case,
you should allocate <CODE>MINSIGSTKSZ</CODE> additional bytes for the signal
stack and increase <CODE>ss_size</CODE> accordingly.
</DL>

<DT><CODE>int ss_flags</CODE>
<DD>
This field contains the bitwise OR of these flags:

<DL COMPACT>

<DT><CODE>SS_DISABLE</CODE>
<DD>
<A NAME="IDX2599"></A>
This tells the system that it should not use the signal stack.

<DT><CODE>SS_ONSTACK</CODE>
<DD>
<A NAME="IDX2600"></A>
This is set by the system, and indicates that the signal stack is
currently in use.  If this bit is not set, then signals will be
delivered on the normal user stack.
</DL>
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>sigaltstack</B> <I>(const struct sigaltstack *<VAR>stack</VAR>, struct sigaltstack *<VAR>oldstack</VAR>)</I>
<DD><A NAME="IDX2601"></A>
The <CODE>sigaltstack</CODE> function specifies an alternate stack for use
during signal handling.  When a signal is received by the process and
its action indicates that the signal stack is used, the system arranges
a switch to the currently installed signal stack while the handler for
that signal is executed.

</P>
<P>
If <VAR>oldstack</VAR> is not a null pointer, information about the currently
installed signal stack is returned in the location it points to.  If
<VAR>stack</VAR> is not a null pointer, then this is installed as the new
stack for use by signal handlers.

</P>
<P>
The return value is <CODE>0</CODE> on success and <CODE>-1</CODE> on failure.  If
<CODE>sigaltstack</CODE> fails, it sets <CODE>errno</CODE> to one of these values:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
You tried to disable a stack that was in fact currently in use.

<DT><CODE>ENOMEM</CODE>
<DD>
The size of the alternate stack was too small.
It must be greater than <CODE>MINSIGSTKSZ</CODE>.
</DL>
</DL>

<P>
Here is the older <CODE>sigstack</CODE> interface.  You should use
<CODE>sigaltstack</CODE> instead on systems that have it.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct sigstack</B>
<DD><A NAME="IDX2602"></A>
This structure describes a signal stack.  It contains the following members:

</P>
<DL COMPACT>

<DT><CODE>void *ss_sp</CODE>
<DD>
This is the stack pointer.  If the stack grows downwards on your
machine, this should point to the top of the area you allocated.  If the
stack grows upwards, it should point to the bottom.

<DT><CODE>int ss_onstack</CODE>
<DD>
This field is true if the process is currently using this stack.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>sigstack</B> <I>(const struct sigstack *<VAR>stack</VAR>, struct sigstack *<VAR>oldstack</VAR>)</I>
<DD><A NAME="IDX2603"></A>
The <CODE>sigstack</CODE> function specifies an alternate stack for use during
signal handling.  When a signal is received by the process and its
action indicates that the signal stack is used, the system arranges a
switch to the currently installed signal stack while the handler for
that signal is executed.

</P>
<P>
If <VAR>oldstack</VAR> is not a null pointer, information about the currently
installed signal stack is returned in the location it points to.  If
<VAR>stack</VAR> is not a null pointer, then this is installed as the new
stack for use by signal handlers.

</P>
<P>
The return value is <CODE>0</CODE> on success and <CODE>-1</CODE> on failure.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_466.html">previous</A>, <A HREF="libc_468.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
