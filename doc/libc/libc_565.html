<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Manipulating the Database</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_564.html">previous</A>, <A HREF="libc_566.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC573" HREF="libc_toc.html#TOC573">Manipulating the User Accounting Database</A></H3>

<P>
These functions and the corresponding data structures are declared in
the header file <TT>`utmp.h'</TT>.
<A NAME="IDX2943"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct exit_status</B>
<DD><A NAME="IDX2944"></A>
The <CODE>exit_status</CODE> data structure is used to hold information about
the exit status of processes marked as <CODE>DEAD_PROCESS</CODE> in the user
accounting database.

</P>
<DL COMPACT>

<DT><CODE>short int e_termination</CODE>
<DD>
The exit status of the process.

<DT><CODE>short int e_exit</CODE>
<DD>
The exit status of the process.
</DL>
</DL>

<P>
<DL>
<DT><U>Data Type:</U> <B>struct utmp</B>
<DD><A NAME="IDX2945"></A>
The <CODE>utmp</CODE> data structure is used to hold information about entries
in the user accounting database.  On the GNU system it has the following
members:

</P>
<DL COMPACT>

<DT><CODE>short int ut_type</CODE>
<DD>
Specifies the type of login; one of <CODE>EMPTY</CODE>, <CODE>RUN_LVL</CODE>,
<CODE>BOOT_TIME</CODE>, <CODE>OLD_TIME</CODE>, <CODE>NEW_TIME</CODE>, <CODE>INIT_PROCESS</CODE>,
<CODE>LOGIN_PROCESS</CODE>, <CODE>USER_PROCESS</CODE>, <CODE>DEAD_PROCESS</CODE> or
<CODE>ACCOUNTING</CODE>.

<DT><CODE>pid_t ut_pid</CODE>
<DD>
The process ID number of the login process.

<DT><CODE>char ut_line[]</CODE>
<DD>
The device name of the tty (without <TT>`/dev/'</TT>).

<DT><CODE>char ut_id[]</CODE>
<DD>
The inittab ID of the process.

<DT><CODE>char ut_user[]</CODE>
<DD>
The user's login name.

<DT><CODE>char ut_host[]</CODE>
<DD>
The name of the host from which the user logged in.

<DT><CODE>struct exit_status ut_exit</CODE>
<DD>
The exit status of a process marked as <CODE>DEAD_PROCESS</CODE>.

<DT><CODE>long ut_session</CODE>
<DD>
The Session ID, used for windowing.

<DT><CODE>struct timeval ut_tv</CODE>
<DD>
Time the entry was made.  For entries of type <CODE>OLD_TIME</CODE> this is
the time when the system clock changed, and for entries of type
<CODE>NEW_TIME</CODE> this is the time the system clock was set to.

<DT><CODE>int32_t ut_addr_v6[4]</CODE>
<DD>
The Internet address of a remote host.
</DL>
</DL>

<P>
The <CODE>ut_type</CODE>, <CODE>ut_pid</CODE>, <CODE>ut_id</CODE>, <CODE>ut_tv</CODE>, and
<CODE>ut_host</CODE> fields are not available on all systems.  Portable
applications therefore should be prepared for these situations.  To help
doing this the <TT>`utmp.h'</TT> header provides macros
<CODE>_HAVE_UT_TYPE</CODE>, <CODE>_HAVE_UT_PID</CODE>, <CODE>_HAVE_UT_ID</CODE>,
<CODE>_HAVE_UT_TV</CODE>, and <CODE>_HAVE_UT_HOST</CODE> if the respective field is
available.  The programmer can handle the situations by using
<CODE>#ifdef</CODE> in the program code.

</P>
<P>
The following macros are defined for use as values for the
<CODE>ut_type</CODE> member of the <CODE>utmp</CODE> structure.  The values are
integer constants.

</P>
<DL COMPACT>

<DT><CODE>EMPTY</CODE>
<DD>
<A NAME="IDX2946"></A>
 
This macro is used to indicate that the entry contains no valid user
accounting information.

<A NAME="IDX2947"></A>
<DT><CODE>RUN_LVL</CODE>
<DD>
This macro is used to identify the systems runlevel.

<A NAME="IDX2948"></A>
<DT><CODE>BOOT_TIME</CODE>
<DD>
This macro is used to identify the time of system boot.

<A NAME="IDX2949"></A>
<DT><CODE>OLD_TIME</CODE>
<DD>
This macro is used to identify the time when the system clock changed.

<A NAME="IDX2950"></A>
<DT><CODE>NEW_TIME</CODE>
<DD>
This macro is used to identify the time after the system changed.

<A NAME="IDX2951"></A>
<DT><CODE>INIT_PROCESS</CODE>
<DD>
This macro is used to identify a process spawned by the init process.

<A NAME="IDX2952"></A>
<DT><CODE>LOGIN_PROCESS</CODE>
<DD>
This macro is used to identify the session leader of a logged in user.

<A NAME="IDX2953"></A>
<DT><CODE>USER_PROCESS</CODE>
<DD>
This macro is used to identify a user process.

<A NAME="IDX2954"></A>
<DT><CODE>DEAD_PROCESS</CODE>
<DD>
This macro is used to identify a terminated process.

<A NAME="IDX2955"></A>
<DT><CODE>ACCOUNTING</CODE>
<DD>
???
</DL>

<P>
The size of the <CODE>ut_line</CODE>, <CODE>ut_id</CODE>, <CODE>ut_user</CODE> and
<CODE>ut_host</CODE> arrays can be found using the <CODE>sizeof</CODE> operator.

</P>
<P>
Many older systems have, instead of an <CODE>ut_tv</CODE> member, an
<CODE>ut_time</CODE> member, usually of type <CODE>time_t</CODE>, for representing
the time associated with the entry.  Therefore, for backwards
compatibility only, <TT>`utmp.h'</TT> defines <CODE>ut_time</CODE> as an alias for
<CODE>ut_tv.tv_sec</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>setutent</B> <I>(void)</I>
<DD><A NAME="IDX2956"></A>
This function opens the user accounting database to begin scanning it.
You can then call <CODE>getutent</CODE>, <CODE>getutid</CODE> or <CODE>getutline</CODE> to
read entries and <CODE>pututline</CODE> to write entries.

</P>
<P>
If the database is already open, it resets the input to the beginning of
the database.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct utmp * <B>getutent</B> <I>(void)</I>
<DD><A NAME="IDX2957"></A>
The <CODE>getutent</CODE> function reads the next entry from the user
accounting database.  It returns a pointer to the entry, which is
statically allocated and may be overwritten by subsequent calls to
<CODE>getutent</CODE>.  You must copy the contents of the structure if you
wish to save the information or you can use the <CODE>getutent_r</CODE>
function which stores the data in a user-provided buffer.

</P>
<P>
A null pointer is returned in case no further entry is available.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>endutent</B> <I>(void)</I>
<DD><A NAME="IDX2958"></A>
This function closes the user accounting database.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct utmp * <B>getutid</B> <I>(const struct utmp *<VAR>id</VAR>)</I>
<DD><A NAME="IDX2959"></A>
This function searches forward from the current point in the database
for an entry that matches <VAR>id</VAR>.  If the <CODE>ut_type</CODE> member of the
<VAR>id</VAR> structure is one of <CODE>RUN_LVL</CODE>, <CODE>BOOT_TIME</CODE>,
<CODE>OLD_TIME</CODE> or <CODE>NEW_TIME</CODE> the entries match if the
<CODE>ut_type</CODE> members are identical.  If the <CODE>ut_type</CODE> member of
the <VAR>id</VAR> structure is <CODE>INIT_PROCESS</CODE>, <CODE>LOGIN_PROCESS</CODE>,
<CODE>USER_PROCESS</CODE> or <CODE>DEAD_PROCESS</CODE>, the entries match if the
<CODE>ut_type</CODE> member of the entry read from the database is one of
these four, and the <CODE>ut_id</CODE> members match.  However if the
<CODE>ut_id</CODE> member of either the <VAR>id</VAR> structure or the entry read
from the database is empty it checks if the <CODE>ut_line</CODE> members match
instead.  If a matching entry is found, <CODE>getutid</CODE> returns a pointer
to the entry, which is statically allocated, and may be overwritten by a
subsequent call to <CODE>getutent</CODE>, <CODE>getutid</CODE> or <CODE>getutline</CODE>.
You must copy the contents of the structure if you wish to save the
information.

</P>
<P>
A null pointer is returned in case the end of the database is reached
without a match.

</P>
<P>
The <CODE>getutid</CODE> function may cache the last read entry.  Therefore,
if you are using <CODE>getutid</CODE> to search for multiple occurrences, it
is necessary to zero out the static data after each call.  Otherwise
<CODE>getutid</CODE> could just return a pointer to the same entry over and
over again.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct utmp * <B>getutline</B> <I>(const struct utmp *<VAR>line</VAR>)</I>
<DD><A NAME="IDX2960"></A>
This function searches forward from the current point in the database
until it finds an entry whose <CODE>ut_type</CODE> value is
<CODE>LOGIN_PROCESS</CODE> or <CODE>USER_PROCESS</CODE>, and whose <CODE>ut_line</CODE>
member matches the <CODE>ut_line</CODE> member of the <VAR>line</VAR> structure.
If it finds such an entry, it returns a pointer to the entry which is
statically allocated, and may be overwritten by a subsequent call to
<CODE>getutent</CODE>, <CODE>getutid</CODE> or <CODE>getutline</CODE>.  You must copy the
contents of the structure if you wish to save the information.

</P>
<P>
A null pointer is returned in case the end of the database is reached
without a match.

</P>
<P>
The <CODE>getutline</CODE> function may cache the last read entry.  Therefore
if you are using <CODE>getutline</CODE> to search for multiple occurrences, it
is necessary to zero out the static data after each call.  Otherwise
<CODE>getutline</CODE> could just return a pointer to the same entry over and
over again.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct utmp * <B>pututline</B> <I>(const struct utmp *<VAR>utmp</VAR>)</I>
<DD><A NAME="IDX2961"></A>
The <CODE>pututline</CODE> function inserts the entry <CODE>*<VAR>utmp</VAR></CODE> at
the appropriate place in the user accounting database.  If it finds that
it is not already at the correct place in the database, it uses
<CODE>getutid</CODE> to search for the position to insert the entry, however
this will not modify the static structure returned by <CODE>getutent</CODE>,
<CODE>getutid</CODE> and <CODE>getutline</CODE>.  If this search fails, the entry
is appended to the database.

</P>
<P>
The <CODE>pututline</CODE> function returns a pointer to a copy of the entry
inserted in the user accounting database, or a null pointer if the entry
could not be added.  The following <CODE>errno</CODE> error conditions are
defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EPERM</CODE>
<DD>
The process does not have the appropriate privileges; you cannot modify
the user accounting database.
</DL>
</DL>

<P>
All the <CODE>get*</CODE> functions mentioned before store the information
they return in a static buffer.  This can be a problem in multi-threaded
programs since the data return for the request is overwritten be the
return value data in another thread.  Therefore the GNU C Library
provides as extensions three more functions which return the data in a
user-provided buffer.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>getutent_r</B> <I>(struct utmp *<VAR>buffer</VAR>, struct utmp **<VAR>result</VAR>)</I>
<DD><A NAME="IDX2962"></A>
The <CODE>getutent_r</CODE> is equivalent to the <CODE>getutent</CODE> function.  It
returns the next entry from the database.  But instead of storing the
information in a static buffer it stores it in the buffer pointed to by
the parameter <VAR>buffer</VAR>.

</P>
<P>
If the call was successful, the function returns <CODE>0</CODE> and the
pointer variable pointed to by the parameter <VAR>result</VAR> contains a
pointer to the buffer which contains the result (this is most probably
the same value as <VAR>buffer</VAR>).  If something went wrong during the
execution of <CODE>getutent_r</CODE> the function returns <CODE>-1</CODE>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>getutid_r</B> <I>(const struct utmp *<VAR>id</VAR>, struct utmp *<VAR>buffer</VAR>, struct utmp **<VAR>result</VAR>)</I>
<DD><A NAME="IDX2963"></A>
This function retrieves just like <CODE>getutid</CODE> the next entry matching
the information stored in <VAR>id</VAR>.  But the result is stored in the
buffer pointed to by the parameter <VAR>buffer</VAR>.

</P>
<P>
If successful the function returns <CODE>0</CODE> and the pointer variable
pointed to by the parameter <VAR>result</VAR> contains a pointer to the
buffer with the result (probably the same as <VAR>result</VAR>.  If not
successful the function return <CODE>-1</CODE>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>getutline_r</B> <I>(const struct utmp *<VAR>line</VAR>, struct utmp *<VAR>buffer</VAR>, struct utmp **<VAR>result</VAR>)</I>
<DD><A NAME="IDX2964"></A>
This function retrieves just like <CODE>getutline</CODE> the next entry
matching the information stored in <VAR>line</VAR>.  But the result is stored
in the buffer pointed to by the parameter <VAR>buffer</VAR>.

</P>
<P>
If successful the function returns <CODE>0</CODE> and the pointer variable
pointed to by the parameter <VAR>result</VAR> contains a pointer to the
buffer with the result (probably the same as <VAR>result</VAR>.  If not
successful the function return <CODE>-1</CODE>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>

<P>
In addition to the user accounting database, most systems keep a number
of similar databases.  For example most systems keep a log file with all
previous logins (usually in <TT>`/etc/wtmp'</TT> or <TT>`/var/log/wtmp'</TT>).

</P>
<P>
For specifying which database to examine, the following function should
be used.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>utmpname</B> <I>(const char *<VAR>file</VAR>)</I>
<DD><A NAME="IDX2965"></A>
The <CODE>utmpname</CODE> function changes the name of the database to be
examined to <VAR>file</VAR>, and closes any previously opened database.  By
default <CODE>getutent</CODE>, <CODE>getutid</CODE>, <CODE>getutline</CODE> and
<CODE>pututline</CODE> read from and write to the user accounting database.

</P>
<P>
The following macros are defined for use as the <VAR>file</VAR> argument:

</P>
<P>
<DL>
<DT><U>Macro:</U> char * <B>_PATH_UTMP</B>
<DD><A NAME="IDX2966"></A>
This macro is used to specify the user accounting database.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> char * <B>_PATH_WTMP</B>
<DD><A NAME="IDX2967"></A>
This macro is used to specify the user accounting log file.
</DL>

</P>
<P>
The <CODE>utmpname</CODE> function returns a value of <CODE>0</CODE> if the new name
was successfully stored, and a value of <CODE>-1</CODE> to indicate an error.
Note that <CODE>utmpname</CODE> does not try to open the database, and that
therefore the return value does not say anything about whether the
database can be successfully opened.
</DL>

</P>
<P>
Specially for maintaining log-like databases the GNU C Library provides
the following function:

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>updwtmp</B> <I>(const char *<VAR>wtmp_file</VAR>, const struct utmp *<VAR>utmp</VAR>)</I>
<DD><A NAME="IDX2968"></A>
The <CODE>updwtmp</CODE> function appends the entry *<VAR>utmp</VAR> to the
database specified by <VAR>wtmp_file</VAR>.  For possible values for the
<VAR>wtmp_file</VAR> argument see the <CODE>utmpname</CODE> function.
</DL>

</P>
<P>
<STRONG>Portability Note:</STRONG> Although many operating systems provide a
subset of these functions, they are not standardized.  There are often
subtle differences in the return types, and there are considerable
differences between the various definitions of <CODE>struct utmp</CODE>.  When
programming for the GNU system, it is probably best to stick
with the functions described in this section.  If however, you want your
program to be portable, consider using the XPG functions described in
section <A HREF="libc_566.html#SEC574">XPG User Accounting Database Functions</A>, or take a look at the BSD compatible functions in
section <A HREF="libc_567.html#SEC575">Logging In and Out</A>.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_564.html">previous</A>, <A HREF="libc_566.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
