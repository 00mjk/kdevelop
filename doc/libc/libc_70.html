<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Search Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_69.html">previous</A>, <A HREF="libc_71.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC70" HREF="libc_toc.html#TOC70">Search Functions</A></H2>

<P>
This section describes library functions which perform various kinds
of searching operations on strings and arrays.  These functions are
declared in the header file <TT>`string.h'</TT>.
<A NAME="IDX457"></A>
<A NAME="IDX458"></A>
<A NAME="IDX459"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>memchr</B> <I>(const void *<VAR>block</VAR>, int <VAR>c</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX460"></A>
This function finds the first occurrence of the byte <VAR>c</VAR> (converted
to an <CODE>unsigned char</CODE>) in the initial <VAR>size</VAR> bytes of the
object beginning at <VAR>block</VAR>.  The return value is a pointer to the
located byte, or a null pointer if no match was found.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strchr</B> <I>(const char *<VAR>string</VAR>, int <VAR>c</VAR>)</I>
<DD><A NAME="IDX461"></A>
The <CODE>strchr</CODE> function finds the first occurrence of the character
<VAR>c</VAR> (converted to a <CODE>char</CODE>) in the null-terminated string
beginning at <VAR>string</VAR>.  The return value is a pointer to the located
character, or a null pointer if no match was found.

</P>
<P>
For example,

<PRE>
strchr ("hello, world", 'l')
    => "llo, world"
strchr ("hello, world", '?')
    => NULL
</PRE>

<P>
The terminating null character is considered to be part of the string,
so you can use this function get a pointer to the end of a string by
specifying a null character as the value of the <VAR>c</VAR> argument.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>index</B> <I>(const char *<VAR>string</VAR>, int <VAR>c</VAR>)</I>
<DD><A NAME="IDX462"></A>
<CODE>index</CODE> is another name for <CODE>strchr</CODE>; they are exactly the same.
New code should always use <CODE>strchr</CODE> since this name is defined in
ISO C while <CODE>index</CODE> is a BSD invention which never was available
on System V derived systems.
</DL>

</P>
<P>
One useful, but unusual, use of the <CODE>strchr</CODE> or <CODE>index</CODE>
function is when one wants to have a pointer pointing to the NUL byte
terminating a string.  This is often written in this way:

</P>

<PRE>
  s += strlen (s);
</PRE>

<P>
This is almost optimal but the addition operation duplicated a bit of
the work already done in the <CODE>strlen</CODE> function.  A better solution
is this:

</P>

<PRE>
  s = strchr (s, '\0');
</PRE>

<P>
There is no restriction on the second parameter of <CODE>strchr</CODE> so it
could very well also be the NUL character.  Those readers thinking very
hard about this might now point out that the <CODE>strchr</CODE> function is
more expensive than the <CODE>strlen</CODE> function since we have two abort
criteria.  This is right.  But when using the GNU C library is used this
<CODE>strchr</CODE> call gets optimized in a special way so that this version
actually is faster.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strrchr</B> <I>(const char *<VAR>string</VAR>, int <VAR>c</VAR>)</I>
<DD><A NAME="IDX463"></A>
The function <CODE>strrchr</CODE> is like <CODE>strchr</CODE>, except that it searches
backwards from the end of the string <VAR>string</VAR> (instead of forwards
from the front).

</P>
<P>
For example,

<PRE>
strrchr ("hello, world", 'l')
    => "ld"
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> char * <B>rindex</B> <I>(const char *<VAR>string</VAR>, int <VAR>c</VAR>)</I>
<DD><A NAME="IDX464"></A>
<CODE>rindex</CODE> is another name for <CODE>strrchr</CODE>; they are exactly the same.
New code should always use <CODE>strrchr</CODE> since this name is defined in
ISO C while <CODE>rindex</CODE> is a BSD invention which never was available
on System V derived systems.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strstr</B> <I>(const char *<VAR>haystack</VAR>, const char *<VAR>needle</VAR>)</I>
<DD><A NAME="IDX465"></A>
This is like <CODE>strchr</CODE>, except that it searches <VAR>haystack</VAR> for a
substring <VAR>needle</VAR> rather than just a single character.  It
returns a pointer into the string <VAR>haystack</VAR> that is the first
character of the substring, or a null pointer if no match was found.  If
<VAR>needle</VAR> is an empty string, the function returns <VAR>haystack</VAR>.

</P>
<P>
For example,

<PRE>
strstr ("hello, world", "l")
    => "llo, world"
strstr ("hello, world", "wo")
    => "world"
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void * <B>memmem</B> <I>(const void *<VAR>haystack</VAR>, size_t <VAR>haystack-len</VAR>,<BR>const void *<VAR>needle</VAR>, size_t <VAR>needle-len</VAR>)</I>
<DD><A NAME="IDX466"></A>
This is like <CODE>strstr</CODE>, but <VAR>needle</VAR> and <VAR>haystack</VAR> are byte
arrays rather than null-terminated strings.  <VAR>needle-len</VAR> is the
length of <VAR>needle</VAR> and <VAR>haystack-len</VAR> is the length of
<VAR>haystack</VAR>.
</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>strspn</B> <I>(const char *<VAR>string</VAR>, const char *<VAR>skipset</VAR>)</I>
<DD><A NAME="IDX467"></A>
The <CODE>strspn</CODE> ("string span") function returns the length of the
initial substring of <VAR>string</VAR> that consists entirely of characters that
are members of the set specified by the string <VAR>skipset</VAR>.  The order
of the characters in <VAR>skipset</VAR> is not important.

</P>
<P>
For example,

<PRE>
strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
    => 5
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> size_t <B>strcspn</B> <I>(const char *<VAR>string</VAR>, const char *<VAR>stopset</VAR>)</I>
<DD><A NAME="IDX468"></A>
The <CODE>strcspn</CODE> ("string complement span") function returns the length
of the initial substring of <VAR>string</VAR> that consists entirely of characters
that are <EM>not</EM> members of the set specified by the string <VAR>stopset</VAR>.
(In other words, it returns the offset of the first character in <VAR>string</VAR>
that is a member of the set <VAR>stopset</VAR>.)

</P>
<P>
For example,

<PRE>
strcspn ("hello, world", " \t\n,.;!?")
    => 5
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> char * <B>strpbrk</B> <I>(const char *<VAR>string</VAR>, const char *<VAR>stopset</VAR>)</I>
<DD><A NAME="IDX469"></A>
The <CODE>strpbrk</CODE> ("string pointer break") function is related to
<CODE>strcspn</CODE>, except that it returns a pointer to the first character
in <VAR>string</VAR> that is a member of the set <VAR>stopset</VAR> instead of the
length of the initial substring.  It returns a null pointer if no such
character from <VAR>stopset</VAR> is found.

</P>
<P>
For example,

</P>

<PRE>
strpbrk ("hello, world", " \t\n,.;!?")
    => ", world"
</PRE>

</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_69.html">previous</A>, <A HREF="libc_71.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
