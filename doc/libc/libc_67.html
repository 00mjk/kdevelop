<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Copying and Concatenation</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_66.html">previous</A>, <A HREF="libc_68.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC67" HREF="libc_toc.html#TOC67">Copying and Concatenation</A></H2>

<P>
You can use the functions described in this section to copy the contents
of strings and arrays, or to append the contents of one string to
another.  These functions are declared in the header file
<TT>`string.h'</TT>.
<A NAME="IDX413"></A>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>

</P>
<P>
A helpful way to remember the ordering of the arguments to the functions
in this section is that it corresponds to an assignment expression, with
the destination array specified to the left of the source array.  All
of these functions return the address of the destination array.

</P>
<P>
Most of these functions do not work properly if the source and
destination arrays overlap.  For example, if the beginning of the
destination array overlaps the end of the source array, the original
contents of that part of the source array may get overwritten before it
is copied.  Even worse, in the case of the string functions, the null
character marking the end of the string may be lost, and the copy
function might get stuck in a loop trashing all the memory allocated to
your program.

</P>
<P>
All functions that have problems copying between overlapping arrays are
explicitly identified in this manual.  In addition to functions in this
section, there are a few others like <CODE>sprintf</CODE> (see section <A HREF="libc_174.html#SEC181">Formatted Output Functions</A>) and <CODE>scanf</CODE> (see section <A HREF="libc_193.html#SEC200">Formatted Input Functions</A>).

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>memcpy</B> <I>(void *<VAR>to</VAR>, const void *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX419"></A>
The <CODE>memcpy</CODE> function copies <VAR>size</VAR> bytes from the object
beginning at <VAR>from</VAR> into the object beginning at <VAR>to</VAR>.  The
behavior of this function is undefined if the two arrays <VAR>to</VAR> and
<VAR>from</VAR> overlap; use <CODE>memmove</CODE> instead if overlapping is possible.

</P>
<P>
The value returned by <CODE>memcpy</CODE> is the value of <VAR>to</VAR>.

</P>
<P>
Here is an example of how you might use <CODE>memcpy</CODE> to copy the
contents of an array:

</P>

<PRE>
struct foo *oldarray, *newarray;
int arraysize;
...
memcpy (new, old, arraysize * sizeof (struct foo));
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> void * <B>mempcpy</B> <I>(void *<VAR>to</VAR>, const void *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX420"></A>
The <CODE>mempcpy</CODE> function is nearly identical to the <CODE>memcpy</CODE>
function.  It copies <VAR>size</VAR> bytes from the object beginning at
<CODE>from</CODE> into the object pointed to by <VAR>to</VAR>.  But instead of
returning the value of <CODE>to</CODE> it returns a pointer to the byte
following the last written byte in the object beginning at <VAR>to</VAR>.
I.e., the value is <CODE>((void *) ((char *) <VAR>to</VAR> + <VAR>size</VAR>))</CODE>.

</P>
<P>
This function is useful in situations where a number of objects shall be
copied to consecutive memory positions.

</P>

<PRE>
void *
combine (void *o1, size_t s1, void *o2, size_t s2)
{
  void *result = malloc (s1 + s2);
  if (result != NULL)
    mempcpy (mempcpy (result, o1, s1), o2, s2);
  return result;
}
</PRE>

<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>memmove</B> <I>(void *<VAR>to</VAR>, const void *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX421"></A>
<CODE>memmove</CODE> copies the <VAR>size</VAR> bytes at <VAR>from</VAR> into the
<VAR>size</VAR> bytes at <VAR>to</VAR>, even if those two blocks of space
overlap.  In the case of overlap, <CODE>memmove</CODE> is careful to copy the
original values of the bytes in the block at <VAR>from</VAR>, including those
bytes which also belong to the block at <VAR>to</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>memccpy</B> <I>(void *<VAR>to</VAR>, const void *<VAR>from</VAR>, int <VAR>c</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX422"></A>
This function copies no more than <VAR>size</VAR> bytes from <VAR>from</VAR> to
<VAR>to</VAR>, stopping if a byte matching <VAR>c</VAR> is found.  The return
value is a pointer into <VAR>to</VAR> one byte past where <VAR>c</VAR> was copied,
or a null pointer if no byte matching <VAR>c</VAR> appeared in the first
<VAR>size</VAR> bytes of <VAR>from</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>memset</B> <I>(void *<VAR>block</VAR>, int <VAR>c</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX423"></A>
This function copies the value of <VAR>c</VAR> (converted to an
<CODE>unsigned char</CODE>) into each of the first <VAR>size</VAR> bytes of the
object beginning at <VAR>block</VAR>.  It returns the value of <VAR>block</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strcpy</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>)</I>
<DD><A NAME="IDX424"></A>
This copies characters from the string <VAR>from</VAR> (up to and including
the terminating null character) into the string <VAR>to</VAR>.  Like
<CODE>memcpy</CODE>, this function has undefined results if the strings
overlap.  The return value is the value of <VAR>to</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strncpy</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX425"></A>
This function is similar to <CODE>strcpy</CODE> but always copies exactly
<VAR>size</VAR> characters into <VAR>to</VAR>.

</P>
<P>
If the length of <VAR>from</VAR> is more than <VAR>size</VAR>, then <CODE>strncpy</CODE>
copies just the first <VAR>size</VAR> characters.  Note that in this case
there is no null terminator written into <VAR>to</VAR>.

</P>
<P>
If the length of <VAR>from</VAR> is less than <VAR>size</VAR>, then <CODE>strncpy</CODE>
copies all of <VAR>from</VAR>, followed by enough null characters to add up
to <VAR>size</VAR> characters in all.  This behavior is rarely useful, but it
is specified by the ISO C standard.

</P>
<P>
The behavior of <CODE>strncpy</CODE> is undefined if the strings overlap.

</P>
<P>
Using <CODE>strncpy</CODE> as opposed to <CODE>strcpy</CODE> is a way to avoid bugs
relating to writing past the end of the allocated space for <VAR>to</VAR>.
However, it can also make your program much slower in one common case:
copying a string which is probably small into a potentially large buffer.
In this case, <VAR>size</VAR> may be large, and when it is, <CODE>strncpy</CODE> will
waste a considerable amount of time copying null characters.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strdup</B> <I>(const char *<VAR>s</VAR>)</I>
<DD><A NAME="IDX426"></A>
This function copies the null-terminated string <VAR>s</VAR> into a newly
allocated string.  The string is allocated using <CODE>malloc</CODE>; see
section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>.  If <CODE>malloc</CODE> cannot allocate space
for the new string, <CODE>strdup</CODE> returns a null pointer.  Otherwise it
returns a pointer to the new string.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strndup</B> <I>(const char *<VAR>s</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX427"></A>
This function is similar to <CODE>strdup</CODE> but always copies at most
<VAR>size</VAR> characters into the newly allocated string.

</P>
<P>
If the length of <VAR>s</VAR> is more than <VAR>size</VAR>, then <CODE>strndup</CODE>
copies just the first <VAR>size</VAR> characters and adds a closing null
terminator.  Otherwise all characters are copied and the string is
terminated.

</P>
<P>
This function is different to <CODE>strncpy</CODE> in that it always
terminates the destination string.

</P>
<P>
<CODE>strndup</CODE> is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>stpcpy</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>)</I>
<DD><A NAME="IDX428"></A>
This function is like <CODE>strcpy</CODE>, except that it returns a pointer to
the end of the string <VAR>to</VAR> (that is, the address of the terminating
null character) rather than the beginning.

</P>
<P>
For example, this program uses <CODE>stpcpy</CODE> to concatenate <SAMP>`foo'</SAMP>
and <SAMP>`bar'</SAMP> to produce <SAMP>`foobar'</SAMP>, which it then prints.

</P>

<PRE>
#include &#60;string.h&#62;
#include &#60;stdio.h&#62;

int
main (void)
{
  char buffer[10];
  char *to = buffer;
  to = stpcpy (to, "foo");
  to = stpcpy (to, "bar");
  puts (buffer);
  return 0;
}
</PRE>

<P>
This function is not part of the ISO or POSIX standards, and is not
customary on Unix systems, but we did not invent it either.  Perhaps it
comes from MS-DOG.

</P>
<P>
Its behavior is undefined if the strings overlap.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>stpncpy</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX429"></A>
This function is similar to <CODE>stpcpy</CODE> but copies always exactly
<VAR>size</VAR> characters into <VAR>to</VAR>.

</P>
<P>
If the length of <VAR>from</VAR> is more then <VAR>size</VAR>, then <CODE>stpncpy</CODE>
copies just the first <VAR>size</VAR> characters and returns a pointer to the
character directly following the one which was copied last.  Note that in
this case there is no null terminator written into <VAR>to</VAR>.

</P>
<P>
If the length of <VAR>from</VAR> is less than <VAR>size</VAR>, then <CODE>stpncpy</CODE>
copies all of <VAR>from</VAR>, followed by enough null characters to add up
to <VAR>size</VAR> characters in all.  This behaviour is rarely useful, but it
is implemented to be useful in contexts where this behaviour of the
<CODE>strncpy</CODE> is used.  <CODE>stpncpy</CODE> returns a pointer to the
<EM>first</EM> written null character.

</P>
<P>
This function is not part of ISO or POSIX but was found useful while
developing the GNU C Library itself.

</P>
<P>
Its behaviour is undefined if the strings overlap.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> char * <B>strdupa</B> <I>(const char *<VAR>s</VAR>)</I>
<DD><A NAME="IDX430"></A>
This function is similar to <CODE>strdup</CODE> but allocates the new string
using <CODE>alloca</CODE> instead of <CODE>malloc</CODE> (see section <A HREF="libc_52.html#SEC52">Automatic Storage with Variable Size</A>).  This means of course the returned string has the same
limitations as any block of memory allocated using <CODE>alloca</CODE>.

</P>
<P>
For obvious reasons <CODE>strdupa</CODE> is implemented only as a macro;
you cannot get the address of this function.  Despite this limitation
it is a useful function.  The following code shows a situation where
using <CODE>malloc</CODE> would be a lot more expensive.

</P>

<PRE>
#include &#60;paths.h&#62;
#include &#60;string.h&#62;
#include &#60;stdio.h&#62;

const char path[] = _PATH_STDPATH;

int
main (void)
{
  char *wr_path = strdupa (path);
  char *cp = strtok (wr_path, ":");

  while (cp != NULL)
    {
      puts (cp);
      cp = strtok (NULL, ":");
    }
  return 0;
}
</PRE>

<P>
Please note that calling <CODE>strtok</CODE> using <VAR>path</VAR> directly is
invalid.

</P>
<P>
This function is only available if GNU CC is used.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> char * <B>strndupa</B> <I>(const char *<VAR>s</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX431"></A>
This function is similar to <CODE>strndup</CODE> but like <CODE>strdupa</CODE> it
allocates the new string using <CODE>alloca</CODE>
see section <A HREF="libc_52.html#SEC52">Automatic Storage with Variable Size</A>.  The same advantages and limitations
of <CODE>strdupa</CODE> are valid for <CODE>strndupa</CODE>, too.

</P>
<P>
This function is implemented only as a macro, just like <CODE>strdupa</CODE>.

</P>
<P>
<CODE>strndupa</CODE> is only available if GNU CC is used.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strcat</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>)</I>
<DD><A NAME="IDX432"></A>
The <CODE>strcat</CODE> function is similar to <CODE>strcpy</CODE>, except that the
characters from <VAR>from</VAR> are concatenated or appended to the end of
<VAR>to</VAR>, instead of overwriting it.  That is, the first character from
<VAR>from</VAR> overwrites the null character marking the end of <VAR>to</VAR>.

</P>
<P>
An equivalent definition for <CODE>strcat</CODE> would be:

</P>

<PRE>
char *
strcat (char *to, const char *from)
{
  strcpy (to + strlen (to), from);
  return to;
}
</PRE>

<P>
This function has undefined results if the strings overlap.
</DL>

</P>
<P>
Programmers using the <CODE>strcat</CODE> function (or the following
<CODE>strncat</CODE> function for that matter) can easily be recognize as
lazy.  In almost all situations the lengths of the participating strings
are known.  Or at least, one could know them if one keeps track of the
results of the various function calls.  But then it is very inefficient
to use <CODE>strcat</CODE>.  A lot of time is wasted finding the end of the
destination string so that the actual copying can start.  This is a
common example:

</P>
<P>
<A NAME="IDX433"></A>
<A NAME="IDX434"></A>

<PRE>
/* This function concatenates arbitrarily many strings.  The last
   parameter must be <CODE>NULL</CODE>.  */
char *
concat (const char *str, ...)
{
  va_list ap, ap2;
  size_t total = 1;
  const char *s;
  char *result;

  va_start (ap, str);
  /* Actually <CODE>va_copy</CODE>, but this is the name more gcc versions
     understand.  */
  __va_copy (ap2, ap);

  /* Determine how much space we need.  */
  for (s = str; s != NULL; s = va_arg (ap, const char *))
    total += strlen (s);

  va_end (ap);

  result = (char *) malloc (total);
  if (result != NULL)
    {
      result[0] = '\0';

      /* Copy the strings.  */
      for (s = str; s != NULL; s = va_arg (ap2, const char *))
        strcat (result, s);
    }

  va_end (ap2);

  return result;
}
</PRE>

<P>
This looks quite simple, especially the second loop where the strings
are actually copied.  But these innocent lines hide a major performance
penalty.  Just imagine that ten strings of 100 bytes each have to be
concatenated.  For the second string we search the already stored 100
bytes for the end of the string so that we can append the next string.
For all strings in total the comparisons necessary to find the end of
the intermediate results sums up to 5500!  If we combine the copying
with the search for the allocation we can write this function more
efficient:

</P>

<PRE>
char *
concat (const char *str, ...)
{
  va_list ap;
  size_t allocated = 100;
  char *result = (char *) malloc (allocated);
  char *wp;

  if (allocated != NULL)
    {
      char *newp;

      va_start (ap, atr);

      wp = result;
      for (s = str; s != NULL; s = va_arg (ap, const char *))
        {
          size_t len = strlen (s);

          /* Resize the allocated memory if necessary.  */
          if (wp + len + 1 &#62; result + allocated)
            {
              allocated = (allocated + len) * 2;
              newp = (char *) realloc (result, allocated);
              if (newp == NULL)
                {
                  free (result);
                  return NULL;
                }
              wp = newp + (wp - result);
              result = newp;
            }

          wp = mempcpy (wp, s, len);
        }

      /* Terminate the result string.  */
      *wp++ = '\0';

      /* Resize memory to the optimal size.  */
      newp = realloc (result, wp - result);
      if (newp != NULL)
        result = newp;

      va_end (ap);
    }

  return result;
}
</PRE>

<P>
With a bit more knowledge about the input strings one could fine-tune
the memory allocation.  The difference we are pointing to here is that
we don't use <CODE>strcat</CODE> anymore.  We always keep track of the length
of the current intermediate result so we can safe us the search for the
end of the string and use <CODE>mempcpy</CODE>.  Please note that we also
don't use <CODE>stpcpy</CODE> which might seem more natural since we handle
with strings.  But this is not necessary since we already know the
length of the string and therefore can use the faster memory copying
function.

</P>
<P>
Whenever a programmer feels the need to use <CODE>strcat</CODE> she or he
should think twice and look through the program whether the code cannot
be rewritten to take advantage of already calculated results.  Again: it
is almost always unnecessary to use <CODE>strcat</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strncat</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX435"></A>
This function is like <CODE>strcat</CODE> except that not more than <VAR>size</VAR>
characters from <VAR>from</VAR> are appended to the end of <VAR>to</VAR>.  A
single null character is also always appended to <VAR>to</VAR>, so the total
allocated size of <VAR>to</VAR> must be at least <CODE><VAR>size</VAR> + 1</CODE> bytes
longer than its initial length.

</P>
<P>
The <CODE>strncat</CODE> function could be implemented like this:

</P>

<PRE>
char *
strncat (char *to, const char *from, size_t size)
{
  strncpy (to + strlen (to), from, size);
  return to;
}
</PRE>

<P>
The behavior of <CODE>strncat</CODE> is undefined if the strings overlap.
</DL>

</P>
<P>
Here is an example showing the use of <CODE>strncpy</CODE> and <CODE>strncat</CODE>.
Notice how, in the call to <CODE>strncat</CODE>, the <VAR>size</VAR> parameter
is computed to avoid overflowing the character array <CODE>buffer</CODE>.

</P>

<PRE>
#include &#60;string.h&#62;
#include &#60;stdio.h&#62;

#define SIZE 10

static char buffer[SIZE];

main ()
{
  strncpy (buffer, "hello", SIZE);
  puts (buffer);
  strncat (buffer, ", world", SIZE - strlen (buffer) - 1);
  puts (buffer);
}
</PRE>

<P>
The output produced by this program looks like:

</P>

<PRE>
hello
hello, wo
</PRE>

<P>
<DL>
<DT><U>Function:</U> void <B>bcopy</B> <I>(const void *<VAR>from</VAR>, void *<VAR>to</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX436"></A>
This is a partially obsolete alternative for <CODE>memmove</CODE>, derived from
BSD.  Note that it is not quite equivalent to <CODE>memmove</CODE>, because the
arguments are not in the same order and there is no return value.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>bzero</B> <I>(void *<VAR>block</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX437"></A>
This is a partially obsolete alternative for <CODE>memset</CODE>, derived from
BSD.  Note that it is not as general as <CODE>memset</CODE>, because the only
value it can store is zero.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_66.html">previous</A>, <A HREF="libc_68.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
