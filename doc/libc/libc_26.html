<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Changing Block Size</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_25.html">previous</A>, <A HREF="libc_27.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC26" HREF="libc_toc.html#TOC26">Changing the Size of a Block</A></H3>
<P>
<A NAME="IDX225"></A>

</P>
<P>
Often you do not know for certain how big a block you will ultimately need
at the time you must begin to use the block.  For example, the block might
be a buffer that you use to hold a line being read from a file; no matter
how long you make the buffer initially, you may encounter a line that is
longer.

</P>
<P>
You can make the block longer by calling <CODE>realloc</CODE>.  This function
is declared in <TT>`stdlib.h'</TT>.
<A NAME="IDX226"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>realloc</B> <I>(void *<VAR>ptr</VAR>, size_t <VAR>newsize</VAR>)</I>
<DD><A NAME="IDX227"></A>
The <CODE>realloc</CODE> function changes the size of the block whose address is
<VAR>ptr</VAR> to be <VAR>newsize</VAR>.

</P>
<P>
Since the space after the end of the block may be in use, <CODE>realloc</CODE>
may find it necessary to copy the block to a new address where more free
space is available.  The value of <CODE>realloc</CODE> is the new address of the
block.  If the block needs to be moved, <CODE>realloc</CODE> copies the old
contents.

</P>
<P>
If you pass a null pointer for <VAR>ptr</VAR>, <CODE>realloc</CODE> behaves just
like <SAMP>`malloc (<VAR>newsize</VAR>)'</SAMP>.  This can be convenient, but beware
that older implementations (before ISO C) may not support this
behavior, and will probably crash when <CODE>realloc</CODE> is passed a null
pointer.
</DL>

</P>
<P>
Like <CODE>malloc</CODE>, <CODE>realloc</CODE> may return a null pointer if no
memory space is available to make the block bigger.  When this happens,
the original block is untouched; it has not been modified or relocated.

</P>
<P>
In most cases it makes no difference what happens to the original block
when <CODE>realloc</CODE> fails, because the application program cannot continue
when it is out of memory, and the only thing to do is to give a fatal error
message.  Often it is convenient to write and use a subroutine,
conventionally called <CODE>xrealloc</CODE>, that takes care of the error message
as <CODE>xmalloc</CODE> does for <CODE>malloc</CODE>:

</P>

<PRE>
void *
xrealloc (void *ptr, size_t size)
{
  register void *value = realloc (ptr, size);
  if (value == 0)
    fatal ("Virtual memory exhausted");
  return value;
}
</PRE>

<P>
You can also use <CODE>realloc</CODE> to make a block smaller.  The reason you
would do this is to avoid tying up a lot of memory space when only a little
is needed.
In several allocation implementations, making a block smaller sometimes
necessitates copying it, so it can fail if no other space is available.

</P>
<P>
If the new size you specify is the same as the old size, <CODE>realloc</CODE>
is guaranteed to change nothing and return the same address that you gave.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_25.html">previous</A>, <A HREF="libc_27.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
