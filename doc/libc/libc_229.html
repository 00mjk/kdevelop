<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Status of AIO Operations</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_228.html">previous</A>, <A HREF="libc_230.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC236" HREF="libc_toc.html#TOC236">Getting the Status of AIO Operations</A></H3>

<P>
As already described in the documentation of the functions in the last
section it must be possible to get information about the status of a I/O
request.  When the operation is performed really asynchronous (as with
<CODE>aio_read</CODE> and <CODE>aio_write</CODE> and with <CODE>aio_listio</CODE> when the
mode is <CODE>LIO_NOWAIT</CODE>) one sometimes needs to know whether a
specific request already terminated and if yes, what the result was..
The following two function allow to get this kind of information.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_error</B> <I>(const struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1079"></A>
This function determines the error state of the request described by the
<CODE>struct aiocb</CODE> variable pointed to by <VAR>aiocbp</VAR>.  If the
request has not yet terminated the value returned is always
<CODE>EINPROGRESS</CODE>.  Once the request has terminated the value
<CODE>aio_error</CODE> returns is either @math{0} if the request completed
successfully or it returns the value which would be stored in the
<CODE>errno</CODE> variable if the request would have been done using
<CODE>read</CODE>, <CODE>write</CODE>, or <CODE>fsync</CODE>.

</P>
<P>
The function can return <CODE>ENOSYS</CODE> if it is not implemented.  It
could also return <CODE>EINVAL</CODE> if the <VAR>aiocbp</VAR> parameter does not
refer to an asynchronous operation whose return status is not yet known.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_error64</CODE> since the LFS interface
transparently replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_error64</B> <I>(const struct aiocb64 *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1080"></A>
This function is similar to <CODE>aio_error</CODE> with the only difference
that the argument is a reference to a variable of type <CODE>struct
aiocb64</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_error</CODE> and so
transparently replaces the interface for small files on 32 bits
machines.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>aio_return</B> <I>(const struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1081"></A>
This function can be used to retrieve the return status of the operation
carried out by the request described in the variable pointed to by
<VAR>aiocbp</VAR>.  As long as the error status of this request as returned
by <CODE>aio_error</CODE> is <CODE>EINPROGRESS</CODE> the return of this function is
undefined.

</P>
<P>
Once the request is finished this function can be used exactly once to
retrieve the return value.  Following calls might lead to undefined
behaviour.  The return value itself is the value which would have been
returned by the <CODE>read</CODE>, <CODE>write</CODE>, or <CODE>fsync</CODE> call.

</P>
<P>
The function can return <CODE>ENOSYS</CODE> if it is not implemented.  It
could also return <CODE>EINVAL</CODE> if the <VAR>aiocbp</VAR> parameter does not
refer to an asynchronous operation whose return status is not yet known.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_return64</CODE> since the LFS interface
transparently replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_return64</B> <I>(const struct aiocb64 *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1082"></A>
This function is similar to <CODE>aio_return</CODE> with the only difference
that the argument is a reference to a variable of type <CODE>struct
aiocb64</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_return</CODE> and so
transparently replaces the interface for small files on 32 bits
machines.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_228.html">previous</A>, <A HREF="libc_230.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
