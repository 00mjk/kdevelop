<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Allocation in an Obstack</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_42.html">previous</A>, <A HREF="libc_44.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC43" HREF="libc_toc.html#TOC43">Allocation in an Obstack</A></H3>
<P>
<A NAME="IDX265"></A>

</P>
<P>
The most direct way to allocate an object in an obstack is with
<CODE>obstack_alloc</CODE>, which is invoked almost like <CODE>malloc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>obstack_alloc</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, int <VAR>size</VAR>)</I>
<DD><A NAME="IDX266"></A>
This allocates an uninitialized block of <VAR>size</VAR> bytes in an obstack
and returns its address.  Here <VAR>obstack-ptr</VAR> specifies which obstack
to allocate the block in; it is the address of the <CODE>struct obstack</CODE>
object which represents the obstack.  Each obstack function or macro
requires you to specify an <VAR>obstack-ptr</VAR> as the first argument.

</P>
<P>
This function calls the obstack's <CODE>obstack_chunk_alloc</CODE> function if
it needs to allocate a new chunk of memory; it calls
<CODE>obstack_alloc_failed_handler</CODE> if allocation of memory by
<CODE>obstack_chunk_alloc</CODE> failed.
</DL>

</P>
<P>
For example, here is a function that allocates a copy of a string <VAR>str</VAR>
in a specific obstack, which is in the variable <CODE>string_obstack</CODE>:

</P>

<PRE>
struct obstack string_obstack;

char *
copystring (char *string)
{
  size_t len = strlen (string) + 1;
  char *s = (char *) obstack_alloc (&#38;string_obstack, len);
  memcpy (s, string, len);
  return s;
}
</PRE>

<P>
To allocate a block with specified contents, use the function
<CODE>obstack_copy</CODE>, declared like this:

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>obstack_copy</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, void *<VAR>address</VAR>, int <VAR>size</VAR>)</I>
<DD><A NAME="IDX267"></A>
This allocates a block and initializes it by copying <VAR>size</VAR>
bytes of data starting at <VAR>address</VAR>.  It calls
<CODE>obstack_alloc_failed_handler</CODE> if allocation of memory by
<CODE>obstack_chunk_alloc</CODE> failed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>obstack_copy0</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, void *<VAR>address</VAR>, int <VAR>size</VAR>)</I>
<DD><A NAME="IDX268"></A>
Like <CODE>obstack_copy</CODE>, but appends an extra byte containing a null
character.  This extra byte is not counted in the argument <VAR>size</VAR>.
</DL>

</P>
<P>
The <CODE>obstack_copy0</CODE> function is convenient for copying a sequence
of characters into an obstack as a null-terminated string.  Here is an
example of its use:

</P>

<PRE>
char *
obstack_savestring (char *addr, int size)
{
  return obstack_copy0 (&#38;myobstack, addr, size);
}
</PRE>

<P>
Contrast this with the previous example of <CODE>savestring</CODE> using
<CODE>malloc</CODE> (see section <A HREF="libc_23.html#SEC23">Basic Storage Allocation</A>).

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_42.html">previous</A>, <A HREF="libc_44.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
