<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - SVID Random</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_364.html">previous</A>, <A HREF="libc_366.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC372" HREF="libc_toc.html#TOC372">SVID Random Number Function</A></H3>

<P>
The C library on SVID systems contains yet another kind of random number
generator functions.  They use a state of 48 bits of data.  The user can
choose among a collection of functions which return the random bits
in different forms.

</P>
<P>
Generally there are two kinds of functions: those which use a state of
the random number generator which is shared among several functions and
by all threads of the process.  The second group of functions require
the user to handle the state.

</P>
<P>
All functions have in common that they use the same congruential
formula with the same constants.  The formula is

</P>

<PRE>
Y = (a * X + c) mod m
</PRE>

<P>
where <VAR>X</VAR> is the state of the generator at the beginning and
<VAR>Y</VAR> the state at the end.  <CODE>a</CODE> and <CODE>c</CODE> are constants
determining the way the generator work.  By default they are

</P>

<PRE>
a = 0x5DEECE66D = 25214903917
c = 0xb = 11
</PRE>

<P>
but they can also be changed by the user.  <CODE>m</CODE> is of course 2^48
since the state consists of a 48 bit array.

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>drand48</B> <I>(void)</I>
<DD><A NAME="IDX2011"></A>
This function returns a <CODE>double</CODE> value in the range of <CODE>0.0</CODE>
to <CODE>1.0</CODE> (exclusive).  The random bits are determined by the global
state of the random number generator in the C library.

</P>
<P>
Since the <CODE>double</CODE> type according to IEEE 754 has a 52 bit
mantissa this means 4 bits are not initialized by the random number
generator.  These are (of course) chosen to be the least significant
bits and they are initialized to <CODE>0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>erand48</B> <I>(unsigned short int <VAR>xsubi</VAR>[3])</I>
<DD><A NAME="IDX2012"></A>
This function returns a <CODE>double</CODE> value in the range of <CODE>0.0</CODE>
to <CODE>1.0</CODE> (exclusive), similar to <CODE>drand48</CODE>.  The argument is
an array describing the state of the random number generator.

</P>
<P>
This function can be called subsequently since it updates the array to
guarantee random numbers.  The array should have been initialized before
using to get reproducible results.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>lrand48</B> <I>(void)</I>
<DD><A NAME="IDX2013"></A>
The <CODE>lrand48</CODE> functions return an integer value in the range of
<CODE>0</CODE> to <CODE>2^31</CODE> (exclusive).  Even if the size of the <CODE>long
int</CODE> type can take more than 32 bits no higher numbers are returned.
The random bits are determined by the global state of the random number
generator in the C library.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>nrand48</B> <I>(unsigned short int <VAR>xsubi</VAR>[3])</I>
<DD><A NAME="IDX2014"></A>
This function is similar to the <CODE>lrand48</CODE> function in that it
returns a number in the range of <CODE>0</CODE> to <CODE>2^31</CODE> (exclusive) but
the state of the random number generator used to produce the random bits
is determined by the array provided as the parameter to the function.

</P>
<P>
The numbers in the array are afterwards updated so that subsequent calls
to this function yield to different results (as it is expected by a
random number generator).  The array should have been initialized before
the first call to get reproducible results.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>mrand48</B> <I>(void)</I>
<DD><A NAME="IDX2015"></A>
The <CODE>mrand48</CODE> function is similar to <CODE>lrand48</CODE>.  The only
difference is that the numbers returned are in the range <CODE>-2^31</CODE> to
<CODE>2^31</CODE> (exclusive).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>jrand48</B> <I>(unsigned short int <VAR>xsubi</VAR>[3])</I>
<DD><A NAME="IDX2016"></A>
The <CODE>jrand48</CODE> function is similar to <CODE>nrand48</CODE>.  The only
difference is that the numbers returned are in the range <CODE>-2^31</CODE> to
<CODE>2^31</CODE> (exclusive).  For the <CODE>xsubi</CODE> parameter the same
requirements are necessary.
</DL>

</P>
<P>
The internal state of the random number generator can be initialized in
several ways.  The functions differ in the completeness of the
information provided.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>srand48</B> <I>(long int <VAR>seedval</VAR>))</I>
<DD><A NAME="IDX2017"></A>
The <CODE>srand48</CODE> function sets the most significant 32 bits of the
state internal state of the random number generator to the least
significant 32 bits of the <VAR>seedval</VAR> parameter.  The lower 16 bits
are initialized to the value <CODE>0x330E</CODE>.  Even if the <CODE>long
int</CODE> type contains more the 32 bits only the lower 32 bits are used.

</P>
<P>
Due to this limitation the initialization of the state using this
function of not very useful.  But it makes it easy to use a construct
like <CODE>srand48 (time (0))</CODE>.

</P>
<P>
A side-effect of this function is that the values <CODE>a</CODE> and <CODE>c</CODE>
from the internal state, which are used in the congruential formula,
are reset to the default values given above.  This is of importance once
the user called the <CODE>lcong48</CODE> function (see below).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned short int * <B>seed48</B> <I>(unsigned short int <VAR>seed16v</VAR>[3])</I>
<DD><A NAME="IDX2018"></A>
The <CODE>seed48</CODE> function initializes all 48 bits of the state of the
internal random number generator from the content of the parameter
<VAR>seed16v</VAR>.  Here the lower 16 bits of the first element of
<VAR>see16v</VAR> initialize the least significant 16 bits of the internal
state, the lower 16 bits of <CODE><VAR>seed16v</VAR>[1]</CODE> initialize the mid-order
16 bits of the state and the 16 lower bits of <CODE><VAR>seed16v</VAR>[2]</CODE>
initialize the most significant 16 bits of the state.

</P>
<P>
Unlike <CODE>srand48</CODE> this function lets the user initialize all 48 bits
of the state.

</P>
<P>
The value returned by <CODE>seed48</CODE> is a pointer to an array containing
the values of the internal state before the change.  This might be
useful to restart the random number generator at a certain state.
Otherwise, the value can simply be ignored.

</P>
<P>
As for <CODE>srand48</CODE>, the values <CODE>a</CODE> and <CODE>c</CODE> from the
congruential formula are reset to the default values.
</DL>

</P>
<P>
There is one more function to initialize the random number generator
which allows to specify even more information by allowing to change the
parameters in the congruential formula.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>lcong48</B> <I>(unsigned short int <VAR>param</VAR>[7])</I>
<DD><A NAME="IDX2019"></A>
The <CODE>lcong48</CODE> function allows the user to change the complete state
of the random number generator.  Unlike <CODE>srand48</CODE> and
<CODE>seed48</CODE>, this function also changes the constants in the
congruential formula.

</P>
<P>
From the seven elements in the array <VAR>param</VAR> the least significant
16 bits of the entries <CODE><VAR>param</VAR>[0]</CODE> to <CODE><VAR>param</VAR>[2]</CODE>
determine the initial state, the least 16 bits of
<CODE><VAR>param</VAR>[3]</CODE> to <CODE><VAR>param</VAR>[5]</CODE> determine the 48 bit
constant <CODE>a</CODE> and <CODE><VAR>param</VAR>[6]</CODE> determines the 16 bit value
<CODE>c</CODE>.
</DL>

</P>
<P>
All the above functions have in common that they use the global
parameters for the congruential formula.  In multi-threaded programs it
might sometimes be useful to have different parameters in different
threads.  For this reason all the above functions have a counterpart
which works on a description of the random number generator in the
user-supplied buffer instead of the global state.

</P>
<P>
Please note that it is no problem if several threads use the global
state if all threads use the functions which take a pointer to an array
containing the state.  The random numbers are computed following the
same loop but if the state in the array is different all threads will
get an individual random number generator.

</P>
<P>
The user supplied buffer must be of type <CODE>struct drand48_data</CODE>.
This type should be regarded as opaque and no member should be used
directly.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>drand48_r</B> <I>(struct drand48_data *<VAR>buffer</VAR>, double *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2020"></A>
This function is equivalent to the <CODE>drand48</CODE> function with the
difference it does not modify the global random number generator
parameters but instead the parameters is the buffer supplied by the
buffer through the pointer <VAR>buffer</VAR>.  The random number is return in
the variable pointed to by <VAR>result</VAR>.

</P>
<P>
The return value of the function indicate whether the call succeeded.
If the value is less than <CODE>0</CODE> an error occurred and <VAR>errno</VAR> is
set to indicate the problem.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>erand48_r</B> <I>(unsigned short int <VAR>xsubi</VAR>[3], struct drand48_data *<VAR>buffer</VAR>, double *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2021"></A>
The <CODE>erand48_r</CODE> function works like the <CODE>erand48</CODE> and it takes
an argument <VAR>buffer</VAR> which describes the random number generator.
The state of the random number generator is taken from the <CODE>xsubi</CODE>
array, the parameters for the congruential formula from the global
random number generator data.  The random number is return in the
variable pointed to by <VAR>result</VAR>.

</P>
<P>
The return value is non-negative is the call succeeded.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lrand48_r</B> <I>(struct drand48_data *<VAR>buffer</VAR>, double *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2022"></A>
This function is similar to <CODE>lrand48</CODE> and it takes a pointer to a
buffer describing the state of the random number generator as a
parameter just like <CODE>drand48</CODE>.

</P>
<P>
If the return value of the function is non-negative the variable pointed
to by <VAR>result</VAR> contains the result.  Otherwise an error occurred.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>nrand48_r</B> <I>(unsigned short int <VAR>xsubi</VAR>[3], struct drand48_data *<VAR>buffer</VAR>, long int *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2023"></A>
The <CODE>nrand48_r</CODE> function works like <CODE>nrand48</CODE> in that it
produces a random number in range <CODE>0</CODE> to <CODE>2^31</CODE>.  But instead
of using the global parameters for the congruential formula it uses the
information from the buffer pointed to by <VAR>buffer</VAR>.  The state is
described by the values in <VAR>xsubi</VAR>.

</P>
<P>
If the return value is non-negative the variable pointed to by
<VAR>result</VAR> contains the result.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>mrand48_r</B> <I>(struct drand48_data *<VAR>buffer</VAR>, double *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2024"></A>
This function is similar to <CODE>mrand48</CODE> but as the other reentrant
function it uses the random number generator described by the value in
the buffer pointed to by <VAR>buffer</VAR>.

</P>
<P>
If the return value is non-negative the variable pointed to by
<VAR>result</VAR> contains the result.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>jrand48_r</B> <I>(unsigned short int <VAR>xsubi</VAR>[3], struct drand48_data *<VAR>buffer</VAR>, long int *<VAR>result</VAR>)</I>
<DD><A NAME="IDX2025"></A>
The <CODE>jrand48_r</CODE> function is similar to <CODE>jrand48</CODE>.  But as the
other reentrant functions of this function family it uses the
congruential formula parameters from the buffer pointed to by
<VAR>buffer</VAR>.

</P>
<P>
If the return value is non-negative the variable pointed to by
<VAR>result</VAR> contains the result.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
Before any of the above functions should be used the buffer of type
<CODE>struct drand48_data</CODE> should initialized.  The easiest way is to
fill the whole buffer with null bytes, e.g., using

</P>

<PRE>
memset (buffer, '\0', sizeof (struct drand48_data));
</PRE>

<P>
Using any of the reentrant functions of this family now will
automatically initialize the random number generator to the default
values for the state and the parameters of the congruential formula.

</P>
<P>
The other possibility is too use any of the functions which explicitly
initialize the buffer.  Though it might be obvious how to initialize the
buffer from the data given as parameter from the function it is highly
recommended to use these functions since the result might not always be
what you expect.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>srand48_r</B> <I>(long int <VAR>seedval</VAR>, struct drand48_data *<VAR>buffer</VAR>)</I>
<DD><A NAME="IDX2026"></A>
The description of the random number generator represented by the
information in <VAR>buffer</VAR> is initialized similar to what the function
<CODE>srand48</CODE> does.  The state is initialized from the parameter
<VAR>seedval</VAR> and the parameters for the congruential formula are
initialized to the default values.

</P>
<P>
If the return value is non-negative the function call succeeded.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>seed48_r</B> <I>(unsigned short int <VAR>seed16v</VAR>[3], struct drand48_data *<VAR>buffer</VAR>)</I>
<DD><A NAME="IDX2027"></A>
This function is similar to <CODE>srand48_r</CODE> but like <CODE>seed48</CODE> it
initializes all 48 bits of the state from the parameter <VAR>seed16v</VAR>.

</P>
<P>
If the return value is non-negative the function call succeeded.  It
does not return a pointer to the previous state of the random number
generator like the <CODE>seed48</CODE> function does.  if the user wants to
preserve the state for a later rerun s/he can copy the whole buffer
pointed to by <VAR>buffer</VAR>.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lcong48_r</B> <I>(unsigned short int <VAR>param</VAR>[7], struct drand48_data *<VAR>buffer</VAR>)</I>
<DD><A NAME="IDX2028"></A>
This function initializes all aspects of the random number generator
described in <VAR>buffer</VAR> by the data in <VAR>param</VAR>.  Here it is
especially true the function does more than just copying the contents of
<VAR>param</VAR> of <VAR>buffer</VAR>.  Some more actions are required and
therefore it is important to use this function and not initialized the
random number generator directly.

</P>
<P>
If the return value is non-negative the function call succeeded.

</P>
<P>
This function is a GNU extension and should not be used in portable
programs.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_364.html">previous</A>, <A HREF="libc_366.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
