<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Temporary Files</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_271.html">previous</A>, <A HREF="libc_273.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC279" HREF="libc_toc.html#TOC279">Temporary Files</A></H2>

<P>
If you need to use a temporary file in your program, you can use the
<CODE>tmpfile</CODE> function to open it.  Or you can use the <CODE>tmpnam</CODE>
(better: <CODE>tmpnam_r</CODE>) function to make a name for a temporary file and
then you can open it in the usual way with <CODE>fopen</CODE>.

</P>
<P>
The <CODE>tempnam</CODE> function is like <CODE>tmpnam</CODE> but lets you choose
what directory temporary files will go in, and something about what
their file names will look like.  Important for multi threaded programs
is that <CODE>tempnam</CODE> is reentrant while <CODE>tmpnam</CODE> is not since it
returns a pointer to a static buffer.

</P>
<P>
These facilities are declared in the header file <TT>`stdio.h'</TT>.
<A NAME="IDX1356"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>tmpfile</B> <I>(void)</I>
<DD><A NAME="IDX1357"></A>
This function creates a temporary binary file for update mode, as if by
calling <CODE>fopen</CODE> with mode <CODE>"wb+"</CODE>.  The file is deleted
automatically when it is closed or when the program terminates.  (On
some other ISO C systems the file may fail to be deleted if the program
terminates abnormally).

</P>
<P>
This function is reentrant.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is in fact <CODE>tmpfile64</CODE>.  I.e., the
LFS interface transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>tmpfile64</B> <I>(void)</I>
<DD><A NAME="IDX1358"></A>
This function is similar to <CODE>tmpfile</CODE> but the stream it returns a
pointer for is opened using <CODE>tmpfile64</CODE>.  Therefore this stream can be
used even on files larger then @math{2^31} bytes on 32 bits machines.

</P>
<P>
Please note that the return type is still <CODE>FILE *</CODE>.  There is no
special <CODE>FILE</CODE> type for the LFS interface.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>tmpfile</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>tmpnam</B> <I>(char *<VAR>result</VAR>)</I>
<DD><A NAME="IDX1359"></A>
This function constructs and returns a file name that is a valid file
name and that does not name any existing file.  If the <VAR>result</VAR>
argument is a null pointer, the return value is a pointer to an internal
static string, which might be modified by subsequent calls and therefore
makes this function non-reentrant.  Otherwise, the <VAR>result</VAR> argument
should be a pointer to an array of at least <CODE>L_tmpnam</CODE> characters,
and the result is written into that array.

</P>
<P>
It is possible for <CODE>tmpnam</CODE> to fail if you call it too many times
without removing previously created files.  This is because the fixed
length of a temporary file name gives room for only a finite number of
different names.  If <CODE>tmpnam</CODE> fails, it returns a null pointer.

</P>
<P>
<STRONG>Warning:</STRONG> Since between the time the pathname is constructed and
the file is created another process might have created a file with this
name using <CODE>tmpnam</CODE> is a possible security hole.  The
implementation generates names which hardly can be predicted but opening
the file in any case should use the <CODE>O_EXCL</CODE> flag.  Using
<CODE>tmpfile</CODE> is a safe way to avoid this problem.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>tmpnam_r</B> <I>(char *<VAR>result</VAR>)</I>
<DD><A NAME="IDX1360"></A>
This function is nearly identical to the <CODE>tmpnam</CODE> function.  But it
does not allow <VAR>result</VAR> to be a null pointer.  In the latter case a
null pointer is returned.

</P>
<P>
This function is reentrant because the non-reentrant situation of
<CODE>tmpnam</CODE> cannot happen here.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>L_tmpnam</B>
<DD><A NAME="IDX1361"></A>
The value of this macro is an integer constant expression that represents
the minimum allocation size of a string large enough to hold the
file name generated by the <CODE>tmpnam</CODE> function.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>TMP_MAX</B>
<DD><A NAME="IDX1362"></A>
The macro <CODE>TMP_MAX</CODE> is a lower bound for how many temporary names
you can create with <CODE>tmpnam</CODE>.  You can rely on being able to call
<CODE>tmpnam</CODE> at least this many times before it might fail saying you
have made too many temporary file names.

</P>
<P>
With the GNU library, you can create a very large number of temporary
file names--if you actually create the files, you will probably run out
of disk space before you run out of names.  Some other systems have a
fixed, small limit on the number of temporary files.  The limit is never
less than <CODE>25</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>tempnam</B> <I>(const char *<VAR>dir</VAR>, const char *<VAR>prefix</VAR>)</I>
<DD><A NAME="IDX1363"></A>
This function generates a unique temporary filename.  If <VAR>prefix</VAR> is
not a null pointer, up to five characters of this string are used as a
prefix for the file name.  The return value is a string newly allocated
with <CODE>malloc</CODE>; you should release its storage with <CODE>free</CODE> when
it is no longer needed.

</P>
<P>
Because the string is dynamically allocated this function is reentrant.

</P>
<P>
The directory prefix for the temporary file name is determined by testing
each of the following, in sequence.  The directory must exist and be
writable.

</P>

<UL>
<LI>

The environment variable <CODE>TMPDIR</CODE>, if it is defined.  For security
reasons this only happens if the program is not SUID or SGID enabled.

<LI>

The <VAR>dir</VAR> argument, if it is not a null pointer.

<LI>

The value of the <CODE>P_tmpdir</CODE> macro.

<LI>

The directory <TT>`/tmp'</TT>.
</UL>

<P>
This function is defined for SVID compatibility.
</DL>
<A NAME="IDX1364"></A>

</P>
<P>
<DL>
<DT><U>SVID Macro:</U> char * <B>P_tmpdir</B>
<DD><A NAME="IDX1365"></A>
This macro is the name of the default directory for temporary files.
</DL>

</P>
<P>
Older Unix systems did not have the functions just described.  Instead
they used <CODE>mktemp</CODE> and <CODE>mkstemp</CODE>.  Both of these functions
work by modifying a file name template string you pass.  The last six
characters of this string must be <SAMP>`XXXXXX'</SAMP>.  These six <SAMP>`X'</SAMP>s
are replaced with six characters which make the whole string a unique
file name.  Usually the template string is something like
<SAMP>`/tmp/<VAR>prefix</VAR>XXXXXX'</SAMP>, and each program uses a unique <VAR>prefix</VAR>.

</P>
<P>
<STRONG>Note:</STRONG> Because <CODE>mktemp</CODE> and <CODE>mkstemp</CODE> modify the
template string, you <EM>must not</EM> pass string constants to them.
String constants are normally in read-only storage, so your program
would crash when <CODE>mktemp</CODE> or <CODE>mkstemp</CODE> tried to modify the
string.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>mktemp</B> <I>(char *<VAR>template</VAR>)</I>
<DD><A NAME="IDX1366"></A>
The <CODE>mktemp</CODE> function generates a unique file name by modifying
<VAR>template</VAR> as described above.  If successful, it returns
<VAR>template</VAR> as modified.  If <CODE>mktemp</CODE> cannot find a unique file
name, it makes <VAR>template</VAR> an empty string and returns that.  If
<VAR>template</VAR> does not end with <SAMP>`XXXXXX'</SAMP>, <CODE>mktemp</CODE> returns a
null pointer.

</P>
<P>
<STRONG>Warning:</STRONG> Since between the time the pathname is constructed and
the file is created another process might have created a file with this
name using <CODE>mktemp</CODE> is a possible security hole.  The
implementation generates names which hardly can be predicted but opening
the file in any case should use the <CODE>O_EXCL</CODE> flag.  Using
<CODE>mkstemp</CODE> is a safe way to avoid this problem.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>mkstemp</B> <I>(char *<VAR>template</VAR>)</I>
<DD><A NAME="IDX1367"></A>
The <CODE>mkstemp</CODE> function generates a unique file name just as
<CODE>mktemp</CODE> does, but it also opens the file for you with <CODE>open</CODE>
(see section <A HREF="libc_214.html#SEC221">Opening and Closing Files</A>).  If successful, it modifies
<VAR>template</VAR> in place and returns a file descriptor open on that file
for reading and writing.  If <CODE>mkstemp</CODE> cannot create a
uniquely-named file, it returns <CODE>-1</CODE>.  If <VAR>template</VAR> does not
end with <SAMP>`XXXXXX'</SAMP>, <CODE>mkstemp</CODE> returns <CODE>-1</CODE> and does not
modify <VAR>template</VAR>.

</P>
<P>
The file is opened using mode <CODE>0600</CODE>.  If the file is meant to be
used by other users the mode must explicitly changed.
</DL>

</P>
<P>
Unlike <CODE>mktemp</CODE>, <CODE>mkstemp</CODE> is actually guaranteed to create a
unique file that cannot possibly clash with any other program trying to
create a temporary file.  This is because it works by calling
<CODE>open</CODE> with the <CODE>O_EXCL</CODE> flag bit, which says you want to
always create a new file, and get an error if the file already exists.
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_271.html">previous</A>, <A HREF="libc_273.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
