<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Hooks for Malloc</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_31.html">previous</A>, <A HREF="libc_33.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC32" HREF="libc_toc.html#TOC32">Storage Allocation Hooks</A></H3>
<P>
<A NAME="IDX244"></A>

</P>
<P>
The GNU C library lets you modify the behavior of <CODE>malloc</CODE>,
<CODE>realloc</CODE>, and <CODE>free</CODE> by specifying appropriate hook
functions.  You can use these hooks to help you debug programs that use
dynamic storage allocation, for example.

</P>
<P>
The hook variables are declared in <TT>`malloc.h'</TT>.
<A NAME="IDX245"></A>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>__malloc_hook</B>
<DD><A NAME="IDX246"></A>
The value of this variable is a pointer to function that <CODE>malloc</CODE>
uses whenever it is called.  You should define this function to look
like <CODE>malloc</CODE>; that is, like:

</P>

<PRE>
void *<VAR>function</VAR> (size_t <VAR>size</VAR>, void *<VAR>caller</VAR>)
</PRE>

<P>
The value of <VAR>caller</VAR> is the return address found on the stack when
the <CODE>malloc</CODE> function was called.  This value allows to trace the
memory consumption of the program.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>__realloc_hook</B>
<DD><A NAME="IDX247"></A>
The value of this variable is a pointer to function that <CODE>realloc</CODE>
uses whenever it is called.  You should define this function to look
like <CODE>realloc</CODE>; that is, like:

</P>

<PRE>
void *<VAR>function</VAR> (void *<VAR>ptr</VAR>, size_t <VAR>size</VAR>, void *<VAR>caller</VAR>)
</PRE>

<P>
The value of <VAR>caller</VAR> is the return address found on the stack when
the <CODE>realloc</CODE> function was called.  This value allows to trace the
memory consumption of the program.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>__free_hook</B>
<DD><A NAME="IDX248"></A>
The value of this variable is a pointer to function that <CODE>free</CODE>
uses whenever it is called.  You should define this function to look
like <CODE>free</CODE>; that is, like:

</P>

<PRE>
void <VAR>function</VAR> (void *<VAR>ptr</VAR>, void *<VAR>caller</VAR>)
</PRE>

<P>
The value of <VAR>caller</VAR> is the return address found on the stack when
the <CODE>free</CODE> function was called.  This value allows to trace the
memory consumption of the program.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>__memalign_hook</B>
<DD><A NAME="IDX249"></A>
The value of this variable is a pointer to function that <CODE>memalign</CODE>
uses whenever it is called.  You should define this function to look
like <CODE>memalign</CODE>; that is, like:

</P>

<PRE>
void *<VAR>function</VAR> (size_t <VAR>size</VAR>, size_t <VAR>alignment</VAR>)
</PRE>

</DL>

<P>
You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without restoring
the old value of the hook first!  Otherwise, your program will get stuck
in an infinite recursion.  Before calling the function recursively, one
should make sure to restore all the hooks to their previous value.  When
coming back from the recursive call, all the hooks should be resaved
since a hook might modify itself.

</P>
<P>
Here is an example showing how to use <CODE>__malloc_hook</CODE> and
<CODE>__free_hook</CODE> properly.  It installs a function that prints out
information every time <CODE>malloc</CODE> or <CODE>free</CODE> is called.  We just
assume here that <CODE>realloc</CODE> and <CODE>memalign</CODE> are not used in our
program.

</P>

<PRE>
/* Global variables used to hold underlaying hook values.  */
static void *(*old_malloc_hook) (size_t);
static void (*old_free_hook) (void*);

/* Prototypes for our hooks.  */
static void *my_malloc_hook (size_t);
static void my_free_hook(void*);

static void *
my_malloc_hook (size_t size)
{
  void *result;
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  result = malloc (size);
  /* Save underlaying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <CODE>printf</CODE> might call <CODE>malloc</CODE>, so protect it too. */
  printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
  return result;
}

static void *
my_free_hook (void *ptr)
{
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  free (ptr);
  /* Save underlaying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <CODE>printf</CODE> might call <CODE>free</CODE>, so protect it too. */
  printf ("freed pointer %p\n", ptr);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

main ()
{
  ...
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
  ...
}
</PRE>

<P>
The <CODE>mcheck</CODE> function (see section <A HREF="libc_31.html#SEC31">Heap Consistency Checking</A>) works by
installing such hooks.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_31.html">previous</A>, <A HREF="libc_33.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
