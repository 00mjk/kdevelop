<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Opening Streams</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_157.html">previous</A>, <A HREF="libc_159.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC165" HREF="libc_toc.html#TOC165">Opening Streams</A></H2>

<P>
<A NAME="IDX778"></A>
Opening a file with the <CODE>fopen</CODE> function creates a new stream and
establishes a connection between the stream and a file.  This may
involve creating a new file.

</P>
<P>
<A NAME="IDX779"></A>
Everything described in this section is declared in the header file
<TT>`stdio.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>fopen</B> <I>(const char *<VAR>filename</VAR>, const char *<VAR>opentype</VAR>)</I>
<DD><A NAME="IDX780"></A>
The <CODE>fopen</CODE> function opens a stream for I/O to the file
<VAR>filename</VAR>, and returns a pointer to the stream.

</P>
<P>
The <VAR>opentype</VAR> argument is a string that controls how the file is
opened and specifies attributes of the resulting stream.  It must begin
with one of the following sequences of characters:

</P>
<DL COMPACT>

<DT><SAMP>`r'</SAMP>
<DD>
Open an existing file for reading only.

<DT><SAMP>`w'</SAMP>
<DD>
Open the file for writing only.  If the file already exists, it is
truncated to zero length.  Otherwise a new file is created.

<DT><SAMP>`a'</SAMP>
<DD>
Open a file for append access; that is, writing at the end of file only.
If the file already exists, its initial contents are unchanged and
output to the stream is appended to the end of the file.
Otherwise, a new, empty file is created.

<DT><SAMP>`r+'</SAMP>
<DD>
Open an existing file for both reading and writing.  The initial contents
of the file are unchanged and the initial file position is at the
beginning of the file.

<DT><SAMP>`w+'</SAMP>
<DD>
Open a file for both reading and writing.  If the file already exists, it
is truncated to zero length.  Otherwise, a new file is created.

<DT><SAMP>`a+'</SAMP>
<DD>
Open or create file for both reading and appending.  If the file exists,
its initial contents are unchanged.  Otherwise, a new file is created.
The initial file position for reading is at the beginning of the file,
but output is always appended to the end of the file.
</DL>

<P>
As you can see, <SAMP>`+'</SAMP> requests a stream that can do both input and
output.  The ISO standard says that when using such a stream, you must
call <CODE>fflush</CODE> (see section <A HREF="libc_199.html#SEC206">Stream Buffering</A>) or a file positioning
function such as <CODE>fseek</CODE> (see section <A HREF="libc_197.html#SEC204">File Positioning</A>) when switching
from reading to writing or vice versa.  Otherwise, internal buffers
might not be emptied properly.  The GNU C library does not have this
limitation; you can do arbitrary reading and writing operations on a
stream in whatever order.

</P>
<P>
Additional characters may appear after these to specify flags for the
call.  Always put the mode (<SAMP>`r'</SAMP>, <SAMP>`w+'</SAMP>, etc.) first; that is
the only part you are guaranteed will be understood by all systems.

</P>
<P>
The GNU C library defines one additional character for use in
<VAR>opentype</VAR>: the character <SAMP>`x'</SAMP> insists on creating a new
file--if a file <VAR>filename</VAR> already exists, <CODE>fopen</CODE> fails
rather than opening it.  If you use <SAMP>`x'</SAMP> you can are guaranteed that
you will not clobber an existing file.  This is equivalent to the
<CODE>O_EXCL</CODE> option to the <CODE>open</CODE> function (see section <A HREF="libc_214.html#SEC221">Opening and Closing Files</A>).

</P>
<P>
The character <SAMP>`b'</SAMP> in <VAR>opentype</VAR> has a standard meaning; it
requests a binary stream rather than a text stream.  But this makes no
difference in POSIX systems (including the GNU system).  If both
<SAMP>`+'</SAMP> and <SAMP>`b'</SAMP> are specified, they can appear in either order.
See section <A HREF="libc_196.html#SEC203">Text and Binary Streams</A>.

</P>
<P>
Any other characters in <VAR>opentype</VAR> are simply ignored.  They may be
meaningful in other systems.

</P>
<P>
If the open fails, <CODE>fopen</CODE> returns a null pointer.

</P>
<P>
When the sources are compiling with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is in fact <CODE>fopen64</CODE> since the LFS
interface replaces transparently the old interface.
</DL>

</P>
<P>
You can have multiple streams (or file descriptors) pointing to the same
file open at the same time.  If you do only input, this works
straightforwardly, but you must be careful if any output streams are
included.  See section <A HREF="libc_219.html#SEC226">Dangers of Mixing Streams and Descriptors</A>.  This is equally true
whether the streams are in one program (not usual) or in several
programs (which can easily happen).  It may be advantageous to use the
file locking facilities to avoid simultaneous access.  See section <A HREF="libc_241.html#SEC248">File Locks</A>.

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>fopen64</B> <I>(const char *<VAR>filename</VAR>, const char *<VAR>opentype</VAR>)</I>
<DD><A NAME="IDX781"></A>
This function is similar to <CODE>fopen</CODE> but the stream it returns a
pointer for is opened using <CODE>open64</CODE>.  Therefore this stream can be
used even on files larger then @math{2^31} bytes on 32 bits machines.

</P>
<P>
Please note that the return type is still <CODE>FILE *</CODE>.  There is no
special <CODE>FILE</CODE> type for the LFS interface.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>fopen</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>FOPEN_MAX</B>
<DD><A NAME="IDX782"></A>
The value of this macro is an integer constant expression that
represents the minimum number of streams that the implementation
guarantees can be open simultaneously.  You might be able to open more
than this many streams, but that is not guaranteed.  The value of this
constant is at least eight, which includes the three standard streams
<CODE>stdin</CODE>, <CODE>stdout</CODE>, and <CODE>stderr</CODE>.  In POSIX.1 systems this
value is determined by the <CODE>OPEN_MAX</CODE> parameter; see section <A HREF="libc_587.html#SEC595">General Capacity Limits</A>.  In BSD and GNU, it is controlled by the <CODE>RLIMIT_NOFILE</CODE>
resource limit; see section <A HREF="libc_411.html#SEC418">Limiting Resource Usage</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>freopen</B> <I>(const char *<VAR>filename</VAR>, const char *<VAR>opentype</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX783"></A>
This function is like a combination of <CODE>fclose</CODE> and <CODE>fopen</CODE>.
It first closes the stream referred to by <VAR>stream</VAR>, ignoring any
errors that are detected in the process.  (Because errors are ignored,
you should not use <CODE>freopen</CODE> on an output stream if you have
actually done any output using the stream.)  Then the file named by
<VAR>filename</VAR> is opened with mode <VAR>opentype</VAR> as for <CODE>fopen</CODE>,
and associated with the same stream object <VAR>stream</VAR>.

</P>
<P>
If the operation fails, a null pointer is returned; otherwise,
<CODE>freopen</CODE> returns <VAR>stream</VAR>.

</P>
<P>
<CODE>freopen</CODE> has traditionally been used to connect a standard stream
such as <CODE>stdin</CODE> with a file of your own choice.  This is useful in
programs in which use of a standard stream for certain purposes is
hard-coded.  In the GNU C library, you can simply close the standard
streams and open new ones with <CODE>fopen</CODE>.  But other systems lack
this ability, so using <CODE>freopen</CODE> is more portable.

</P>
<P>
When the sources are compiling with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is in fact <CODE>freopen64</CODE> since the LFS
interface replaces transparently the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>freopen64</B> <I>(const char *<VAR>filename</VAR>, const char *<VAR>opentype</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX784"></A>
This function is similar to <CODE>freopen</CODE>.  The only difference is that
on 32 bits machine the stream returned is able to read beyond the
@math{2^31} bytes limits imposed by the normal interface.  It should be
noted that the stream pointed to by <VAR>stream</VAR> need not be opened
using <CODE>fopen64</CODE> or <CODE>freopen64</CODE> since its mode is not important
for this function.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>freopen</CODE>
and so transparently replaces the old interface.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_157.html">previous</A>, <A HREF="libc_159.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
