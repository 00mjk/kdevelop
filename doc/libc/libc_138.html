<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Regexp Cleanup</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_137.html">previous</A>, <A HREF="libc_139.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC145" HREF="libc_toc.html#TOC145">POSIX Regexp Matching Cleanup</A></H3>

<P>
When you are finished using a compiled regular expression, you can
free the storage it uses by calling <CODE>regfree</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>regfree</B> <I>(regex_t *<VAR>compiled</VAR>)</I>
<DD><A NAME="IDX733"></A>
Calling <CODE>regfree</CODE> frees all the storage that <CODE>*<VAR>compiled</VAR></CODE>
points to.  This includes various internal fields of the <CODE>regex_t</CODE>
structure that aren't documented in this manual.

</P>
<P>
<CODE>regfree</CODE> does not free the object <CODE>*<VAR>compiled</VAR></CODE> itself.
</DL>

</P>
<P>
You should always free the space in a <CODE>regex_t</CODE> structure with
<CODE>regfree</CODE> before using the structure to compile another regular
expression.

</P>
<P>
When <CODE>regcomp</CODE> or <CODE>regexec</CODE> reports an error, you can use
the function <CODE>regerror</CODE> to turn it into an error message string.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>regerror</B> <I>(int <VAR>errcode</VAR>, regex_t *<VAR>compiled</VAR>, char *<VAR>buffer</VAR>, size_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX734"></A>
This function produces an error message string for the error code
<VAR>errcode</VAR>, and stores the string in <VAR>length</VAR> bytes of memory
starting at <VAR>buffer</VAR>.  For the <VAR>compiled</VAR> argument, supply the
same compiled regular expression structure that <CODE>regcomp</CODE> or
<CODE>regexec</CODE> was working with when it got the error.  Alternatively,
you can supply <CODE>NULL</CODE> for <VAR>compiled</VAR>; you will still get a
meaningful error message, but it might not be as detailed.

</P>
<P>
If the error message can't fit in <VAR>length</VAR> bytes (including a
terminating null character), then <CODE>regerror</CODE> truncates it.
The string that <CODE>regerror</CODE> stores is always null-terminated
even if it has been truncated.

</P>
<P>
The return value of <CODE>regerror</CODE> is the minimum length needed to
store the entire error message.  If this is less than <VAR>length</VAR>, then
the error message was not truncated, and you can use it.  Otherwise, you
should call <CODE>regerror</CODE> again with a larger buffer.

</P>
<P>
Here is a function which uses <CODE>regerror</CODE>, but always dynamically
allocates a buffer for the error message:

</P>

<PRE>
char *get_regerror (int errcode, regex_t *compiled)
{
  size_t length = regerror (errcode, compiled, NULL, 0);
  char *buffer = xmalloc (length);
  (void) regerror (errcode, compiled, buffer, length);
  return buffer;
}
</PRE>

</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_137.html">previous</A>, <A HREF="libc_139.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
