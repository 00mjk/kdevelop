<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Rounding Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_379.html">previous</A>, <A HREF="libc_381.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC387" HREF="libc_toc.html#TOC387">Rounding Functions</A></H3>
<P>
<A NAME="IDX2132"></A>

</P>
<P>
<A NAME="IDX2133"></A>
The functions listed here perform operations such as rounding and
truncation of floating-point values. Some of these functions convert
floating point numbers to integer values.  They are all declared in
<TT>`math.h'</TT>.

</P>
<P>
You can also convert floating-point numbers to integers simply by
casting them to <CODE>int</CODE>.  This discards the fractional part,
effectively rounding towards zero.  However, this only works if the
result can actually be represented as an <CODE>int</CODE>---for very large
numbers, this is impossible.  The functions listed here return the
result as a <CODE>double</CODE> instead to get around this problem.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>ceil</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2134"></A>
<DT><U>Function:</U> float <B>ceilf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2135"></A>
<DT><U>Function:</U> long double <B>ceill</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2136"></A>
These functions round <VAR>x</VAR> upwards to the nearest integer,
returning that value as a <CODE>double</CODE>.  Thus, <CODE>ceil (1.5)</CODE>
is <CODE>2.0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>floor</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2137"></A>
<DT><U>Function:</U> float <B>floorf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2138"></A>
<DT><U>Function:</U> long double <B>floorl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2139"></A>
These functions round <VAR>x</VAR> downwards to the nearest
integer, returning that value as a <CODE>double</CODE>.  Thus, <CODE>floor
(1.5)</CODE> is <CODE>1.0</CODE> and <CODE>floor (-1.5)</CODE> is <CODE>-2.0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>trunc</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2140"></A>
<DT><U>Function:</U> float <B>truncf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2141"></A>
<DT><U>Function:</U> long double <B>truncl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2142"></A>
<CODE>trunc</CODE> is another name for <CODE>floor</CODE>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>rint</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2143"></A>
<DT><U>Function:</U> float <B>rintf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2144"></A>
<DT><U>Function:</U> long double <B>rintl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2145"></A>
These functions round <VAR>x</VAR> to an integer value according to the
current rounding mode.  See section <A HREF="libc_632.html#SEC640">Floating Point Parameters</A>, for
information about the various rounding modes.  The default
rounding mode is to round to the nearest integer; some machines
support other modes, but round-to-nearest is always used unless
you explicitly select another.

</P>
<P>
If <VAR>x</VAR> was not initially an integer, these functions raise the
inexact exception.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>nearbyint</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2146"></A>
<DT><U>Function:</U> float <B>nearbyintf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2147"></A>
<DT><U>Function:</U> long double <B>nearbyintl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2148"></A>
These functions return the same value as the <CODE>rint</CODE> functions, but
do not raise the inexact exception if <VAR>x</VAR> is not an integer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>round</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2149"></A>
<DT><U>Function:</U> float <B>roundf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2150"></A>
<DT><U>Function:</U> long double <B>roundl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2151"></A>
These functions are similar to <CODE>rint</CODE>, but they round halfway
cases away from zero instead of to the nearest even integer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>lrint</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2152"></A>
<DT><U>Function:</U> long int <B>lrintf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2153"></A>
<DT><U>Function:</U> long int <B>lrintl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2154"></A>
These functions are just like <CODE>rint</CODE>, but they return a
<CODE>long int</CODE> instead of a floating-point number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>llrint</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2155"></A>
<DT><U>Function:</U> long long int <B>llrintf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2156"></A>
<DT><U>Function:</U> long long int <B>llrintl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2157"></A>
These functions are just like <CODE>rint</CODE>, but they return a
<CODE>long long int</CODE> instead of a floating-point number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>lround</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2158"></A>
<DT><U>Function:</U> long int <B>lroundf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2159"></A>
<DT><U>Function:</U> long int <B>lroundl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2160"></A>
These functions are just like <CODE>round</CODE>, but they return a
<CODE>long int</CODE> instead of a floating-point number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>llround</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2161"></A>
<DT><U>Function:</U> long long int <B>llroundf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2162"></A>
<DT><U>Function:</U> long long int <B>llroundl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2163"></A>
These functions are just like <CODE>round</CODE>, but they return a
<CODE>long long int</CODE> instead of a floating-point number.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>modf</B> <I>(double <VAR>value</VAR>, double *<VAR>integer-part</VAR>)</I>
<DD><A NAME="IDX2164"></A>
<DT><U>Function:</U> float <B>modff</B> <I>(float <VAR>value</VAR>, float *<VAR>integer-part</VAR>)</I>
<DD><A NAME="IDX2165"></A>
<DT><U>Function:</U> long double <B>modfl</B> <I>(long double <VAR>value</VAR>, long double *<VAR>integer-part</VAR>)</I>
<DD><A NAME="IDX2166"></A>
These functions break the argument <VAR>value</VAR> into an integer part and a
fractional part (between <CODE>-1</CODE> and <CODE>1</CODE>, exclusive).  Their sum
equals <VAR>value</VAR>.  Each of the parts has the same sign as <VAR>value</VAR>,
and the integer part is always rounded toward zero.

</P>
<P>
<CODE>modf</CODE> stores the integer part in <CODE>*<VAR>integer-part</VAR></CODE>, and
returns the fractional part.  For example, <CODE>modf (2.5, &#38;intpart)</CODE>
returns <CODE>0.5</CODE> and stores <CODE>2.0</CODE> into <CODE>intpart</CODE>.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_379.html">previous</A>, <A HREF="libc_381.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
