<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Interrupted Primitives</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_448.html">previous</A>, <A HREF="libc_450.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC456" HREF="libc_toc.html#TOC456">Primitives Interrupted by Signals</A></H2>

<P>
A signal can arrive and be handled while an I/O primitive such as
<CODE>open</CODE> or <CODE>read</CODE> is waiting for an I/O device.  If the signal
handler returns, the system faces the question: what should happen next?

</P>
<P>
POSIX specifies one approach: make the primitive fail right away.  The
error code for this kind of failure is <CODE>EINTR</CODE>.  This is flexible,
but usually inconvenient.  Typically, POSIX applications that use signal
handlers must check for <CODE>EINTR</CODE> after each library function that
can return it, in order to try the call again.  Often programmers forget
to check, which is a common source of error.

</P>
<P>
The GNU library provides a convenient way to retry a call after a
temporary failure, with the macro <CODE>TEMP_FAILURE_RETRY</CODE>:

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>TEMP_FAILURE_RETRY</B> <I>(<VAR>expression</VAR>)</I>
<DD><A NAME="IDX2553"></A>
This macro evaluates <VAR>expression</VAR> once.  If it fails and reports
error code <CODE>EINTR</CODE>, <CODE>TEMP_FAILURE_RETRY</CODE> evaluates it again,
and over and over until the result is not a temporary failure.

</P>
<P>
The value returned by <CODE>TEMP_FAILURE_RETRY</CODE> is whatever value
<VAR>expression</VAR> produced.
</DL>

</P>
<P>
BSD avoids <CODE>EINTR</CODE> entirely and provides a more convenient
approach: to restart the interrupted primitive, instead of making it
fail.  If you choose this approach, you need not be concerned with
<CODE>EINTR</CODE>.

</P>
<P>
You can choose either approach with the GNU library.  If you use
<CODE>sigaction</CODE> to establish a signal handler, you can specify how that
handler should behave.  If you specify the <CODE>SA_RESTART</CODE> flag,
return from that handler will resume a primitive; otherwise, return from
that handler will cause <CODE>EINTR</CODE>.  See section <A HREF="libc_436.html#SEC443">Flags for <CODE>sigaction</CODE></A>.

</P>
<P>
Another way to specify the choice is with the <CODE>siginterrupt</CODE>
function.  See section <A HREF="libc_469.html#SEC476">BSD Function to Establish a Handler</A>.

</P>
<P>
When you don't specify with <CODE>sigaction</CODE> or <CODE>siginterrupt</CODE> what
a particular handler should do, it uses a default choice.  The default
choice in the GNU library depends on the feature test macros you have
defined.  If you define <CODE>_BSD_SOURCE</CODE> or <CODE>_GNU_SOURCE</CODE> before
calling <CODE>signal</CODE>, the default is to resume primitives; otherwise,
the default is to make them fail with <CODE>EINTR</CODE>.  (The library
contains alternate versions of the <CODE>signal</CODE> function, and the
feature test macros determine which one you really call.)  See section <A HREF="libc_13.html#SEC13">Feature Test Macros</A>.
<A NAME="IDX2554"></A>
<A NAME="IDX2555"></A>
<A NAME="IDX2556"></A>
<A NAME="IDX2557"></A>

</P>
<P>
The description of each primitive affected by this issue
lists <CODE>EINTR</CODE> among the error codes it can return.

</P>
<P>
There is one situation where resumption never happens no matter which
choice you make: when a data-transfer function such as <CODE>read</CODE> or
<CODE>write</CODE> is interrupted by a signal after transferring part of the
data.  In this case, the function returns the number of bytes already
transferred, indicating partial success.

</P>
<P>
This might at first appear to cause unreliable behavior on
record-oriented devices (including datagram sockets; see section <A HREF="libc_319.html#SEC326">Datagram Socket Operations</A>),
where splitting one <CODE>read</CODE> or <CODE>write</CODE> into two would read or
write two records.  Actually, there is no problem, because interruption
after a partial transfer cannot happen on such devices; they always
transfer an entire record in one burst, with no waiting once data
transfer has started.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_448.html">previous</A>, <A HREF="libc_450.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
