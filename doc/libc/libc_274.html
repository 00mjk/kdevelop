<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Creating a Pipe</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_273.html">previous</A>, <A HREF="libc_275.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC281" HREF="libc_toc.html#TOC281">Creating a Pipe</A></H2>
<P>
<A NAME="IDX1370"></A>
<A NAME="IDX1371"></A>
<A NAME="IDX1372"></A>

</P>
<P>
The primitive for creating a pipe is the <CODE>pipe</CODE> function.  This
creates both the reading and writing ends of the pipe.  It is not very
useful for a single process to use a pipe to talk to itself.  In typical
use, a process creates a pipe just before it forks one or more child
processes (see section <A HREF="libc_516.html#SEC524">Creating a Process</A>).  The pipe is then used for
communication either between the parent or child processes, or between
two sibling processes.

</P>
<P>
The <CODE>pipe</CODE> function is declared in the header file
<TT>`unistd.h'</TT>.
<A NAME="IDX1373"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pipe</B> <I>(int <VAR>filedes</VAR><TT>[2]</TT>)</I>
<DD><A NAME="IDX1374"></A>
The <CODE>pipe</CODE> function creates a pipe and puts the file descriptors
for the reading and writing ends of the pipe (respectively) into
<CODE><VAR>filedes</VAR>[0]</CODE> and <CODE><VAR>filedes</VAR>[1]</CODE>.

</P>
<P>
An easy way to remember that the input end comes first is that file
descriptor <CODE>0</CODE> is standard input, and file descriptor <CODE>1</CODE> is
standard output.

</P>
<P>
If successful, <CODE>pipe</CODE> returns a value of <CODE>0</CODE>.  On failure,
<CODE>-1</CODE> is returned.  The following <CODE>errno</CODE> error conditions are
defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EMFILE</CODE>
<DD>
The process has too many files open.

<DT><CODE>ENFILE</CODE>
<DD>
There are too many open files in the entire system.  See section <A HREF="libc_17.html#SEC17">Error Codes</A>,
for more information about <CODE>ENFILE</CODE>.  This error never occurs in
the GNU system.
</DL>
</DL>

<P>
Here is an example of a simple program that creates a pipe.  This program
uses the <CODE>fork</CODE> function (see section <A HREF="libc_516.html#SEC524">Creating a Process</A>) to create
a child process.  The parent process writes data to the pipe, which is
read by the child process.

</P>

<PRE>
#include &#60;sys/types.h&#62;
#include &#60;unistd.h&#62;
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;

/* Read characters from the pipe and echo them to <CODE>stdout</CODE>. */

void 
read_from_pipe (int file)
{
  FILE *stream;
  int c;
  stream = fdopen (file, "r");
  while ((c = fgetc (stream)) != EOF)
    putchar (c);
  fclose (stream);
}

/* Write some random text to the pipe. */

void 
write_to_pipe (int file)
{
  FILE *stream;
  stream = fdopen (file, "w");
  fprintf (stream, "hello, world!\n");
  fprintf (stream, "goodbye, world!\n");
  fclose (stream);
}

int
main (void)
{
  pid_t pid;
  int mypipe[2];

  /* Create the pipe. */
  if (pipe (mypipe))
    {
      fprintf (stderr, "Pipe failed.\n");
      return EXIT_FAILURE;
    }

  /* Create the child process. */
  pid = fork ();
  if (pid == (pid_t) 0)
    {
      /* This is the child process. */
      read_from_pipe (mypipe[0]);
      return EXIT_SUCCESS;
    }
  else if (pid &#60; (pid_t) 0)
    {
      /* The fork failed. */
      fprintf (stderr, "Fork failed.\n");
      return EXIT_FAILURE;
    }
  else
    {
      /* This is the parent process. */
      write_to_pipe (mypipe[1]);
      return EXIT_SUCCESS;
    }
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_273.html">previous</A>, <A HREF="libc_275.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
