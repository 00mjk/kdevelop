<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - FP Bit Twiddling</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_381.html">previous</A>, <A HREF="libc_383.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC389" HREF="libc_toc.html#TOC389">Setting and modifying single bits of FP values</A></H3>
<P>
<A NAME="IDX2176"></A>

</P>
<P>
There are some operations that are too complicated or expensive to
perform by hand on floating-point numbers.  ISO C 9x defines
functions to do these operations, which mostly involve changing single
bits.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>copysign</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2177"></A>
<DT><U>Function:</U> float <B>copysignf</B> <I>(float <VAR>x</VAR>, float <VAR>y</VAR>)</I>
<DD><A NAME="IDX2178"></A>
<DT><U>Function:</U> long double <B>copysignl</B> <I>(long double <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2179"></A>
These functions return <VAR>x</VAR> but with the sign of <VAR>y</VAR>.  They work
even if <VAR>x</VAR> or <VAR>y</VAR> are NaN or zero.  Both of these can carry a
sign (although not all implementations support it) and this is one of
the few operations that can tell the difference.

</P>
<P>
<CODE>copysign</CODE> never raises an exception.

</P>
<P>
This function is defined in IEC 559 (and the appendix with
recommended functions in IEEE 754/IEEE 854).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>signbit</B> <I>(<EM>float-type</EM> <VAR>x</VAR>)</I>
<DD><A NAME="IDX2180"></A>
<CODE>signbit</CODE> is a generic macro which can work on all floating-point
types.  It returns a nonzero value if the value of <VAR>x</VAR> has its sign
bit set.

</P>
<P>
This is not the same as <CODE>x &#60; 0.0</CODE>, because IEEE 754 floating
point allows zero to be signed.  The comparison <CODE>-0.0 &#60; 0.0</CODE> is
false, but <CODE>signbit (-0.0)</CODE> will return a nonzero value.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>nextafter</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2181"></A>
<DT><U>Function:</U> float <B>nextafterf</B> <I>(float <VAR>x</VAR>, float <VAR>y</VAR>)</I>
<DD><A NAME="IDX2182"></A>
<DT><U>Function:</U> long double <B>nextafterl</B> <I>(long double <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2183"></A>
The <CODE>nextafter</CODE> function returns the next representable neighbor of
<VAR>x</VAR> in the direction towards <VAR>y</VAR>.  The size of the step between
<VAR>x</VAR> and the result depends on the type of the result.  If
@math{<VAR>x</VAR> = <VAR>y</VAR>} the function simply returns <VAR>x</VAR>.  If either
value is <CODE>NaN</CODE>, <CODE>NaN</CODE> is returned.  Otherwise
a value corresponding to the value of the least significant bit in the
mantissa is added or subtracted, depending on the direction.
<CODE>nextafter</CODE> will signal overflow or underflow if the result goes
outside of the range of normalized numbers.

</P>
<P>
This function is defined in IEC 559 (and the appendix with
recommended functions in IEEE 754/IEEE 854).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>nexttoward</B> <I>(double <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2184"></A>
<DT><U>Function:</U> float <B>nexttowardf</B> <I>(float <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2185"></A>
<DT><U>Function:</U> long double <B>nexttowardl</B> <I>(long double <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX2186"></A>
These functions are identical to the corresponding versions of
<CODE>nextafter</CODE> except that their second argument is a <CODE>long
double</CODE>.
</DL>

</P>
<P>
<A NAME="IDX2187"></A>
<DL>
<DT><U>Function:</U> double <B>nan</B> <I>(const char *<VAR>tagp</VAR>)</I>
<DD><A NAME="IDX2188"></A>
<DT><U>Function:</U> float <B>nanf</B> <I>(const char *<VAR>tagp</VAR>)</I>
<DD><A NAME="IDX2189"></A>
<DT><U>Function:</U> long double <B>nanl</B> <I>(const char *<VAR>tagp</VAR>)</I>
<DD><A NAME="IDX2190"></A>
The <CODE>nan</CODE> function returns a representation of NaN, provided that
NaN is supported by the target platform.
<CODE>nan ("<VAR>n-char-sequence</VAR>")</CODE> is equivalent to
<CODE>strtod ("NAN(<VAR>n-char-sequence</VAR>)")</CODE>.

</P>
<P>
The argument <VAR>tagp</VAR> is used in an unspecified manner.  On IEEE
754 systems, there are many representations of NaN, and <VAR>tagp</VAR>
selects one.  On other systems it may do nothing.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_381.html">previous</A>, <A HREF="libc_383.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
