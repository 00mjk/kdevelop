<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Filesystem handling</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_584.html">previous</A>, <A HREF="libc_586.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC593" HREF="libc_toc.html#TOC593">Which filesystems are mounted and/or available?</A></H2>

<P>
The Unix concept of <EM>Everything is a file</EM> is based on the
possibility to <STRONG>mount</STRONG> filesystems or other things into the
filesystem.  For some programs it is desirable and necessary to access
the information whether and, if yes, where a certain filesystem is
mounted or simply to get lists of all the available filesystems.  The
GNU libc provides some functions to retrieve this information portably.

</P>
<P>
Traditionally Unix systems have a file named <TT>`/etc/fstab'</TT> which
describes all possibly mounted filesystems.  The <CODE>mount</CODE> program
uses this file to mount at startup time of the system all the necessary
filesystems.  The information about all the filesystems actually mounted
is normally kept in a file named <TT>`/etc/mtab'</TT>.  Both files share
the same syntax and it is crucial that this syntax is followed all the
time.  Therefore it is best to never directly write the files.  The
functions described in this section can do this and they also provide
the functionality to convert the external textual representation to the
internal representation.

</P>
<P>
<A NAME="IDX3044"></A>
<A NAME="IDX3045"></A>
<A NAME="IDX3046"></A>
<A NAME="IDX3047"></A>
The filenames given above should never be used directly.  The portable
way to handle these file is to use the macros <CODE>_PATH_FSTAB</CODE>,
defined in <TT>`fstab.h'</TT> and <CODE>_PATH_MNTTAB</CODE>, defined in
<TT>`mntent.h'</TT>, respectively.  There are also two alternate macro names
<CODE>FSTAB</CODE> and <CODE>_PATH_MOUNTED</CODE> defined but both names are
deprecated and kept only for backward compatibility.  The two former
names should always be used.

</P>
<P>
The internal representation for entries of the file is <CODE>struct
fstab</CODE>, defined in <TT>`fstab.h'</TT>.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct fstab</B>
<DD><A NAME="IDX3048"></A>
This structure is used with the <CODE>getfsent</CODE>, <CODE>getfsspec</CODE>, and
<CODE>getfsfile</CODE> functions.

</P>
<DL COMPACT>

<DT><CODE>char *fs_spec</CODE>
<DD>
This element describes the device from which the filesystem is mounted.
Normally this is the name of a special device, such as a hard disk
partition, but it could also be a more or less generic string.  For
<STRONG>NFS</STRONG> it would be a hostname and directory name combination.

Even though the element is not declared <CODE>const</CODE> it shouldn't be
modified.  The missing <CODE>const</CODE> has historic reasons, since this
function predates ISO C.  The same is true for the other string
elements of this structure.

<DT><CODE>char *fs_file</CODE>
<DD>
This describes the mount point on the local system.  I.e., accessing any
file in this filesystem has implicitly or explicitly this string as a
prefix.

<DT><CODE>char *fs_vfstype</CODE>
<DD>
This is the type of the filesystem.  Depending on what the underlying
kernel understands it can be any string.

<DT><CODE>char *fs_mntops</CODE>
<DD>
This is a string containing options passed to the kernel with the
<CODE>mount</CODE> call.  Again, this can be almost anything.  There can be
more than one option, separated from the others by a comma.  Each option
consists of a name and an optional value part, introduced by an <CODE>=</CODE>
character.

If the value of this element must be processed it should best happen
using the <CODE>getsubopt</CODE> function; see section <A HREF="libc_501.html#SEC509">Parsing of Suboptions</A>.

<DT><CODE>const char *fs_type</CODE>
<DD>
This name is poorly chosen.  This element points to a string (possibly
in the <CODE>fs_mntops</CODE> string) which describes the modes with which the
filesystem is mounted.  <TT>`fstab'</TT> defines five macros to describe the
possible values:

<DL COMPACT>

<DT><CODE>FSTAB_RW</CODE>
<DD>
<A NAME="IDX3049"></A>
The filesystems gets mounted with read and write enabled.
<DT><CODE>FSTAB_RQ</CODE>
<DD>
<A NAME="IDX3050"></A>
The filesystems gets mounted with read and write enabled.  Write access
is restricted by quotas.
<DT><CODE>FSTAB_RO</CODE>
<DD>
<A NAME="IDX3051"></A>
The filesystem gets mounted read-only.
<DT><CODE>FSTAB_SW</CODE>
<DD>
<A NAME="IDX3052"></A>
This is not a real filesystem, it is a swap device.
<DT><CODE>FSTAB_XX</CODE>
<DD>
<A NAME="IDX3053"></A>
This entry from the <TT>`fstab'</TT> file is totally ignored.
</DL>

Testing for equality with these value must happen using <CODE>strcmp</CODE>
since these are all strings.  Comparing the pointer will probably always
fail.

<DT><CODE>int fs_freq</CODE>
<DD>
This element describes the dump frequency in days.

<DT><CODE>int fs_passno</CODE>
<DD>
This element describes the pass number on parallel dumps.  It is closely
related to the <CODE>dump</CODE> utility used on Unix systems.
</DL>
</DL>

<P>
To read the entire content of the of the <TT>`fstab'</TT> file the GNU libc
contains a set of three functions which are designed in the usual way.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>setfsent</B> <I>(void)</I>
<DD><A NAME="IDX3054"></A>
This function makes sure that the internal read pointer for the
<TT>`fstab'</TT> file is at the beginning of the file.  This is done by
either opening the file or resetting the read pointer.

</P>
<P>
Since the file handle is internal to the libc this function is not
thread-safe.

</P>
<P>
This function returns a non-zero value if the operation was successful
and the <CODE>getfs*</CODE> functions can be used to read the entries of the
file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>endfsent</B> <I>(void)</I>
<DD><A NAME="IDX3055"></A>
This function makes sure that all resources acquired by a prior call to
<CODE>setfsent</CODE> (explicitly or implicitly by calling <CODE>getfsent</CODE>) are
freed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct fstab * <B>getfsent</B> <I>(void)</I>
<DD><A NAME="IDX3056"></A>
This function returns the next entry of the <TT>`fstab'</TT> file.  If this
is the first call to any of the functions handling <TT>`fstab'</TT> since
program start or the last call of <CODE>endfsent</CODE>, the file will be
opened.

</P>
<P>
The function returns a pointer to an variable of type <CODE>struct
fstab</CODE>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <CODE>getfsent</CODE>
returns a <CODE>NULL</CODE> pointer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct fstab * <B>getfsspec</B> <I>(const char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX3057"></A>
This function returns the next entry of the <TT>`fstab'</TT> file which has
a string equal to <VAR>name</VAR> pointed to by the <CODE>fs_spec</CODE> element.
Since there is normally exactly one entry for each special device it
makes no sense to call this function more than once for the same
argument.  If this is the first call to any of the functions handling
<TT>`fstab'</TT> since program start or the last call of <CODE>endfsent</CODE>,
the file will be opened.

</P>
<P>
The function returns a pointer to an variable of type <CODE>struct
fstab</CODE>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <CODE>getfsent</CODE>
returns a <CODE>NULL</CODE> pointer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct fstab * <B>getfsfile</B> <I>(const char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX3058"></A>
This function returns the next entry of the <TT>`fstab'</TT> file which has
a string equal to <VAR>name</VAR> pointed to by the <CODE>fs_file</CODE> element.
Since there is normally exactly one entry for each mount point it
makes no sense to call this function more than once for the same
argument.  If this is the first call to any of the functions handling
<TT>`fstab'</TT> since program start or the last call of <CODE>endfsent</CODE>,
the file will be opened.

</P>
<P>
The function returns a pointer to an variable of type <CODE>struct
fstab</CODE>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <CODE>getfsent</CODE>
returns a <CODE>NULL</CODE> pointer.
</DL>

</P>
<P>
To access the <TT>`mtab'</TT> file there is a different set of functions and
also a different structure to describe the results.

</P>

<P>
<DL>
<DT><U>Data Type:</U> <B>struct mntent</B>
<DD><A NAME="IDX3059"></A>
This structure is used with the <CODE>getmntent</CODE>, <CODE>getmntent_t</CODE>,
<CODE>addmntent</CODE>, and <CODE>hasmntopt</CODE> functions.

</P>
<DL COMPACT>

<DT><CODE>char *mnt_fsname</CODE>
<DD>
This element contains a pointer to a string describing the name of the
special device from which the filesystem is mounted.  It corresponds to
the <CODE>fs_spec</CODE> element in <CODE>struct fstab</CODE>.

<DT><CODE>char *mnt_dir</CODE>
<DD>
This element points to a string describing the mount point of the
filesystem.  It corresponds to the <CODE>fs_file</CODE> element in
<CODE>struct fstab</CODE>.

<DT><CODE>char *mnt_type</CODE>
<DD>
<CODE>mnt_type</CODE> describes the filesystem type and is therefore
equivalent to <CODE>fs_vfstype</CODE> in <CODE>struct fstab</CODE>.  <TT>`mntent.h'</TT>
defines a few symbolic names for some of the value this string can have.
But since the kernel can support an arbitrary filesystems it does not
make much sense to give them symbolic names.  If one knows the symbol
name one also knows the filesystem name.  Nevertheless here follows the
list of the symbol provided in <TT>`mntent.h'</TT>.

<DL COMPACT>

<DT><CODE>MNTTYPE_IGNORE</CODE>
<DD>
<A NAME="IDX3060"></A>
This symbol expands to <CODE>"ignore"</CODE>.  The value is sometime used in
<TT>`fstab'</TT> files to make sure entries are not used without removing them.
<DT><CODE>MNTTYPE_NFS</CODE>
<DD>
<A NAME="IDX3061"></A>
Expands to <CODE>"nfs"</CODE>.  Using this macro sometimes could make sense
since it names the default NFS implementation, in case both version 2
and 3 are supported.
<DT><CODE>MNTTYPE_SWAP</CODE>
<DD>
<A NAME="IDX3062"></A>
This symbol expands to <CODE>"swap"</CODE>.  It names the special <TT>`fstab'</TT>
entry which names one of the possibly multiple swap partitions.
</DL>

<DT><CODE>char *mnt_opts</CODE>
<DD>
The element contains a string describing the options used while mounting
the filesystem.  As for the equivalent element <CODE>fs_mntops</CODE> of
<CODE>struct fstab</CODE> it is best to use the function <CODE>getsubopt</CODE>
(see section <A HREF="libc_501.html#SEC509">Parsing of Suboptions</A>) to access the parts of this string.

The <TT>`mntent.h'</TT> file defines a number of macros with string values
which correspond to some of the options understood by the kernel.  There
might be many more options which are possible so it makes not much sense
to rely on these macros but to be consistent here is the list:

<DL COMPACT>

<DT><CODE>MNTOPT_DEFAULTS</CODE>
<DD>
<A NAME="IDX3063"></A>
Expands to <CODE>"defaults"</CODE>.  This option should be used alone since it
indicates all values for the customizable values are chosen to be the
default.
<DT><CODE>MNTOPT_RO</CODE>
<DD>
<A NAME="IDX3064"></A>
Expands to <CODE>"ro"</CODE>.  See the <CODE>FSTAB_RO</CODE> value, it means the
filesystem is mounted read-only.
<DT><CODE>MNTOPT_RW</CODE>
<DD>
<A NAME="IDX3065"></A>
Expand to <CODE>"rw"</CODE>.  See the <CODE>FSTAB_RW</CODE> value, it means the
filesystem is mounted with read and write permissions.
<DT><CODE>MNTOPT_SUID</CODE>
<DD>
<A NAME="IDX3066"></A>
Expands to <CODE>"suid"</CODE>.  This means that the SUID bit (see section <A HREF="libc_556.html#SEC564">How an Application Can Change Persona</A>) is respected when a program from the filesystem is
started.
<DT><CODE>MNTOPT_NOSUID</CODE>
<DD>
<A NAME="IDX3067"></A>
Expands to <CODE>"nosuid"</CODE>.  This is the opposite of <CODE>MNTOPT_SUID</CODE>,
the SUID bit for all files from the filesystem is ignored.
<DT><CODE>MNTOPT_NOAUTO</CODE>
<DD>
<A NAME="IDX3068"></A>
Expands to <CODE>"noauto"</CODE>.  At startup time the <CODE>mount</CODE> program
will ignore this entry if it is started with the <CODE>-a</CODE> option to
mount all filesystems mentioned in the <TT>`fstab'</TT> file.
</DL>

As for the <CODE>FSTAB_*</CODE> entries introduced above it is important to
use <CODE>strcmp</CODE> to check for equality.

<DT><CODE>mnt_freq</CODE>
<DD>
This elements corresponds to <CODE>fs_freq</CODE> and also specifies the
frequency in days in which dumps are made.

<DT><CODE>mnt_passno</CODE>
<DD>
This element is equivalent to <CODE>fs_passno</CODE> with the same meaning
which is uninteresting for all programs beside <CODE>dump</CODE>.
</DL>
</DL>

<P>
For accessing the <TT>`mtab'</TT> file there is again a set of three
functions to access all entries in a row.  Unlike the functions to
handle <TT>`fstab'</TT> these functions do not access a fixed file and there
is even a thread safe variant of the get function.  Beside this the GNU
libc contains functions to alter the file and test for specific options.

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>setmntent</B> <I>(const char *<VAR>file</VAR>, const char *<VAR>mode</VAR>)</I>
<DD><A NAME="IDX3069"></A>
The <CODE>setmntent</CODE> function prepares the file named <VAR>FILE</VAR> which
must be in the format of a <TT>`fstab'</TT> and <TT>`mtab'</TT> file for the
upcoming processing through the other functions of the family.  The
<VAR>mode</VAR> parameter can be chosen in the way the <VAR>opentype</VAR>
parameter for <CODE>fopen</CODE> (see section <A HREF="libc_158.html#SEC165">Opening Streams</A>) can be chosen.  If
the file is opened for writing the file is also allowed to be empty.

</P>
<P>
If the file was successfully opened <CODE>setmntent</CODE> returns a file
descriptor for future use.  Otherwise the return value is <CODE>NULL</CODE>
and <CODE>errno</CODE> is set accordingly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>endmntent</B> <I>(FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX3070"></A>
This function takes for the <VAR>stream</VAR> parameter a file handle which
previously was returned from the <CODE>setmntent</CODE> call.
<CODE>endmntent</CODE> closes the stream and frees all resources.

</P>
<P>
The return value is @math{1} unless an error occurred in which case it
is @math{0}.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct mntent * <B>getmntent</B> <I>(FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX3071"></A>
The <CODE>getmntent</CODE> function takes as the parameter a file handle
previously returned by successful call to <CODE>setmntent</CODE>.  It returns
a pointer to a static variable of type <CODE>struct mntent</CODE> which is
filled with the information from the next entry from the file currently
read.

</P>
<P>
If there was an error or the end of the file is reached the return value
is <CODE>NULL</CODE>.

</P>
<P>
This function is not thread-safe since all calls to this function return
a pointer to the same static variable.  <CODE>getmntent_r</CODE> should be
used in situations where multiple threads access the file.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct mntent * <B>getmntent_r</B> <I>(FILE *<VAR>stream</VAR>, struct mentent *<VAR>result</VAR>, char *<VAR>buffer</VAR>, int <VAR>bufsize</VAR>)</I>
<DD><A NAME="IDX3072"></A>
The <CODE>getmntent_r</CODE> function is the reentrant variant of
<CODE>getmntent</CODE>.  It also returns the next entry from the file and
returns a pointer.  The actual variable the values are stored in is not
static, though.  Instead the function stores the values in the variable
pointed to by the <VAR>result</VAR> parameter.  Additional information (e.g.,
the strings pointed to by the elements of the result) are kept in the
buffer of size <VAR>bufsize</VAR> pointed to by <VAR>buffer</VAR>.

</P>
<P>
The function returns a <CODE>NULL</CODE> pointer in error cases.  Errors could be:

<UL>
<LI>

error while reading the file,
<LI>

end of file reached,
<LI>

<VAR>bufsize</VAR> is too small for reading a complete new entry.
</UL>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>addmntent</B> <I>(FILE *<VAR>stream</VAR>, const struct mntent *<VAR>mnt</VAR>)</I>
<DD><A NAME="IDX3073"></A>
The <CODE>addmntent</CODE> function allows to add a new entry to the file
previously opened with <CODE>setmntent</CODE>.  The new entries are always
appended.  I.e., even if the position of the file descriptor is not at
the end of the file this function does not overwrite an existing entry
following the current position.

</P>
<P>
The implication of this is that to remove an entry from a file one has
to create a new file while leaving out the entry to be removed and after
closing the file remove the old one and rename the new file to the
chosen name.

</P>
<P>
This function returns @math{0} in case the operation was successful.
Otherwise the return value is @math{1} and <CODE>errno</CODE> is set
appropriately.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>hasmntopt</B> <I>(const struct mntent *<VAR>mnt</VAR>, const char *<VAR>opt</VAR>)</I>
<DD><A NAME="IDX3074"></A>
This function can be used to check whether the string pointed to by the
<CODE>mnt_opts</CODE> element of the variable pointed to by <VAR>mnt</VAR> contains
the option <VAR>opt</VAR>.  If this is true a pointer to the beginning of the
option in the <CODE>mnt_opts</CODE> element is returned.  If no such option
exists the function returns <CODE>NULL</CODE>.

</P>
<P>
This function is useful to test whether a specific option is present but
when all options have to be processed one is better off with using the
<CODE>getsubopt</CODE> function to iterate over all options in the string.
</DL>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_584.html">previous</A>, <A HREF="libc_586.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
