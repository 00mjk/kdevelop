<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Threads and Signal Handling</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_610.html">previous</A>, <A HREF="libc_612.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC619" HREF="libc_toc.html#TOC619">Threads and Signal Handling</A></H2>

<P>
<DL>
<DT><U>Function:</U> int <B>pthread_sigmask</B> <I>(int <VAR>how</VAR>, const sigset_t *<VAR>newmask</VAR>, sigset_t *<VAR>oldmask</VAR>)</I>
<DD><A NAME="IDX3185"></A>
<CODE>pthread_sigmask</CODE> changes the signal mask for the calling thread as
described by the <VAR>how</VAR> and <VAR>newmask</VAR> arguments. If <VAR>oldmask</VAR>
is not <CODE>NULL</CODE>, the previous signal mask is stored in the location
pointed to by <VAR>oldmask</VAR>.

</P>
<P>
The meaning of the <VAR>how</VAR> and <VAR>newmask</VAR> arguments is the same as
for <CODE>sigprocmask</CODE>. If <VAR>how</VAR> is <CODE>SIG_SETMASK</CODE>, the signal
mask is set to <VAR>newmask</VAR>. If <VAR>how</VAR> is <CODE>SIG_BLOCK</CODE>, the
signals specified to <VAR>newmask</VAR> are added to the current signal mask.
If <VAR>how</VAR> is <CODE>SIG_UNBLOCK</CODE>, the signals specified to
<VAR>newmask</VAR> are removed from the current signal mask.

</P>
<P>
Recall that signal masks are set on a per-thread basis, but signal
actions and signal handlers, as set with <CODE>sigaction</CODE>, are shared
between all threads.

</P>
<P>
The <CODE>pthread_sigmask</CODE> function returns 0 on success, and one of the
following error codes on error:
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>how</VAR> is not one of <CODE>SIG_SETMASK</CODE>, <CODE>SIG_BLOCK</CODE>, or <CODE>SIG_UNBLOCK</CODE>

<DT><CODE>EFAULT</CODE>
<DD>
<VAR>newmask</VAR> or <VAR>oldmask</VAR> point to invalid addresses
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>pthread_kill</B> <I>(pthread_t <VAR>thread</VAR>, int <VAR>signo</VAR>)</I>
<DD><A NAME="IDX3186"></A>
<CODE>pthread_kill</CODE> sends signal number <VAR>signo</VAR> to the thread
<VAR>thread</VAR>.  The signal is delivered and handled as described in
section <A HREF="libc_417.html#SEC424">Signal Handling</A>.

</P>
<P>
<CODE>pthread_kill</CODE> returns 0 on success, one of the following error codes
on error:
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>signo</VAR> is not a valid signal number

<DT><CODE>ESRCH</CODE>
<DD>
The thread <VAR>thread</VAR> does not exist (e.g. it has already terminated)
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>sigwait</B> <I>(const sigset_t *<VAR>set</VAR>, int *<VAR>sig</VAR>)</I>
<DD><A NAME="IDX3187"></A>
<CODE>sigwait</CODE> suspends the calling thread until one of the signals in
<VAR>set</VAR> is delivered to the calling thread. It then stores the number
of the signal received in the location pointed to by <VAR>sig</VAR> and
returns. The signals in <VAR>set</VAR> must be blocked and not ignored on
entrance to <CODE>sigwait</CODE>. If the delivered signal has a signal handler
function attached, that function is <EM>not</EM> called.

</P>
<P>
<CODE>sigwait</CODE> is a cancellation point.  It always returns 0.
</DL>

</P>
<P>
For <CODE>sigwait</CODE> to work reliably, the signals being waited for must be
blocked in all threads, not only in the calling thread, since
otherwise the POSIX semantics for signal delivery do not guarantee
that it's the thread doing the <CODE>sigwait</CODE> that will receive the signal.
The best way to achieve this is block those signals before any threads
are created, and never unblock them in the program other than by
calling <CODE>sigwait</CODE>.

</P>
<P>
Signal handling in LinuxThreads departs significantly from the POSIX
standard. According to the standard, "asynchronous" (external) signals
are addressed to the whole process (the collection of all threads),
which then delivers them to one particular thread. The thread that
actually receives the signal is any thread that does not currently block
the signal.

</P>
<P>
In LinuxThreads, each thread is actually a kernel process with its own
PID, so external signals are always directed to one particular thread.
If, for instance, another thread is blocked in <CODE>sigwait</CODE> on that
signal, it will not be restarted.

</P>
<P>
The LinuxThreads implementation of <CODE>sigwait</CODE> installs dummy signal
handlers for the signals in <VAR>set</VAR> for the duration of the
wait. Since signal handlers are shared between all threads, other
threads must not attach their own signal handlers to these signals, or
alternatively they should all block these signals (which is recommended
anyway).

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_610.html">previous</A>, <A HREF="libc_612.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
