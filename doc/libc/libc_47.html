<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Extra Fast Growing</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_46.html">previous</A>, <A HREF="libc_48.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC47" HREF="libc_toc.html#TOC47">Extra Fast Growing Objects</A></H3>
<P>
<A NAME="IDX283"></A>

</P>
<P>
The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you
are frequently constructing objects in small steps of growth, this
overhead can be significant.

</P>
<P>
You can reduce the overhead by using special "fast growth"
functions that grow the object without checking.  In order to have a
robust program, you must do the checking yourself.  If you do this checking
in the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check
more efficiently, then you make the program faster.

</P>
<P>
The function <CODE>obstack_room</CODE> returns the amount of room available
in the current chunk.  It is declared as follows:

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>obstack_room</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>)</I>
<DD><A NAME="IDX284"></A>
This returns the number of bytes that can be added safely to the current
growing object (or to an object about to be started) in obstack
<VAR>obstack</VAR> using the fast growth functions.
</DL>

</P>
<P>
While you know there is room, you can use these fast growth functions
for adding data to a growing object:

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>obstack_1grow_fast</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, char <VAR>c</VAR>)</I>
<DD><A NAME="IDX285"></A>
The function <CODE>obstack_1grow_fast</CODE> adds one byte containing the
character <VAR>c</VAR> to the growing object in obstack <VAR>obstack-ptr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>obstack_ptr_grow_fast</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, void *<VAR>data</VAR>)</I>
<DD><A NAME="IDX286"></A>
The function <CODE>obstack_ptr_grow_fast</CODE> adds <CODE>sizeof (void *)</CODE>
bytes containing the value of <VAR>data</VAR> to the growing object in
obstack <VAR>obstack-ptr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>obstack_int_grow_fast</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, int <VAR>data</VAR>)</I>
<DD><A NAME="IDX287"></A>
The function <CODE>obstack_int_grow_fast</CODE> adds <CODE>sizeof (int)</CODE> bytes
containing the value of <VAR>data</VAR> to the growing object in obstack
<VAR>obstack-ptr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>obstack_blank_fast</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>, int <VAR>size</VAR>)</I>
<DD><A NAME="IDX288"></A>
The function <CODE>obstack_blank_fast</CODE> adds <VAR>size</VAR> bytes to the
growing object in obstack <VAR>obstack-ptr</VAR> without initializing them.
</DL>

</P>
<P>
When you check for space using <CODE>obstack_room</CODE> and there is not
enough room for what you want to add, the fast growth functions
are not safe.  In this case, simply use the corresponding ordinary
growth function instead.  Very soon this will copy the object to a
new chunk; then there will be lots of room available again.

</P>
<P>
So, each time you use an ordinary growth function, check afterward for
sufficient space using <CODE>obstack_room</CODE>.  Once the object is copied
to a new chunk, there will be plenty of space again, so the program will
start using the fast growth functions again.

</P>
<P>
Here is an example:

</P>

<PRE>
void
add_string (struct obstack *obstack, const char *ptr, int len)
{
  while (len &#62; 0)
    {
      int room = obstack_room (obstack);
      if (room == 0)
        {
          /* Not enough room. Add one character slowly,
             which may copy to a new chunk and make room.  */
          obstack_1grow (obstack, *ptr++);
          len--;
        }
      else
        {
          if (room &#62; len)
            room = len;
          /* Add fast as much as we have room for. */
          len -= room;
          while (room-- &#62; 0)
            obstack_1grow_fast (obstack, *ptr++);
        }
    }
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_46.html">previous</A>, <A HREF="libc_48.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
