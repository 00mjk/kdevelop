<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Scatter-Gather</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_222.html">previous</A>, <A HREF="libc_224.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC230" HREF="libc_toc.html#TOC230">Fast Scatter-Gather I/O</A></H2>
<P>
<A NAME="IDX1034"></A>

</P>
<P>
Some applications may need to read or write data to multiple buffers,
which are separated in memory.  Although this can be done easily enough
with multiple calls to <CODE>read</CODE> and <CODE>write</CODE>, it is inefficient
because there is overhead associated with each kernel call.

</P>
<P>
Instead, many platforms provide special high-speed primitives to perform
these <STRONG>scatter-gather</STRONG> operations in a single kernel call.  The GNU C
library will provide an emulation on any system that lacks these
primitives, so they are not a portability threat.  They are defined in
<CODE>sys/uio.h</CODE>.

</P>
<P>
These functions are controlled with arrays of <CODE>iovec</CODE> structures,
which describe the location and size of each buffer.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct iovec</B>
<DD><A NAME="IDX1035"></A>

</P>
<P>
The <CODE>iovec</CODE> structure describes a buffer. It contains two fields:

</P>
<DL COMPACT>

<DT><CODE>void *iov_base</CODE>
<DD>
Contains the address of a buffer.

<DT><CODE>size_t iov_len</CODE>
<DD>
Contains the length of the buffer.

</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> ssize_t <B>readv</B> <I>(int <VAR>filedes</VAR>, const struct iovec *<VAR>vector</VAR>, int <VAR>count</VAR>)</I>
<DD><A NAME="IDX1036"></A>

</P>
<P>
The <CODE>readv</CODE> function reads data from <VAR>filedes</VAR> and scatters it
into the buffers described in <VAR>vector</VAR>, which is taken to be
<VAR>count</VAR> structures long.  As each buffer is filled, data is sent to the
next.

</P>
<P>
Note that <CODE>readv</CODE> is not guaranteed to fill all the buffers.
It may stop at any point, for the same reasons <CODE>read</CODE> would.

</P>
<P>
The return value is a count of bytes (<EM>not</EM> buffers) read, @math{0}
indicating end-of-file, or @math{-1} indicating an error.  The possible
errors are the same as in <CODE>read</CODE>.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> ssize_t <B>writev</B> <I>(int <VAR>filedes</VAR>, const struct iovec *<VAR>vector</VAR>, int <VAR>count</VAR>)</I>
<DD><A NAME="IDX1037"></A>

</P>
<P>
The <CODE>writev</CODE> function gathers data from the buffers described in
<VAR>vector</VAR>, which is taken to be <VAR>count</VAR> structures long, and writes
them to <CODE>filedes</CODE>.  As each buffer is written, it moves on to the
next.

</P>
<P>
Like <CODE>readv</CODE>, <CODE>writev</CODE> may stop midstream under the same
conditions <CODE>write</CODE> would.

</P>
<P>
The return value is a count of bytes written, or @math{-1} indicating an
error.  The possible errors are the same as in <CODE>write</CODE>.

</P>
</DL>

<P>
Note that if the buffers are small (under about 1kB), high-level streams
may be easier to use than these functions.  However, <CODE>readv</CODE> and
<CODE>writev</CODE> are more efficient when the individual buffers themselves
(as opposed to the total output), are large.  In that case, a high-level
stream would not be able to cache the data effectively.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_222.html">previous</A>, <A HREF="libc_224.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
