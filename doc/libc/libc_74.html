<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Argz Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_73.html">previous</A>, <A HREF="libc_75.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC74" HREF="libc_toc.html#TOC74">Argz Functions</A></H3>

<P>
Each argz vector is represented by a pointer to the first element, of
type <CODE>char *</CODE>, and a size, of type <CODE>size_t</CODE>, both of which can
be initialized to <CODE>0</CODE> to represent an empty argz vector.  All argz
functions accept either a pointer and a size argument, or pointers to
them, if they will be modified.

</P>
<P>
The argz functions use <CODE>malloc</CODE>/<CODE>realloc</CODE> to allocate/grow
argz vectors, and so any argz vector creating using these functions may
be freed by using <CODE>free</CODE>; conversely, any argz function that may
grow a string expects that string to have been allocated using
<CODE>malloc</CODE> (those argz functions that only examine their arguments or
modify them in place will work on any sort of memory).
See section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>.

</P>
<P>
All argz functions that do memory allocation have a return type of
<CODE>error_t</CODE>, and return <CODE>0</CODE> for success, and <CODE>ENOMEM</CODE> if an
allocation error occurs.

</P>
<P>
<A NAME="IDX484"></A>
These functions are declared in the standard include file <TT>`argz.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_create</B> <I>(char *const <VAR>argv</VAR>[], char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX485"></A>
The <CODE>argz_create</CODE> function converts the Unix-style argument vector
<VAR>argv</VAR> (a vector of pointers to normal C strings, terminated by
<CODE>(char *)0</CODE>; see section <A HREF="libc_472.html#SEC479">Program Arguments</A>) into an argz vector with
the same elements, which is returned in <VAR>argz</VAR> and <VAR>argz_len</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_create_sep</B> <I>(const char *<VAR>string</VAR>, int <VAR>sep</VAR>, char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>)</I>
<DD><A NAME="IDX486"></A>
The <CODE>argz_create_sep</CODE> function converts the null-terminated string
<VAR>string</VAR> into an argz vector (returned in <VAR>argz</VAR> and
<VAR>argz_len</VAR>) by splitting it into elements at every occurrence of the
character <VAR>sep</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>argz_count</B> <I>(const char *<VAR>argz</VAR>, size_t <VAR>arg_len</VAR>)</I>
<DD><A NAME="IDX487"></A>
Returns the number of elements in the argz vector <VAR>argz</VAR> and
<VAR>argz_len</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>argz_extract</B> <I>(char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>, char **<VAR>argv</VAR>)</I>
<DD><A NAME="IDX488"></A>
The <CODE>argz_extract</CODE> function converts the argz vector <VAR>argz</VAR> and
<VAR>argz_len</VAR> into a Unix-style argument vector stored in <VAR>argv</VAR>,
by putting pointers to every element in <VAR>argz</VAR> into successive
positions in <VAR>argv</VAR>, followed by a terminator of <CODE>0</CODE>.
<VAR>Argv</VAR> must be pre-allocated with enough space to hold all the
elements in <VAR>argz</VAR> plus the terminating <CODE>(char *)0</CODE>
(<CODE>(argz_count (<VAR>argz</VAR>, <VAR>argz_len</VAR>) + 1) * sizeof (char *)</CODE>
bytes should be enough).  Note that the string pointers stored into
<VAR>argv</VAR> point into <VAR>argz</VAR>---they are not copies--and so
<VAR>argz</VAR> must be copied if it will be changed while <VAR>argv</VAR> is
still active.  This function is useful for passing the elements in
<VAR>argz</VAR> to an exec function (see section <A HREF="libc_517.html#SEC525">Executing a File</A>).
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>argz_stringify</B> <I>(char *<VAR>argz</VAR>, size_t <VAR>len</VAR>, int <VAR>sep</VAR>)</I>
<DD><A NAME="IDX489"></A>
The <CODE>argz_stringify</CODE> converts <VAR>argz</VAR> into a normal string with
the elements separated by the character <VAR>sep</VAR>, by replacing each
<CODE>'\0'</CODE> inside <VAR>argz</VAR> (except the last one, which terminates the
string) with <VAR>sep</VAR>.  This is handy for printing <VAR>argz</VAR> in a
readable manner.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_add</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, const char *<VAR>str</VAR>)</I>
<DD><A NAME="IDX490"></A>
The <CODE>argz_add</CODE> function adds the string <VAR>str</VAR> to the end of the
argz vector <CODE>*<VAR>argz</VAR></CODE>, and updates <CODE>*<VAR>argz</VAR></CODE> and
<CODE>*<VAR>argz_len</VAR></CODE> accordingly.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_add_sep</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, const char *<VAR>str</VAR>, int <VAR>delim</VAR>)</I>
<DD><A NAME="IDX491"></A>
The <CODE>argz_add_sep</CODE> function is similar to <CODE>argz_add</CODE>, but
<VAR>str</VAR> is split into separate elements in the result at occurrences of
the character <VAR>delim</VAR>.  This is useful, for instance, for
adding the components of a Unix search path to an argz vector, by using
a value of <CODE>':'</CODE> for <VAR>delim</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_append</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, const char *<VAR>buf</VAR>, size_t <VAR>buf_len</VAR>)</I>
<DD><A NAME="IDX492"></A>
The <CODE>argz_append</CODE> function appends <VAR>buf_len</VAR> bytes starting at
<VAR>buf</VAR> to the argz vector <CODE>*<VAR>argz</VAR></CODE>, reallocating
<CODE>*<VAR>argz</VAR></CODE> to accommodate it, and adding <VAR>buf_len</VAR> to
<CODE>*<VAR>argz_len</VAR></CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_delete</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, char *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX493"></A>
If <VAR>entry</VAR> points to the beginning of one of the elements in the
argz vector <CODE>*<VAR>argz</VAR></CODE>, the <CODE>argz_delete</CODE> function will
remove this entry and reallocate <CODE>*<VAR>argz</VAR></CODE>, modifying
<CODE>*<VAR>argz</VAR></CODE> and <CODE>*<VAR>argz_len</VAR></CODE> accordingly.  Note that as
destructive argz functions usually reallocate their argz argument,
pointers into argz vectors such as <VAR>entry</VAR> will then become invalid.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_insert</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, char *<VAR>before</VAR>, const char *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX494"></A>
The <CODE>argz_insert</CODE> function inserts the string <VAR>entry</VAR> into the
argz vector <CODE>*<VAR>argz</VAR></CODE> at a point just before the existing
element pointed to by <VAR>before</VAR>, reallocating <CODE>*<VAR>argz</VAR></CODE> and
updating <CODE>*<VAR>argz</VAR></CODE> and <CODE>*<VAR>argz_len</VAR></CODE>.  If <VAR>before</VAR>
is <CODE>0</CODE>, <VAR>entry</VAR> is added to the end instead (as if by
<CODE>argz_add</CODE>).  Since the first element is in fact the same as
<CODE>*<VAR>argz</VAR></CODE>, passing in <CODE>*<VAR>argz</VAR></CODE> as the value of
<VAR>before</VAR> will result in <VAR>entry</VAR> being inserted at the beginning.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>argz_next</B> <I>(char *<VAR>argz</VAR>, size_t <VAR>argz_len</VAR>, const char *<VAR>entry</VAR>)</I>
<DD><A NAME="IDX495"></A>
The <CODE>argz_next</CODE> function provides a convenient way of iterating
over the elements in the argz vector <VAR>argz</VAR>.  It returns a pointer
to the next element in <VAR>argz</VAR> after the element <VAR>entry</VAR>, or
<CODE>0</CODE> if there are no elements following <VAR>entry</VAR>.  If <VAR>entry</VAR>
is <CODE>0</CODE>, the first element of <VAR>argz</VAR> is returned.

</P>
<P>
This behavior suggests two styles of iteration:

</P>

<PRE>
    char *entry = 0;
    while ((entry = argz_next (<VAR>argz</VAR>, <VAR>argz_len</VAR>, entry)))
      <VAR>action</VAR>;
</PRE>

<P>
(the double parentheses are necessary to make some C compilers shut up
about what they consider a questionable <CODE>while</CODE>-test) and:

</P>

<PRE>
    char *entry;
    for (entry = <VAR>argz</VAR>;
         entry;
         entry = argz_next (<VAR>argz</VAR>, <VAR>argz_len</VAR>, entry))
      <VAR>action</VAR>;
</PRE>

<P>
Note that the latter depends on <VAR>argz</VAR> having a value of <CODE>0</CODE> if
it is empty (rather than a pointer to an empty block of memory); this
invariant is maintained for argz vectors created by the functions here.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> error_t <B>argz_replace</B> <I>(char **<VAR>argz</VAR>, size_t *<VAR>argz_len</VAR>, const char *<VAR>str</VAR>, const char *<VAR>with</VAR>, unsigned *<VAR>replace_count</VAR>)</I>
<DD><A NAME="IDX496"></A>
Replace any occurrences of the string <VAR>str</VAR> in <VAR>argz</VAR> with
<VAR>with</VAR>, reallocating <VAR>argz</VAR> as necessary.  If
<VAR>replace_count</VAR> is non-zero, <CODE>*<VAR>replace_count</VAR></CODE> will be
incremented by number of replacements performed.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_73.html">previous</A>, <A HREF="libc_75.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
