<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - iconv Examples</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_90.html">previous</A>, <A HREF="libc_92.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC91" HREF="libc_toc.html#TOC91">A complete <CODE>iconv</CODE> example</A></H3>

<P>
The example below features a solution for a common problem.  Given that
one knows the internal encoding used by the system for <CODE>wchar_t</CODE>
strings one often is in the position to read text from a file and store
it in wide character buffers.  One can do this using <CODE>mbsrtowcs</CODE>
but then we run into the problems discussed above.

</P>

<PRE>
int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open ("UCS4", charset);
  if (cd == (iconv_t) -1)
    {
      /* Something went wrong.  */
      if (errno == EINVAL)
        error (0, 0, "conversion from `%s' to `UCS4' no available",
               charset);
      else
        perror ("iconv_open");

      /* Terminate the output string.  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail &#62; 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* Read more input.  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* When we come here the file is completely read.
             This still could mean there are some unused
             characters in the <CODE>inbuf</CODE>.  Put them back.  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;
          break;
        }
      insize += nread;

      /* Do the conversion.  */
      nconv = iconv (cd, &#38;inptr, &#38;insize, &#38;wrptr, &#38;avail);
      if (nconv == (size_t) -1)
        {
          /* Not everything went right.  It might only be
             an unfinished byte sequence at the end of the
             buffer.  Or it is a real problem.  */
          if (errno == EINVAL)
            /* This is harmless.  Simply move the unused
               bytes to the beginning of the buffer so that
               they can be used in the next round.  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* It is a real problem.  Maybe we ran out of
                 space in the output buffer or we have invalid
                 input.  In any case back the file pointer to
                 the position of the last processed byte.  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* Terminate the output string.  */
  *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror ("iconv_close");

  return (wchar_t *) wrptr - outbuf;
}
</PRE>

<P>
<A NAME="IDX566"></A>
This example shows the most important aspects of using the <CODE>iconv</CODE>
functions.  It shows how successive calls to <CODE>iconv</CODE> can be used to
convert large amounts of text.  The user does not have to care about
stateful encodings as the functions take care of everything.

</P>
<P>
An interesting point is the case where <CODE>iconv</CODE> return an error and
<CODE>errno</CODE> is set to <CODE>EINVAL</CODE>.  This is not really an error in
the transformation.  It can happen whenever the input character set
contains byte sequences of more than one byte for some character and
texts are not processed in one piece.  In this case there is a chance
that a multibyte sequence is cut.  The caller than can simply read the
remainder of the takes and feed the offending bytes together with new
character from the input to <CODE>iconv</CODE> and continue the work.  The
internal state kept in the descriptor is <EM>not</EM> unspecified after
such an event as it is the case with the conversion functions from the
ISO C standard.

</P>
<P>
The example also shows the problem of using wide character strings with
<CODE>iconv</CODE>.  As explained in the description of the <CODE>iconv</CODE>
function above the function always takes a pointer to a <CODE>char</CODE>
array and the available space is measured in bytes.  In the example the
output buffer is a wide character buffer.  Therefore we use a local
variable <VAR>wrptr</VAR> of type <CODE>char *</CODE> which is used in the
<CODE>iconv</CODE> calls.

</P>
<P>
This looks rather innocent but can lead to problems on platforms which
have tight restriction on alignment.  Therefore the caller of
<CODE>iconv</CODE> has to make sure that the pointers passed are suitable for
access of characters from the appropriate character set.  Since in the
above case the input parameter to the function is a <CODE>wchar_t</CODE>
pointer this is the case (unless the user violates alignment when
computing the parameter).  But in other situations, especially when
writing generic functions where one does not know what type of character
set one uses and therefore treats text as a sequence of bytes, it might
become tricky.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_90.html">previous</A>, <A HREF="libc_92.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
