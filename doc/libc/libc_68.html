<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - String/Array Comparison</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_67.html">previous</A>, <A HREF="libc_69.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC68" HREF="libc_toc.html#TOC68">String/Array Comparison</A></H2>
<P>
<A NAME="IDX438"></A>
<A NAME="IDX439"></A>
<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
<A NAME="IDX442"></A>

</P>
<P>
You can use the functions in this section to perform comparisons on the
contents of strings and arrays.  As well as checking for equality, these
functions can also be used as the ordering functions for sorting
operations.  See section <A HREF="libc_119.html#SEC126">Searching and Sorting</A>, for an example of this.

</P>
<P>
Unlike most comparison operations in C, the string comparison functions
return a nonzero value if the strings are <EM>not</EM> equivalent rather
than if they are.  The sign of the value indicates the relative ordering
of the first characters in the strings that are not equivalent:  a
negative value indicates that the first string is "less" than the
second, while a positive value indicates that the first string is
"greater".

</P>
<P>
The most common use of these functions is to check only for equality.
This is canonically done with an expression like <SAMP>`! strcmp (s1, s2)'</SAMP>.

</P>
<P>
All of these functions are declared in the header file <TT>`string.h'</TT>.
<A NAME="IDX443"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>memcmp</B> <I>(const void *<VAR>a1</VAR>, const void *<VAR>a2</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX444"></A>
The function <CODE>memcmp</CODE> compares the <VAR>size</VAR> bytes of memory
beginning at <VAR>a1</VAR> against the <VAR>size</VAR> bytes of memory beginning
at <VAR>a2</VAR>.  The value returned has the same sign as the difference
between the first differing pair of bytes (interpreted as <CODE>unsigned
char</CODE> objects, then promoted to <CODE>int</CODE>).

</P>
<P>
If the contents of the two blocks are equal, <CODE>memcmp</CODE> returns
<CODE>0</CODE>.
</DL>

</P>
<P>
On arbitrary arrays, the <CODE>memcmp</CODE> function is mostly useful for
testing equality.  It usually isn't meaningful to do byte-wise ordering
comparisons on arrays of things other than bytes.  For example, a
byte-wise comparison on the bytes that make up floating-point numbers
isn't likely to tell you anything about the relationship between the
values of the floating-point numbers.

</P>
<P>
You should also be careful about using <CODE>memcmp</CODE> to compare objects
that can contain "holes", such as the padding inserted into structure
objects to enforce alignment requirements, extra space at the end of
unions, and extra characters at the ends of strings whose length is less
than their allocated size.  The contents of these "holes" are
indeterminate and may cause strange behavior when performing byte-wise
comparisons.  For more predictable results, perform an explicit
component-wise comparison.

</P>
<P>
For example, given a structure type definition like:

</P>

<PRE>
struct foo
  {
    unsigned char tag;
    union
      {
        double f;
        long i;
        char *p;
      } value;
  };
</PRE>

<P>
you are better off writing a specialized comparison function to compare
<CODE>struct foo</CODE> objects instead of comparing them with <CODE>memcmp</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>strcmp</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>)</I>
<DD><A NAME="IDX445"></A>
The <CODE>strcmp</CODE> function compares the string <VAR>s1</VAR> against
<VAR>s2</VAR>, returning a value that has the same sign as the difference
between the first differing pair of characters (interpreted as
<CODE>unsigned char</CODE> objects, then promoted to <CODE>int</CODE>).

</P>
<P>
If the two strings are equal, <CODE>strcmp</CODE> returns <CODE>0</CODE>.

</P>
<P>
A consequence of the ordering used by <CODE>strcmp</CODE> is that if <VAR>s1</VAR>
is an initial substring of <VAR>s2</VAR>, then <VAR>s1</VAR> is considered to be
"less than" <VAR>s2</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>strcasecmp</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>)</I>
<DD><A NAME="IDX446"></A>
This function is like <CODE>strcmp</CODE>, except that differences in case are
ignored.  How uppercase and lowercase characters are related is
determined by the currently selected locale.  In the standard <CODE>"C"</CODE>
locale the characters @"A and @"a do not match but in a locale which
regards these characters as parts of the alphabet they do match.

</P>
<P>
<CODE>strcasecmp</CODE> is derived from BSD.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>strncasecmp</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX447"></A>
This function is like <CODE>strncmp</CODE>, except that differences in case
are ignored.  Like <CODE>strcasecmp</CODE>, it is locale dependent how
uppercase and lowercase characters are related.

</P>
<P>
<CODE>strncasecmp</CODE> is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>strncmp</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX448"></A>
This function is the similar to <CODE>strcmp</CODE>, except that no more than
<VAR>size</VAR> characters are compared.  In other words, if the two strings are
the same in their first <VAR>size</VAR> characters, the return value is zero.
</DL>

</P>
<P>
Here are some examples showing the use of <CODE>strcmp</CODE> and <CODE>strncmp</CODE>.
These examples assume the use of the ASCII character set.  (If some
other character set--say, EBCDIC--is used instead, then the glyphs
are associated with different numeric codes, and the return values
and ordering may differ.)

</P>

<PRE>
strcmp ("hello", "hello")
    => 0    /* These two strings are the same. */
strcmp ("hello", "Hello")
    => 32   /* Comparisons are case-sensitive. */
strcmp ("hello", "world")
    => -15  /* The character <CODE>'h'</CODE> comes before <CODE>'w'</CODE>. */
strcmp ("hello", "hello, world")
    => -44  /* Comparing a null character against a comma. */
strncmp ("hello", "hello, world", 5)
    => 0    /* The initial 5 characters are the same. */
strncmp ("hello, world", "hello, stupid world!!!", 5)
    => 0    /* The initial 5 characters are the same. */
</PRE>

<P>
<DL>
<DT><U>Function:</U> int <B>strverscmp</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>)</I>
<DD><A NAME="IDX449"></A>
The <CODE>strverscmp</CODE> function compares the string <VAR>s1</VAR> against
<VAR>s2</VAR>, considering them as holding indices/version numbers.  Return
value follows the same conventions as found in the <CODE>strverscmp</CODE>
function.  In fact, if <VAR>s1</VAR> and <VAR>s2</VAR> contain no digits,
<CODE>strverscmp</CODE> behaves like <CODE>strcmp</CODE>.

</P>
<P>
Basically, we compare strings normally (character by character), until
we find a digit in each string - then we enter a special comparison
mode, where each sequence of digits is taken as a whole.  If we reach the
end of these two parts without noticing a difference, we return to the
standard comparison mode.  There are two types of numeric parts:
"integral" and "fractional" (those  begin with a '0'). The types
of the numeric parts affect the way we sort them:

</P>

<UL>
<LI>

integral/integral: we compare values as you would expect.

<LI>

fractional/integral: the fractional part is less than the integral one.
Again, no surprise.

<LI>

fractional/fractional: the things become a bit more complex.
If the common prefix contains only leading zeroes, the longest part is less
than the other one; else the comparison behaves normally.
</UL>


<PRE>
strverscmp ("no digit", "no digit")
    => 0    /* same behaviour as strcmp. */
strverscmp ("item#99", "item#100")
    => &#60;0   /* same prefix, but 99 &#60; 100. */
strverscmp ("alpha1", "alpha001")
    => &#62;0   /* fractional part inferior to integral one. */
strverscmp ("part1_f012", "part1_f01")
    => &#62;0   /* two fractional parts. */
strverscmp ("foo.009", "foo.0")
    => &#60;0   /* idem, but with leading zeroes only. */
</PRE>

<P>
This function is especially useful when dealing with filename sorting,
because filenames frequently hold indices/version numbers.

</P>
<P>
<CODE>strverscmp</CODE> is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>bcmp</B> <I>(const void *<VAR>a1</VAR>, const void *<VAR>a2</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX450"></A>
This is an obsolete alias for <CODE>memcmp</CODE>, derived from BSD.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_67.html">previous</A>, <A HREF="libc_69.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
