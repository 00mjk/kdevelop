<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Host Names</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_295.html">previous</A>, <A HREF="libc_297.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC303" HREF="libc_toc.html#TOC303">Host Names</A></H4>
<P>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
<A NAME="IDX1468"></A>

</P>
<P>
Besides the standard numbers-and-dots notation for Internet addresses,
you can also refer to a host by a symbolic name.  The advantage of a
symbolic name is that it is usually easier to remember.  For example,
the machine with Internet address <SAMP>`158.121.106.19'</SAMP> is also known as
<SAMP>`alpha.gnu.org'</SAMP>; and other machines in the <SAMP>`gnu.org'</SAMP>
domain can refer to it simply as <SAMP>`alpha'</SAMP>.

</P>
<P>
<A NAME="IDX1469"></A>
<A NAME="IDX1470"></A>
Internally, the system uses a database to keep track of the mapping
between host names and host numbers.  This database is usually either
the file <TT>`/etc/hosts'</TT> or an equivalent provided by a name server.
The functions and other symbols for accessing this database are declared
in <TT>`netdb.h'</TT>.  They are BSD features, defined unconditionally if
you include <TT>`netdb.h'</TT>.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct hostent</B>
<DD><A NAME="IDX1471"></A>
This data type is used to represent an entry in the hosts database.  It
has the following members:

</P>
<DL COMPACT>

<DT><CODE>char *h_name</CODE>
<DD>
This is the "official" name of the host.

<DT><CODE>char **h_aliases</CODE>
<DD>
These are alternative names for the host, represented as a null-terminated
vector of strings.

<DT><CODE>int h_addrtype</CODE>
<DD>
This is the host address type; in practice, its value is always either
<CODE>AF_INET</CODE> or <CODE>AF_INET6</CODE>, with the latter being used for IPv6
hosts.  In principle other kinds of addresses could be represented in
the data base as well as Internet addresses; if this were done, you
might find a value in this field other than <CODE>AF_INET</CODE> or
<CODE>AF_INET6</CODE>.  See section <A HREF="libc_281.html#SEC288">Socket Addresses</A>.

<DT><CODE>int h_length</CODE>
<DD>
This is the length, in bytes, of each address.

<DT><CODE>char **h_addr_list</CODE>
<DD>
This is the vector of addresses for the host.  (Recall that the host
might be connected to multiple networks and have different addresses on
each one.)  The vector is terminated by a null pointer.

<DT><CODE>char *h_addr</CODE>
<DD>
This is a synonym for <CODE>h_addr_list[0]</CODE>; in other words, it is the
first host address.
</DL>
</DL>

<P>
As far as the host database is concerned, each address is just a block
of memory <CODE>h_length</CODE> bytes long.  But in other contexts there is an
implicit assumption that you can convert IPv4 addresses to a
<CODE>struct in_addr</CODE> or an <CODE>uint32_t</CODE>.  Host addresses in
a <CODE>struct hostent</CODE> structure are always given in network byte
order; see section <A HREF="libc_299.html#SEC306">Byte Order Conversion</A>.

</P>
<P>
You can use <CODE>gethostbyname</CODE>, <CODE>gethostbyname2</CODE> or
<CODE>gethostbyaddr</CODE> to search the hosts database for information about
a particular host.  The information is returned in a
statically-allocated structure; you must copy the information if you
need to save it across calls.  You can also use <CODE>getaddrinfo</CODE> and
<CODE>getnameinfo</CODE> to obtain this information.

</P>
<P>
<DL>
<DT><U>Function:</U> struct hostent * <B>gethostbyname</B> <I>(const char *<VAR>name</VAR>)</I>
<DD><A NAME="IDX1472"></A>
The <CODE>gethostbyname</CODE> function returns information about the host
named <VAR>name</VAR>.  If the lookup fails, it returns a null pointer.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct hostent * <B>gethostbyname2</B> <I>(const char *<VAR>name</VAR>, int <VAR>af</VAR>)</I>
<DD><A NAME="IDX1473"></A>
The <CODE>gethostbyname2</CODE> function is like <CODE>gethostbyname</CODE>, but
allows the caller to specify the desired address family (e.g.
<CODE>AF_INET</CODE> or <CODE>AF_INET6</CODE>) for the result.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct hostent * <B>gethostbyaddr</B> <I>(const char *<VAR>addr</VAR>, int <VAR>length</VAR>, int <VAR>format</VAR>)</I>
<DD><A NAME="IDX1474"></A>
The <CODE>gethostbyaddr</CODE> function returns information about the host
with Internet address <VAR>addr</VAR>.  The parameter <VAR>addr</VAR> is not
really a pointer to char - it can be a pointer to an IPv4 or an IPv6
address. The <VAR>length</VAR> argument is the size (in bytes) of the address
at <VAR>addr</VAR>.  <VAR>format</VAR> specifies the address format; for an IPv4
Internet address, specify a value of <CODE>AF_INET</CODE>; for an IPv6
Internet address, use <CODE>AF_INET6</CODE>.

</P>
<P>
If the lookup fails, <CODE>gethostbyaddr</CODE> returns a null pointer.
</DL>

</P>
<P>
<A NAME="IDX1475"></A>
If the name lookup by <CODE>gethostbyname</CODE> or <CODE>gethostbyaddr</CODE>
fails, you can find out the reason by looking at the value of the
variable <CODE>h_errno</CODE>.  (It would be cleaner design for these
functions to set <CODE>errno</CODE>, but use of <CODE>h_errno</CODE> is compatible
with other systems.)

</P>
<P>
Here are the error codes that you may find in <CODE>h_errno</CODE>:

</P>
<DL COMPACT>

<DT><CODE>HOST_NOT_FOUND</CODE>
<DD>
<A NAME="IDX1476"></A>
No such host is known in the data base.

<DT><CODE>TRY_AGAIN</CODE>
<DD>
<A NAME="IDX1477"></A>
This condition happens when the name server could not be contacted.  If
you try again later, you may succeed then.

<DT><CODE>NO_RECOVERY</CODE>
<DD>
<A NAME="IDX1478"></A>
A non-recoverable error occurred.

<DT><CODE>NO_ADDRESS</CODE>
<DD>
<A NAME="IDX1479"></A>
The host database contains an entry for the name, but it doesn't have an
associated Internet address.
</DL>

<P>
The lookup functions above all have one in common: they are not
reentrant and therefore unusable in multi-threaded applications.
Therefore provides the GNU C library a new set of functions which can be
used in this context.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gethostbyname_r</B> <I>(const char *restrict <VAR>name</VAR>, struct hostent *restrict <VAR>result_buf</VAR>, char *restrict <VAR>buf</VAR>, size_t <VAR>buflen</VAR>, struct hostent **restrict <VAR>result</VAR>, int *restrict <VAR>h_errnop</VAR>)</I>
<DD><A NAME="IDX1480"></A>
The <CODE>gethostbyname_r</CODE> function returns information about the host
named <VAR>name</VAR>.  The caller must pass a pointer to an object of type
<CODE>struct hostent</CODE> in the <VAR>result_buf</VAR> parameter.  In addition
the function may need extra buffer space and the caller must pass an
pointer and the size of the buffer in the <VAR>buf</VAR> and <VAR>buflen</VAR>
parameters.

</P>
<P>
A pointer to the buffer, in which the result is stored, is available in
<CODE>*<VAR>result</VAR></CODE> after the function call successfully returned.  If
an error occurs or if no entry is found, the pointer <CODE>*<VAR>result</VAR></CODE>
is a null pointer.  Success is signalled by a zero return value.  If the
function failed the return value is an error number.  In addition to the
errors defined for <CODE>gethostbyname</CODE> it can also be <CODE>ERANGE</CODE>.
In this case the call should be repeated with a larger buffer.
Additional error information is not stored in the global variable
<CODE>h_errno</CODE> but instead in the object pointed to by <VAR>h_errnop</VAR>.

</P>
<P>
Here's a small example:

<PRE>
struct hostent *
gethostname (char *host)
{
  struct hostent hostbuf, *hp;
  size_t hstbuflen;
  char *tmphstbuf;
  int res;
  int herr;

  hstbuflen = 1024;
  tmphstbuf = malloc (hstbuflen);

  while ((res = gethostbyname_r (host, &#38;hostbuf, tmphstbuf, hstbuflen,
                                 &#38;hp, &#38;herr)) == ERANGE)
    {
      /* Enlarge the buffer.  */
      hstbuflen *= 2;
      tmphstbuf = realloc (tmphstbuf, hstbuflen);
    }
  /*  Check for errors.  */
  if (res || hp == NULL)
    return NULL;
  return hp-&#62;h_name;
}
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>gethostbyname2_r</B> <I>(const char *<VAR>name</VAR>, int <VAR>af</VAR>, struct hostent *restrict <VAR>result_buf</VAR>, char *restrict <VAR>buf</VAR>, size_t <VAR>buflen</VAR>, struct hostent **restrict <VAR>result</VAR>, int *restrict <VAR>h_errnop</VAR>)</I>
<DD><A NAME="IDX1481"></A>
The <CODE>gethostbyname2_r</CODE> function is like <CODE>gethostbyname_r</CODE>, but
allows the caller to specify the desired address family (e.g.
<CODE>AF_INET</CODE> or <CODE>AF_INET6</CODE>) for the result.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gethostbyaddr_r</B> <I>(const char *<VAR>addr</VAR>, int <VAR>length</VAR>, int <VAR>format</VAR>, struct hostent *restrict <VAR>result_buf</VAR>, char *restrict <VAR>buf</VAR>, size_t <VAR>buflen</VAR>, struct hostent **restrict <VAR>result</VAR>, int *restrict <VAR>h_errnop</VAR>)</I>
<DD><A NAME="IDX1482"></A>
The <CODE>gethostbyaddr_r</CODE> function returns information about the host
with Internet address <VAR>addr</VAR>.  The parameter <VAR>addr</VAR> is not
really a pointer to char - it can be a pointer to an IPv4 or an IPv6
address. The <VAR>length</VAR> argument is the size (in bytes) of the address
at <VAR>addr</VAR>.  <VAR>format</VAR> specifies the address format; for an IPv4
Internet address, specify a value of <CODE>AF_INET</CODE>; for an IPv6
Internet address, use <CODE>AF_INET6</CODE>.

</P>
<P>
Similar to the <CODE>gethostbyname_r</CODE> function, the caller must provide
buffers for the result and memory used internally.  In case of success
the function returns zero.  Otherwise the value is an error number where
<CODE>ERANGE</CODE> has the special meaning that the caller-provided buffer is
too small.
</DL>

</P>
<P>
You can also scan the entire hosts database one entry at a time using
<CODE>sethostent</CODE>, <CODE>gethostent</CODE>, and <CODE>endhostent</CODE>.  Be careful
in using these functions, because they are not reentrant.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>sethostent</B> <I>(int <VAR>stayopen</VAR>)</I>
<DD><A NAME="IDX1483"></A>
This function opens the hosts database to begin scanning it.  You can
then call <CODE>gethostent</CODE> to read the entries.

</P>
<P>
If the <VAR>stayopen</VAR> argument is nonzero, this sets a flag so that
subsequent calls to <CODE>gethostbyname</CODE> or <CODE>gethostbyaddr</CODE> will
not close the database (as they usually would).  This makes for more
efficiency if you call those functions several times, by avoiding
reopening the database for each call.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> struct hostent * <B>gethostent</B> <I>(void)</I>
<DD><A NAME="IDX1484"></A>
This function returns the next entry in the hosts database.  It
returns a null pointer if there are no more entries.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>endhostent</B> <I>(void)</I>
<DD><A NAME="IDX1485"></A>
This function closes the hosts database.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_295.html">previous</A>, <A HREF="libc_297.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
