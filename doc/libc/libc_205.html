<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Obstack Streams</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_204.html">previous</A>, <A HREF="libc_206.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC212" HREF="libc_toc.html#TOC212">Obstack Streams</A></H3>

<P>
You can open an output stream that puts it data in an obstack.
See section <A HREF="libc_40.html#SEC40">Obstacks</A>.

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>open_obstack_stream</B> <I>(struct obstack *<VAR>obstack</VAR>)</I>
<DD><A NAME="IDX940"></A>
This function opens a stream for writing data into the obstack <VAR>obstack</VAR>.
This starts an object in the obstack and makes it grow as data is
written (see section <A HREF="libc_46.html#SEC46">Growing Objects</A>).

</P>
<P>
Calling <CODE>fflush</CODE> on this stream updates the current size of the
object to match the amount of data that has been written.  After a call
to <CODE>fflush</CODE>, you can examine the object temporarily.

</P>
<P>
You can move the file position of an obstack stream with <CODE>fseek</CODE> or
<CODE>fseeko</CODE> (see section <A HREF="libc_197.html#SEC204">File Positioning</A>).  Moving the file position past
the end of the data written fills the intervening space with zeros.

</P>
<P>
To make the object permanent, update the obstack with <CODE>fflush</CODE>, and
then use <CODE>obstack_finish</CODE> to finalize the object and get its address.
The following write to the stream starts a new object in the obstack,
and later writes add to that object until you do another <CODE>fflush</CODE>
and <CODE>obstack_finish</CODE>.

</P>
<P>
But how do you find out how long the object is?  You can get the length
in bytes by calling <CODE>obstack_object_size</CODE> (see section <A HREF="libc_48.html#SEC48">Status of an Obstack</A>), or you can null-terminate the object like this:

</P>

<PRE>
obstack_1grow (<VAR>obstack</VAR>, 0);
</PRE>

<P>
Whichever one you do, you must do it <EM>before</EM> calling
<CODE>obstack_finish</CODE>.  (You can do both if you wish.)
</DL>

</P>
<P>
Here is a sample function that uses <CODE>open_obstack_stream</CODE>:

</P>

<PRE>
char *
make_message_string (const char *a, int b)
{
  FILE *stream = open_obstack_stream (&#38;message_obstack);
  output_task (stream);
  fprintf (stream, ": ");
  fprintf (stream, a, b);
  fprintf (stream, "\n");
  fclose (stream);
  obstack_1grow (&#38;message_obstack, 0);
  return obstack_finish (&#38;message_obstack);
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_204.html">previous</A>, <A HREF="libc_206.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
