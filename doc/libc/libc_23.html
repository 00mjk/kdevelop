<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Basic Allocation</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_22.html">previous</A>, <A HREF="libc_24.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC23" HREF="libc_toc.html#TOC23">Basic Storage Allocation</A></H3>
<P>
<A NAME="IDX217"></A>

</P>
<P>
To allocate a block of memory, call <CODE>malloc</CODE>.  The prototype for
this function is in <TT>`stdlib.h'</TT>.
<A NAME="IDX218"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>malloc</B> <I>(size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX219"></A>
This function returns a pointer to a newly allocated block <VAR>size</VAR>
bytes long, or a null pointer if the block could not be allocated.
</DL>

</P>
<P>
The contents of the block are undefined; you must initialize it yourself
(or use <CODE>calloc</CODE> instead; see section <A HREF="libc_27.html#SEC27">Allocating Cleared Space</A>).
Normally you would cast the value as a pointer to the kind of object
that you want to store in the block.  Here we show an example of doing
so, and of initializing the space with zeros using the library function
<CODE>memset</CODE> (see section <A HREF="libc_67.html#SEC67">Copying and Concatenation</A>):

</P>

<PRE>
struct foo *ptr;
...
ptr = (struct foo *) malloc (sizeof (struct foo));
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
</PRE>

<P>
You can store the result of <CODE>malloc</CODE> into any pointer variable
without a cast, because ISO C automatically converts the type
<CODE>void *</CODE> to another type of pointer when necessary.  But the cast
is necessary in contexts other than assignment operators or if you might
want your code to run in traditional C.

</P>
<P>
Remember that when allocating space for a string, the argument to
<CODE>malloc</CODE> must be one plus the length of the string.  This is
because a string is terminated with a null character that doesn't count
in the "length" of the string but does need space.  For example:

</P>

<PRE>
char *ptr;
...
ptr = (char *) malloc (length + 1);
</PRE>

<P>
See section <A HREF="libc_64.html#SEC64">Representation of Strings</A>, for more information about this.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_22.html">previous</A>, <A HREF="libc_24.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
