<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Longjmp in Handler</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_440.html">previous</A>, <A HREF="libc_442.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC448" HREF="libc_toc.html#TOC448">Nonlocal Control Transfer in Handlers</A></H3>
<P>
<A NAME="IDX2544"></A>

</P>
<P>
You can do a nonlocal transfer of control out of a signal handler using
the <CODE>setjmp</CODE> and <CODE>longjmp</CODE> facilities (see section <A HREF="libc_413.html#SEC420">Non-Local Exits</A>).

</P>
<P>
When the handler does a nonlocal control transfer, the part of the
program that was running will not continue.  If this part of the program
was in the middle of updating an important data structure, the data
structure will remain inconsistent.  Since the program does not
terminate, the inconsistency is likely to be noticed later on.

</P>
<P>
There are two ways to avoid this problem.  One is to block the signal
for the parts of the program that update important data structures.
Blocking the signal delays its delivery until it is unblocked, once the
critical updating is finished.  See section <A HREF="libc_455.html#SEC462">Blocking Signals</A>.

</P>
<P>
The other way to re-initialize the crucial data structures in the signal
handler, or make their values consistent.

</P>
<P>
Here is a rather schematic example showing the reinitialization of one
global variable.

</P>

<PRE>
#include &#60;signal.h&#62;
#include &#60;setjmp.h&#62;

jmp_buf return_to_top_level;

volatile sig_atomic_t waiting_for_input;

void
handle_sigint (int signum)
{
  /* We may have been waiting for input when the signal arrived,
     but we are no longer waiting once we transfer control. */
  waiting_for_input = 0;
  longjmp (return_to_top_level, 1);
}

int
main (void)
{
  ...
  signal (SIGINT, sigint_handler);
  ...
  while (1) {
    prepare_for_command ();
    if (setjmp (return_to_top_level) == 0)
      read_and_execute_command ();
  }
}

/* Imagine this is a subroutine used by various commands. */
char *
read_data ()
{
  if (input_from_terminal) {
    waiting_for_input = 1;
    ...
    waiting_for_input = 0;
  } else {
    ...
  }
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_440.html">previous</A>, <A HREF="libc_442.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
