<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Representation of Strings</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_63.html">previous</A>, <A HREF="libc_65.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC64" HREF="libc_toc.html#TOC64">Representation of Strings</A></H2>
<P>
<A NAME="IDX401"></A>

</P>
<P>
This section is a quick summary of string concepts for beginning C
programmers.  It describes how character strings are represented in C
and some common pitfalls.  If you are already familiar with this
material, you can skip this section.

</P>
<P>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
A <STRONG>string</STRONG> is an array of <CODE>char</CODE> objects.  But string-valued
variables are usually declared to be pointers of type <CODE>char *</CODE>.
Such variables do not include space for the text of a string; that has
to be stored somewhere else--in an array variable, a string constant,
or dynamically allocated memory (see section <A HREF="libc_19.html#SEC19">Memory Allocation</A>).  It's up to
you to store the address of the chosen memory space into the pointer
variable.  Alternatively you can store a <STRONG>null pointer</STRONG> in the
pointer variable.  The null pointer does not point anywhere, so
attempting to reference the string it points to gets an error.

</P>
<P>
By convention, a <STRONG>null character</STRONG>, <CODE>'\0'</CODE>, marks the end of a
string.  For example, in testing to see whether the <CODE>char *</CODE>
variable <VAR>p</VAR> points to a null character marking the end of a string,
you can write <CODE>!*<VAR>p</VAR></CODE> or <CODE>*<VAR>p</VAR> == '\0'</CODE>.

</P>
<P>
A null character is quite different conceptually from a null pointer,
although both are represented by the integer <CODE>0</CODE>.

</P>
<P>
<A NAME="IDX404"></A>
<STRONG>String literals</STRONG> appear in C program source as strings of
characters between double-quote characters (<SAMP>`"'</SAMP>).  In ISO C,
string literals can also be formed by <STRONG>string concatenation</STRONG>:
<CODE>"a" "b"</CODE> is the same as <CODE>"ab"</CODE>.  Modification of string
literals is not allowed by the GNU C compiler, because literals
are placed in read-only storage.

</P>
<P>
Character arrays that are declared <CODE>const</CODE> cannot be modified
either.  It's generally good style to declare non-modifiable string
pointers to be of type <CODE>const char *</CODE>, since this often allows the
C compiler to detect accidental modifications as well as providing some
amount of documentation about what your program intends to do with the
string.

</P>
<P>
The amount of memory allocated for the character array may extend past
the null character that normally marks the end of the string.  In this
document, the term <STRONG>allocated size</STRONG> is always used to refer to the
total amount of memory allocated for the string, while the term
<STRONG>length</STRONG> refers to the number of characters up to (but not
including) the terminating null character.
<A NAME="IDX405"></A>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>
<A NAME="IDX408"></A>
<A NAME="IDX409"></A>

</P>
<P>
A notorious source of program bugs is trying to put more characters in a
string than fit in its allocated size.  When writing code that extends
strings or moves characters into a pre-allocated array, you should be
very careful to keep track of the length of the text and make explicit
checks for overflowing the array.  Many of the library functions
<EM>do not</EM> do this for you!  Remember also that you need to allocate
an extra byte to hold the null character that marks the end of the
string.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_63.html">previous</A>, <A HREF="libc_65.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
