<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Basic Signal Handling</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_431.html">previous</A>, <A HREF="libc_433.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC439" HREF="libc_toc.html#TOC439">Basic Signal Handling</A></H3>
<P>
<A NAME="IDX2520"></A>

</P>
<P>
The <CODE>signal</CODE> function provides a simple interface for establishing
an action for a particular signal.  The function and associated macros
are declared in the header file <TT>`signal.h'</TT>.
<A NAME="IDX2521"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>sighandler_t</B>
<DD><A NAME="IDX2522"></A>
This is the type of signal handler functions.  Signal handlers take one
integer argument specifying the signal number, and have return type
<CODE>void</CODE>.  So, you should define handler functions like this:

</P>

<PRE>
void <VAR>handler</VAR> (int <CODE>signum</CODE>) { ... }
</PRE>

<P>
The name <CODE>sighandler_t</CODE> for this data type is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> sighandler_t <B>signal</B> <I>(int <VAR>signum</VAR>, sighandler_t <VAR>action</VAR>)</I>
<DD><A NAME="IDX2523"></A>
The <CODE>signal</CODE> function establishes <VAR>action</VAR> as the action for
the signal <VAR>signum</VAR>.

</P>
<P>
The first argument, <VAR>signum</VAR>, identifies the signal whose behavior
you want to control, and should be a signal number.  The proper way to
specify a signal number is with one of the symbolic signal names
(see section <A HREF="libc_422.html#SEC429">Standard Signals</A>)---don't use an explicit number, because
the numerical code for a given kind of signal may vary from operating
system to operating system.

</P>
<P>
The second argument, <VAR>action</VAR>, specifies the action to use for the
signal <VAR>signum</VAR>.  This can be one of the following:

</P>
<DL COMPACT>

<DT><CODE>SIG_DFL</CODE>
<DD>
<A NAME="IDX2524"></A>
<A NAME="IDX2525"></A>
<CODE>SIG_DFL</CODE> specifies the default action for the particular signal.
The default actions for various kinds of signals are stated in
section <A HREF="libc_422.html#SEC429">Standard Signals</A>.

<DT><CODE>SIG_IGN</CODE>
<DD>
<A NAME="IDX2526"></A>
<A NAME="IDX2527"></A>
<CODE>SIG_IGN</CODE> specifies that the signal should be ignored.

Your program generally should not ignore signals that represent serious
events or that are normally used to request termination.  You cannot
ignore the <CODE>SIGKILL</CODE> or <CODE>SIGSTOP</CODE> signals at all.  You can
ignore program error signals like <CODE>SIGSEGV</CODE>, but ignoring the error
won't enable the program to continue executing meaningfully.  Ignoring
user requests such as <CODE>SIGINT</CODE>, <CODE>SIGQUIT</CODE>, and <CODE>SIGTSTP</CODE>
is unfriendly.

When you do not wish signals to be delivered during a certain part of
the program, the thing to do is to block them, not ignore them.
See section <A HREF="libc_455.html#SEC462">Blocking Signals</A>.

<DT><CODE><VAR>handler</VAR></CODE>
<DD>
Supply the address of a handler function in your program, to specify
running this handler as the way to deliver the signal.

For more information about defining signal handler functions,
see section <A HREF="libc_438.html#SEC445">Defining Signal Handlers</A>.
</DL>

<P>
If you set the action for a signal to <CODE>SIG_IGN</CODE>, or if you set it
to <CODE>SIG_DFL</CODE> and the default action is to ignore that signal, then
any pending signals of that type are discarded (even if they are
blocked).  Discarding the pending signals means that they will never be
delivered, not even if you subsequently specify another action and
unblock this kind of signal.

</P>
<P>
The <CODE>signal</CODE> function returns the action that was previously in
effect for the specified <VAR>signum</VAR>.  You can save this value and
restore it later by calling <CODE>signal</CODE> again.

</P>
<P>
If <CODE>signal</CODE> can't honor the request, it returns <CODE>SIG_ERR</CODE>
instead.  The following <CODE>errno</CODE> error conditions are defined for
this function:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
You specified an invalid <VAR>signum</VAR>; or you tried to ignore or provide
a handler for <CODE>SIGKILL</CODE> or <CODE>SIGSTOP</CODE>.
</DL>
</DL>

<P>
<STRONG>Compatibility Note:</STRONG> A problem when working with the
<CODE>signal</CODE> function is that it has a different semantic on BSD and
SVID system.  The difference is that on SVID systems the signal handler
is deinstalled after an signal was delivered.  On BSD systems the
handler must be explicitly deinstalled.  In the GNU C Library we use the
BSD version by default.  To use the SVID version you can either use the
function <CODE>sysv_signal</CODE> (see below) or use the <CODE>_XOPEN_SOURCE</CODE>
feature select macro (see section <A HREF="libc_13.html#SEC13">Feature Test Macros</A>).  Generally it should
be avoided to use this functions due to the compatibility problems.  It
is better to use <CODE>sigaction</CODE> if it is available since the results
are much more reliable.

</P>
<P>
Here is a simple example of setting up a handler to delete temporary
files when certain fatal signals happen:

</P>

<PRE>
#include &#60;signal.h&#62;

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&#62;next)
    unlink (p-&#62;name);
}

int
main (void)
{
  ...
  if (signal (SIGINT, termination_handler) == SIG_IGN)
    signal (SIGINT, SIG_IGN);
  if (signal (SIGHUP, termination_handler) == SIG_IGN)
    signal (SIGHUP, SIG_IGN);
  if (signal (SIGTERM, termination_handler) == SIG_IGN)
    signal (SIGTERM, SIG_IGN);
  ...
}
</PRE>

<P>
Note how if a given signal was previously set to be ignored, this code
avoids altering that setting.  This is because non-job-control shells
often ignore certain signals when starting children, and it is important
for the children to respect this.

</P>
<P>
We do not handle <CODE>SIGQUIT</CODE> or the program error signals in this
example because these are designed to provide information for debugging
(a core dump), and the temporary files may give useful information.

</P>
<P>
<DL>
<DT><U>Function:</U> sighandler_t <B>sysv_signal</B> <I>(int <VAR>signum</VAR>, sighandler_t <VAR>action</VAR>)</I>
<DD><A NAME="IDX2528"></A>
The <CODE>sysv_signal</CODE> implements the behaviour of the standard
<CODE>signal</CODE> function as found on SVID systems.  The difference to BSD
systems is that the handler is deinstalled after a delivery of a signal.

</P>
<P>
<STRONG>Compatibility Note:</STRONG> As said above for <CODE>signal</CODE>, this
function should be avoided when possible.  <CODE>sigaction</CODE> is the
preferred method.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> sighandler_t <B>ssignal</B> <I>(int <VAR>signum</VAR>, sighandler_t <VAR>action</VAR>)</I>
<DD><A NAME="IDX2529"></A>
The <CODE>ssignal</CODE> function does the same thing as <CODE>signal</CODE>; it is
provided only for compatibility with SVID.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> sighandler_t <B>SIG_ERR</B>
<DD><A NAME="IDX2530"></A>
The value of this macro is used as the return value from <CODE>signal</CODE>
to indicate an error.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_431.html">previous</A>, <A HREF="libc_433.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
