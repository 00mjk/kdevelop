<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Formatting Numbers</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_105.html">previous</A>, <A HREF="libc_107.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC110" HREF="libc_toc.html#TOC110">A dedicated function to format numbers</A></H2>

<P>
We have seen that the structure returned by <CODE>localeconv</CODE> as well as
the values given to <CODE>nl_langinfo</CODE> allow to retrieve the various
pieces of locale specific information to format numbers and monetary
amounts.  But we have also seen that the rules underlying this
information are quite complex.

</P>
<P>
Therefore the X/Open standards introduce a function which uses this
information from the locale and so makes it is for the user to format
numbers according to these rules.

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>strfmon</B> <I>(char *<VAR>s</VAR>, size_t <VAR>maxsize</VAR>, const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX679"></A>
The <CODE>strfmon</CODE> function is similar to the <CODE>strftime</CODE> function
in that it takes a description of a buffer (with size), a format string
and values to write into a buffer a textual representation of the values
according to the format string.  As for <CODE>strftime</CODE> the function
also returns the number of bytes written into the buffer.

</P>
<P>
There are two difference: <CODE>strfmon</CODE> can take more than one argument
and of course the format specification is different.  The format string
consists as for <CODE>strftime</CODE> of normal text which is simply printed
and format specifiers, which here are also introduced using <SAMP>`%'</SAMP>.
Following the <SAMP>`%'</SAMP> the function allows similar to <CODE>printf</CODE> a
sequence of flags and other specifications before the format character:

</P>

<UL>
<LI>

Immediately following the <SAMP>`%'</SAMP> there can be one or more of the
following flags:
<DL COMPACT>

<DT><SAMP>`=<VAR>f</VAR>'</SAMP>
<DD>
The single byte character <VAR>f</VAR> is used for this field as the numeric
fill character.  By default this character is a space character.
Filling with this character is only performed if a left precision
is specified.  It is not just to fill to the given field width.
<DT><SAMP>`^'</SAMP>
<DD>
The number is printed without grouping the digits using the rules of the
current locale.  By default grouping is enabled.
<DT><SAMP>`+'</SAMP>, <SAMP>`('</SAMP>
<DD>
At most one of these flags must be used.  They select which format to
represent the sign of currency amount is used.  By default and if
<SAMP>`+'</SAMP> is used the locale equivalent to @math{+}/@math{-} is used.  If
<SAMP>`('</SAMP> is used negative amounts are enclosed in parentheses.  The
exact format is determined by the values of the <CODE>LC_MONETARY</CODE>
category of the locale selected at program runtime.
<DT><SAMP>`!'</SAMP>
<DD>
The output will not contain the currency symbol.
<DT><SAMP>`-'</SAMP>
<DD>
The output will be formatted right-justified instead left-justified if
the output does not fill the entire field width.
</DL>
</UL>

<P>
The next part of a specification is an, again optional, specification of
the field width.  The width is given by digits following the flags.  If
no width is specified it is assumed to be @math{0}.  The width value is
used after it is determined how much space the printed result needs.  If
it does not require fewer characters than specified by the width value
nothing happens.  Otherwise the output is extended to use as many
characters as the width says by filling with spaces.  At which side
depends on whether the <SAMP>`-'</SAMP> flag was given or not.  If it was given,
the spaces are added at the right, making the output right-justified and
vice versa.

</P>
<P>
So far the format looks familiar as it is similar to <CODE>printf</CODE> or
<CODE>strftime</CODE> formats.  But the next two fields introduce something
new.  The first one, if available, is introduced by a <SAMP>`#'</SAMP> character
which is followed by a decimal digit string.  The value of the digit
string specifies the width the formatted digits left to the radix
character.  This does <EM>not</EM> include the grouping character needed
if the <SAMP>`^'</SAMP> flag is not given.  If the space needed to print the
number does not fill the whole width the field is padded at the left
side with the fill character which can be selected using the <SAMP>`='</SAMP>
flag and which by default is a space.  For example, if the field width
is selected as 6 and the number is @math{123}, the fill character is
<SAMP>`*'</SAMP> the result will be <SAMP>`***123'</SAMP>.

</P>
<P>
The next field is introduced by a <SAMP>`.'</SAMP> (period) and consists of
another decimal digit string.  Its value describes the number of
characters printed after the radix character.  The default is
selected from the current locale (<CODE>frac_digits</CODE>,
<CODE>int_frac_digits</CODE>, see see section <A HREF="libc_102.html#SEC106">Generic Numeric Formatting Parameters</A>).  If the exact
representation needs more digits than those specified by the field width
the displayed value is rounded.  In case the number of fractional digits
is selected to be zero, no radix character is printed.

</P>
<P>
As a GNU extension the <CODE>strfmon</CODE> implementation in the GNU libc
allows as the next field an optional <SAMP>`L'</SAMP> as a format modifier.  If
this modifier is given the argument is expected to be a <CODE>long
double</CODE> instead of a <CODE>double</CODE> value.

</P>
<P>
Finally as the last component of the format there must come a format
specifying.  There are three specifiers defined:

</P>
<DL COMPACT>

<DT><SAMP>`i'</SAMP>
<DD>
The argument is formatted according to the locale's rules to format an
international currency value.
<DT><SAMP>`n'</SAMP>
<DD>
The argument is formatted according to the locale's rules to format an
national currency value.
<DT><SAMP>`%'</SAMP>
<DD>
Creates a <SAMP>`%'</SAMP> in the output.  There must be no flag, width
specifier or modifier given, only <SAMP>`%%'</SAMP> is allowed.
</DL>

<P>
As it is done for <CODE>printf</CODE>, the function reads the format string
from left to right and uses the values passed to the function following
the format string.  The values are expected to be either of type
<CODE>double</CODE> or <CODE>long double</CODE>, depending on the presence of the
modifier <SAMP>`L'</SAMP>.  The result is stored in the buffer pointed to by
<VAR>s</VAR>.  At most <VAR>maxsize</VAR> characters are stored.

</P>
<P>
The return value of the function is the number of characters stored in
<VAR>s</VAR>, including the terminating NUL byte.  If the number of
characters stored would exceed <VAR>maxsize</VAR> the function returns
@math{-1} and the content of the buffer <VAR>s</VAR> is unspecified.  In this
case <CODE>errno</CODE> is set to <CODE>E2BIG</CODE>.
</DL>

</P>
<P>
A few examples should make it clear how to use this function.  It is
assumed that all the following pieces of code are executed in a program
which uses the locale valid for the USA (<CODE>en_US</CODE>).  The simplest
form of the format is this:

</P>

<PRE>
strfmon (buf, 100, "@%n@%n@%n@", 123.45, -567.89, 12345.678);
</PRE>

<P>
The output produced is

<PRE>
"@$123.45@-$567.89@$12,345.68@"
</PRE>

<P>
We can notice several things here.  First, the width for all formats is
different.  We have not specified a width in the format string and so
this is no wonder.  Second, the third number is printed using thousands
separators.  The thousands separator for the <CODE>en_US</CODE> locale is a
comma.  Beside this the number is rounded.  The @math{.678} are rounded
to @math{.68} since the format does not specify a precision and the
default value in the locale is @math{2}.  A last thing is that the
national currency symbol is printed since <SAMP>`%n'</SAMP> was used, not
<SAMP>`i'</SAMP>.  The next example shows how we can align the output.

</P>

<PRE>
strfmon (buf, 100, "@%=*11n@%=*11n@%=*11n@", 123.45, -567.89, 12345.678);
</PRE>

<P>
The output this time is:

</P>

<PRE>
"@    $123.45@   -$567.89@ $12,345.68@"
</PRE>

<P>
Two things stand out.  First, all fields have the same width (eleven
characters) since this is the width given in the format and since no
number required more characters to be printed.  The second important
point is that the fill character is not used.  This is correct since the
white space was not used to fill the space specified by the right
precision, but instead it is used to fill to the given width.  The
difference becomes obvious if we now add a right width specification.

</P>

<PRE>
strfmon (buf, 100, "@%=*11#5n@%=*11#5n@%=*11#5n@",
         123.45, -567.89, 12345.678);
</PRE>

<P>
The output is

</P>

<PRE>
"@ $***123.45@-$***567.89@ $12,456.68@"
</PRE>

<P>
Here we can see that all the currency symbols are now aligned and the
space between the currency sign and the number is filled with the
selected fill character.  Please note that although the right precision
is selected to be @math{5} and @math{123.45} has three characters right
of the radix character, the space is filled with three asterisks.  This
is correct since as explained above, the right precision does not count
the characters used for the thousands separators in.  One last example
should explain the remaining functionality.

</P>

<PRE>
strfmon (buf, 100, "@%=0(16#5.3i@%=0(16#5.3i@%=0(16#5.3i@",
         123.45, -567.89, 12345.678);
</PRE>

<P>
This rather complex format string produces the following output:

</P>

<PRE>
"@ USD 000123,450 @(USD 000567.890)@ USD 12,345.678 @"
</PRE>

<P>
The most noticeable change is the use of the alternative style to
represent negative numbers.  In financial circles it is often done using
parentheses and this is what the <SAMP>`('</SAMP> flag selected.  The fill character
is now <SAMP>`0'</SAMP>.  Please note that this <SAMP>`0'</SAMP> character is not
regarded as a numeric zero and therefore the first and second number are
not printed using a thousands separator.  Since we use in the format the
specifier <SAMP>`i'</SAMP> instead of <SAMP>`n'</SAMP> now the international form of the
currency symbol is used.  This is a four letter string, in this case
<CODE>"USD "</CODE>.  The last point is that since the left precision is
selected to be three the first and second number are printed with an
extra zero at the end and the third number is printed unrounded.
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_105.html">previous</A>, <A HREF="libc_107.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
