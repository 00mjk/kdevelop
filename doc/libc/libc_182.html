<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Defining the Output Handler</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_181.html">previous</A>, <A HREF="libc_183.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC189" HREF="libc_toc.html#TOC189">Defining the Output Handler</A></H3>

<P>
Now let's look at how to define the handler and arginfo functions
which are passed as arguments to <CODE>register_printf_function</CODE>.

</P>
<P>
<STRONG>Compatibility Note:</STRONG> The interface changed in the GNU libc
version 2.0.  Previously the third argument was of type
<CODE>va_list *</CODE>.

</P>
<P>
You should define your handler functions with a prototype like:

</P>

<PRE>
int <VAR>function</VAR> (FILE *stream, const struct printf_info *info,
                    const void *const *args)
</PRE>

<P>
The <VAR>stream</VAR> argument passed to the handler function is the stream to
which it should write output.

</P>
<P>
The <VAR>info</VAR> argument is a pointer to a structure that contains
information about the various options that were included with the
conversion in the template string.  You should not modify this structure
inside your handler function.  See section <A HREF="libc_181.html#SEC188">Conversion Specifier Options</A>, for
a description of this data structure.

</P>

<P>
The <VAR>args</VAR> is a vector of pointers to the arguments data.
The number of arguments were determined by calling the argument
information function provided by the user.

</P>
<P>
Your handler function should return a value just like <CODE>printf</CODE>
does: it should return the number of characters it has written, or a
negative value to indicate an error.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>printf_function</B>
<DD><A NAME="IDX864"></A>
This is the data type that a handler function should have.
</DL>

</P>
<P>
If you are going to use <CODE>parse_printf_format</CODE> in your
application, you must also define a function to pass as the
<VAR>arginfo-function</VAR> argument for each new conversion you install with
<CODE>register_printf_function</CODE>.

</P>
<P>
You have to define these functions with a prototype like:

</P>

<PRE>
int <VAR>function</VAR> (const struct printf_info *info,
                    size_t n, int *argtypes)
</PRE>

<P>
The return value from the function should be the number of arguments the
conversion expects.  The function should also fill in no more than
<VAR>n</VAR> elements of the <VAR>argtypes</VAR> array with information about the
types of each of these arguments.  This information is encoded using the
various <SAMP>`PA_'</SAMP> macros.  (You will notice that this is the same
calling convention <CODE>parse_printf_format</CODE> itself uses.)

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>printf_arginfo_function</B>
<DD><A NAME="IDX865"></A>
This type is used to describe functions that return information about
the number and type of arguments used by a conversion specifier.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_181.html">previous</A>, <A HREF="libc_183.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
