<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Control Modes</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_340.html">previous</A>, <A HREF="libc_342.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC348" HREF="libc_toc.html#TOC348">Control Modes</A></H3>

<P>
This section describes the terminal flags and fields that control
parameters usually associated with asynchronous serial data
transmission.  These flags may not make sense for other kinds of
terminal ports (such as a network connection pseudo-terminal).  All of
these are contained in the <CODE>c_cflag</CODE> member of the <CODE>struct
termios</CODE> structure.

</P>
<P>
The <CODE>c_cflag</CODE> member itself is an integer, and you change the flags
and fields using the operators <CODE>&#38;</CODE>, <CODE>|</CODE>, and <CODE>^</CODE>.  Don't
try to specify the entire value for <CODE>c_cflag</CODE>---instead, change
only specific flags and leave the rest untouched (see section <A HREF="libc_338.html#SEC345">Setting Terminal Modes Properly</A>).

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CLOCAL</B>
<DD><A NAME="IDX1642"></A>
If this bit is set, it indicates that the terminal is connected
"locally" and that the modem status lines (such as carrier detect)
should be ignored.
<A NAME="IDX1643"></A>
<A NAME="IDX1644"></A>

</P>
<P>
On many systems if this bit is not set and you call <CODE>open</CODE> without
the <CODE>O_NONBLOCK</CODE> flag set, <CODE>open</CODE> blocks until a modem
connection is established.

</P>
<P>
If this bit is not set and a modem disconnect is detected, a
<CODE>SIGHUP</CODE> signal is sent to the controlling process group for the
terminal (if it has one).  Normally, this causes the process to exit;
see section <A HREF="libc_417.html#SEC424">Signal Handling</A>.  Reading from the terminal after a disconnect
causes an end-of-file condition, and writing causes an <CODE>EIO</CODE> error
to be returned.  The terminal device must be closed and reopened to
clear the condition.
<A NAME="IDX1645"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>HUPCL</B>
<DD><A NAME="IDX1646"></A>
If this bit is set, a modem disconnect is generated when all processes
that have the terminal device open have either closed the file or exited.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CREAD</B>
<DD><A NAME="IDX1647"></A>
If this bit is set, input can be read from the terminal.  Otherwise,
input is discarded when it arrives.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CSTOPB</B>
<DD><A NAME="IDX1648"></A>
If this bit is set, two stop bits are used.  Otherwise, only one stop bit
is used.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>PARENB</B>
<DD><A NAME="IDX1649"></A>
If this bit is set, generation and detection of a parity bit are enabled.
See section <A HREF="libc_339.html#SEC346">Input Modes</A>, for information on how input parity errors are handled.

</P>
<P>
If this bit is not set, no parity bit is added to output characters, and
input characters are not checked for correct parity.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>PARODD</B>
<DD><A NAME="IDX1650"></A>
This bit is only useful if <CODE>PARENB</CODE> is set.  If <CODE>PARODD</CODE> is set,
odd parity is used, otherwise even parity is used.
</DL>

</P>
<P>
The control mode flags also includes a field for the number of bits per
character.  You can use the <CODE>CSIZE</CODE> macro as a mask to extract the
value, like this: <CODE>settings.c_cflag &#38; CSIZE</CODE>.

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CSIZE</B>
<DD><A NAME="IDX1651"></A>
This is a mask for the number of bits per character.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CS5</B>
<DD><A NAME="IDX1652"></A>
This specifies five bits per byte.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CS6</B>
<DD><A NAME="IDX1653"></A>
This specifies six bits per byte.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CS7</B>
<DD><A NAME="IDX1654"></A>
This specifies seven bits per byte.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CS8</B>
<DD><A NAME="IDX1655"></A>
This specifies eight bits per byte.
</DL>

</P>
<P>
The following four bits are BSD extensions; this exist only on BSD
systems and the GNU system.

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CCTS_OFLOW</B>
<DD><A NAME="IDX1656"></A>
If this bit is set, enable flow control of output based on the CTS wire
(RS232 protocol).
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CRTS_IFLOW</B>
<DD><A NAME="IDX1657"></A>
If this bit is set, enable flow control of input based on the RTS wire
(RS232 protocol).
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>MDMBUF</B>
<DD><A NAME="IDX1658"></A>
If this bit is set, enable carrier-based flow control of output.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> tcflag_t <B>CIGNORE</B>
<DD><A NAME="IDX1659"></A>
If this bit is set, it says to ignore the control modes and line speed
values entirely.  This is only meaningful in a call to <CODE>tcsetattr</CODE>.

</P>
<P>
The <CODE>c_cflag</CODE> member and the line speed values returned by
<CODE>cfgetispeed</CODE> and <CODE>cfgetospeed</CODE> will be unaffected by the
call.  <CODE>CIGNORE</CODE> is useful if you want to set all the software
modes in the other members, but leave the hardware details in
<CODE>c_cflag</CODE> unchanged.  (This is how the <CODE>TCSASOFT</CODE> flag to
<CODE>tcsettattr</CODE> works.)

</P>
<P>
This bit is never set in the structure filled in by <CODE>tcgetattr</CODE>.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_340.html">previous</A>, <A HREF="libc_342.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
