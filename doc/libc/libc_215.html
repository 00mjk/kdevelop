<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Truncating Files</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_214.html">previous</A>, <A HREF="libc_216.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC222" HREF="libc_toc.html#TOC222">Change the size of a file</A></H2>

<P>
In some situations it is useful to explicitly determine the size of a
file.  Since the 4.2BSD days there is a function to truncate a file to
at most a given number of bytes and POSIX defines one additional
function.  The prototypes for these functions are in <TT>`unistd.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>truncate</B> <I>(const char *<VAR>name</VAR>, off_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX987"></A>
The <CODE>truncation</CODE> function truncates the file named by <VAR>name</VAR> to
at most <VAR>length</VAR> bytes.  I.e., if the file was larger before the
extra bytes are stripped of.  If the file was small or equal to
<VAR>length</VAR> in size before nothing is done.  The file must be writable
by the user to perform this operation.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> the
<CODE>truncate</CODE> function is in fact <CODE>truncate64</CODE> and the type
<CODE>off_t</CODE> has 64 bits which makes it possible to handle files up to
@math{2^63} bytes in length.

</P>
<P>
The return value is zero is everything went ok.  Otherwise the return
value is @math{-1} and the global variable <VAR>errno</VAR> is set to:
<DL COMPACT>

<DT><CODE>EACCES</CODE>
<DD>
The file is not accessible to the user.
<DT><CODE>EINVAL</CODE>
<DD>
The <VAR>length</VAR> value is illegal.
<DT><CODE>EISDIR</CODE>
<DD>
The object named by <VAR>name</VAR> is a directory.
<DT><CODE>ENOENT</CODE>
<DD>
The file named by <VAR>name</VAR> does not exist.
<DT><CODE>ENOTDIR</CODE>
<DD>
One part of the <VAR>name</VAR> is not a directory.
</DL>

<P>
This function was introduced in 4.2BSD but also was available in later
System V systems.  It is not added to POSIX since the authors felt
it is only of marginally additional utility.  See below.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>truncate64</B> <I>(const char *<VAR>name</VAR>, off64_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX988"></A>
This function is similar to the <CODE>truncate</CODE> function.  The
difference is that the <VAR>length</VAR> argument is 64 bits wide even on 32
bits machines which allows to handle file with a size up to @math{2^63}
bytes.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is actually available under the name
<CODE>truncate</CODE> and so transparently replaces the 32 bits interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>ftruncate</B> <I>(int <VAR>fd</VAR>, off_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX989"></A>
The <CODE>ftruncate</CODE> function is similar to the <CODE>truncate</CODE>
function.  The main difference is that it takes a descriptor for an
opened file instead of a file name to identify the object.  The file
must be opened for writing to successfully carry out the operation.

</P>
<P>
The POSIX standard leaves it implementation defined what happens if the
specified new <VAR>length</VAR> of the file is bigger than the original size.
The <CODE>ftruncate</CODE> function might simply leave the file alone and do
nothing or it can increase the size to the desired size.  In this later
case the extended area should be zero-filled.  So using <CODE>ftruncate</CODE>
is no reliable way to increase the file size but if it is possible it is
probably the fastest way.  The function also operates on POSIX shared
memory segments if these are implemented by the system.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> the
<CODE>ftruncate</CODE> function is in fact <CODE>ftruncate64</CODE> and the type
<CODE>off_t</CODE> has 64 bits which makes it possible to handle files up to
@math{2^63} bytes in length.

</P>
<P>
On success the function returns zero.  Otherwise it returns @math{-1}
and set <VAR>errno</VAR> to one of these values:
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
<VAR>fd</VAR> is no valid file descriptor or is not opened for writing.
<DT><CODE>EINVAL</CODE>
<DD>
The object referred to by <VAR>fd</VAR> does not permit this operation.
<DT><CODE>EROFS</CODE>
<DD>
The file is on a read-only file system.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>ftruncate64</B> <I>(int <VAR>id</VAR>, off64_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX990"></A>
This function is similar to the <CODE>ftruncate</CODE> function.  The
difference is that the <VAR>length</VAR> argument is 64 bits wide even on 32
bits machines which allows to handle file with a size up to @math{2^63}
bytes.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is actually available under the name
<CODE>ftruncate</CODE> and so transparently replaces the 32 bits interface.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_214.html">previous</A>, <A HREF="libc_216.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
