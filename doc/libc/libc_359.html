<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Exponents and Logarithms</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_358.html">previous</A>, <A HREF="libc_360.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC366" HREF="libc_toc.html#TOC366">Exponentiation and Logarithms</A></H2>
<P>
<A NAME="IDX1849"></A>
<A NAME="IDX1850"></A>
<A NAME="IDX1851"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>exp</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1852"></A>
<DT><U>Function:</U> float <B>expf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1853"></A>
<DT><U>Function:</U> long double <B>expl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1854"></A>
These functions compute <CODE>e</CODE> (the base of natural logarithms) raised
to the power <VAR>x</VAR>.

</P>
<P>
If the magnitude of the result is too large to be representable,
<CODE>exp</CODE> signals overflow.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>exp2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1855"></A>
<DT><U>Function:</U> float <B>exp2f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1856"></A>
<DT><U>Function:</U> long double <B>exp2l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1857"></A>
These functions compute <CODE>2</CODE> raised to the power <VAR>x</VAR>.
Mathematically, <CODE>exp2 (x)</CODE> is the same as <CODE>exp (x * log (2))</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>exp10</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1858"></A>
<DT><U>Function:</U> float <B>exp10f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1859"></A>
<DT><U>Function:</U> long double <B>exp10l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1860"></A>
<DT><U>Function:</U> double <B>pow10</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1861"></A>
<DT><U>Function:</U> float <B>pow10f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1862"></A>
<DT><U>Function:</U> long double <B>pow10l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1863"></A>
These functions compute <CODE>10</CODE> raised to the power <VAR>x</VAR>.
Mathematically, <CODE>exp10 (x)</CODE> is the same as <CODE>exp (x * log (10))</CODE>.

</P>
<P>
These functions are GNU extensions.  The name <CODE>exp10</CODE> is
preferred, since it is analogous to <CODE>exp</CODE> and <CODE>exp2</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> double <B>log</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1864"></A>
<DT><U>Function:</U> float <B>logf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1865"></A>
<DT><U>Function:</U> long double <B>logl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1866"></A>
These functions compute the natural logarithm of <VAR>x</VAR>.  <CODE>exp (log
(<VAR>x</VAR>))</CODE> equals <VAR>x</VAR>, exactly in mathematics and approximately in
C.

</P>
<P>
If <VAR>x</VAR> is negative, <CODE>log</CODE> signals a domain error.  If <VAR>x</VAR>
is zero, it returns negative infinity; if <VAR>x</VAR> is too close to zero,
it may signal overflow.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>log10</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1867"></A>
<DT><U>Function:</U> float <B>log10f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1868"></A>
<DT><U>Function:</U> long double <B>log10l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1869"></A>
These functions return the base-10 logarithm of <VAR>x</VAR>.
<CODE>log10 (<VAR>x</VAR>)</CODE> equals <CODE>log (<VAR>x</VAR>) / log (10)</CODE>.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>log2</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1870"></A>
<DT><U>Function:</U> float <B>log2f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1871"></A>
<DT><U>Function:</U> long double <B>log2l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1872"></A>
These functions return the base-2 logarithm of <VAR>x</VAR>.
<CODE>log2 (<VAR>x</VAR>)</CODE> equals <CODE>log (<VAR>x</VAR>) / log (2)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>logb</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1873"></A>
<DT><U>Function:</U> float <B>logbf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1874"></A>
<DT><U>Function:</U> long double <B>logbl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1875"></A>
These functions extract the exponent of <VAR>x</VAR> and return it as a
floating-point value.  If <CODE>FLT_RADIX</CODE> is two, <CODE>logb</CODE> is equal
to <CODE>floor (log2 (x))</CODE>, except it's probably faster.

</P>
<P>
If <VAR>x</VAR> is denormalized, <CODE>logb</CODE> returns the exponent <VAR>x</VAR>
would have if it were normalized.  If <VAR>x</VAR> is infinity (positive or
negative), <CODE>logb</CODE> returns @math{@infinity{}}.  If <VAR>x</VAR> is zero,
<CODE>logb</CODE> returns @math{@infinity{}}.  It does not signal.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>ilogb</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1876"></A>
<DT><U>Function:</U> int <B>ilogbf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1877"></A>
<DT><U>Function:</U> int <B>ilogbl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1878"></A>
These functions are equivalent to the corresponding <CODE>logb</CODE>
functions except that they return signed integer values.
</DL>

</P>
<P>
Since integers cannot represent infinity and NaN, <CODE>ilogb</CODE> instead
returns an integer that can't be the exponent of a normal floating-point
number.  <TT>`math.h'</TT> defines constants so you can check for this.

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>FP_ILOGB0</B>
<DD><A NAME="IDX1879"></A>
<CODE>ilogb</CODE> returns this value if its argument is <CODE>0</CODE>.  The
numeric value is either <CODE>INT_MIN</CODE> or <CODE>-INT_MAX</CODE>.

</P>
<P>
This macro is defined in ISO C 9X.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>FP_ILOGBNAN</B>
<DD><A NAME="IDX1880"></A>
<CODE>ilogb</CODE> returns this value if its argument is <CODE>NaN</CODE>.  The
numeric value is either <CODE>INT_MIN</CODE> or <CODE>INT_MAX</CODE>.

</P>
<P>
This macro is defined in ISO C 9X.
</DL>

</P>
<P>
These values are system specific.  They might even be the same.  The
proper way to test the result of <CODE>ilogb</CODE> is as follows:

</P>

<PRE>
i = ilogb (f);
if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
  {
    if (isnan (f))
      {
        /* Handle NaN.  */
      }
    else if (f  == 0.0)
      {
        /* Handle 0.0.  */
      }
    else
      {
        /* Some other value with large exponent,
           perhaps +Inf.  */
      }
  }
</PRE>

<P>
<DL>
<DT><U>Function:</U> double <B>pow</B> <I>(double <VAR>base</VAR>, double <VAR>power</VAR>)</I>
<DD><A NAME="IDX1881"></A>
<DT><U>Function:</U> float <B>powf</B> <I>(float <VAR>base</VAR>, float <VAR>power</VAR>)</I>
<DD><A NAME="IDX1882"></A>
<DT><U>Function:</U> long double <B>powl</B> <I>(long double <VAR>base</VAR>, long double <VAR>power</VAR>)</I>
<DD><A NAME="IDX1883"></A>
These are general exponentiation functions, returning <VAR>base</VAR> raised
to <VAR>power</VAR>.

</P>
<P>
Mathematically, <CODE>pow</CODE> would return a complex number when <VAR>base</VAR>
is negative and <VAR>power</VAR> is not an integral value.  <CODE>pow</CODE> can't
do that, so instead it signals a domain error. <CODE>pow</CODE> may also
underflow or overflow the destination type.
</DL>

</P>
<P>
<A NAME="IDX1884"></A>
<DL>
<DT><U>Function:</U> double <B>sqrt</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1885"></A>
<DT><U>Function:</U> float <B>sqrtf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1886"></A>
<DT><U>Function:</U> long double <B>sqrtl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1887"></A>
These functions return the nonnegative square root of <VAR>x</VAR>.

</P>
<P>
If <VAR>x</VAR> is negative, <CODE>sqrt</CODE> signals a domain error.
Mathematically, it should return a complex number.
</DL>

</P>
<P>
<A NAME="IDX1888"></A>
<DL>
<DT><U>Function:</U> double <B>cbrt</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1889"></A>
<DT><U>Function:</U> float <B>cbrtf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1890"></A>
<DT><U>Function:</U> long double <B>cbrtl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1891"></A>
These functions return the cube root of <VAR>x</VAR>.  They cannot
fail; every representable real value has a representable real cube root.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>hypot</B> <I>(double <VAR>x</VAR>, double <VAR>y</VAR>)</I>
<DD><A NAME="IDX1892"></A>
<DT><U>Function:</U> float <B>hypotf</B> <I>(float <VAR>x</VAR>, float <VAR>y</VAR>)</I>
<DD><A NAME="IDX1893"></A>
<DT><U>Function:</U> long double <B>hypotl</B> <I>(long double <VAR>x</VAR>, long double <VAR>y</VAR>)</I>
<DD><A NAME="IDX1894"></A>
These functions return <CODE>sqrt (<VAR>x</VAR>*<VAR>x</VAR> +
<VAR>y</VAR>*<VAR>y</VAR>)</CODE>.  This is the length of the hypotenuse of a right
triangle with sides of length <VAR>x</VAR> and <VAR>y</VAR>, or the distance
of the point (<VAR>x</VAR>, <VAR>y</VAR>) from the origin.  Using this function
instead of the direct formula is wise, since the error is
much smaller.  See also the function <CODE>cabs</CODE> in section <A HREF="libc_378.html#SEC385">Absolute Value</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>expm1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1895"></A>
<DT><U>Function:</U> float <B>expm1f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1896"></A>
<DT><U>Function:</U> long double <B>expm1l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1897"></A>
These functions return a value equivalent to <CODE>exp (<VAR>x</VAR>) - 1</CODE>.
They are computed in a way that is accurate even if <VAR>x</VAR> is
near zero--a case where <CODE>exp (<VAR>x</VAR>) - 1</CODE> would be inaccurate due
to subtraction of two numbers that are nearly equal.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>log1p</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1898"></A>
<DT><U>Function:</U> float <B>log1pf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1899"></A>
<DT><U>Function:</U> long double <B>log1pl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1900"></A>
These functions returns a value equivalent to <CODE>log (1 + <VAR>x</VAR>)</CODE>.
They are computed in a way that is accurate even if <VAR>x</VAR> is
near zero.
</DL>

</P>
<P>
<A NAME="IDX1901"></A>
<A NAME="IDX1902"></A>

</P>
<P>
ISO C 9X defines complex variants of some of the exponentiation and
logarithm functions.

</P>
<P>
<DL>
<DT><U>Function:</U> complex double <B>cexp</B> <I>(complex double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1903"></A>
<DT><U>Function:</U> complex float <B>cexpf</B> <I>(complex float <VAR>z</VAR>)</I>
<DD><A NAME="IDX1904"></A>
<DT><U>Function:</U> complex long double <B>cexpl</B> <I>(complex long double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1905"></A>
These functions return <CODE>e</CODE> (the base of natural
logarithms) raised to the power of <VAR>z</VAR>.
Mathematically this corresponds to the value

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> complex double <B>clog</B> <I>(complex double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1906"></A>
<DT><U>Function:</U> complex float <B>clogf</B> <I>(complex float <VAR>z</VAR>)</I>
<DD><A NAME="IDX1907"></A>
<DT><U>Function:</U> complex long double <B>clogl</B> <I>(complex long double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1908"></A>
These functions return the natural logarithm of <VAR>z</VAR>.
Mathematically this corresponds to the value

</P>

<P>
<CODE>clog</CODE> has a pole at 0, and will signal overflow if <VAR>z</VAR> equals
or is very close to 0.  It is well-defined for all other values of
<VAR>z</VAR>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> complex double <B>clog10</B> <I>(complex double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1909"></A>
<DT><U>Function:</U> complex float <B>clog10f</B> <I>(complex float <VAR>z</VAR>)</I>
<DD><A NAME="IDX1910"></A>
<DT><U>Function:</U> complex long double <B>clog10l</B> <I>(complex long double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1911"></A>
These functions return the base 10 logarithm of the complex value
<VAR>z</VAR>. Mathematically this corresponds to the value

</P>

<P>
These functions are GNU extensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> complex double <B>csqrt</B> <I>(complex double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1912"></A>
<DT><U>Function:</U> complex float <B>csqrtf</B> <I>(complex float <VAR>z</VAR>)</I>
<DD><A NAME="IDX1913"></A>
<DT><U>Function:</U> complex long double <B>csqrtl</B> <I>(complex long double <VAR>z</VAR>)</I>
<DD><A NAME="IDX1914"></A>
These functions return the complex square root of the argument <VAR>z</VAR>.  Unlike
the real-valued functions, they are defined for all values of <VAR>z</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> complex double <B>cpow</B> <I>(complex double <VAR>base</VAR>, complex double <VAR>power</VAR>)</I>
<DD><A NAME="IDX1915"></A>
<DT><U>Function:</U> complex float <B>cpowf</B> <I>(complex float <VAR>base</VAR>, complex float <VAR>power</VAR>)</I>
<DD><A NAME="IDX1916"></A>
<DT><U>Function:</U> complex long double <B>cpowl</B> <I>(complex long double <VAR>base</VAR>, complex long double <VAR>power</VAR>)</I>
<DD><A NAME="IDX1917"></A>
These functions return <VAR>base</VAR> raised to the power of
<VAR>power</VAR>.  This is equivalent to <CODE>cexp (y * clog (x))</CODE>
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_358.html">previous</A>, <A HREF="libc_360.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
