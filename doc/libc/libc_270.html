<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - File Size</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_269.html">previous</A>, <A HREF="libc_271.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC277" HREF="libc_toc.html#TOC277">File Size</A></H3>

<P>
Normally file sizes are maintained automatically.  A file begins with a
size of @math{0} and is automatically extended when data is written
past its end.  It is also possible to empty a file completely in an
<CODE>open</CODE> or <CODE>fopen</CODE> call.

</P>
<P>
However, sometimes it is necessary to <EM>reduce</EM> the size of a file.
This can be done with the <CODE>truncate</CODE> and <CODE>ftruncate</CODE> functions.
They were introduced in BSD Unix.  <CODE>ftruncate</CODE> was later added to
POSIX.1.

</P>
<P>
Some systems allow you to extend a file (creating holes) with these
functions.  This is useful when using memory-mapped I/O
(see section <A HREF="libc_224.html#SEC231">Memory-mapped I/O</A>), where files are not automatically extended.
However it is not portable but must be implemented if <CODE>mmap</CODE> allows
mapping of files (i.e., <CODE>_POSIX_MAPPED_FILES</CODE> is defined).

</P>
<P>
Using these functions on anything other than a regular file gives
<EM>undefined</EM> results.  On many systems, such a call will appear to
succeed, without actually accomplishing anything.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>truncate</B> <I>(const char *<VAR>filename</VAR>, off_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX1350"></A>

</P>
<P>
The <CODE>truncate</CODE> function changes the size of <VAR>filename</VAR> to
<VAR>length</VAR>.  If <VAR>length</VAR> is shorter than the previous length, data at
the end will be lost.

</P>
<P>
If <VAR>length</VAR> is longer, holes will be added to the end.  However, some
systems do not support this feature and will leave the file unchanged.

</P>
<P>
The return value is @math{0} for success, or @math{-1} for an error.  In
addition to the usual file name errors, the following errors may occur:

</P>
<DL COMPACT>

<DT><CODE>EACCES</CODE>
<DD>
The file is a directory or not writable.

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>length</VAR> is negative.

<DT><CODE>EFBIG</CODE>
<DD>
The operation would extend the file beyond the limits of the operating system.

<DT><CODE>EIO</CODE>
<DD>
A hardware I/O error occurred.

<DT><CODE>EPERM</CODE>
<DD>
The file is "append-only" or "immutable".

<DT><CODE>EINTR</CODE>
<DD>
The operation was interrupted by a signal.

</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>ftruncate</B> <I>(int <VAR>fd</VAR>, off_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX1351"></A>

</P>
<P>
This is like <CODE>truncate</CODE>, but it works on a file descriptor <VAR>fd</VAR>.

</P>
<P>
<CODE>ftruncate</CODE> is especially useful in combination with <CODE>mmap</CODE>.
Since the mapped region must have a fixed size one cannot enlarge the
file by writing something beyond the last mapped page.  Instead one has
to enlarge the file itself and then remap the file with the new size.
The example below shows how this works.

</P>
<P>
The return value is @math{0} for success, or @math{-1} for an error.  The
following errors may occur:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
<VAR>fd</VAR> does not correspond to an open file.

<DT><CODE>EACCES</CODE>
<DD>
<VAR>fd</VAR> is a directory or not open for write.

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>length</VAR> is negative.

<DT><CODE>EFBIG</CODE>
<DD>
The operation would extend the file beyond the limits of the operating system.

<DT><CODE>EIO</CODE>
<DD>
A hardware I/O error occurred.

<DT><CODE>EPERM</CODE>
<DD>
The file is "append-only" or "immutable".

<DT><CODE>EINTR</CODE>
<DD>
The operation was interrupted by a signal.

</DL>

</DL>

<P>
As announced here is a little example how to use <CODE>ftruncate</CODE> in
combination with <CODE>mmap</CODE>:

</P>

<PRE>
int fd;
void *start;
size_t len;

int
add (off_t at, void *block, size_t size)
{
  if (at + size &#62; len)
    {
      /* Resize the file and remap.  */
      size_t ps = sysconf (_SC_PAGESIZE);
      size_t ns = (at + size + ps - 1) &#38; ~(ps - 1);
      void *np;
      if (ftruncate (fd, ns) &#60; 0)
        return -1;
      np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
      if (np == MAP_FAILED)
        return -1;
      start = np;
      len = ns;
    }
  memcpy ((char *) start + at, block, size);
  return 0;
}
</PRE>

<P>
The function <CODE>add</CODE> allows to add at arbitrary positions in the file
given blocks of memory.  If the current size of the file is too small it
is extended.  Please note the it is extended in multiples of a pagesize.
This is a requirement of <CODE>mmap</CODE>.  The program has to track the real
size and once the program finished to work a final <CODE>ftruncate</CODE> call
should set the real size of the file.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_269.html">previous</A>, <A HREF="libc_271.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
