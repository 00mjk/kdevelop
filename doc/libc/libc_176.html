<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Variable Arguments Output</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_175.html">previous</A>, <A HREF="libc_177.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC183" HREF="libc_toc.html#TOC183">Variable Arguments Output Functions</A></H3>

<P>
The functions <CODE>vprintf</CODE> and friends are provided so that you can
define your own variadic <CODE>printf</CODE>-like functions that make use of
the same internals as the built-in formatted output functions.

</P>
<P>
The most natural way to define such functions would be to use a language
construct to say, "Call <CODE>printf</CODE> and pass this template plus all
of my arguments after the first five."  But there is no way to do this
in C, and it would be hard to provide a way, since at the C language
level there is no way to tell how many arguments your function received.

</P>
<P>
Since that method is impossible, we provide alternative functions, the
<CODE>vprintf</CODE> series, which lets you pass a <CODE>va_list</CODE> to describe
"all of my arguments after the first five."

</P>
<P>
When it is sufficient to define a macro rather than a real function,
the GNU C compiler provides a way to do this much more easily with macros.
For example:

</P>

<PRE>
#define myprintf(a, b, c, d, e, rest...) \
            printf (mytemplate , ## rest...)
</PRE>

<P>
See section `Macros with Variable Numbers of Arguments' in <CITE>Using GNU CC</CITE>, for details.  But this is limited to macros,
and does not apply to real functions at all.

</P>
<P>
Before calling <CODE>vprintf</CODE> or the other functions listed in this
section, you <EM>must</EM> call <CODE>va_start</CODE> (see section <A HREF="libc_615.html#SEC623">Variadic Functions</A>) to initialize a pointer to the variable arguments.  Then you
can call <CODE>va_arg</CODE> to fetch the arguments that you want to handle
yourself.  This advances the pointer past those arguments.

</P>
<P>
Once your <CODE>va_list</CODE> pointer is pointing at the argument of your
choice, you are ready to call <CODE>vprintf</CODE>.  That argument and all
subsequent arguments that were passed to your function are used by
<CODE>vprintf</CODE> along with the template that you specified separately.

</P>
<P>
In some other systems, the <CODE>va_list</CODE> pointer may become invalid
after the call to <CODE>vprintf</CODE>, so you must not use <CODE>va_arg</CODE>
after you call <CODE>vprintf</CODE>.  Instead, you should call <CODE>va_end</CODE>
to retire the pointer from service.  However, you can safely call
<CODE>va_start</CODE> on another pointer variable and begin fetching the
arguments again through that pointer.  Calling <CODE>vprintf</CODE> does not
destroy the argument list of your function, merely the particular
pointer that you passed to it.

</P>
<P>
GNU C does not have such restrictions.  You can safely continue to fetch
arguments from a <CODE>va_list</CODE> pointer after passing it to
<CODE>vprintf</CODE>, and <CODE>va_end</CODE> is a no-op.  (Note, however, that
subsequent <CODE>va_arg</CODE> calls will fetch the same arguments which
<CODE>vprintf</CODE> previously used.)

</P>
<P>
Prototypes for these functions are declared in <TT>`stdio.h'</TT>.
<A NAME="IDX835"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>vprintf</B> <I>(const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX836"></A>
This function is similar to <CODE>printf</CODE> except that, instead of taking
a variable number of arguments directly, it takes an argument list
pointer <VAR>ap</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>vfprintf</B> <I>(FILE *<VAR>stream</VAR>, const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX837"></A>
This is the equivalent of <CODE>fprintf</CODE> with the variable argument list
specified directly as for <CODE>vprintf</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>vsprintf</B> <I>(char *<VAR>s</VAR>, const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX838"></A>
This is the equivalent of <CODE>sprintf</CODE> with the variable argument list
specified directly as for <CODE>vprintf</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>vsnprintf</B> <I>(char *<VAR>s</VAR>, size_t <VAR>size</VAR>, const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX839"></A>
This is the equivalent of <CODE>snprintf</CODE> with the variable argument list
specified directly as for <CODE>vprintf</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>vasprintf</B> <I>(char **<VAR>ptr</VAR>, const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX840"></A>
The <CODE>vasprintf</CODE> function is the equivalent of <CODE>asprintf</CODE> with the
variable argument list specified directly as for <CODE>vprintf</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>obstack_vprintf</B> <I>(struct obstack *<VAR>obstack</VAR>, const char *<VAR>template</VAR>, va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX841"></A>
The <CODE>obstack_vprintf</CODE> function is the equivalent of
<CODE>obstack_printf</CODE> with the variable argument list specified directly
as for <CODE>vprintf</CODE>.</DL>

</P>
<P>
Here's an example showing how you might use <CODE>vfprintf</CODE>.  This is a
function that prints error messages to the stream <CODE>stderr</CODE>, along
with a prefix indicating the name of the program
(see section <A HREF="libc_18.html#SEC18">Error Messages</A>, for a description of
<CODE>program_invocation_short_name</CODE>).

</P>

<PRE>
#include &#60;stdio.h&#62;
#include &#60;stdarg.h&#62;

void
eprintf (const char *template, ...)
{
  va_list ap;
  extern char *program_invocation_short_name;

  fprintf (stderr, "%s: ", program_invocation_short_name);
  va_start (ap, template);
  vfprintf (stderr, template, ap);
  va_end (ap);
}
</PRE>

<P>
You could call <CODE>eprintf</CODE> like this:

</P>

<PRE>
eprintf ("file `%s' does not exist\n", filename);
</PRE>

<P>
In GNU C, there is a special construct you can use to let the compiler
know that a function uses a <CODE>printf</CODE>-style format string.  Then it
can check the number and types of arguments in each call to the
function, and warn you when they do not match the format string.
For example, take this declaration of <CODE>eprintf</CODE>:

</P>

<PRE>
void eprintf (const char *template, ...)
        __attribute__ ((format (printf, 1, 2)));
</PRE>

<P>
This tells the compiler that <CODE>eprintf</CODE> uses a format string like
<CODE>printf</CODE> (as opposed to <CODE>scanf</CODE>; see section <A HREF="libc_185.html#SEC192">Formatted Input</A>);
the format string appears as the first argument;
and the arguments to satisfy the format begin with the second.
See section `Declaring Attributes of Functions' in <CITE>Using GNU CC</CITE>, for more information.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_175.html">previous</A>, <A HREF="libc_177.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
