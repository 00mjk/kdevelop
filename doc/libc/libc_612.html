<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Miscellaneous Thread Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_611.html">previous</A>, <A HREF="libc_613.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC620" HREF="libc_toc.html#TOC620">Miscellaneous Thread Functions</A></H2>

<P>
<DL>
<DT><U>Function:</U> pthread_t <B>pthread_self</B> <I>(<VAR>void</VAR>)</I>
<DD><A NAME="IDX3188"></A>
<CODE>pthread_self</CODE> returns the thread identifier for the calling thread.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_equal</B> <I>(pthread_t thread1, pthread_t thread2)</I>
<DD><A NAME="IDX3189"></A>
<CODE>pthread_equal</CODE> determines if two thread identifiers refer to the same
thread.

</P>
<P>
A non-zero value is returned if <VAR>thread1</VAR> and <VAR>thread2</VAR> refer to
the same thread. Otherwise, 0 is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_detach</B> <I>(pthread_t <VAR>th</VAR>)</I>
<DD><A NAME="IDX3190"></A>
<CODE>pthread_detach</CODE> puts the thread <VAR>th</VAR> in the detached
state. This guarantees that the memory resources consumed by <VAR>th</VAR>
will be freed immediately when <VAR>th</VAR> terminates. However, this
prevents other threads from synchronizing on the termination of <VAR>th</VAR>
using <CODE>pthread_join</CODE>.

</P>
<P>
A thread can be created initially in the detached state, using the
<CODE>detachstate</CODE> attribute to <CODE>pthread_create</CODE>. In contrast,
<CODE>pthread_detach</CODE> applies to threads created in the joinable state,
and which need to be put in the detached state later.

</P>
<P>
After <CODE>pthread_detach</CODE> completes, subsequent attempts to perform
<CODE>pthread_join</CODE> on <VAR>th</VAR> will fail. If another thread is already
joining the thread <VAR>th</VAR> at the time <CODE>pthread_detach</CODE> is called,
<CODE>pthread_detach</CODE> does nothing and leaves <VAR>th</VAR> in the joinable
state.

</P>
<P>
On success, 0 is returned. On error, one of the following codes is
returned:
<DL COMPACT>

<DT><CODE>ESRCH</CODE>
<DD>
No thread could be found corresponding to that specified by <VAR>th</VAR>
<DT><CODE>EINVAL</CODE>
<DD>
The thread <VAR>th</VAR> is already in the detached state
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>pthread_atfork</B> <I>(void (*<VAR>prepare</VAR>)(void), void (*<VAR>parent</VAR>)(void), void (*<VAR>child</VAR>)(void))</I>
<DD><A NAME="IDX3191"></A>

</P>
<P>
<CODE>pthread_atfork</CODE> registers handler functions to be called just
before and just after a new process is created with <CODE>fork</CODE>. The
<VAR>prepare</VAR> handler will be called from the parent process, just
before the new process is created. The <VAR>parent</VAR> handler will be
called from the parent process, just before <CODE>fork</CODE> returns. The
<VAR>child</VAR> handler will be called from the child process, just before
<CODE>fork</CODE> returns.

</P>
<P>
<CODE>pthread_atfork</CODE> returns 0 on success and a non-zero error code on
error.

</P>
<P>
One or more of the three handlers <VAR>prepare</VAR>, <VAR>parent</VAR> and
<VAR>child</VAR> can be given as <CODE>NULL</CODE>, meaning that no handler needs
to be called at the corresponding point.

</P>
<P>
<CODE>pthread_atfork</CODE> can be called several times to install several
sets of handlers. At <CODE>fork</CODE> time, the <VAR>prepare</VAR> handlers are
called in LIFO order (last added with <CODE>pthread_atfork</CODE>, first
called before <CODE>fork</CODE>), while the <VAR>parent</VAR> and <VAR>child</VAR>
handlers are called in FIFO order (first added, first called).

</P>
<P>
If there is insufficient memory available to register the handlers,
<CODE>pthread_atfork</CODE> fails and returns <CODE>ENOMEM</CODE>.  Otherwise it
returns 0.
</DL>

</P>
<P>
To understand the purpose of <CODE>pthread_atfork</CODE>, recall that
<CODE>fork</CODE> duplicates the whole memory space, including mutexes in
their current locking state, but only the calling thread: other threads
are not running in the child process. Thus, if a mutex is locked by a
thread other than the thread calling <CODE>fork</CODE>, that mutex will remain
locked forever in the child process, possibly blocking the execution of
the child process. To avoid this, install handlers with
<CODE>pthread_atfork</CODE> as follows: the <VAR>prepare</VAR> handler locks the
global mutexes (in locking order), and the <VAR>parent</VAR> and <VAR>child</VAR>
handlers unlock them (in reverse order). Alternatively, <VAR>prepare</VAR>
and <VAR>parent</VAR> can be set to <CODE>NULL</CODE> and <VAR>child</VAR> to a function
that calls <CODE>pthread_mutex_init</CODE> on the global mutexes.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>pthread_kill_other_threads_np</B> <I>(<VAR>void</VAR>)</I>
<DD><A NAME="IDX3192"></A>
<CODE>pthread_kill_other_threads_np</CODE> is a non-portable LinuxThreads extension.
It causes all threads in the program to terminate immediately, except
the calling thread which proceeds normally. It is intended to be
called just before a thread calls one of the <CODE>exec</CODE> functions,
e.g. <CODE>execve</CODE>.

</P>
<P>
Termination of the other threads is not performed through
<CODE>pthread_cancel</CODE> and completely bypasses the cancellation
mechanism. Hence, the current settings for cancellation state and
cancellation type are ignored, and the cleanup handlers are not
executed in the terminated threads.

</P>
<P>
According to POSIX 1003.1c, a successful <CODE>exec*</CODE> in one of the
threads should automatically terminate all other threads in the program.
This behavior is not yet implemented in LinuxThreads.  Calling
<CODE>pthread_kill_other_threads_np</CODE> before <CODE>exec*</CODE> achieves much
of the same behavior, except that if <CODE>exec*</CODE> ultimately fails, then
all other threads are already killed.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_once</B> <I>(pthread_once_t *once_<VAR>control</VAR>, void (*<VAR>init_routine</VAR>) (void))</I>
<DD><A NAME="IDX3193"></A>

</P>
<P>
The purpose of <CODE>pthread_once</CODE> is to ensure that a piece of
initialization code is executed at most once. The <VAR>once_control</VAR>
argument points to a static or extern variable statically initialized
to <CODE>PTHREAD_ONCE_INIT</CODE>.

</P>
<P>
The first time <CODE>pthread_once</CODE> is called with a given
<VAR>once_control</VAR> argument, it calls <VAR>init_routine</VAR> with no
argument and changes the value of the <VAR>once_control</VAR> variable to
record that initialization has been performed. Subsequent calls to
<CODE>pthread_once</CODE> with the same <CODE>once_control</CODE> argument do
nothing.

</P>
<P>
<CODE>pthread_once</CODE> always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_setschedparam</B> <I>(pthread_t target_<VAR>thread</VAR>, int <VAR>policy</VAR>, const struct sched_param *<VAR>param</VAR>)</I>
<DD><A NAME="IDX3194"></A>

</P>
<P>
<CODE>pthread_setschedparam</CODE> sets the scheduling parameters for the
thread <VAR>target_thread</VAR> as indicated by <VAR>policy</VAR> and
<VAR>param</VAR>. <VAR>policy</VAR> can be either <CODE>SCHED_OTHER</CODE> (regular,
non-realtime scheduling), <CODE>SCHED_RR</CODE> (realtime, round-robin) or
<CODE>SCHED_FIFO</CODE> (realtime, first-in first-out). <VAR>param</VAR> specifies
the scheduling priority for the two realtime policies.  See
<CODE>sched_setpolicy</CODE> for more information on scheduling policies.

</P>
<P>
The realtime scheduling policies <CODE>SCHED_RR</CODE> and <CODE>SCHED_FIFO</CODE>
are available only to processes with superuser privileges.

</P>
<P>
On success, <CODE>pthread_setschedparam</CODE> returns 0.  On error it returns
one of the following codes:
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>policy</VAR> is not one of <CODE>SCHED_OTHER</CODE>, <CODE>SCHED_RR</CODE>,
<CODE>SCHED_FIFO</CODE>, or the priority value specified by <VAR>param</VAR> is not
valid for the specified policy

<DT><CODE>EPERM</CODE>
<DD>
Realtime scheduling was requested but the calling process does not have
sufficient privileges.

<DT><CODE>ESRCH</CODE>
<DD>
The <VAR>target_thread</VAR> is invalid or has already terminated

<DT><CODE>EFAULT</CODE>
<DD>
<VAR>param</VAR> points outside the process memory space
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>pthread_getschedparam</B> <I>(pthread_t target_<VAR>thread</VAR>, int *<VAR>policy</VAR>, struct sched_param *<VAR>param</VAR>)</I>
<DD><A NAME="IDX3195"></A>

</P>
<P>
<CODE>pthread_getschedparam</CODE> retrieves the scheduling policy and
scheduling parameters for the thread <VAR>target_thread</VAR> and stores them
in the locations pointed to by <VAR>policy</VAR> and <VAR>param</VAR>,
respectively.

</P>
<P>
<CODE>pthread_getschedparam</CODE> returns 0 on success, or one of the
following error codes on failure:
<DL COMPACT>

<DT><CODE>ESRCH</CODE>
<DD>
The <VAR>target_thread</VAR> is invalid or has already terminated.

<DT><CODE>EFAULT</CODE>
<DD>
<VAR>policy</VAR> or <VAR>param</VAR> point outside the process memory space.

</DL>
</DL>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_611.html">previous</A>, <A HREF="libc_613.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
