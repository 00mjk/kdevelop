<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Precision Time</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_406.html">previous</A>, <A HREF="libc_408.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC414" HREF="libc_toc.html#TOC414">Precision Time</A></H2>

<P>
<A NAME="IDX2348"></A>
<A NAME="IDX2349"></A>
The <CODE>net_gettime</CODE> and <CODE>ntp_adjtime</CODE> functions provide an
interface to monitor and manipulate high precision time.  These
functions are declared in <TT>`sys/timex.h'</TT>.

</P>
<P>
<A NAME="IDX2350"></A>
<DL>
<DT><U>Data Type:</U> <B>struct ntptimeval</B>
<DD><A NAME="IDX2351"></A>
This structure is used to monitor kernel time.  It contains the
following members:
<DL COMPACT>

<DT><CODE>struct timeval time</CODE>
<DD>
This is the current time.  The <CODE>struct timeval</CODE> data type is
described in section <A HREF="libc_398.html#SEC405">High-Resolution Calendar</A>.

<DT><CODE>long int maxerror</CODE>
<DD>
This is the maximum error, measured in microseconds.  Unless updated
via <CODE>ntp_adjtime</CODE> periodically, this value will reach some
platform-specific maximum value.

<DT><CODE>long int esterror</CODE>
<DD>
This is the estimated error, measured in microseconds.  This value can
be set by <CODE>ntp_adjtime</CODE> to indicate the estimated offset of the
local clock against the true time.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>ntp_gettime</B> <I>(struct ntptimeval *<VAR>tptr</VAR>)</I>
<DD><A NAME="IDX2352"></A>
The <CODE>ntp_gettime</CODE> function sets the structure pointed to by
<VAR>tptr</VAR> to current values.  The elements of the structure afterwards
contain the values the timer implementation in the kernel assumes.  They
might or might not be correct.  If they are not a <CODE>ntp_adjtime</CODE>
call is necessary.

</P>
<P>
The return value is <CODE>0</CODE> on success and other values on failure.  The
following <CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>TIME_ERROR</CODE>
<DD>
The precision clock model is not properly set up at the moment, thus the
clock must be considered unsynchronized, and the values should be
treated with care.
</DL>
</DL>

<P>
<A NAME="IDX2353"></A>
<DL>
<DT><U>Data Type:</U> <B>struct timex</B>
<DD><A NAME="IDX2354"></A>
This structure is used to control and monitor kernel time in a greater
level of detail.  It contains the following members:
<DL COMPACT>

<DT><CODE>unsigned int modes</CODE>
<DD>
This variable controls whether and which values are set.  Several
symbolic constants have to be combined with <EM>binary or</EM> to specify
the effective mode.  These constants start with <CODE>MOD_</CODE>.

<DT><CODE>long int offset</CODE>
<DD>
This value indicates the current offset of the local clock from the true
time.  The value is given in microseconds.  If bit <CODE>MOD_OFFSET</CODE> is
set in <CODE>modes</CODE>, the offset (and possibly other dependent values) can
be set.  The offset's absolute value must not exceed <CODE>MAXPHASE</CODE>.

<DT><CODE>long int frequency</CODE>
<DD>
This value indicates the difference in frequency between the true time
and the local clock.  The value is expressed as scaled PPM (parts per
million, 0.0001%).  The scaling is <CODE>1 &#60;&#60; SHIFT_USEC</CODE>.  The value
can be set with bit <CODE>MOD_FREQUENCY</CODE>, but the absolute value must
not exceed <CODE>MAXFREQ</CODE>.

<DT><CODE>long int maxerror</CODE>
<DD>
This is the maximum error, measured in microseconds.  A new value can be
set using bit <CODE>MOD_MAXERROR</CODE>.  Unless updated via
<CODE>ntp_adjtime</CODE> periodically, this value will increase steadily
and reach some platform-specific maximum value.

<DT><CODE>long int esterror</CODE>
<DD>
This is the estimated error, measured in microseconds.  This value can
be set using bit <CODE>MOD_ESTERROR</CODE>.

<DT><CODE>int status</CODE>
<DD>
This variable reflects the various states of the clock machinery.  There
are symbolic constants for the significant bits, starting with
<CODE>STA_</CODE>.  Some of these flags can be updated using the
<CODE>MOD_STATUS</CODE> bit.

<DT><CODE>long int constant</CODE>
<DD>
This value represents the bandwidth or stiffness of the PLL (phase
locked loop) implemented in the kernel.  The value can be changed using
bit <CODE>MOD_TIMECONST</CODE>.

<DT><CODE>long int precision</CODE>
<DD>
This value represents the accuracy or the maximum error when reading the
system clock.  The value is expressed in microseconds and can't be changed.

<DT><CODE>long int tolerance</CODE>
<DD>
This value represents the maximum frequency error of the system clock in
scaled PPM.  This value is used to increase the <CODE>maxerror</CODE> every
second.

<DT><CODE>long int ppsfreq</CODE>
<DD>
This is the first of a few optional variables that are present only if
the system clock can use a PPS (pulse per second) signal to discipline
the local clock.  The value is expressed in scaled PPM and it denotes
the difference in frequency between the local clock and the PPS signal.

<DT><CODE>long int jitter</CODE>
<DD>
This value expresses a median filtered average of the PPS signal's
dispersion in microseconds.

<DT><CODE>int int shift</CODE>
<DD>
This value is a binary exponent for the duration of the PPS calibration
interval, ranging from <CODE>PPS_SHIFT</CODE> to <CODE>PPS_SHIFTMAX</CODE>.

<DT><CODE>long int stabil</CODE>
<DD>
This value represents the median filtered dispersion of the PPS
frequency in scaled PPM.

<DT><CODE>long int jitcnt</CODE>
<DD>
This counter represents the number of pulses where the jitter exceeded
the allowed maximum <CODE>MAXTIME</CODE>.

<DT><CODE>long int calcnt</CODE>
<DD>
This counter reflects the number of successful calibration intervals.

<DT><CODE>long int errcnt</CODE>
<DD>
This counter represents the number of calibration errors (caused by
large offsets or jitter).

<DT><CODE>long int stbcnt</CODE>
<DD>
This counter denotes the number of of calibrations where the stability
exceeded the threshold.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>ntp_adjtime</B> <I>(struct timex *<VAR>tptr</VAR>)</I>
<DD><A NAME="IDX2355"></A>
The <CODE>ntp_adjtime</CODE> function sets the structure specified by
<VAR>tptr</VAR> to current values.  In addition, values passed in <VAR>tptr</VAR>
can be used to replace existing settings.  To do this the <CODE>modes</CODE>
element of the <CODE>struct timex</CODE> must be set appropriately.  Setting
it to zero selects reading the current state.

</P>
<P>
The return value is <CODE>0</CODE> on success and other values on failure.  The
following <CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>TIME_ERROR</CODE>
<DD>
The precision clock model is not properly set up at the moment, thus the
clock must be considered unsynchronized, and the values should be
treated with care.  Another reason could be that the specified new values
are not allowed.
</DL>

<P>
For more details see RFC1305 (Network Time Protocol, Version 3) and
related documents.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_406.html">previous</A>, <A HREF="libc_408.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
