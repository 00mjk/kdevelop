<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Limits on Resources</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_410.html">previous</A>, <A HREF="libc_412.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC418" HREF="libc_toc.html#TOC418">Limiting Resource Usage</A></H2>
<P>
<A NAME="IDX2380"></A>
<A NAME="IDX2381"></A>
<A NAME="IDX2382"></A>

</P>
<P>
You can specify limits for the resource usage of a process.  When the
process tries to exceed a limit, it may get a signal, or the system call
by which it tried to do so may fail, depending on the limit.  Each
process initially inherits its limit values from its parent, but it can
subsequently change them.

</P>
<P>
<A NAME="IDX2383"></A>
The symbols in this section are defined in <TT>`sys/resource.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>getrlimit</B> <I>(int <VAR>resource</VAR>, struct rlimit *<VAR>rlp</VAR>)</I>
<DD><A NAME="IDX2384"></A>
Read the current value and the maximum value of resource <VAR>resource</VAR>
and store them in <CODE>*<VAR>rlp</VAR></CODE>.

</P>
<P>
The return value is <CODE>0</CODE> on success and <CODE>-1</CODE> on failure.  The
only possible <CODE>errno</CODE> error condition is <CODE>EFAULT</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is in fact <CODE>getrlimit64</CODE>.  I.e., the
LFS interface transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>getrlimit64</B> <I>(int <VAR>resource</VAR>, struct rlimit64 *<VAR>rlp</VAR>)</I>
<DD><A NAME="IDX2385"></A>
This function is similar to the <CODE>getrlimit</CODE> but its second
parameter is a pointer to a variable of type <CODE>struct rlimit64</CODE>
which allows this function to read values which wouldn't fit in the
member of a <CODE>struct rlimit</CODE>.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>getrlimit</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>setrlimit</B> <I>(int <VAR>resource</VAR>, const struct rlimit *<VAR>rlp</VAR>)</I>
<DD><A NAME="IDX2386"></A>
Store the current value and the maximum value of resource <VAR>resource</VAR>
in <CODE>*<VAR>rlp</VAR></CODE>.

</P>
<P>
The return value is <CODE>0</CODE> on success and <CODE>-1</CODE> on failure.  The
following <CODE>errno</CODE> error condition is possible:

</P>
<DL COMPACT>

<DT><CODE>EPERM</CODE>
<DD>
You tried to change the maximum permissible limit value,
but you don't have privileges to do so.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system this function is in fact <CODE>setrlimit64</CODE>.  I.e., the
LFS interface transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>setrlimit64</B> <I>(int <VAR>resource</VAR>, const struct rlimit64 *<VAR>rlp</VAR>)</I>
<DD><A NAME="IDX2387"></A>
This function is similar to the <CODE>setrlimit</CODE> but its second
parameter is a pointer to a variable of type <CODE>struct rlimit64</CODE>
which allows this function to set values which wouldn't fit in the
member of a <CODE>struct rlimit</CODE>.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>setrlimit</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct rlimit</B>
<DD><A NAME="IDX2388"></A>
This structure is used with <CODE>getrlimit</CODE> to receive limit values,
and with <CODE>setrlimit</CODE> to specify limit values.  It has two fields:

</P>
<DL COMPACT>

<DT><CODE>rlim_t rlim_cur</CODE>
<DD>
The current value of the limit in question.
This is also called the "soft limit".
<A NAME="IDX2389"></A>

<DT><CODE>rlim_t rlim_max</CODE>
<DD>
The maximum permissible value of the limit in question.  You cannot set
the current value of the limit to a larger number than this maximum.
Only the super user can change the maximum permissible value.
This is also called the "hard limit".
<A NAME="IDX2390"></A>
</DL>

<P>
In <CODE>getrlimit</CODE>, the structure is an output; it receives the current
values.  In <CODE>setrlimit</CODE>, it specifies the new values.
</DL>

</P>
<P>
For the LFS functions a similar type is defined in <TT>`sys/resource.h'</TT>.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct rlimit64</B>
<DD><A NAME="IDX2391"></A>
This structure is used with <CODE>getrlimit64</CODE> to receive limit values,
and with <CODE>setrlimit64</CODE> to specify limit values.  It has two fields:

</P>
<DL COMPACT>

<DT><CODE>rlim64_t rlim_cur</CODE>
<DD>
The current value of the limit in question.
This is also called the "soft limit".

<DT><CODE>rlim64_t rlim_max</CODE>
<DD>
The maximum permissible value of the limit in question.  You cannot set
the current value of the limit to a larger number than this maximum.
Only the super user can change the maximum permissible value.
This is also called the "hard limit".
</DL>

<P>
In <CODE>getrlimit64</CODE>, the structure is an output; it receives the current
values.  In <CODE>setrlimit64</CODE>, it specifies the new values.
</DL>

</P>
<P>
Here is a list of resources that you can specify a limit for.
Those that are sizes are measured in bytes.

</P>
<DL COMPACT>

<DT><CODE>RLIMIT_CPU</CODE>
<DD>
<A NAME="IDX2392"></A>
The maximum amount of cpu time the process can use.  If it runs for
longer than this, it gets a signal: <CODE>SIGXCPU</CODE>.  The value is
measured in seconds.  See section <A HREF="libc_428.html#SEC435">Operation Error Signals</A>.

<DT><CODE>RLIMIT_FSIZE</CODE>
<DD>
<A NAME="IDX2393"></A>
The maximum size of file the process can create.  Trying to write a
larger file causes a signal: <CODE>SIGXFSZ</CODE>.  See section <A HREF="libc_428.html#SEC435">Operation Error Signals</A>.

<DT><CODE>RLIMIT_DATA</CODE>
<DD>
<A NAME="IDX2394"></A>
The maximum size of data memory for the process.  If the process tries
to allocate data memory beyond this amount, the allocation function
fails.

<DT><CODE>RLIMIT_STACK</CODE>
<DD>
<A NAME="IDX2395"></A>
The maximum stack size for the process.  If the process tries to extend
its stack past this size, it gets a <CODE>SIGSEGV</CODE> signal.
See section <A HREF="libc_423.html#SEC430">Program Error Signals</A>.

<DT><CODE>RLIMIT_CORE</CODE>
<DD>
<A NAME="IDX2396"></A>
The maximum size core file that this process can create.  If the process
terminates and would dump a core file larger than this maximum size,
then no core file is created.  So setting this limit to zero prevents
core files from ever being created.

<DT><CODE>RLIMIT_RSS</CODE>
<DD>
<A NAME="IDX2397"></A>
The maximum amount of physical memory that this process should get.
This parameter is a guide for the system's scheduler and memory
allocator; the system may give the process more memory when there is a
surplus.

<DT><CODE>RLIMIT_MEMLOCK</CODE>
<DD>
The maximum amount of memory that can be locked into physical memory (so
it will never be paged out).

<DT><CODE>RLIMIT_NPROC</CODE>
<DD>
The maximum number of processes that can be created with the same user ID.
If you have reached the limit for your user ID, <CODE>fork</CODE> will fail
with <CODE>EAGAIN</CODE>.  See section <A HREF="libc_516.html#SEC524">Creating a Process</A>.

<DT><CODE>RLIMIT_NOFILE</CODE>
<DD>
<A NAME="IDX2398"></A>
<DT><CODE>RLIMIT_OFILE</CODE>
<DD>
<A NAME="IDX2399"></A>
The maximum number of files that the process can open.  If it tries to
open more files than this, it gets error code <CODE>EMFILE</CODE>.
See section <A HREF="libc_17.html#SEC17">Error Codes</A>.  Not all systems support this limit; GNU does, and
4.4 BSD does.

<DT><CODE>RLIM_NLIMITS</CODE>
<DD>
<A NAME="IDX2400"></A>
The number of different resource limits.  Any valid <VAR>resource</VAR>
operand must be less than <CODE>RLIM_NLIMITS</CODE>.
</DL>

<P>
<DL>
<DT><U>Constant:</U> int <B>RLIM_INFINITY</B>
<DD><A NAME="IDX2401"></A>
This constant stands for a value of "infinity" when supplied as
the limit value in <CODE>setrlimit</CODE>.
</DL>

</P>
<P>
Two historical functions for setting resource limits, <CODE>ulimit</CODE> and
<CODE>vlimit</CODE>, are not documented here.  The latter is declared in
<TT>`sys/vlimit.h'</TT> and comes from BSD.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_410.html">previous</A>, <A HREF="libc_412.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
