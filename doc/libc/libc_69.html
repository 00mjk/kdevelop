<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Collation Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_68.html">previous</A>, <A HREF="libc_70.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC69" HREF="libc_toc.html#TOC69">Collation Functions</A></H2>

<P>
<A NAME="IDX451"></A>
<A NAME="IDX452"></A>

</P>
<P>
In some locales, the conventions for lexicographic ordering differ from
the strict numeric ordering of character codes.  For example, in Spanish
most glyphs with diacritical marks such as accents are not considered
distinct letters for the purposes of collation.  On the other hand, the
two-character sequence <SAMP>`ll'</SAMP> is treated as a single letter that is
collated immediately after <SAMP>`l'</SAMP>.

</P>
<P>
You can use the functions <CODE>strcoll</CODE> and <CODE>strxfrm</CODE> (declared in
the header file <TT>`string.h'</TT>) to compare strings using a collation
ordering appropriate for the current locale.  The locale used by these
functions in particular can be specified by setting the locale for the
<CODE>LC_COLLATE</CODE> category; see section <A HREF="libc_94.html#SEC98">Locales and Internationalization</A>.
<A NAME="IDX453"></A>

</P>
<P>
In the standard C locale, the collation sequence for <CODE>strcoll</CODE> is
the same as that for <CODE>strcmp</CODE>.

</P>
<P>
Effectively, the way these functions work is by applying a mapping to
transform the characters in a string to a byte sequence that represents
the string's position in the collating sequence of the current locale.
Comparing two such byte sequences in a simple fashion is equivalent to
comparing the strings with the locale's collating sequence.

</P>
<P>
The function <CODE>strcoll</CODE> performs this translation implicitly, in
order to do one comparison.  By contrast, <CODE>strxfrm</CODE> performs the
mapping explicitly.  If you are making multiple comparisons using the
same string or set of strings, it is likely to be more efficient to use
<CODE>strxfrm</CODE> to transform all the strings just once, and subsequently
compare the transformed strings with <CODE>strcmp</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>strcoll</B> <I>(const char *<VAR>s1</VAR>, const char *<VAR>s2</VAR>)</I>
<DD><A NAME="IDX454"></A>
The <CODE>strcoll</CODE> function is similar to <CODE>strcmp</CODE> but uses the
collating sequence of the current locale for collation (the
<CODE>LC_COLLATE</CODE> locale).
</DL>

</P>
<P>
Here is an example of sorting an array of strings, using <CODE>strcoll</CODE>
to compare them.  The actual sort algorithm is not written here; it
comes from <CODE>qsort</CODE> (see section <A HREF="libc_122.html#SEC129">Array Sort Function</A>).  The job of the
code shown here is to say how to compare the strings while sorting them.
(Later on in this section, we will show a way to do this more
efficiently using <CODE>strxfrm</CODE>.)

</P>

<PRE>
/* This is the comparison function used with <CODE>qsort</CODE>. */

int
compare_elements (char **p1, char **p2)
{
  return strcoll (*p1, *p2);
}

/* This is the entry point--the function to sort
   strings using the locale's collating sequence. */

void
sort_strings (char **array, int nstrings)
{
  /* Sort <CODE>temp_array</CODE> by comparing the strings. */
  qsort (array, nstrings,
         sizeof (char *), compare_elements);
}
</PRE>

<P>
<A NAME="IDX455"></A>
<DL>
<DT><U>Function:</U> size_t <B>strxfrm</B> <I>(char *<VAR>to</VAR>, const char *<VAR>from</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX456"></A>
The function <CODE>strxfrm</CODE> transforms <VAR>string</VAR> using the collation
transformation determined by the locale currently selected for
collation, and stores the transformed string in the array <VAR>to</VAR>.  Up
to <VAR>size</VAR> characters (including a terminating null character) are
stored.

</P>
<P>
The behavior is undefined if the strings <VAR>to</VAR> and <VAR>from</VAR>
overlap; see section <A HREF="libc_67.html#SEC67">Copying and Concatenation</A>.

</P>
<P>
The return value is the length of the entire transformed string.  This
value is not affected by the value of <VAR>size</VAR>, but if it is greater
or equal than <VAR>size</VAR>, it means that the transformed string did not
entirely fit in the array <VAR>to</VAR>.  In this case, only as much of the
string as actually fits was stored.  To get the whole transformed
string, call <CODE>strxfrm</CODE> again with a bigger output array.

</P>
<P>
The transformed string may be longer than the original string, and it
may also be shorter.

</P>
<P>
If <VAR>size</VAR> is zero, no characters are stored in <VAR>to</VAR>.  In this
case, <CODE>strxfrm</CODE> simply returns the number of characters that would
be the length of the transformed string.  This is useful for determining
what size string to allocate.  It does not matter what <VAR>to</VAR> is if
<VAR>size</VAR> is zero; <VAR>to</VAR> may even be a null pointer.
</DL>

</P>
<P>
Here is an example of how you can use <CODE>strxfrm</CODE> when
you plan to do many comparisons.  It does the same thing as the previous
example, but much faster, because it has to transform each string only
once, no matter how many times it is compared with other strings.  Even
the time needed to allocate and free storage is much less than the time
we save, when there are many strings.

</P>

<PRE>
struct sorter { char *input; char *transformed; };

/* This is the comparison function used with <CODE>qsort</CODE>
   to sort an array of <CODE>struct sorter</CODE>. */

int
compare_elements (struct sorter *p1, struct sorter *p2)
{
  return strcmp (p1-&#62;transformed, p2-&#62;transformed);
}

/* This is the entry point--the function to sort
   strings using the locale's collating sequence. */

void
sort_strings_fast (char **array, int nstrings)
{
  struct sorter temp_array[nstrings];
  int i;

  /* Set up <CODE>temp_array</CODE>.  Each element contains
     one input string and its transformed string. */
  for (i = 0; i &#60; nstrings; i++)
    {
      size_t length = strlen (array[i]) * 2;
      char *transformed;
      size_t transformed_length;

      temp_array[i].input = array[i];

      /* First try a buffer perhaps big enough.  */
      transformed = (char *) xmalloc (length);

      /* Transform <CODE>array[i]</CODE>.  */
      transformed_length = strxfrm (transformed, array[i], length);

      /* If the buffer was not large enough, resize it
         and try again.  */
      if (transformed_length &#62;= length)
        {
          /* Allocate the needed space. +1 for terminating
             <CODE>NUL</CODE> character.  */
          transformed = (char *) xrealloc (transformed,
                                           transformed_length + 1);

          /* The return value is not interesting because we know
             how long the transformed string is.  */
          (void) strxfrm (transformed, array[i],
                          transformed_length + 1);
        }

      temp_array[i].transformed = transformed;
    }

  /* Sort <CODE>temp_array</CODE> by comparing transformed strings. */
  qsort (temp_array, sizeof (struct sorter),
         nstrings, compare_elements);

  /* Put the elements back in the permanent array
     in their sorted order. */
  for (i = 0; i &#60; nstrings; i++)
    array[i] = temp_array[i].input;

  /* Free the strings we allocated. */
  for (i = 0; i &#60; nstrings; i++)
    free (temp_array[i].transformed);
}
</PRE>

<P>
<STRONG>Compatibility Note:</STRONG>  The string collation functions are a new
feature of ISO C 89.  Older C dialects have no equivalent feature.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_68.html">previous</A>, <A HREF="libc_70.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
