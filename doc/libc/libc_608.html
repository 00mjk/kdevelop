<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Condition Variables</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_607.html">previous</A>, <A HREF="libc_609.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC616" HREF="libc_toc.html#TOC616">Condition Variables</A></H2>

<P>
A condition (short for "condition variable") is a synchronization
device that allows threads to suspend execution until some predicate on
shared data is satisfied. The basic operations on conditions are: signal
the condition (when the predicate becomes true), and wait for the
condition, suspending the thread execution until another thread signals
the condition.

</P>
<P>
A condition variable must always be associated with a mutex, to avoid
the race condition where a thread prepares to wait on a condition
variable and another thread signals the condition just before the first
thread actually waits on it.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_init</B> <I>(pthread_cond_t *<VAR>cond</VAR>, pthread_condattr_t *cond_<VAR>attr</VAR>)</I>
<DD><A NAME="IDX3166"></A>

</P>
<P>
<CODE>pthread_cond_init</CODE> initializes the condition variable <VAR>cond</VAR>,
using the condition attributes specified in <VAR>cond_attr</VAR>, or default
attributes if <VAR>cond_attr</VAR> is <CODE>NULL</CODE>. The LinuxThreads
implementation supports no attributes for conditions, hence the
<VAR>cond_attr</VAR> parameter is actually ignored.

</P>
<P>
Variables of type <CODE>pthread_cond_t</CODE> can also be initialized
statically, using the constant <CODE>PTHREAD_COND_INITIALIZER</CODE>.

</P>
<P>
This function always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_signal</B> <I>(pthread_cond_t *<VAR>cond</VAR>)</I>
<DD><A NAME="IDX3167"></A>
<CODE>pthread_cond_signal</CODE> restarts one of the threads that are waiting
on the condition variable <VAR>cond</VAR>. If no threads are waiting on
<VAR>cond</VAR>, nothing happens. If several threads are waiting on
<VAR>cond</VAR>, exactly one is restarted, but it is not specified which.

</P>
<P>
This function always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_broadcast</B> <I>(pthread_cond_t *<VAR>cond</VAR>)</I>
<DD><A NAME="IDX3168"></A>
<CODE>pthread_cond_broadcast</CODE> restarts all the threads that are waiting
on the condition variable <VAR>cond</VAR>. Nothing happens if no threads are
waiting on <VAR>cond</VAR>.

</P>
<P>
This function always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_wait</B> <I>(pthread_cond_t *<VAR>cond</VAR>, pthread_mutex_t *<VAR>mutex</VAR>)</I>
<DD><A NAME="IDX3169"></A>
<CODE>pthread_cond_wait</CODE> atomically unlocks the <VAR>mutex</VAR> (as per
<CODE>pthread_unlock_mutex</CODE>) and waits for the condition variable
<VAR>cond</VAR> to be signaled. The thread execution is suspended and does
not consume any CPU time until the condition variable is signaled. The
<VAR>mutex</VAR> must be locked by the calling thread on entrance to
<CODE>pthread_cond_wait</CODE>. Before returning to the calling thread,
<CODE>pthread_cond_wait</CODE> re-acquires <VAR>mutex</VAR> (as per
<CODE>pthread_lock_mutex</CODE>).

</P>
<P>
Unlocking the mutex and suspending on the condition variable is done
atomically. Thus, if all threads always acquire the mutex before
signaling the condition, this guarantees that the condition cannot be
signaled (and thus ignored) between the time a thread locks the mutex
and the time it waits on the condition variable.

</P>
<P>
This function always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_timedwait</B> <I>(pthread_cond_t *<VAR>cond</VAR>, pthread_mutex_t *<VAR>mutex</VAR>, const struct timespec *<VAR>abstime</VAR>)</I>
<DD><A NAME="IDX3170"></A>
<CODE>pthread_cond_timedwait</CODE> atomically unlocks <VAR>mutex</VAR> and waits
on <VAR>cond</VAR>, as <CODE>pthread_cond_wait</CODE> does, but it also bounds the
duration of the wait. If <VAR>cond</VAR> has not been signaled before time
<VAR>abstime</VAR>, the mutex <VAR>mutex</VAR> is re-acquired and
<CODE>pthread_cond_timedwait</CODE> returns the error code <CODE>ETIMEDOUT</CODE>.
The wait can also be interrupted by a signal; in that case
<CODE>pthread_cond_timedwait</CODE> returns <CODE>EINTR</CODE>.

</P>
<P>
The <VAR>abstime</VAR> parameter specifies an absolute time, with the same
origin as <CODE>time</CODE> and <CODE>gettimeofday</CODE>: an <VAR>abstime</VAR> of 0
corresponds to 00:00:00 GMT, January 1, 1970.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_cond_destroy</B> <I>(pthread_cond_t *<VAR>cond</VAR>)</I>
<DD><A NAME="IDX3171"></A>
<CODE>pthread_cond_destroy</CODE> destroys the condition variable <VAR>cond</VAR>,
freeing the resources it might hold.  If any threads are waiting on the
condition variable, <CODE>pthread_cond_destroy</CODE> leaves <VAR>cond</VAR>
untouched and returns <CODE>EBUSY</CODE>.  Otherwise it returns 0, and
<VAR>cond</VAR> must not be used again until it is reinitialized.

</P>
<P>
In the LinuxThreads implementation, no resources are associated with
condition variables, so <CODE>pthread_cond_destroy</CODE> actually does
nothing.
</DL>

</P>
<P>
<CODE>pthread_cond_wait</CODE> and <CODE>pthread_cond_timedwait</CODE> are
cancellation points. If a thread is cancelled while suspended in one of
these functions, the thread immediately resumes execution, relocks the
mutex specified by  <VAR>mutex</VAR>, and finally executes the cancellation.
Consequently, cleanup handlers are assured that <VAR>mutex</VAR> is locked
when they are called.

</P>
<P>
It is not safe to call the condition variable functions from a signal
handler. In particular, calling <CODE>pthread_cond_signal</CODE> or
<CODE>pthread_cond_broadcast</CODE> from a signal handler may deadlock the
calling thread.

</P>
<P>
Consider two shared variables <VAR>x</VAR> and <VAR>y</VAR>, protected by the
mutex <VAR>mut</VAR>, and a condition variable <VAR>cond</VAR> that is to be
signaled whenever <VAR>x</VAR> becomes greater than <VAR>y</VAR>.

</P>

<PRE>
int x,y;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
</PRE>

<P>
Waiting until <VAR>x</VAR> is greater than <VAR>y</VAR> is performed as follows:

</P>

<PRE>
pthread_mutex_lock(&#38;mut);
while (x &#60;= y) {
        pthread_cond_wait(&#38;cond, &#38;mut);
}
/* operate on x and y */
pthread_mutex_unlock(&#38;mut);
</PRE>

<P>
Modifications on <VAR>x</VAR> and <VAR>y</VAR> that may cause <VAR>x</VAR> to become greater than
<VAR>y</VAR> should signal the condition if needed:

</P>

<PRE>
pthread_mutex_lock(&#38;mut);
/* modify x and y */
if (x &#62; y) pthread_cond_broadcast(&#38;cond);
pthread_mutex_unlock(&#38;mut);
</PRE>

<P>
If it can be proved that at most one waiting thread needs to be waken
up (for instance, if there are only two threads communicating through
<VAR>x</VAR> and <VAR>y</VAR>), <CODE>pthread_cond_signal</CODE> can be used as a slightly more
efficient alternative to <CODE>pthread_cond_broadcast</CODE>. In doubt, use
<CODE>pthread_cond_broadcast</CODE>.

</P>
<P>
To wait for <VAR>x</VAR> to becomes greater than <VAR>y</VAR> with a timeout of 5
seconds, do:

</P>

<PRE>
struct timeval now;
struct timespec timeout;
int retcode;

pthread_mutex_lock(&#38;mut);
gettimeofday(&#38;now);
timeout.tv_sec = now.tv_sec + 5;
timeout.tv_nsec = now.tv_usec * 1000;
retcode = 0;
while (x &#60;= y &#38;&#38; retcode != ETIMEDOUT) {
        retcode = pthread_cond_timedwait(&#38;cond, &#38;mut, &#38;timeout);
}
if (retcode == ETIMEDOUT) {
        /* timeout occurred */
} else {
        /* operate on x and y */
}
pthread_mutex_unlock(&#38;mut);
</PRE>

<P>
Condition attributes can be specified at condition creation time, by
passing a condition attribute object as second argument to
<CODE>pthread_cond_init</CODE>.  Passing <CODE>NULL</CODE> is equivalent to passing
a condition attribute object with all attributes set to their default
values.

</P>
<P>
The LinuxThreads implementation supports no attributes for
conditions. The functions on condition attributes are included only for
compliance with the POSIX standard.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_condattr_init</B> <I>(pthread_condattr_t *<VAR>attr</VAR>)</I>
<DD><A NAME="IDX3172"></A>
<DT><U>Function:</U> int <B>pthread_condattr_destroy</B> <I>(pthread_condattr_t *<VAR>attr</VAR>)</I>
<DD><A NAME="IDX3173"></A>
<CODE>pthread_condattr_init</CODE> initializes the condition attribute object
<VAR>attr</VAR> and fills it with default values for the attributes.
<CODE>pthread_condattr_destroy</CODE> destroys the condition attribute object
<VAR>attr</VAR>.

</P>
<P>
Both functions do nothing in the LinuxThreads implementation.

</P>
<P>
<CODE>pthread_condattr_init</CODE> and <CODE>pthread_condattr_destroy</CODE> always
return 0.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_607.html">previous</A>, <A HREF="libc_609.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
