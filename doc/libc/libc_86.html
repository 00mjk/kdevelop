<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Non-reentrant Character Conversion</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_85.html">previous</A>, <A HREF="libc_87.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC86" HREF="libc_toc.html#TOC86">Non-reentrant Conversion of Single Characters</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>mbtowc</B> <I>(wchar_t *restrict <VAR>result</VAR>, const char *restrict <VAR>string</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX552"></A>
The <CODE>mbtowc</CODE> ("multibyte to wide character") function when called
with non-null <VAR>string</VAR> converts the first multibyte character
beginning at <VAR>string</VAR> to its corresponding wide character code.  It
stores the result in <CODE>*<VAR>result</VAR></CODE>.

</P>
<P>
<CODE>mbtowc</CODE> never examines more than <VAR>size</VAR> bytes.  (The idea is
to supply for <VAR>size</VAR> the number of bytes of data you have in hand.)

</P>
<P>
<CODE>mbtowc</CODE> with non-null <VAR>string</VAR> distinguishes three
possibilities: the first <VAR>size</VAR> bytes at <VAR>string</VAR> start with
valid multibyte character, they start with an invalid byte sequence or
just part of a character, or <VAR>string</VAR> points to an empty string (a
null character).

</P>
<P>
For a valid multibyte character, <CODE>mbtowc</CODE> converts it to a wide
character and stores that in <CODE>*<VAR>result</VAR></CODE>, and returns the
number of bytes in that character (always at least @math{1}, and never
more than <VAR>size</VAR>).

</P>
<P>
For an invalid byte sequence, <CODE>mbtowc</CODE> returns @math{-1}.  For an
empty string, it returns @math{0}, also storing <CODE>'\0'</CODE> in
<CODE>*<VAR>result</VAR></CODE>.

</P>
<P>
If the multibyte character code uses shift characters, then
<CODE>mbtowc</CODE> maintains and updates a shift state as it scans.  If you
call <CODE>mbtowc</CODE> with a null pointer for <VAR>string</VAR>, that
initializes the shift state to its standard initial value.  It also
returns nonzero if the multibyte character code in use actually has a
shift state.  See section <A HREF="libc_88.html#SEC88">States in Non-reentrant Functions</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>wctomb</B> <I>(char *<VAR>string</VAR>, wchar_t <VAR>wchar</VAR>)</I>
<DD><A NAME="IDX553"></A>
The <CODE>wctomb</CODE> ("wide character to multibyte") function converts
the wide character code <VAR>wchar</VAR> to its corresponding multibyte
character sequence, and stores the result in bytes starting at
<VAR>string</VAR>.  At most <CODE>MB_CUR_MAX</CODE> characters are stored.

</P>
<P>
<CODE>wctomb</CODE> with non-null <VAR>string</VAR> distinguishes three
possibilities for <VAR>wchar</VAR>: a valid wide character code (one that can
be translated to a multibyte character), an invalid code, and <CODE>L'\0'</CODE>.

</P>
<P>
Given a valid code, <CODE>wctomb</CODE> converts it to a multibyte character,
storing the bytes starting at <VAR>string</VAR>.  Then it returns the number
of bytes in that character (always at least @math{1}, and never more
than <CODE>MB_CUR_MAX</CODE>).

</P>
<P>
If <VAR>wchar</VAR> is an invalid wide character code, <CODE>wctomb</CODE> returns
@math{-1}.  If <VAR>wchar</VAR> is <CODE>L'\0'</CODE>, it returns <CODE>0</CODE>, also
storing <CODE>'\0'</CODE> in <CODE>*<VAR>string</VAR></CODE>.

</P>
<P>
If the multibyte character code uses shift characters, then
<CODE>wctomb</CODE> maintains and updates a shift state as it scans.  If you
call <CODE>wctomb</CODE> with a null pointer for <VAR>string</VAR>, that
initializes the shift state to its standard initial value.  It also
returns nonzero if the multibyte character code in use actually has a
shift state.  See section <A HREF="libc_88.html#SEC88">States in Non-reentrant Functions</A>.

</P>
<P>
Calling this function with a <VAR>wchar</VAR> argument of zero when
<VAR>string</VAR> is not null has the side-effect of reinitializing the
stored shift state <EM>as well as</EM> storing the multibyte character
<CODE>'\0'</CODE> and returning @math{0}.
</DL>

</P>
<P>
Similar to <CODE>mbrlen</CODE> there is also a non-reentrant function which
computes the length of a multibyte character.  It can be defined in
terms of <CODE>mbtowc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>mblen</B> <I>(const char *<VAR>string</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX554"></A>
The <CODE>mblen</CODE> function with a non-null <VAR>string</VAR> argument returns
the number of bytes that make up the multibyte character beginning at
<VAR>string</VAR>, never examining more than <VAR>size</VAR> bytes.  (The idea is
to supply for <VAR>size</VAR> the number of bytes of data you have in hand.)

</P>
<P>
The return value of <CODE>mblen</CODE> distinguishes three possibilities: the
first <VAR>size</VAR> bytes at <VAR>string</VAR> start with valid multibyte
character, they start with an invalid byte sequence or just part of a
character, or <VAR>string</VAR> points to an empty string (a null character).

</P>
<P>
For a valid multibyte character, <CODE>mblen</CODE> returns the number of
bytes in that character (always at least <CODE>1</CODE>, and never more than
<VAR>size</VAR>).  For an invalid byte sequence, <CODE>mblen</CODE> returns
@math{-1}.  For an empty string, it returns @math{0}.

</P>
<P>
If the multibyte character code uses shift characters, then <CODE>mblen</CODE>
maintains and updates a shift state as it scans.  If you call
<CODE>mblen</CODE> with a null pointer for <VAR>string</VAR>, that initializes the
shift state to its standard initial value.  It also returns a nonzero
value if the multibyte character code in use actually has a shift state.
See section <A HREF="libc_88.html#SEC88">States in Non-reentrant Functions</A>.

</P>
<P>
<A NAME="IDX555"></A>
The function <CODE>mblen</CODE> is declared in <TT>`stdlib.h'</TT>.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_85.html">previous</A>, <A HREF="libc_87.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
