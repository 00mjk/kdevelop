<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Formatted Output Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_173.html">previous</A>, <A HREF="libc_175.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC181" HREF="libc_toc.html#TOC181">Formatted Output Functions</A></H3>

<P>
This section describes how to call <CODE>printf</CODE> and related functions.
Prototypes for these functions are in the header file <TT>`stdio.h'</TT>.
Because these functions take a variable number of arguments, you
<EM>must</EM> declare prototypes for them before using them.  Of course,
the easiest way to make sure you have all the right prototypes is to
just include <TT>`stdio.h'</TT>.
<A NAME="IDX828"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>printf</B> <I>(const char *<VAR>template</VAR>, ...)</I>
<DD><A NAME="IDX829"></A>
The <CODE>printf</CODE> function prints the optional arguments under the
control of the template string <VAR>template</VAR> to the stream
<CODE>stdout</CODE>.  It returns the number of characters printed, or a
negative value if there was an output error.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fprintf</B> <I>(FILE *<VAR>stream</VAR>, const char *<VAR>template</VAR>, ...)</I>
<DD><A NAME="IDX830"></A>
This function is just like <CODE>printf</CODE>, except that the output is
written to the stream <VAR>stream</VAR> instead of <CODE>stdout</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sprintf</B> <I>(char *<VAR>s</VAR>, const char *<VAR>template</VAR>, ...)</I>
<DD><A NAME="IDX831"></A>
This is like <CODE>printf</CODE>, except that the output is stored in the character
array <VAR>s</VAR> instead of written to a stream.  A null character is written
to mark the end of the string.

</P>
<P>
The <CODE>sprintf</CODE> function returns the number of characters stored in
the array <VAR>s</VAR>, not including the terminating null character.

</P>
<P>
The behavior of this function is undefined if copying takes place
between objects that overlap--for example, if <VAR>s</VAR> is also given
as an argument to be printed under control of the <SAMP>`%s'</SAMP> conversion.
See section <A HREF="libc_67.html#SEC67">Copying and Concatenation</A>.

</P>
<P>
<STRONG>Warning:</STRONG> The <CODE>sprintf</CODE> function can be <STRONG>dangerous</STRONG>
because it can potentially output more characters than can fit in the
allocation size of the string <VAR>s</VAR>.  Remember that the field width
given in a conversion specification is only a <EM>minimum</EM> value.

</P>
<P>
To avoid this problem, you can use <CODE>snprintf</CODE> or <CODE>asprintf</CODE>,
described below.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>snprintf</B> <I>(char *<VAR>s</VAR>, size_t <VAR>size</VAR>, const char *<VAR>template</VAR>, ...)</I>
<DD><A NAME="IDX832"></A>
The <CODE>snprintf</CODE> function is similar to <CODE>sprintf</CODE>, except that
the <VAR>size</VAR> argument specifies the maximum number of characters to
produce.  The trailing null character is counted towards this limit, so
you should allocate at least <VAR>size</VAR> characters for the string <VAR>s</VAR>.

</P>
<P>
The return value is the number of characters which would be generated
for the given input, excluding the trailing null.  If this value is
greater or equal to <VAR>size</VAR>, not all characters from the result have
been stored in <VAR>s</VAR>.  You should try again with a bigger output
string.  Here is an example of doing this:

</P>

<PRE>
/* Construct a message describing the value of a variable
   whose name is <VAR>name</VAR> and whose value is <VAR>value</VAR>. */
char *
make_message (char *name, char *value)
{
  /* Guess we need no more than 100 chars of space. */
  int size = 100;
  char *buffer = (char *) xmalloc (size);
  int nchars;
 /* Try to print in the allocated space. */
  nchars = snprintf (buffer, size, "value of %s is %s",
                     name, value);
  if (nchars &#62;= size)
    {
      /* Reallocate buffer now that we know
         how much space is needed. */
      buffer = (char *) xrealloc (buffer, nchars + 1);

      /* Try again. */
      snprintf (buffer, size, "value of %s is %s",
                name, value);
    }
  /* The last call worked, return the string. */
  return buffer;
}
</PRE>

<P>
In practice, it is often easier just to use <CODE>asprintf</CODE>, below.

</P>
<P>
<STRONG>Attention:</STRONG> In the GNU C library version 2.0 the return value
is the number of characters stored, not including the terminating null.
If this value equals <CODE><VAR>size</VAR> - 1</CODE>, then there was not enough
space in <VAR>s</VAR> for all the output.  This change was necessary with
the adoption of snprintf by ISO C9x.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_173.html">previous</A>, <A HREF="libc_175.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
