<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Opening and Closing Files</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_213.html">previous</A>, <A HREF="libc_215.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC221" HREF="libc_toc.html#TOC221">Opening and Closing Files</A></H2>

<P>
<A NAME="IDX978"></A>
<A NAME="IDX979"></A>
This section describes the primitives for opening and closing files
using file descriptors.  The <CODE>open</CODE> and <CODE>creat</CODE> functions are
declared in the header file <TT>`fcntl.h'</TT>, while <CODE>close</CODE> is
declared in <TT>`unistd.h'</TT>.
<A NAME="IDX980"></A>
<A NAME="IDX981"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>open</B> <I>(const char *<VAR>filename</VAR>, int <VAR>flags</VAR>[, mode_t <VAR>mode</VAR>])</I>
<DD><A NAME="IDX982"></A>
The <CODE>open</CODE> function creates and returns a new file descriptor
for the file named by <VAR>filename</VAR>.  Initially, the file position
indicator for the file is at the beginning of the file.  The argument
<VAR>mode</VAR> is used only when a file is created, but it doesn't hurt
to supply the argument in any case.

</P>
<P>
The <VAR>flags</VAR> argument controls how the file is to be opened.  This is
a bit mask; you create the value by the bitwise OR of the appropriate
parameters (using the <SAMP>`|'</SAMP> operator in C).
See section <A HREF="libc_236.html#SEC243">File Status Flags</A>, for the parameters available.

</P>
<P>
The normal return value from <CODE>open</CODE> is a non-negative integer file
descriptor.  In the case of an error, a value of @math{-1} is returned
instead.  In addition to the usual file name errors (see section <A HREF="libc_153.html#SEC160">File Name Errors</A>), the following <CODE>errno</CODE> error conditions are defined
for this function:

</P>
<DL COMPACT>

<DT><CODE>EACCES</CODE>
<DD>
The file exists but is not readable/writable as requested by the <VAR>flags</VAR>
argument, the file does not exist and the directory is unwritable so
it cannot be created.

<DT><CODE>EEXIST</CODE>
<DD>
Both <CODE>O_CREAT</CODE> and <CODE>O_EXCL</CODE> are set, and the named file already
exists.

<DT><CODE>EINTR</CODE>
<DD>
The <CODE>open</CODE> operation was interrupted by a signal.
See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.

<DT><CODE>EISDIR</CODE>
<DD>
The <VAR>flags</VAR> argument specified write access, and the file is a directory.

<DT><CODE>EMFILE</CODE>
<DD>
The process has too many files open.
The maximum number of file descriptors is controlled by the
<CODE>RLIMIT_NOFILE</CODE> resource limit; see section <A HREF="libc_411.html#SEC418">Limiting Resource Usage</A>.

<DT><CODE>ENFILE</CODE>
<DD>
The entire system, or perhaps the file system which contains the
directory, cannot support any additional open files at the moment.
(This problem cannot happen on the GNU system.)

<DT><CODE>ENOENT</CODE>
<DD>
The named file does not exist, and <CODE>O_CREAT</CODE> is not specified.

<DT><CODE>ENOSPC</CODE>
<DD>
The directory or file system that would contain the new file cannot be
extended, because there is no disk space left.

<DT><CODE>ENXIO</CODE>
<DD>
<CODE>O_NONBLOCK</CODE> and <CODE>O_WRONLY</CODE> are both set in the <VAR>flags</VAR>
argument, the file named by <VAR>filename</VAR> is a FIFO (see section <A HREF="libc_273.html#SEC280">Pipes and FIFOs</A>), and no process has the file open for reading.

<DT><CODE>EROFS</CODE>
<DD>
The file resides on a read-only file system and any of <CODE>O_WRONLY</CODE>,
<CODE>O_RDWR</CODE>, and <CODE>O_TRUNC</CODE> are set in the <VAR>flags</VAR> argument,
or <CODE>O_CREAT</CODE> is set and the file does not already exist.
</DL>

<P>
If on a 32 bits machine the sources are translated with
<CODE>_FILE_OFFSET_BITS == 64</CODE> the function <CODE>open</CODE> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to @math{2^63} bytes in size and offset from
@math{-2^63} to @math{2^63}.  This happens transparently for the user
since all of the lowlevel file handling functions are equally replaced.

</P>
<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>open</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>open</CODE> should be
protected using cancelation handlers.

</P>
<P>
The <CODE>open</CODE> function is the underlying primitive for the <CODE>fopen</CODE>
and <CODE>freopen</CODE> functions, that create streams.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>open64</B> <I>(const char *<VAR>filename</VAR>, int <VAR>flags</VAR>[, mode_t <VAR>mode</VAR>])</I>
<DD><A NAME="IDX983"></A>
This function is similar to <CODE>open</CODE>.  It returns a file descriptor
which can be used to access the file named by <VAR>filename</VAR>.  The only
the difference is that on 32 bits systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.

</P>
<P>
When the sources are translated with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is actually available under the name <CODE>open</CODE>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API.
</DL>

</P>
<P>
<DL>
<DT><U>Obsolete function:</U> int <B>creat</B> <I>(const char *<VAR>filename</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX984"></A>
This function is obsolete.  The call:

</P>

<PRE>
creat (<VAR>filename</VAR>, <VAR>mode</VAR>)
</PRE>

<P>
is equivalent to:

</P>

<PRE>
open (<VAR>filename</VAR>, O_WRONLY | O_CREAT | O_TRUNC, <VAR>mode</VAR>)
</PRE>

<P>
If on a 32 bits machine the sources are translated with
<CODE>_FILE_OFFSET_BITS == 64</CODE> the function <CODE>creat</CODE> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to @math{2^63} in size and offset from
@math{-2^63} to @math{2^63}.  This happens transparently for the user
since all of the lowlevel file handling functions are equally replaced.
</DL>

</P>
<P>
<DL>
<DT><U>Obsolete function:</U> int <B>creat64</B> <I>(const char *<VAR>filename</VAR>, mode_t <VAR>mode</VAR>)</I>
<DD><A NAME="IDX985"></A>
This function is similar to <CODE>creat</CODE>.  It returns a file descriptor
which can be used to access the file named by <VAR>filename</VAR>.  The only
the difference is that on 32 bits systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.

</P>
<P>
To use this file descriptor one must not use the normal operations but
instead the counterparts named <CODE>*64</CODE>, e.g., <CODE>read64</CODE>.

</P>
<P>
When the sources are translated with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is actually available under the name <CODE>open</CODE>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>close</B> <I>(int <VAR>filedes</VAR>)</I>
<DD><A NAME="IDX986"></A>
The function <CODE>close</CODE> closes the file descriptor <VAR>filedes</VAR>.
Closing a file has the following consequences:

</P>

<UL>
<LI>

The file descriptor is deallocated.

<LI>

Any record locks owned by the process on the file are unlocked.

<LI>

When all file descriptors associated with a pipe or FIFO have been closed,
any unread data is discarded.
</UL>

<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>close</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>close</CODE> should be
protected using cancelation handlers.

</P>
<P>
The normal return value from <CODE>close</CODE> is @math{0}; a value of @math{-1}
is returned in case of failure.  The following <CODE>errno</CODE> error
conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>filedes</VAR> argument is not a valid file descriptor.

<DT><CODE>EINTR</CODE>
<DD>
The <CODE>close</CODE> call was interrupted by a signal.
See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.
Here is an example of how to handle <CODE>EINTR</CODE> properly:


<PRE>
TEMP_FAILURE_RETRY (close (desc));
</PRE>

<DT><CODE>ENOSPC</CODE>
<DD>
<DT><CODE>EIO</CODE>
<DD>
<DT><CODE>EDQUOT</CODE>
<DD>
When the file is accessed by NFS, these errors from <CODE>write</CODE> can sometimes
not be detected until <CODE>close</CODE>.  See section <A HREF="libc_216.html#SEC223">Input and Output Primitives</A>, for details
on their meaning.
</DL>

<P>
Please note that there is <EM>no</EM> separate <CODE>close64</CODE> function.
This is not necessary since this function does not determine nor depend
on the mode of the file.  The kernel which performs the <CODE>close</CODE>
operation knows for which mode the descriptor is used and can handle
this situation.
</DL>

</P>
<P>
To close a stream, call <CODE>fclose</CODE> (see section <A HREF="libc_159.html#SEC166">Closing Streams</A>) instead
of trying to close its underlying file descriptor with <CODE>close</CODE>.
This flushes any buffered output and updates the stream object to
indicate that it is closed.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_213.html">previous</A>, <A HREF="libc_215.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
