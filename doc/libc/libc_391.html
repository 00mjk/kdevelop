<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - System V Number Conversion</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_390.html">previous</A>, <A HREF="libc_392.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC398" HREF="libc_toc.html#TOC398">Old-fashioned System V number-to-string functions</A></H2>

<P>
The old System V C library provided three functions to convert
numbers to strings, with unusual and hard-to-use semantics.  The GNU C
library also provides these functions and some natural extensions.

</P>
<P>
These functions are only available in glibc and on systems descended
from AT&#38;T Unix.  Therefore, unless these functions do precisely what you
need, it is better to use <CODE>sprintf</CODE>, which is standard.

</P>
<P>
All these functions are defined in <TT>`stdlib.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>ecvt</B> <I>(double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>)</I>
<DD><A NAME="IDX2274"></A>
The function <CODE>ecvt</CODE> converts the floating-point number <VAR>value</VAR>
to a string with at most <VAR>ndigit</VAR> decimal digits.  The
returned string contains no decimal point or sign. The first digit of
the string is non-zero (unless <VAR>value</VAR> is actually zero) and the
last digit is rounded to nearest.  <CODE>*<VAR>decpt</VAR></CODE> is set to the
index in the string of the first digit after the decimal point.
<CODE>*<VAR>neg</VAR></CODE> is set to a nonzero value if <VAR>value</VAR> is negative,
zero otherwise.

</P>
<P>
If <VAR>ndigit</VAR> decimal digits would exceed the precision of a
<CODE>double</CODE> it is reduced to a system-specific value.

</P>
<P>
The returned string is statically allocated and overwritten by each call
to <CODE>ecvt</CODE>.

</P>
<P>
If <VAR>value</VAR> is zero, it is implementation defined whether
<CODE>*<VAR>decpt</VAR></CODE> is <CODE>0</CODE> or <CODE>1</CODE>.

</P>
<P>
For example: <CODE>ecvt (12.3, 5, &#38;d, &#38;n)</CODE> returns <CODE>"12300"</CODE>
and sets <VAR>d</VAR> to <CODE>2</CODE> and <VAR>n</VAR> to <CODE>0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>fcvt</B> <I>(double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>)</I>
<DD><A NAME="IDX2275"></A>
The function <CODE>fcvt</CODE> is like <CODE>ecvt</CODE>, but <VAR>ndigit</VAR> specifies
the number of digits after the decimal point.  If <VAR>ndigit</VAR> is less
than zero, <VAR>value</VAR> is rounded to the @math{<VAR>ndigit</VAR>+1}'th place to the
left of the decimal point.  For example, if <VAR>ndigit</VAR> is <CODE>-1</CODE>,
<VAR>value</VAR> will be rounded to the nearest 10.  If <VAR>ndigit</VAR> is
negative and larger than the number of digits to the left of the decimal
point in <VAR>value</VAR>, <VAR>value</VAR> will be rounded to one significant digit.

</P>
<P>
If <VAR>ndigit</VAR> decimal digits would exceed the precision of a
<CODE>double</CODE> it is reduced to a system-specific value.

</P>
<P>
The returned string is statically allocated and overwritten by each call
to <CODE>fcvt</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>gcvt</B> <I>(double <VAR>value</VAR>, int <VAR>ndigit</VAR>, char *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX2276"></A>
<CODE>gcvt</CODE> is functionally equivalent to <SAMP>`sprintf(buf, "%*g",
ndigit, value'</SAMP>.  It is provided only for compatibility's sake.  It
returns <VAR>buf</VAR>.

</P>
<P>
If <VAR>ndigit</VAR> decimal digits would exceed the precision of a
<CODE>double</CODE> it is reduced to a system-specific value.
</DL>

</P>
<P>
As extensions, the GNU C library provides versions of these three
functions that take <CODE>long double</CODE> arguments.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>qecvt</B> <I>(long double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>)</I>
<DD><A NAME="IDX2277"></A>
This function is equivalent to <CODE>ecvt</CODE> except that it takes a
<CODE>long double</CODE> for the first parameter and that <VAR>ndigit</VAR> is
restricted by the precision of a <CODE>long double</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>qfcvt</B> <I>(long double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>)</I>
<DD><A NAME="IDX2278"></A>
This function is equivalent to <CODE>fcvt</CODE> except that it
takes a <CODE>long double</CODE> for the first parameter and that <VAR>ndigit</VAR> is
restricted by the precision of a <CODE>long double</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>qgcvt</B> <I>(long double <VAR>value</VAR>, int <VAR>ndigit</VAR>, char *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX2279"></A>
This function is equivalent to <CODE>gcvt</CODE> except that it takes a
<CODE>long double</CODE> for the first parameter and that <VAR>ndigit</VAR> is
restricted by the precision of a <CODE>long double</CODE>.
</DL>

</P>

<P>
<A NAME="IDX2280"></A>
The <CODE>ecvt</CODE> and <CODE>fcvt</CODE> functions, and their <CODE>long double</CODE>
equivalents, all return a string located in a static buffer which is
overwritten by the next call to the function.  The GNU C library
provides another set of extended functions which write the converted
string into a user-supplied buffer.  These have the conventional
<CODE>_r</CODE> suffix.

</P>
<P>
<CODE>gcvt_r</CODE> is not necessary, because <CODE>gcvt</CODE> already uses a
user-supplied buffer.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>ecvt_r</B> <I>(double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>, char *<VAR>buf</VAR>, size_t <VAR>len</VAR>)</I>
<DD><A NAME="IDX2281"></A>
The <CODE>ecvt_r</CODE> function is the same as <CODE>ecvt</CODE>, except
that it places its result into the user-specified buffer pointed to by
<VAR>buf</VAR>, with length <VAR>len</VAR>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>fcvt_r</B> <I>(double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>, char *<VAR>buf</VAR>, size_t <VAR>len</VAR>)</I>
<DD><A NAME="IDX2282"></A>
The <CODE>fcvt_r</CODE> function is the same as <CODE>fcvt</CODE>, except
that it places its result into the user-specified buffer pointed to by
<VAR>buf</VAR>, with length <VAR>len</VAR>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>qecvt_r</B> <I>(long double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>, char *<VAR>buf</VAR>, size_t <VAR>len</VAR>)</I>
<DD><A NAME="IDX2283"></A>
The <CODE>qecvt_r</CODE> function is the same as <CODE>qecvt</CODE>, except
that it places its result into the user-specified buffer pointed to by
<VAR>buf</VAR>, with length <VAR>len</VAR>.

</P>
<P>
This function is a GNU extension.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>qfcvt_r</B> <I>(long double <VAR>value</VAR>, int <VAR>ndigit</VAR>, int *<VAR>decpt</VAR>, int *<VAR>neg</VAR>, char *<VAR>buf</VAR>, size_t <VAR>len</VAR>)</I>
<DD><A NAME="IDX2284"></A>
The <CODE>qfcvt_r</CODE> function is the same as <CODE>qfcvt</CODE>, except
that it places its result into the user-specified buffer pointed to by
<VAR>buf</VAR>, with length <VAR>len</VAR>.

</P>
<P>
This function is a GNU extension.
</DL>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_390.html">previous</A>, <A HREF="libc_392.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
