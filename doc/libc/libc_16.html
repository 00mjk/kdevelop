<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Checking for Errors</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_15.html">previous</A>, <A HREF="libc_17.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC16" HREF="libc_toc.html#TOC16">Checking for Errors</A></H2>

<P>
Most library functions return a special value to indicate that they have
failed.  The special value is typically <CODE>-1</CODE>, a null pointer, or a
constant such as <CODE>EOF</CODE> that is defined for that purpose.  But this
return value tells you only that an error has occurred.  To find out
what kind of error it was, you need to look at the error code stored in the
variable <CODE>errno</CODE>.  This variable is declared in the header file
<TT>`errno.h'</TT>.
<A NAME="IDX58"></A>

</P>
<P>
<DL>
<DT><U>Variable:</U> volatile int <B>errno</B>
<DD><A NAME="IDX59"></A>
The variable <CODE>errno</CODE> contains the system error number.  You can
change the value of <CODE>errno</CODE>.

</P>
<P>
Since <CODE>errno</CODE> is declared <CODE>volatile</CODE>, it might be changed
asynchronously by a signal handler; see section <A HREF="libc_438.html#SEC445">Defining Signal Handlers</A>.
However, a properly written signal handler saves and restores the value
of <CODE>errno</CODE>, so you generally do not need to worry about this
possibility except when writing signal handlers.

</P>
<P>
The initial value of <CODE>errno</CODE> at program startup is zero.  Many
library functions are guaranteed to set it to certain nonzero values
when they encounter certain kinds of errors.  These error conditions are
listed for each function.  These functions do not change <CODE>errno</CODE>
when they succeed; thus, the value of <CODE>errno</CODE> after a successful
call is not necessarily zero, and you should not use <CODE>errno</CODE> to
determine <EM>whether</EM> a call failed.  The proper way to do that is
documented for each function.  <EM>If</EM> the call the failed, you can
examine <CODE>errno</CODE>.

</P>
<P>
Many library functions can set <CODE>errno</CODE> to a nonzero value as a
result of calling other library functions which might fail.  You should
assume that any library function might alter <CODE>errno</CODE> when the
function returns an error.

</P>
<P>
<STRONG>Portability Note:</STRONG> ISO C specifies <CODE>errno</CODE> as a
"modifiable lvalue" rather than as a variable, permitting it to be
implemented as a macro.  For example, its expansion might involve a
function call, like <CODE>*_errno ()</CODE>.  In fact, that is what it is
on the GNU system itself.  The GNU library, on non-GNU systems, does
whatever is right for the particular system.

</P>
<P>
There are a few library functions, like <CODE>sqrt</CODE> and <CODE>atan</CODE>,
that return a perfectly legitimate value in case of an error, but also
set <CODE>errno</CODE>.  For these functions, if you want to check to see
whether an error occurred, the recommended method is to set <CODE>errno</CODE>
to zero before calling the function, and then check its value afterward.
</DL>

</P>
<P>
<A NAME="IDX60"></A>
All the error codes have symbolic names; they are macros defined in
<TT>`errno.h'</TT>.  The names start with <SAMP>`E'</SAMP> and an upper-case
letter or digit; you should consider names of this form to be
reserved names.  See section <A HREF="libc_12.html#SEC12">Reserved Names</A>.

</P>
<P>
The error code values are all positive integers and are all distinct,
with one exception: <CODE>EWOULDBLOCK</CODE> and <CODE>EAGAIN</CODE> are the same.
Since the values are distinct, you can use them as labels in a
<CODE>switch</CODE> statement; just don't use both <CODE>EWOULDBLOCK</CODE> and
<CODE>EAGAIN</CODE>.  Your program should not make any other assumptions about
the specific values of these symbolic constants.

</P>
<P>
The value of <CODE>errno</CODE> doesn't necessarily have to correspond to any
of these macros, since some library functions might return other error
codes of their own for other situations.  The only values that are
guaranteed to be meaningful for a particular library function are the
ones that this manual lists for that function.

</P>
<P>
On non-GNU systems, almost any system call can return <CODE>EFAULT</CODE> if
it is given an invalid pointer as an argument.  Since this could only
happen as a result of a bug in your program, and since it will not
happen on the GNU system, we have saved space by not mentioning
<CODE>EFAULT</CODE> in the descriptions of individual functions.

</P>
<P>
In some Unix systems, many system calls can also return <CODE>EFAULT</CODE> if
given as an argument a pointer into the stack, and the kernel for some
obscure reason fails in its attempt to extend the stack.  If this ever
happens, you should probably try using statically or dynamically
allocated memory instead of stack memory on that system.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_15.html">previous</A>, <A HREF="libc_17.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
