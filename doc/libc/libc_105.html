<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - The Elegant and Fast Way</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_104.html">previous</A>, <A HREF="libc_106.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC109" HREF="libc_toc.html#TOC109">Pinpoint Access to Locale Data</A></H3>

<P>
When writing the X/Open Portability Guide the authors realized that the
<CODE>localeconv</CODE> function is not enough to provide reasonable access to
the locale information.  The information which was meant to be available
in the locale (as later specified in the POSIX.1 standard) requires more
possibilities to access it.  Therefore the <CODE>nl_langinfo</CODE> function
was introduced.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>nl_langinfo</B> <I>(nl_item <VAR>item</VAR>)</I>
<DD><A NAME="IDX603"></A>
The <CODE>nl_langinfo</CODE> function can be used to access individual
elements of the locale categories.  I.e., unlike the <CODE>localeconv</CODE>
function which always returns all the information <CODE>nl_langinfo</CODE>
lets the caller select what information is necessary.  This is very
fast and it is no problem to call this function multiple times.

</P>
<P>
The second advantage is that not only the numeric and monetary
formatting information is available.  Also the information of the
<CODE>LC_TIME</CODE> and <CODE>LC_MESSAGES</CODE> categories is available.

</P>
<P>
The type <CODE>nl_type</CODE> is defined in <TT>`nl_types.h'</TT>.
The argument <VAR>item</VAR> is a numeric values which must be one of the
values defined in the header <TT>`langinfo.h'</TT>.  The X/Open standard
defines the following values:

</P>
<DL COMPACT>

<DT><CODE>ABDAY_1</CODE>
<DD>
<A NAME="IDX604"></A>
<DT><CODE>ABDAY_2</CODE>
<DD>
<A NAME="IDX605"></A>
<DT><CODE>ABDAY_3</CODE>
<DD>
<A NAME="IDX606"></A>
<DT><CODE>ABDAY_4</CODE>
<DD>
<A NAME="IDX607"></A>
<DT><CODE>ABDAY_5</CODE>
<DD>
<A NAME="IDX608"></A>
<DT><CODE>ABDAY_6</CODE>
<DD>
<A NAME="IDX609"></A>
<DT><CODE>ABDAY_7</CODE>
<DD>
<A NAME="IDX610"></A>
<CODE>nl_langinfo</CODE> returns the abbreviated weekday name.  <CODE>ABDAY_1</CODE>
corresponds to Sunday.
<DT><CODE>DAY_1</CODE>
<DD>
<A NAME="IDX611"></A>
<DT><CODE>DAY_2</CODE>
<DD>
<A NAME="IDX612"></A>
<DT><CODE>DAY_3</CODE>
<DD>
<A NAME="IDX613"></A>
<DT><CODE>DAY_4</CODE>
<DD>
<A NAME="IDX614"></A>
<DT><CODE>DAY_5</CODE>
<DD>
<A NAME="IDX615"></A>
<DT><CODE>DAY_6</CODE>
<DD>
<A NAME="IDX616"></A>
<DT><CODE>DAY_7</CODE>
<DD>
<A NAME="IDX617"></A>
Similar to <CODE>ABDAY_1</CODE> etc, but here the return value is the
unabbreviated weekday name.
<DT><CODE>ABMON_1</CODE>
<DD>
<A NAME="IDX618"></A>
<DT><CODE>ABMON_2</CODE>
<DD>
<A NAME="IDX619"></A>
<DT><CODE>ABMON_3</CODE>
<DD>
<A NAME="IDX620"></A>
<DT><CODE>ABMON_4</CODE>
<DD>
<A NAME="IDX621"></A>
<DT><CODE>ABMON_5</CODE>
<DD>
<A NAME="IDX622"></A>
<DT><CODE>ABMON_6</CODE>
<DD>
<A NAME="IDX623"></A>
<DT><CODE>ABMON_7</CODE>
<DD>
<A NAME="IDX624"></A>
<DT><CODE>ABMON_8</CODE>
<DD>
<A NAME="IDX625"></A>
<DT><CODE>ABMON_9</CODE>
<DD>
<A NAME="IDX626"></A>
<DT><CODE>ABMON_10</CODE>
<DD>
<A NAME="IDX627"></A>
<DT><CODE>ABMON_11</CODE>
<DD>
<A NAME="IDX628"></A>
<DT><CODE>ABMON_12</CODE>
<DD>
<A NAME="IDX629"></A>
The return value is abbreviated name for the month names.  <CODE>ABMON_1</CODE>
corresponds to January.
<DT><CODE>MON_1</CODE>
<DD>
<A NAME="IDX630"></A>
<DT><CODE>MON_2</CODE>
<DD>
<A NAME="IDX631"></A>
<DT><CODE>MON_3</CODE>
<DD>
<A NAME="IDX632"></A>
<DT><CODE>MON_4</CODE>
<DD>
<A NAME="IDX633"></A>
<DT><CODE>MON_5</CODE>
<DD>
<A NAME="IDX634"></A>
<DT><CODE>MON_6</CODE>
<DD>
<A NAME="IDX635"></A>
<DT><CODE>MON_7</CODE>
<DD>
<A NAME="IDX636"></A>
<DT><CODE>MON_8</CODE>
<DD>
<A NAME="IDX637"></A>
<DT><CODE>MON_9</CODE>
<DD>
<A NAME="IDX638"></A>
<DT><CODE>MON_10</CODE>
<DD>
<A NAME="IDX639"></A>
<DT><CODE>MON_11</CODE>
<DD>
<A NAME="IDX640"></A>
<DT><CODE>MON_12</CODE>
<DD>
<A NAME="IDX641"></A>
Similar to <CODE>ABMON_1</CODE> etc but here the month names are not abbreviated.
Here the first value <CODE>MON_1</CODE> also corresponds to January.
<DT><CODE>AM_STR</CODE>
<DD>
<A NAME="IDX642"></A>
<DT><CODE>PM_STR</CODE>
<DD>
<A NAME="IDX643"></A>
The return values are strings which can be used in the time representation
which uses to American 1 to 12 hours plus am/pm representation.

Please note that in locales which do not know this time representation
these strings actually might be empty and therefore the am/pm format
cannot be used at all.
<DT><CODE>D_T_FMT</CODE>
<DD>
<A NAME="IDX644"></A>
The return value can be used as a format string for <CODE>strftime</CODE> to
represent time and date in a locale specific way.
<DT><CODE>D_FMT</CODE>
<DD>
<A NAME="IDX645"></A>
The return value can be used as a format string for <CODE>strftime</CODE> to
represent a date in a locale specific way.
<DT><CODE>T_FMT</CODE>
<DD>
<A NAME="IDX646"></A>
The return value can be used as a format string for <CODE>strftime</CODE> to
represent time in a locale specific way.
<DT><CODE>T_FMT_AMPM</CODE>
<DD>
<A NAME="IDX647"></A>
The return value can be used as a format string for <CODE>strftime</CODE> to
represent time using the American-style am/pm format.

Please note that if the am/pm format does not make any sense for the
selected locale the returned value might be the same as the one for
<CODE>T_FMT</CODE>.
<DT><CODE>ERA</CODE>
<DD>
<A NAME="IDX648"></A>
The return value is value representing the eras of time used in the
current locale.

Most locales do not define this value.  An example for a locale which
does define this value is the Japanese.  Here the traditional data
representation is based on the eras measured by the reigns of the
emperors.

Normally it should not be necessary to use this value directly.  Using
the <CODE>E</CODE> modifier for its formats the <CODE>strftime</CODE> functions can
be made to use this information.  The format of the returned string
is not specified and therefore one should not generalize the knowledge
about the representation on one system.
<DT><CODE>ERA_YEAR</CODE>
<DD>
<A NAME="IDX649"></A>
The return value describes the name years for the eras of this locale.
As for <CODE>ERA</CODE> it should not be necessary to use this value directly.
<DT><CODE>ERA_D_T_FMT</CODE>
<DD>
<A NAME="IDX650"></A>
This return value can be used as a format string for <CODE>strftime</CODE> to
represent time and date using the era representation in a locale
specific way.
<DT><CODE>ERA_D_FMT</CODE>
<DD>
<A NAME="IDX651"></A>
This return value can be used as a format string for <CODE>strftime</CODE> to
represent a date using the era representation in a locale specific way.
<DT><CODE>ERA_T_FMT</CODE>
<DD>
<A NAME="IDX652"></A>
This return value can be used as a format string for <CODE>strftime</CODE> to
represent time using the era representation in a locale specific way.
<DT><CODE>ALT_DIGITS</CODE>
<DD>
<A NAME="IDX653"></A>
The return value is a representation of up to @math{100} values used to
represent the values @math{0} to @math{99}.  As for <CODE>ERA</CODE> this
value is not intended to be used directly, but instead indirectly
through the <CODE>strftime</CODE> function.  When the modifier <CODE>O</CODE> is
used for format which would use numerals to represent hours, minutes,
seconds, weekdays, months, or weeks the appropriate value for this
locale values is used instead of the number.
<DT><CODE>INT_CURR_SYMBOL</CODE>
<DD>
<A NAME="IDX654"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>int_curr_symbol</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>CURRENCY_SYMBOL</CODE>
<DD>
<A NAME="IDX655"></A>
<DT><CODE>CRNCYSTR</CODE>
<DD>
<A NAME="IDX656"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>currency_symbol</CODE> element of the <CODE>struct lconv</CODE>.

<CODE>CRNCYSTR</CODE> is a deprecated alias, still required by Unix98.
<DT><CODE>MON_DECIMAL_POINT</CODE>
<DD>
<A NAME="IDX657"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>mon_decimal_point</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>MON_THOUSANDS_SEP</CODE>
<DD>
<A NAME="IDX658"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>mon_thousands_sep</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>MON_GROUPING</CODE>
<DD>
<A NAME="IDX659"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>mon_grouping</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>POSITIVE_SIGN</CODE>
<DD>
<A NAME="IDX660"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>positive_sign</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>NEGATIVE_SIGN</CODE>
<DD>
<A NAME="IDX661"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>negative_sign</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>INT_FRAC_DIGITS</CODE>
<DD>
<A NAME="IDX662"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>int_frac_digits</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>FRAC_DIGITS</CODE>
<DD>
<A NAME="IDX663"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>frac_digits</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>P_CS_PRECEDES</CODE>
<DD>
<A NAME="IDX664"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>p_cs_precedes</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>P_SEP_BY_SPACE</CODE>
<DD>
<A NAME="IDX665"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>p_sep_by_space</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>N_CS_PRECEDES</CODE>
<DD>
<A NAME="IDX666"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>n_cs_precedes</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>N_SEP_BY_SPACE</CODE>
<DD>
<A NAME="IDX667"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>n_sep_by_space</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>P_SIGN_POSN</CODE>
<DD>
<A NAME="IDX668"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>p_sign_posn</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>N_SIGN_POSN</CODE>
<DD>
<A NAME="IDX669"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>n_sign_posn</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>DECIMAL_POINT</CODE>
<DD>
<A NAME="IDX670"></A>
<DT><CODE>RADIXCHAR</CODE>
<DD>
<A NAME="IDX671"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>decimal_point</CODE> element of the <CODE>struct lconv</CODE>.

The name <CODE>RADIXCHAR</CODE> is a deprecated alias still used in Unix98.
<DT><CODE>THOUSANDS_SEP</CODE>
<DD>
<A NAME="IDX672"></A>
<DT><CODE>THOUSEP</CODE>
<DD>
<A NAME="IDX673"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>thousands_sep</CODE> element of the <CODE>struct lconv</CODE>.

The name <CODE>THOUSEP</CODE> is a deprecated alias still used in Unix98.
<DT><CODE>GROUPING</CODE>
<DD>
<A NAME="IDX674"></A>
This value is the same as returned by <CODE>localeconv</CODE> in the
<CODE>grouping</CODE> element of the <CODE>struct lconv</CODE>.
<DT><CODE>YESEXPR</CODE>
<DD>
<A NAME="IDX675"></A>
The return value is a regular expression which can be used with the
<CODE>regex</CODE> function to recognize a positive response to a yes/no
question.
<DT><CODE>NOEXPR</CODE>
<DD>
<A NAME="IDX676"></A>
The return value is a regular expression which can be used with the
<CODE>regex</CODE> function to recognize a negative response to a yes/no
question.
<DT><CODE>YESSTR</CODE>
<DD>
<A NAME="IDX677"></A>
The return value is a locale specific translation of the positive response
to a yes/no question.

Using this value is deprecated since it is a very special case of
message translation and this better can be handled using the message
translation functions (see section <A HREF="libc_107.html#SEC111">Message Translation</A>).
<DT><CODE>NOSTR</CODE>
<DD>
<A NAME="IDX678"></A>
The return value is a locale specific translation of the negative response
to a yes/no question.  What is said for <CODE>YESSTR</CODE> is also true here.
</DL>

<P>
The file <TT>`langinfo.h'</TT> defines a lot more symbols but none of them
is official.  Using them is completely unportable and the format of the
return values might change.  Therefore it is highly requested to not use
them in any situation.

</P>
<P>
Please note that the return value for any valid argument can be used for
in all situations (with the possible exception of the am/pm time format
related values).  If the user has not selected any locale for the
appropriate category <CODE>nl_langinfo</CODE> returns the information from the
<CODE>"C"</CODE> locale.  It is therefore possible to use this function as
shown in the example below.

</P>
<P>
If the argument <VAR>item</VAR> is not valid a pointer to an empty string is
returned.
</DL>

</P>
<P>
An example for the use of <CODE>nl_langinfo</CODE> is a function which has to
print a given date and time in the locale specific way.  At first one
might think the since <CODE>strftime</CODE> internally uses the locale
information writing something like the following is enough:

</P>

<PRE>
size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
  return strftime (s, len, "%X %D", tp);
}
</PRE>

<P>
The format contains no weekday or month names and therefore is
internationally usable.  Wrong!  The output produced is something like
<CODE>"hh:mm:ss MM/DD/YY"</CODE>.  This format is only recognizable in the
USA.  Other countries use different formats.  Therefore the function
should be rewritten like this:

</P>

<PRE>
size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
  return strftime (s, len, nl_langinfo (D_T_FMT), tp);
}
</PRE>

<P>
Now the date and time format which is explicitly selected for the locale
in place when the program runs is used.  If the user selects the locale
correctly there should never be a misunderstanding over the time and
date format.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_104.html">previous</A>, <A HREF="libc_106.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
