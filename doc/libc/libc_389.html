<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Parsing of Integers</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_388.html">previous</A>, <A HREF="libc_390.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC396" HREF="libc_toc.html#TOC396">Parsing of Integers</A></H3>

<P>
<A NAME="IDX2253"></A>
These functions are declared in <TT>`stdlib.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>strtol</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2254"></A>
The <CODE>strtol</CODE> ("string-to-long") function converts the initial
part of <VAR>string</VAR> to a signed integer, which is returned as a value
of type <CODE>long int</CODE>.

</P>
<P>
This function attempts to decompose <VAR>string</VAR> as follows:

</P>

<UL>
<LI>

A (possibly empty) sequence of whitespace characters.  Which characters
are whitespace is determined by the <CODE>isspace</CODE> function
(see section <A HREF="libc_58.html#SEC58">Classification of Characters</A>).  These are discarded.

<LI>

An optional plus or minus sign (<SAMP>`+'</SAMP> or <SAMP>`-'</SAMP>).

<LI>

A nonempty sequence of digits in the radix specified by <VAR>base</VAR>.

If <VAR>base</VAR> is zero, decimal radix is assumed unless the series of
digits begins with <SAMP>`0'</SAMP> (specifying octal radix), or <SAMP>`0x'</SAMP> or
<SAMP>`0X'</SAMP> (specifying hexadecimal radix); in other words, the same
syntax used for integer constants in C.

Otherwise <VAR>base</VAR> must have a value between <CODE>2</CODE> and <CODE>35</CODE>.
If <VAR>base</VAR> is <CODE>16</CODE>, the digits may optionally be preceded by
<SAMP>`0x'</SAMP> or <SAMP>`0X'</SAMP>.  If base has no legal value the value returned
is <CODE>0l</CODE> and the global variable <CODE>errno</CODE> is set to <CODE>EINVAL</CODE>.

<LI>

Any remaining characters in the string.  If <VAR>tailptr</VAR> is not a null
pointer, <CODE>strtol</CODE> stores a pointer to this tail in
<CODE>*<VAR>tailptr</VAR></CODE>.
</UL>

<P>
If the string is empty, contains only whitespace, or does not contain an
initial substring that has the expected syntax for an integer in the
specified <VAR>base</VAR>, no conversion is performed.  In this case,
<CODE>strtol</CODE> returns a value of zero and the value stored in
<CODE>*<VAR>tailptr</VAR></CODE> is the value of <VAR>string</VAR>.

</P>
<P>
In a locale other than the standard <CODE>"C"</CODE> locale, this function
may recognize additional implementation-dependent syntax.

</P>
<P>
If the string has valid syntax for an integer but the value is not
representable because of overflow, <CODE>strtol</CODE> returns either
<CODE>LONG_MAX</CODE> or <CODE>LONG_MIN</CODE> (see section <A HREF="libc_629.html#SEC637">Range of an Integer Type</A>), as
appropriate for the sign of the value.  It also sets <CODE>errno</CODE>
to <CODE>ERANGE</CODE> to indicate there was overflow.

</P>
<P>
You should not check for errors by examining the return value of
<CODE>strtol</CODE>, because the string might be a valid representation of
<CODE>0l</CODE>, <CODE>LONG_MAX</CODE>, or <CODE>LONG_MIN</CODE>.  Instead, check whether
<VAR>tailptr</VAR> points to what you expect after the number
(e.g. <CODE>'\0'</CODE> if the string should end after the number).  You also
need to clear <VAR>errno</VAR> before the call and check it afterward, in
case there was overflow.

</P>
<P>
There is an example at the end of this section.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long int <B>strtoul</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2255"></A>
The <CODE>strtoul</CODE> ("string-to-unsigned-long") function is like
<CODE>strtol</CODE> except it returns an <CODE>unsigned long int</CODE> value.  If
the number has a leading <SAMP>`-'</SAMP> sign, the return value is negated.
The syntax is the same as described above for <CODE>strtol</CODE>.  The value
returned on overflow is <CODE>ULONG_MAX</CODE> (see section <A HREF="libc_629.html#SEC637">Range of an Integer Type</A>).

</P>
<P>
<CODE>strtoul</CODE> sets <VAR>errno</VAR> to <CODE>EINVAL</CODE> if <VAR>base</VAR> is out of
range, or <CODE>ERANGE</CODE> on overflow.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>strtoll</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2256"></A>
The <CODE>strtoll</CODE> function is like <CODE>strtol</CODE> except that it returns
a <CODE>long long int</CODE> value, and accepts numbers with a correspondingly
larger range.

</P>
<P>
If the string has valid syntax for an integer but the value is not
representable because of overflow, <CODE>strtoll</CODE> returns either
<CODE>LONG_LONG_MAX</CODE> or <CODE>LONG_LONG_MIN</CODE> (see section <A HREF="libc_629.html#SEC637">Range of an Integer Type</A>), as
appropriate for the sign of the value.  It also sets <CODE>errno</CODE> to
<CODE>ERANGE</CODE> to indicate there was overflow.

</P>
<P>
The <CODE>strtoll</CODE> function was introduced in ISO C 9x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>strtoq</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2257"></A>
<CODE>strtoq</CODE> ("string-to-quad-word") is the BSD name for <CODE>strtoll</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long long int <B>strtoull</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2258"></A>
The <CODE>strtoull</CODE> function is like <CODE>strtoul</CODE> except that it
returns an <CODE>unsigned long long int</CODE>.  The value returned on overflow
is <CODE>ULONG_LONG_MAX</CODE> (see section <A HREF="libc_629.html#SEC637">Range of an Integer Type</A>).

</P>
<P>
The <CODE>strtoull</CODE> function was introduced in ISO C 9x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned long long int <B>strtouq</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>, int <VAR>base</VAR>)</I>
<DD><A NAME="IDX2259"></A>
<CODE>strtouq</CODE> is the BSD name for <CODE>strtoull</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long int <B>atol</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX2260"></A>
This function is similar to the <CODE>strtol</CODE> function with a <VAR>base</VAR>
argument of <CODE>10</CODE>, except that it need not detect overflow errors.
The <CODE>atol</CODE> function is provided mostly for compatibility with
existing code; using <CODE>strtol</CODE> is more robust.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>atoi</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX2261"></A>
This function is like <CODE>atol</CODE>, except that it returns an <CODE>int</CODE>.
The <CODE>atoi</CODE> function is also considered obsolete; use <CODE>strtol</CODE>
instead.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>atoll</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX2262"></A>
This function is similar to <CODE>atol</CODE>, except it returns a <CODE>long
long int</CODE>.

</P>
<P>
The <CODE>atoll</CODE> function was introduced in ISO C 9x.  It too is
obsolete (despite having just been added); use <CODE>strtoll</CODE> instead.
</DL>

</P>
<P>
<A NAME="IDX2263"></A>
<A NAME="IDX2264"></A>
<A NAME="IDX2265"></A>
<A NAME="IDX2266"></A>
<A NAME="IDX2267"></A>
<A NAME="IDX2268"></A>
Some locales specify a printed syntax for numbers other than the one
that these functions understand.  If you need to read numbers formatted
in some other locale, you can use the <CODE>strtoX_l</CODE> functions.  Each
of the <CODE>strtoX</CODE> functions has a counterpart with <SAMP>`_l'</SAMP> added to
its name.  The <SAMP>`_l'</SAMP> counterparts take an additional argument: a
pointer to an <CODE>locale_t</CODE> structure, which describes how the numbers
to be read are formatted.  See section <A HREF="libc_94.html#SEC98">Locales and Internationalization</A>.

</P>
<P>
<STRONG>Portability Note:</STRONG> These functions are all GNU extensions.  You
can also use <CODE>scanf</CODE> or its relatives, which have the <SAMP>`''</SAMP> flag
for parsing numeric input according to the current locale
(see section <A HREF="libc_189.html#SEC196">Numeric Input Conversions</A>).  This feature is standard.

</P>
<P>
Here is a function which parses a string as a sequence of integers and
returns the sum of them:

</P>

<PRE>
int
sum_ints_from_string (char *string)
{
  int sum = 0;

  while (1) {
    char *tail;
    int next;

    /* Skip whitespace by hand, to detect the end.  */
    while (isspace (*string)) string++;
    if (*string == 0)
      break;

    /* There is more nonwhitespace,  */
    /* so it ought to be another number.  */
    errno = 0;
    /* Parse it.  */
    next = strtol (string, &#38;tail, 0);
    /* Add it in, if not overflow.  */
    if (errno)
      printf ("Overflow\n");
    else
      sum += next;
    /* Advance past it.  */
    string = tail;
  }

  return sum;
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_388.html">previous</A>, <A HREF="libc_390.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
