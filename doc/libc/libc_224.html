<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Memory-mapped I/O</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_223.html">previous</A>, <A HREF="libc_225.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC231" HREF="libc_toc.html#TOC231">Memory-mapped I/O</A></H2>

<P>
On modern operating systems, it is possible to <STRONG>mmap</STRONG> (pronounced
"em-map") a file to a region of memory.  When this is done, the file can
be accessed just like an array in the program.

</P>
<P>
This is more efficient than <CODE>read</CODE> or <CODE>write</CODE>, as only regions
of the file a program actually accesses are loaded.  Accesses to
not-yet-loaded parts of the mmapped region are handled in the same way as
swapped out pages.

</P>
<P>
Since mmapped pages can be stored back to their file when physical memory
is low, it is possible to mmap files orders of magnitude larger than both
the physical memory <EM>and</EM> swap space.  The only limit is address
space.  The theoretical limit is 4GB on a 32-bit machine - however, the
actual limit will be smaller since some areas will be reserved for other
purposes.

</P>
<P>
Memory mapping only works on entire pages of memory.  Thus, addresses
for mapping must be page-aligned, and length values will be rounded up.
To determine the size of a page the machine uses one should use

</P>

<PRE>
size_t page_size = (size_t) sysconf (_SC_PAGESIZE);
</PRE>

<P>
These functions are declared in <TT>`sys/mman.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>mmap</B> <I>(void *<VAR>address</VAR>, size_t <VAR>length</VAR>,int <VAR>protect</VAR>, int <VAR>flags</VAR>, int <VAR>filedes</VAR>, off_t <VAR>offset</VAR>)</I>
<DD><A NAME="IDX1038"></A>

</P>
<P>
The <CODE>mmap</CODE> function creates a new mapping, connected to bytes
(<VAR>offset</VAR>) to (<VAR>offset</VAR> + <VAR>length</VAR>) in the file open on
<VAR>filedes</VAR>.

</P>
<P>
<VAR>address</VAR> gives a preferred starting address for the mapping.
<CODE>NULL</CODE> expresses no preference. Any previous mapping at that
address is automatically removed. The address you give may still be
changed, unless you use the <CODE>MAP_FIXED</CODE> flag.

</P>
<P>
<A NAME="IDX1039"></A>
<A NAME="IDX1040"></A>
<A NAME="IDX1041"></A>
<VAR>protect</VAR> contains flags that control what kind of access is
permitted.  They include <CODE>PROT_READ</CODE>, <CODE>PROT_WRITE</CODE>, and
<CODE>PROT_EXEC</CODE>, which permit reading, writing, and execution,
respectively.  Inappropriate access will cause a segfault (see section <A HREF="libc_423.html#SEC430">Program Error Signals</A>).

</P>
<P>
Note that most hardware designs cannot support write permission without
read permission, and many do not distinguish read and execute permission.
Thus, you may receive wider permissions than you ask for, and mappings of
write-only files may be denied even if you do not use <CODE>PROT_READ</CODE>.

</P>
<P>
<VAR>flags</VAR> contains flags that control the nature of the map.
One of <CODE>MAP_SHARED</CODE> or <CODE>MAP_PRIVATE</CODE> must be specified.

</P>
<P>
They include:

</P>
<DL COMPACT>

<DT><CODE>MAP_PRIVATE</CODE>
<DD>
<A NAME="IDX1042"></A>
This specifies that writes to the region should never be written back
to the attached file.  Instead, a copy is made for the process, and the
region will be swapped normally if memory runs low.  No other process will
see the changes.

Since private mappings effectively revert to ordinary memory
when written to, you must have enough virtual memory for a copy of
the entire mmapped region if you use this mode with <CODE>PROT_WRITE</CODE>.

<DT><CODE>MAP_SHARED</CODE>
<DD>
<A NAME="IDX1043"></A>
This specifies that writes to the region will be written back to the
file.  Changes made will be shared immediately with other processes
mmaping the same file.

Note that actual writing may take place at any time.  You need to use
<CODE>msync</CODE>, described below, if it is important that other processes
using conventional I/O get a consistent view of the file.

<DT><CODE>MAP_FIXED</CODE>
<DD>
<A NAME="IDX1044"></A>
This forces the system to use the exact mapping address specified in
<VAR>address</VAR> and fail if it can't.

<DT><CODE>MAP_ANONYMOUS</CODE>
<DD>
<A NAME="IDX1045"></A>
<DT><CODE>MAP_ANON</CODE>
<DD>
<A NAME="IDX1046"></A>
This flag tells the system to create an anonymous mapping, not connected
to a file.  <VAR>filedes</VAR> and <VAR>off</VAR> are ignored, and the region is
initialized with zeros.

Anonymous maps are used as the basic primitive to extend the heap on some
systems.  They are also useful to share data between multiple tasks
without creating a file.

On some systems using private anonymous mmaps is more efficient than using
<CODE>malloc</CODE> for large blocks.  This is not an issue with the GNU C library,
as the included <CODE>malloc</CODE> automatically uses <CODE>mmap</CODE> where appropriate.

</DL>

<P>
<CODE>mmap</CODE> returns the address of the new mapping, or @math{-1} for an
error.

</P>
<P>
Possible errors include:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
Either <VAR>address</VAR> was unusable, or inconsistent <VAR>flags</VAR> were
given.

<DT><CODE>EACCES</CODE>
<DD>
<VAR>filedes</VAR> was not open for the type of access specified in <VAR>protect</VAR>.

<DT><CODE>ENOMEM</CODE>
<DD>
Either there is not enough memory for the operation, or the process is
out of address space.

<DT><CODE>ENODEV</CODE>
<DD>
This file is of a type that doesn't support mapping.

<DT><CODE>ENOEXEC</CODE>
<DD>
The file is on a filesystem that doesn't support mapping.

</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>munmap</B> <I>(void *<VAR>addr</VAR>, size_t <VAR>length</VAR>)</I>
<DD><A NAME="IDX1047"></A>

</P>
<P>
<CODE>munmap</CODE> removes any memory maps from (<VAR>addr</VAR>) to (<VAR>addr</VAR> +
<VAR>length</VAR>).  <VAR>length</VAR> should be the length of the mapping.

</P>
<P>
It is safe to un-map multiple mappings in one command, or include unmapped
space in the range.  It is also possible to unmap only part of an existing
mapping, however only entire pages can be removed.  If <VAR>length</VAR> is not
an even number of pages, it will be rounded up.

</P>
<P>
It returns @math{0} for success and @math{-1} for an error.

</P>
<P>
One error is possible:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
The memory range given was outside the user mmap range, or wasn't page
aligned.

</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>msync</B> <I>(void *<VAR>address</VAR>, size_t <VAR>length</VAR>, int <VAR>flags</VAR>)</I>
<DD><A NAME="IDX1048"></A>

</P>
<P>
When using shared mappings, the kernel can write the file at any time
before the mapping is removed.  To be certain data has actually been
written to the file and will be accessible to non-memory-mapped I/O, it
is necessary to use this function.

</P>
<P>
It operates on the region <VAR>address</VAR> to (<VAR>address</VAR> + <VAR>length</VAR>).
It may be used on part of a mapping or multiple mappings, however the
region given should not contain any unmapped space.

</P>
<P>
<VAR>flags</VAR> can contain some options:

</P>
<DL COMPACT>

<DT><CODE>MS_SYNC</CODE>
<DD>
<A NAME="IDX1049"></A>

This flag makes sure the data is actually written <EM>to disk</EM>.
Normally <CODE>msync</CODE> only makes sure that accesses to a file with
conventional I/O reflect the recent changes.

<DT><CODE>MS_ASYNC</CODE>
<DD>
<A NAME="IDX1050"></A>

This tells <CODE>msync</CODE> to begin the synchronization, but not to wait for
it to complete.

</DL>

<P>
<CODE>msync</CODE> returns @math{0} for success and @math{-1} for
error.  Errors include:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
An invalid region was given, or the <VAR>flags</VAR> were invalid.

<DT><CODE>EFAULT</CODE>
<DD>
There is no existing mapping in at least part of the given region.

</DL>

</DL>

<P>
<DL>
<DT><U>Function:</U> void * <B>mremap</B> <I>(void *<VAR>address</VAR>, size_t <VAR>length</VAR>, size_t <VAR>new_length</VAR>, int <VAR>flag</VAR>)</I>
<DD><A NAME="IDX1051"></A>

</P>
<P>
This function can be used to change the size of an existing memory
area. <VAR>address</VAR> and <VAR>length</VAR> must cover a region entirely mapped
in the same <CODE>mmap</CODE> statement. A new mapping with the same
characteristics will be returned, but a with the length <VAR>new_length</VAR>
instead.

</P>
<P>
One option is possible, <CODE>MREMAP_MAYMOVE</CODE>. If it is given in
<VAR>flags</VAR>, the system may remove the existing mapping and create a new
one of the desired length in another location.

</P>
<P>
The address of the resulting mapping is returned, or @math{-1}. Possible
error codes include:

</P>
<P>
This function is only available on a few systems.  Except for performing
optional optimizations one should not rely on this function.
<DL COMPACT>

<DT><CODE>EFAULT</CODE>
<DD>
There is no existing mapping in at least part of the original region, or
the region covers two or more distinct mappings.

<DT><CODE>EINVAL</CODE>
<DD>
The address given is misaligned or inappropriate.

<DT><CODE>EAGAIN</CODE>
<DD>
The region has pages locked, and if extended it would exceed the
process's resource limit for locked pages.  See section <A HREF="libc_411.html#SEC418">Limiting Resource Usage</A>.

<DT><CODE>ENOMEM</CODE>
<DD>
The region is private writable, and insufficient virtual memory is
available to extend it.  Also, this error will occur if
<CODE>MREMAP_MAYMOVE</CODE> is not given and the extension would collide with
another mapped region.

</DL>
</DL>

<P>
Not all file descriptors may be mapped.  Sockets, pipes, and most devices
only allow sequential access and do not fit into the mapping abstraction.
In addition, some regular files may not be mmapable, and older kernels may
not support mapping at all.  Thus, programs using <CODE>mmap</CODE> should
have a fallback method to use should it fail. See section `Mmap' in <CITE>GNU Coding Standards</CITE>.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_223.html">previous</A>, <A HREF="libc_225.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
