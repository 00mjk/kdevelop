<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Special Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_360.html">previous</A>, <A HREF="libc_362.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC368" HREF="libc_toc.html#TOC368">Special Functions</A></H2>
<P>
<A NAME="IDX1958"></A>
<A NAME="IDX1959"></A>
<A NAME="IDX1960"></A>

</P>
<P>
These are some more exotic mathematical functions, which are sometimes
useful.  Currently they only have real-valued versions.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>erf</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1961"></A>
<DT><U>Function:</U> float <B>erff</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1962"></A>
<DT><U>Function:</U> long double <B>erfl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1963"></A>
<CODE>erf</CODE> returns the error function of <VAR>x</VAR>.  The error
function is defined as
@ifnottex

<PRE>
erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt
</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> double <B>erfc</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1964"></A>
<DT><U>Function:</U> float <B>erfcf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1965"></A>
<DT><U>Function:</U> long double <B>erfcl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1966"></A>
<CODE>erfc</CODE> returns <CODE>1.0 - erf(<VAR>x</VAR>)</CODE>, but computed in a
fashion that avoids round-off error when <VAR>x</VAR> is large.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>lgamma</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1967"></A>
<DT><U>Function:</U> float <B>lgammaf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1968"></A>
<DT><U>Function:</U> long double <B>lgammal</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1969"></A>
<CODE>lgamma</CODE> returns the natural logarithm of the absolute value of
the gamma function of <VAR>x</VAR>.  The gamma function is defined as
@ifnottex

<PRE>
gamma (x) = integral from 0 to @infinity{} of t^(x-1) e^-t dt
</PRE>

<P>
<A NAME="IDX1970"></A>
The sign of the gamma function is stored in the global variable
<VAR>signgam</VAR>, which is declared in <TT>`math.h'</TT>.  It is <CODE>1</CODE> if
the intermediate result was positive or zero, and, <CODE>-1</CODE> if it was
negative.

</P>
<P>
To compute the real gamma function you can use the <CODE>tgamma</CODE>
function or you can compute the values as follows:

<PRE>
lgam = lgamma(x);
gam  = signgam*exp(lgam);
</PRE>

<P>
The gamma function has singularities at the nonpositive integers.
<CODE>lgamma</CODE> will raise the zero divide exception if evaluated at a
singularity.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>lgamma_r</B> <I>(double <VAR>x</VAR>, int *<VAR>signp</VAR>)</I>
<DD><A NAME="IDX1971"></A>
<DT><U>Function:</U> float <B>lgammaf_r</B> <I>(float <VAR>x</VAR>, int *<VAR>signp</VAR>)</I>
<DD><A NAME="IDX1972"></A>
<DT><U>Function:</U> long double <B>lgammal_r</B> <I>(long double <VAR>x</VAR>, int *<VAR>signp</VAR>)</I>
<DD><A NAME="IDX1973"></A>
<CODE>lgamma_r</CODE> is just like <CODE>lgamma</CODE>, but it stores the sign of
the intermediate result in the variable pointed to by <VAR>signp</VAR>
instead of in the <VAR>signgam</VAR> global.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>gamma</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1974"></A>
<DT><U>Function:</U> float <B>gammaf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1975"></A>
<DT><U>Function:</U> long double <B>gammal</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1976"></A>
These functions exist for compatibility reasons.  They are equivalent to
<CODE>lgamma</CODE> etc.  It is better to use <CODE>lgamma</CODE> since for one the
name reflects better the actual computation and <CODE>lgamma</CODE> is also
standardized in ISO C 9x while <CODE>gamma</CODE> is not.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>tgamma</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1977"></A>
<DT><U>Function:</U> float <B>tgammaf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1978"></A>
<DT><U>Function:</U> long double <B>tgammal</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1979"></A>
<CODE>tgamma</CODE> applies the gamma function to <VAR>x</VAR>.  The gamma
function is defined as
@ifnottex

<PRE>
gamma (x) = integral from 0 to @infinity{} of t^(x-1) e^-t dt
</PRE>

<P>
This function was introduced in ISO C 9x.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>j0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1980"></A>
<DT><U>Function:</U> float <B>j0f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1981"></A>
<DT><U>Function:</U> long double <B>j0l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1982"></A>
<CODE>j0</CODE> returns the Bessel function of the first kind of order 0 of
<VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>j1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1983"></A>
<DT><U>Function:</U> float <B>j1f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1984"></A>
<DT><U>Function:</U> long double <B>j1l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1985"></A>
<CODE>j1</CODE> returns the Bessel function of the first kind of order 1 of
<VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>jn</B> <I>(int n, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1986"></A>
<DT><U>Function:</U> float <B>jnf</B> <I>(int n, float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1987"></A>
<DT><U>Function:</U> long double <B>jnl</B> <I>(int n, long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1988"></A>
<CODE>jn</CODE> returns the Bessel function of the first kind of order
<VAR>n</VAR> of <VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>y0</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1989"></A>
<DT><U>Function:</U> float <B>y0f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1990"></A>
<DT><U>Function:</U> long double <B>y0l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1991"></A>
<CODE>y0</CODE> returns the Bessel function of the second kind of order 0 of
<VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.  If <VAR>x</VAR>
is negative, <CODE>y0</CODE> signals a domain error; if it is zero,
<CODE>y0</CODE> signals overflow and returns @math{-@infinity}.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>y1</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1992"></A>
<DT><U>Function:</U> float <B>y1f</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1993"></A>
<DT><U>Function:</U> long double <B>y1l</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1994"></A>
<CODE>y1</CODE> returns the Bessel function of the second kind of order 1 of
<VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.  If <VAR>x</VAR>
is negative, <CODE>y1</CODE> signals a domain error; if it is zero,
<CODE>y1</CODE> signals overflow and returns @math{-@infinity}.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>yn</B> <I>(int n, double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1995"></A>
<DT><U>Function:</U> float <B>ynf</B> <I>(int n, float <VAR>x</VAR>)</I>
<DD><A NAME="IDX1996"></A>
<DT><U>Function:</U> long double <B>ynl</B> <I>(int n, long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX1997"></A>
<CODE>yn</CODE> returns the Bessel function of the second kind of order <VAR>n</VAR> of
<VAR>x</VAR>.  It may signal underflow if <VAR>x</VAR> is too large.  If <VAR>x</VAR>
is negative, <CODE>yn</CODE> signals a domain error; if it is zero,
<CODE>yn</CODE> signals overflow and returns @math{-@infinity}.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_360.html">previous</A>, <A HREF="libc_362.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
