<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - I/O Primitives</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_215.html">previous</A>, <A HREF="libc_217.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC223" HREF="libc_toc.html#TOC223">Input and Output Primitives</A></H2>

<P>
This section describes the functions for performing primitive input and
output operations on file descriptors: <CODE>read</CODE>, <CODE>write</CODE>, and
<CODE>lseek</CODE>.  These functions are declared in the header file
<TT>`unistd.h'</TT>.
<A NAME="IDX991"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>ssize_t</B>
<DD><A NAME="IDX992"></A>
This data type is used to represent the sizes of blocks that can be
read or written in a single operation.  It is similar to <CODE>size_t</CODE>,
but must be a signed type.
</DL>

</P>
<P>
<A NAME="IDX993"></A>
<DL>
<DT><U>Function:</U> ssize_t <B>read</B> <I>(int <VAR>filedes</VAR>, void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX994"></A>
The <CODE>read</CODE> function reads up to <VAR>size</VAR> bytes from the file
with descriptor <VAR>filedes</VAR>, storing the results in the <VAR>buffer</VAR>.
(This is not necessarily a character string and there is no terminating
null character added.)

</P>
<P>
<A NAME="IDX995"></A>
The return value is the number of bytes actually read.  This might be
less than <VAR>size</VAR>; for example, if there aren't that many bytes left
in the file or if there aren't that many bytes immediately available.
The exact behavior depends on what kind of file it is.  Note that
reading less than <VAR>size</VAR> bytes is not an error.

</P>
<P>
A value of zero indicates end-of-file (except if the value of the
<VAR>size</VAR> argument is also zero).  This is not considered an error.
If you keep calling <CODE>read</CODE> while at end-of-file, it will keep
returning zero and doing nothing else.

</P>
<P>
If <CODE>read</CODE> returns at least one character, there is no way you can
tell whether end-of-file was reached.  But if you did reach the end, the
next read will return zero.

</P>
<P>
In case of an error, <CODE>read</CODE> returns @math{-1}.  The following
<CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
Normally, when no input is immediately available, <CODE>read</CODE> waits for
some input.  But if the <CODE>O_NONBLOCK</CODE> flag is set for the file
(see section <A HREF="libc_236.html#SEC243">File Status Flags</A>), <CODE>read</CODE> returns immediately without
reading any data, and reports this error.

<STRONG>Compatibility Note:</STRONG> Most versions of BSD Unix use a different
error code for this: <CODE>EWOULDBLOCK</CODE>.  In the GNU library,
<CODE>EWOULDBLOCK</CODE> is an alias for <CODE>EAGAIN</CODE>, so it doesn't matter
which name you use.

On some systems, reading a large amount of data from a character special
file can also fail with <CODE>EAGAIN</CODE> if the kernel cannot find enough
physical memory to lock down the user's pages.  This is limited to
devices that transfer with direct memory access into the user's memory,
which means it does not include terminals, since they always use
separate buffers inside the kernel.  This problem never happens in the
GNU system.

Any condition that could result in <CODE>EAGAIN</CODE> can instead result in a
successful <CODE>read</CODE> which returns fewer bytes than requested.
Calling <CODE>read</CODE> again immediately would result in <CODE>EAGAIN</CODE>.

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>filedes</VAR> argument is not a valid file descriptor,
or is not open for reading.

<DT><CODE>EINTR</CODE>
<DD>
<CODE>read</CODE> was interrupted by a signal while it was waiting for input.
See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.  A signal will not necessary cause
<CODE>read</CODE> to return <CODE>EINTR</CODE>; it may instead result in a
successful <CODE>read</CODE> which returns fewer bytes than requested.

<DT><CODE>EIO</CODE>
<DD>
For many devices, and for disk files, this error code indicates
a hardware error.

<CODE>EIO</CODE> also occurs when a background process tries to read from the
controlling terminal, and the normal action of stopping the process by
sending it a <CODE>SIGTTIN</CODE> signal isn't working.  This might happen if
signal is being blocked or ignored, or because the process group is
orphaned.  See section <A HREF="libc_522.html#SEC530">Job Control</A>, for more information about job control,
and section <A HREF="libc_417.html#SEC424">Signal Handling</A>, for information about signals.
</DL>

<P>
Please note that there is no function named <CODE>read64</CODE>.  This is not
necessary since this function does not directly modify or handle the
possibly wide file offset.  Since the kernel handles this state
internally the <CODE>read</CODE> function can be used for all cases.

</P>
<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>read</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>read</CODE> should be
protected using cancelation handlers.

</P>
<P>
The <CODE>read</CODE> function is the underlying primitive for all of the
functions that read from streams, such as <CODE>fgetc</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>pread</B> <I>(int <VAR>filedes</VAR>, void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>, off_t <VAR>offset</VAR>)</I>
<DD><A NAME="IDX996"></A>
The <CODE>pread</CODE> function is similar to the <CODE>read</CODE> function.  The
first three arguments are identical and also the return values and error
codes correspond.

</P>
<P>
The difference is the fourth argument and its handling.  The data block
is not read from the current position of the file descriptor
<CODE>filedes</CODE>.  Instead the data is read from the file starting at
position <VAR>offset</VAR>.  The position of the file descriptor itself is
not effected by the operation.  The value is the same as before the call.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> the
<CODE>pread</CODE> function is in fact <CODE>pread64</CODE> and the type
<CODE>off_t</CODE> has 64 bits which makes it possible to handle files up to
@math{2^63} bytes in length.

</P>
<P>
The return value of <CODE>pread</CODE> describes the number of bytes read.
In the error case it returns @math{-1} like <CODE>read</CODE> does and the
error codes are also the same.  Only there are a few more error codes:
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
The value given for <VAR>offset</VAR> is negative and therefore illegal.

<DT><CODE>ESPIPE</CODE>
<DD>
The file descriptor <VAR>filedes</VAR> is associate with a pipe or a FIFO and
this device does not allow positioning of the file pointer.
</DL>

<P>
The function is an extension defined in the Unix Single Specification
version 2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>pread64</B> <I>(int <VAR>filedes</VAR>, void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>, off64_t <VAR>offset</VAR>)</I>
<DD><A NAME="IDX997"></A>
This function is similar to the <CODE>pread</CODE> function.  The difference
is that the <VAR>offset</VAR> parameter is of type <CODE>off64_t</CODE> instead of
<CODE>off_t</CODE> which makes it possible on 32 bits machines to address
files larger than @math{2^31} bytes and up to @math{2^63} bytes.  The
file descriptor <CODE>filedes</CODE> must be opened using <CODE>open64</CODE> since
otherwise the large offsets possible with <CODE>off64_t</CODE> will lead to
errors with a descriptor in small file mode.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is actually available under the name
<CODE>pread</CODE> and so transparently replaces the 32 bits interface.
</DL>

</P>
<P>
<A NAME="IDX998"></A>
<DL>
<DT><U>Function:</U> ssize_t <B>write</B> <I>(int <VAR>filedes</VAR>, const void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX999"></A>
The <CODE>write</CODE> function writes up to <VAR>size</VAR> bytes from
<VAR>buffer</VAR> to the file with descriptor <VAR>filedes</VAR>.  The data in
<VAR>buffer</VAR> is not necessarily a character string and a null character is
output like any other character.

</P>
<P>
The return value is the number of bytes actually written.  This may be
<VAR>size</VAR>, but can always be smaller.  Your program should always call
<CODE>write</CODE> in a loop, iterating until all the data is written.

</P>
<P>
Once <CODE>write</CODE> returns, the data is enqueued to be written and can be
read back right away, but it is not necessarily written out to permanent
storage immediately.  You can use <CODE>fsync</CODE> when you need to be sure
your data has been permanently stored before continuing.  (It is more
efficient for the system to batch up consecutive writes and do them all
at once when convenient.  Normally they will always be written to disk
within a minute or less.)  Modern systems provide another function
<CODE>fdatasync</CODE> which guarantees integrity only for the file data and
is therefore faster.
You can use the <CODE>O_FSYNC</CODE> open mode to make <CODE>write</CODE> always
store the data to disk before returning; see section <A HREF="libc_239.html#SEC246">I/O Operating Modes</A>.

</P>
<P>
In the case of an error, <CODE>write</CODE> returns @math{-1}.  The following
<CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
Normally, <CODE>write</CODE> blocks until the write operation is complete.
But if the <CODE>O_NONBLOCK</CODE> flag is set for the file (see section <A HREF="libc_233.html#SEC240">Control Operations on Files</A>), it returns immediately without writing any data, and
reports this error.  An example of a situation that might cause the
process to block on output is writing to a terminal device that supports
flow control, where output has been suspended by receipt of a STOP
character.

<STRONG>Compatibility Note:</STRONG> Most versions of BSD Unix use a different
error code for this: <CODE>EWOULDBLOCK</CODE>.  In the GNU library,
<CODE>EWOULDBLOCK</CODE> is an alias for <CODE>EAGAIN</CODE>, so it doesn't matter
which name you use.

On some systems, writing a large amount of data from a character special
file can also fail with <CODE>EAGAIN</CODE> if the kernel cannot find enough
physical memory to lock down the user's pages.  This is limited to
devices that transfer with direct memory access into the user's memory,
which means it does not include terminals, since they always use
separate buffers inside the kernel.  This problem does not arise in the
GNU system.

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>filedes</VAR> argument is not a valid file descriptor,
or is not open for writing.

<DT><CODE>EFBIG</CODE>
<DD>
The size of the file would become larger than the implementation can support.

<DT><CODE>EINTR</CODE>
<DD>
The <CODE>write</CODE> operation was interrupted by a signal while it was
blocked waiting for completion.  A signal will not necessary cause
<CODE>write</CODE> to return <CODE>EINTR</CODE>; it may instead result in a
successful <CODE>write</CODE> which writes fewer bytes than requested.
See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.

<DT><CODE>EIO</CODE>
<DD>
For many devices, and for disk files, this error code indicates
a hardware error.

<DT><CODE>ENOSPC</CODE>
<DD>
The device containing the file is full.

<DT><CODE>EPIPE</CODE>
<DD>
This error is returned when you try to write to a pipe or FIFO that
isn't open for reading by any process.  When this happens, a <CODE>SIGPIPE</CODE>
signal is also sent to the process; see section <A HREF="libc_417.html#SEC424">Signal Handling</A>.
</DL>

<P>
Unless you have arranged to prevent <CODE>EINTR</CODE> failures, you should
check <CODE>errno</CODE> after each failing call to <CODE>write</CODE>, and if the
error was <CODE>EINTR</CODE>, you should simply repeat the call.
See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.  The easy way to do this is with the
macro <CODE>TEMP_FAILURE_RETRY</CODE>, as follows:

</P>

<PRE>
nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));
</PRE>

<P>
Please note that there is no function named <CODE>write64</CODE>.  This is not
necessary since this function does not directly modify or handle the
possibly wide file offset.  Since the kernel handles this state
internally the <CODE>write</CODE> function can be used for all cases.

</P>
<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>write</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>write</CODE> should be
protected using cancelation handlers.

</P>
<P>
The <CODE>write</CODE> function is the underlying primitive for all of the
functions that write to streams, such as <CODE>fputc</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>pwrite</B> <I>(int <VAR>filedes</VAR>, const void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>, off_t <VAR>offset</VAR>)</I>
<DD><A NAME="IDX1000"></A>
The <CODE>pwrite</CODE> function is similar to the <CODE>write</CODE> function.  The
first three arguments are identical and also the return values and error
codes correspond.

</P>
<P>
The difference is the fourth argument and its handling.  The data block
is not written to the current position of the file descriptor
<CODE>filedes</CODE>.  Instead the data is written to the file starting at
position <VAR>offset</VAR>.  The position of the file descriptor itself is
not effected by the operation.  The value is the same as before the call.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> the
<CODE>pwrite</CODE> function is in fact <CODE>pwrite64</CODE> and the type
<CODE>off_t</CODE> has 64 bits which makes it possible to handle files up to
@math{2^63} bytes in length.

</P>
<P>
The return value of <CODE>pwrite</CODE> describes the number of written bytes.
In the error case it returns @math{-1} like <CODE>write</CODE> does and the
error codes are also the same.  Only there are a few more error codes:
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
The value given for <VAR>offset</VAR> is negative and therefore illegal.

<DT><CODE>ESPIPE</CODE>
<DD>
The file descriptor <VAR>filedes</VAR> is associate with a pipe or a FIFO and
this device does not allow positioning of the file pointer.
</DL>

<P>
The function is an extension defined in the Unix Single Specification
version 2.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> ssize_t <B>pwrite64</B> <I>(int <VAR>filedes</VAR>, const void *<VAR>buffer</VAR>, size_t <VAR>size</VAR>, off64_t <VAR>offset</VAR>)</I>
<DD><A NAME="IDX1001"></A>
This function is similar to the <CODE>pwrite</CODE> function.  The difference
is that the <VAR>offset</VAR> parameter is of type <CODE>off64_t</CODE> instead of
<CODE>off_t</CODE> which makes it possible on 32 bits machines to address
files larger than @math{2^31} bytes and up to @math{2^63} bytes.  The
file descriptor <CODE>filedes</CODE> must be opened using <CODE>open64</CODE> since
otherwise the large offsets possible with <CODE>off64_t</CODE> will lead to
errors with a descriptor in small file mode.

</P>
<P>
When the source file is compiled using <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is actually available under the name
<CODE>pwrite</CODE> and so transparently replaces the 32 bits interface.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_215.html">previous</A>, <A HREF="libc_217.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
