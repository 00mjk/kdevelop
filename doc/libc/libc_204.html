<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - String Streams</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_203.html">previous</A>, <A HREF="libc_205.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC211" HREF="libc_toc.html#TOC211">String Streams</A></H3>

<P>
<A NAME="IDX935"></A>
<A NAME="IDX936"></A>
The <CODE>fmemopen</CODE> and <CODE>open_memstream</CODE> functions allow you to do
I/O to a string or memory buffer.  These facilities are declared in
<TT>`stdio.h'</TT>.
<A NAME="IDX937"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> FILE * <B>fmemopen</B> <I>(void *<VAR>buf</VAR>, size_t <VAR>size</VAR>, const char *<VAR>opentype</VAR>)</I>
<DD><A NAME="IDX938"></A>
This function opens a stream that allows the access specified by the
<VAR>opentype</VAR> argument, that reads from or writes to the buffer specified
by the argument <VAR>buf</VAR>.  This array must be at least <VAR>size</VAR> bytes long.

</P>
<P>
If you specify a null pointer as the <VAR>buf</VAR> argument, <CODE>fmemopen</CODE>
dynamically allocates (as with <CODE>malloc</CODE>; see section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>) an array <VAR>size</VAR> bytes long.  This is really only useful
if you are going to write things to the buffer and then read them back
in again, because you have no way of actually getting a pointer to the
buffer (for this, try <CODE>open_memstream</CODE>, below).  The buffer is
freed when the stream is open.

</P>
<P>
The argument <VAR>opentype</VAR> is the same as in <CODE>fopen</CODE>
(see section <A HREF="libc_158.html#SEC165">Opening Streams</A>).  If the <VAR>opentype</VAR> specifies
append mode, then the initial file position is set to the first null
character in the buffer.  Otherwise the initial file position is at the
beginning of the buffer.

</P>
<P>
When a stream open for writing is flushed or closed, a null character
(zero byte) is written at the end of the buffer if it fits.  You
should add an extra byte to the <VAR>size</VAR> argument to account for this.
Attempts to write more than <VAR>size</VAR> bytes to the buffer result
in an error.

</P>
<P>
For a stream open for reading, null characters (zero bytes) in the
buffer do not count as "end of file".  Read operations indicate end of
file only when the file position advances past <VAR>size</VAR> bytes.  So, if
you want to read characters from a null-terminated string, you should
supply the length of the string as the <VAR>size</VAR> argument.
</DL>

</P>
<P>
Here is an example of using <CODE>fmemopen</CODE> to create a stream for
reading from a string:

</P>

<PRE>
#include &#60;stdio.h&#62;

static char buffer[] = "foobar";

int
main (void)
{
  int ch;
  FILE *stream;

  stream = fmemopen (buffer, strlen (buffer), "r");
  while ((ch = fgetc (stream)) != EOF)
    printf ("Got %c\n", ch);
  fclose (stream);

  return 0;
}
</PRE>

<P>
This program produces the following output:

</P>

<PRE>
Got f
Got o
Got o
Got b
Got a
Got r
</PRE>

<P>
<DL>
<DT><U>Function:</U> FILE * <B>open_memstream</B> <I>(char **<VAR>ptr</VAR>, size_t *<VAR>sizeloc</VAR>)</I>
<DD><A NAME="IDX939"></A>
This function opens a stream for writing to a buffer.  The buffer is
allocated dynamically (as with <CODE>malloc</CODE>; see section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>) and grown as necessary.

</P>
<P>
When the stream is closed with <CODE>fclose</CODE> or flushed with
<CODE>fflush</CODE>, the locations <VAR>ptr</VAR> and <VAR>sizeloc</VAR> are updated to
contain the pointer to the buffer and its size.  The values thus stored
remain valid only as long as no further output on the stream takes
place.  If you do more output, you must flush the stream again to store
new values before you use them again.

</P>
<P>
A null character is written at the end of the buffer.  This null character
is <EM>not</EM> included in the size value stored at <VAR>sizeloc</VAR>.

</P>
<P>
You can move the stream's file position with <CODE>fseek</CODE> or
<CODE>fseeko</CODE> (see section <A HREF="libc_197.html#SEC204">File Positioning</A>).  Moving the file position past
the end of the data already written fills the intervening space with
zeroes.
</DL>

</P>
<P>
Here is an example of using <CODE>open_memstream</CODE>:

</P>

<PRE>
#include &#60;stdio.h&#62;

int
main (void)
{
  char *bp;
  size_t size;
  FILE *stream;

  stream = open_memstream (&#38;bp, &#38;size);
  fprintf (stream, "hello");
  fflush (stream);
  printf ("buf = `%s', size = %d\n", bp, size);
  fprintf (stream, ", world");
  fclose (stream);
  printf ("buf = `%s', size = %d\n", bp, size);

  return 0;
}
</PRE>

<P>
This program produces the following output:

</P>

<PRE>
buf = `hello', size = 5
buf = `hello, world', size = 12
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_203.html">previous</A>, <A HREF="libc_205.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
