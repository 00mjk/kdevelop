<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Nonreentrancy</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_443.html">previous</A>, <A HREF="libc_445.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC451" HREF="libc_toc.html#TOC451">Signal Handling and Nonreentrant Functions</A></H3>
<P>
<A NAME="IDX2549"></A>

</P>
<P>
Handler functions usually don't do very much.  The best practice is to
write a handler that does nothing but set an external variable that the
program checks regularly, and leave all serious work to the program.
This is best because the handler can be called at asynchronously, at
unpredictable times--perhaps in the middle of a primitive function, or
even between the beginning and the end of a C operator that requires
multiple instructions.  The data structures being manipulated might
therefore be in an inconsistent state when the handler function is
invoked.  Even copying one <CODE>int</CODE> variable into another can take two
instructions on most machines.

</P>
<P>
This means you have to be very careful about what you do in a signal
handler.

</P>

<UL>
<LI>

<A NAME="IDX2550"></A>
If your handler needs to access any global variables from your program,
declare those variables <CODE>volatile</CODE>.  This tells the compiler that
the value of the variable might change asynchronously, and inhibits
certain optimizations that would be invalidated by such modifications.

<LI>

<A NAME="IDX2551"></A>
If you call a function in the handler, make sure it is <STRONG>reentrant</STRONG>
with respect to signals, or else make sure that the signal cannot
interrupt a call to a related function.
</UL>

<P>
A function can be non-reentrant if it uses memory that is not on the
stack.

</P>

<UL>
<LI>

If a function uses a static variable or a global variable, or a
dynamically-allocated object that it finds for itself, then it is
non-reentrant and any two calls to the function can interfere.

For example, suppose that the signal handler uses <CODE>gethostbyname</CODE>.
This function returns its value in a static object, reusing the same
object each time.  If the signal happens to arrive during a call to
<CODE>gethostbyname</CODE>, or even after one (while the program is still
using the value), it will clobber the value that the program asked for.

However, if the program does not use <CODE>gethostbyname</CODE> or any other
function that returns information in the same object, or if it always
blocks signals around each use, then you are safe.

There are a large number of library functions that return values in a
fixed object, always reusing the same object in this fashion, and all of
them cause the same problem.  The description of a function in this
manual always mentions this behavior.

<LI>

If a function uses and modifies an object that you supply, then it is
potentially non-reentrant; two calls can interfere if they use the same
object.

This case arises when you do I/O using streams.  Suppose that the
signal handler prints a message with <CODE>fprintf</CODE>.  Suppose that the
program was in the middle of an <CODE>fprintf</CODE> call using the same
stream when the signal was delivered.  Both the signal handler's message
and the program's data could be corrupted, because both calls operate on
the same data structure--the stream itself.

However, if you know that the stream that the handler uses cannot
possibly be used by the program at a time when signals can arrive, then
you are safe.  It is no problem if the program uses some other stream.

<LI>

On most systems, <CODE>malloc</CODE> and <CODE>free</CODE> are not reentrant,
because they use a static data structure which records what memory
blocks are free.  As a result, no library functions that allocate or
free memory are reentrant.  This includes functions that allocate space
to store a result.

The best way to avoid the need to allocate memory in a handler is to
allocate in advance space for signal handlers to use.

The best way to avoid freeing memory in a handler is to flag or record
the objects to be freed, and have the program check from time to time
whether anything is waiting to be freed.  But this must be done with
care, because placing an object on a chain is not atomic, and if it is
interrupted by another signal handler that does the same thing, you
could "lose" one of the objects.

<LI>

Any function that modifies <CODE>errno</CODE> is non-reentrant, but you can
correct for this: in the handler, save the original value of
<CODE>errno</CODE> and restore it before returning normally.  This prevents
errors that occur within the signal handler from being confused with
errors from system calls at the point the program is interrupted to run
the handler.

This technique is generally applicable; if you want to call in a handler
a function that modifies a particular object in memory, you can make
this safe by saving and restoring that object.

<LI>

Merely reading from a memory object is safe provided that you can deal
with any of the values that might appear in the object at a time when
the signal can be delivered.  Keep in mind that assignment to some data
types requires more than one instruction, which means that the handler
could run "in the middle of" an assignment to the variable if its type
is not atomic.  See section <A HREF="libc_445.html#SEC452">Atomic Data Access and Signal Handling</A>.

<LI>

Merely writing into a memory object is safe as long as a sudden change
in the value, at any time when the handler might run, will not disturb
anything.
</UL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_443.html">previous</A>, <A HREF="libc_445.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
