<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Asynchronous Reads/Writes</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_227.html">previous</A>, <A HREF="libc_229.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC235" HREF="libc_toc.html#TOC235">Asynchronous Read and Write Operations</A></H3>

<P>
<DL>
<DT><U>Function:</U> int <B>aio_read</B> <I>(struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1073"></A>
This function initiates an asynchronous read operation.  The function
call immediately returns after the operation was enqueued or when an
error was encountered.

</P>
<P>
The first <CODE>aiocbp-&#62;aio_nbytes</CODE> bytes of the file for which
<CODE>aiocbp-&#62;aio_fildes</CODE> is a descriptor are written to the buffer
starting at <CODE>aiocbp-&#62;aio_buf</CODE>.  Reading starts at the absolute
position <CODE>aiocbp-&#62;aio_offset</CODE> in the file.

</P>
<P>
If prioritized I/O is supported by the platform the
<CODE>aiocbp-&#62;aio_reqprio</CODE> value is used to adjust the priority before
the request is actually enqueued.

</P>
<P>
The calling process is notified about the termination of the read
request according to the <CODE>aiocbp-&#62;aio_sigevent</CODE> value.

</P>
<P>
When <CODE>aio_read</CODE> returns the return value is zero if no error
occurred that can be found before the process is enqueued.  If such an
early error is found the function returns @math{-1} and sets
<CODE>errno</CODE> to one of the following values.

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
The request was not enqueued due to (temporarily) exceeded resource
limitations.
<DT><CODE>ENOSYS</CODE>
<DD>
The <CODE>aio_read</CODE> function is not implemented.
<DT><CODE>EBADF</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_fildes</CODE> descriptor is not valid.  This condition
needs not be recognized before enqueueing the request and so this error
might also be signaled asynchronously.
<DT><CODE>EINVAL</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_offset</CODE> or <CODE>aiocbp-&#62;aio_reqpiro</CODE> value is
invalid.  This condition need not be recognized before enqueueing the
request and so this error might also be signaled asynchronously.
</DL>

<P>
In the case <CODE>aio_read</CODE> returns zero the current status of the
request can be queried using <CODE>aio_error</CODE> and <CODE>aio_return</CODE>
functions.  As long as the value returned by <CODE>aio_error</CODE> is
<CODE>EINPROGRESS</CODE> the operation has not yet completed.  If
<CODE>aio_error</CODE> returns zero the operation successfully terminated,
otherwise the value is to be interpreted as an error code.  If the
function terminated the result of the operation can be get using a call
to <CODE>aio_return</CODE>.  The returned value is the same as an equivalent
call to <CODE>read</CODE> would have returned.  Possible error codes returned
by <CODE>aio_error</CODE> are:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_fildes</CODE> descriptor is not valid.
<DT><CODE>ECANCELED</CODE>
<DD>
The operation was canceled before the operation was finished
(see section <A HREF="libc_231.html#SEC238">Cancelation of AIO Operations</A>)
<DT><CODE>EINVAL</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_offset</CODE> value is invalid.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_read64</CODE> since the LFS interface transparently
replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_read64</B> <I>(struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1074"></A>
This function is similar to the <CODE>aio_read</CODE> function.  The only
difference is that on 32 bits machines the file descriptor should
be opened in the large file mode.  Internally <CODE>aio_read64</CODE> uses
functionality equivalent to <CODE>lseek64</CODE> (see section <A HREF="libc_217.html#SEC224">Setting the File Position of a Descriptor</A>) to position the file descriptor correctly for the reading,
as opposed to <CODE>lseek</CODE> functionality used in <CODE>aio_read</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_read</CODE> and so transparently
replaces the interface for small files on 32 bits machines.
</DL>

</P>
<P>
To write data asynchronously to a file there exists an equivalent pair
of functions with a very similar interface.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_write</B> <I>(struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1075"></A>
This function initiates an asynchronous write operation.  The function
call immediately returns after the operation was enqueued or if before
this happens an error was encountered.

</P>
<P>
The first <CODE>aiocbp-&#62;aio_nbytes</CODE> bytes from the buffer starting at
<CODE>aiocbp-&#62;aio_buf</CODE> are written to the file for which
<CODE>aiocbp-&#62;aio_fildes</CODE> is an descriptor, starting at the absolute
position <CODE>aiocbp-&#62;aio_offset</CODE> in the file.

</P>
<P>
If prioritized I/O is supported by the platform the
<CODE>aiocbp-&#62;aio_reqprio</CODE> value is used to adjust the priority before
the request is actually enqueued.

</P>
<P>
The calling process is notified about the termination of the read
request according to the <CODE>aiocbp-&#62;aio_sigevent</CODE> value.

</P>
<P>
When <CODE>aio_write</CODE> returns the return value is zero if no error
occurred that can be found before the process is enqueued.  If such an
early error is found the function returns @math{-1} and sets
<CODE>errno</CODE> to one of the following values.

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
The request was not enqueued due to (temporarily) exceeded resource
limitations.
<DT><CODE>ENOSYS</CODE>
<DD>
The <CODE>aio_write</CODE> function is not implemented.
<DT><CODE>EBADF</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_fildes</CODE> descriptor is not valid.  This condition
needs not be recognized before enqueueing the request and so this error
might also be signaled asynchronously.
<DT><CODE>EINVAL</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_offset</CODE> or <CODE>aiocbp-&#62;aio_reqpiro</CODE> value is
invalid.  This condition needs not be recognized before enqueueing the
request and so this error might also be signaled asynchronously.
</DL>

<P>
In the case <CODE>aio_write</CODE> returns zero the current status of the
request can be queried using <CODE>aio_error</CODE> and <CODE>aio_return</CODE>
functions.  As long as the value returned by <CODE>aio_error</CODE> is
<CODE>EINPROGRESS</CODE> the operation has not yet completed.  If
<CODE>aio_error</CODE> returns zero the operation successfully terminated,
otherwise the value is to be interpreted as an error code.  If the
function terminated the result of the operation can be get using a call
to <CODE>aio_return</CODE>.  The returned value is the same as an equivalent
call to <CODE>read</CODE> would have returned.  Possible error code returned
by <CODE>aio_error</CODE> are:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_fildes</CODE> descriptor is not valid.
<DT><CODE>ECANCELED</CODE>
<DD>
The operation was canceled before the operation was finished
(see section <A HREF="libc_231.html#SEC238">Cancelation of AIO Operations</A>)
<DT><CODE>EINVAL</CODE>
<DD>
The <CODE>aiocbp-&#62;aio_offset</CODE> value is invalid.
</DL>

<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>aio_write64</CODE> since the LFS interface transparently
replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>aio_write64</B> <I>(struct aiocb *<VAR>aiocbp</VAR>)</I>
<DD><A NAME="IDX1076"></A>
This function is similar to the <CODE>aio_write</CODE> function.  The only
difference is that on 32 bits machines the file descriptor should
be opened in the large file mode.  Internally <CODE>aio_write64</CODE> uses
functionality equivalent to <CODE>lseek64</CODE> (see section <A HREF="libc_217.html#SEC224">Setting the File Position of a Descriptor</A>) to position the file descriptor correctly for the writing,
as opposed to <CODE>lseek</CODE> functionality used in <CODE>aio_write</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>aio_write</CODE> and so transparently
replaces the interface for small files on 32 bits machines.
</DL>

</P>
<P>
Beside these functions with the more or less traditional interface
POSIX.1b also defines a function with can initiate more than one
operation at once and which can handled freely mixed read and write
operation.  It is therefore similar to a combination of <CODE>readv</CODE> and
<CODE>writev</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lio_listio</B> <I>(int <VAR>mode</VAR>, struct aiocb *const <VAR>list</VAR>[], int <VAR>nent</VAR>, struct sigevent *<VAR>sig</VAR>)</I>
<DD><A NAME="IDX1077"></A>
The <CODE>lio_listio</CODE> function can be used to enqueue an arbitrary
number of read and write requests at one time.  The requests can all be
meant for the same file, all for different files or every solution in
between.

</P>
<P>
<CODE>lio_listio</CODE> gets the <VAR>nent</VAR> requests from the array pointed to
by <VAR>list</VAR>.  What operation has to be performed is determined by the
<CODE>aio_lio_opcode</CODE> member in each element of <VAR>list</VAR>.  If this
field is <CODE>LIO_READ</CODE> an read operation is queued, similar to a call
of <CODE>aio_read</CODE> for this element of the array (except that the way
the termination is signalled is different, as we will see below).  If
the <CODE>aio_lio_opcode</CODE> member is <CODE>LIO_WRITE</CODE> an write operation
is enqueued.  Otherwise the <CODE>aio_lio_opcode</CODE> must be <CODE>LIO_NOP</CODE>
in which case this element of <VAR>list</VAR> is simply ignored.  This
"operation" is useful in situations where one has a fixed array of
<CODE>struct aiocb</CODE> elements from which only a few need to be handled at
a time.  Another situation is where the <CODE>lio_listio</CODE> call was
cancelled before all requests are processed (see section <A HREF="libc_231.html#SEC238">Cancelation of AIO Operations</A>) and the remaining requests have to be reissued.

</P>
<P>
The other members of each element of the array pointed to by
<CODE>list</CODE> must have values suitable for the operation as described in
the documentation for <CODE>aio_read</CODE> and <CODE>aio_write</CODE> above.

</P>
<P>
The <VAR>mode</VAR> argument determines how <CODE>lio_listio</CODE> behaves after
having enqueued all the requests.  If <VAR>mode</VAR> is <CODE>LIO_WAIT</CODE> it
waits until all requests terminated.  Otherwise <VAR>mode</VAR> must be
<CODE>LIO_NOWAIT</CODE> and in this case the function returns immediately after
having enqueued all the requests.  In this case the caller gets a
notification of the termination of all requests according to the
<VAR>sig</VAR> parameter.  If <VAR>sig</VAR> is <CODE>NULL</CODE> no notification is
send.  Otherwise a signal is sent or a thread is started, just as
described in the description for <CODE>aio_read</CODE> or <CODE>aio_write</CODE>.

</P>
<P>
If <VAR>mode</VAR> is <CODE>LIO_WAIT</CODE> the return value of <CODE>lio_listio</CODE>
is @math{0} when all requests completed successfully.  Otherwise the
function return @math{-1} and <CODE>errno</CODE> is set accordingly.  To find
out which request or requests failed one has to use the <CODE>aio_error</CODE>
function on all the elements of the array <VAR>list</VAR>.

</P>
<P>
In case <VAR>mode</VAR> is <CODE>LIO_NOWAIT</CODE> the function return @math{0} if
all requests were enqueued correctly.  The current state of the requests
can be found using <CODE>aio_error</CODE> and <CODE>aio_return</CODE> as described
above.  In case <CODE>lio_listio</CODE> returns @math{-1} in this mode the
global variable <CODE>errno</CODE> is set accordingly.  If a request did not
yet terminate a call to <CODE>aio_error</CODE> returns <CODE>EINPROGRESS</CODE>.  If
the value is different the request is finished and the error value (or
@math{0}) is returned and the result of the operation can be retrieved
using <CODE>aio_return</CODE>.

</P>
<P>
Possible values for <CODE>errno</CODE> are:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
The resources necessary to queue all the requests are not available in
the moment.  The error status for each element of <VAR>list</VAR> must be
checked which request failed.

Another reason could be that the system wide limit of AIO requests is
exceeded.  This cannot be the case for the implementation on GNU systems
since no arbitrary limits exist.
<DT><CODE>EINVAL</CODE>
<DD>
The <VAR>mode</VAR> parameter is invalid or <VAR>nent</VAR> is larger than
<CODE>AIO_LISTIO_MAX</CODE>.
<DT><CODE>EIO</CODE>
<DD>
One or more of the request's I/O operations failed.  The error status of
each request should be checked for which one failed.
<DT><CODE>ENOSYS</CODE>
<DD>
The <CODE>lio_listio</CODE> function is not supported.
</DL>

<P>
If the <VAR>mode</VAR> parameter is <CODE>LIO_NOWAIT</CODE> and the caller cancels
an request the error status for this request returned by
<CODE>aio_error</CODE> is <CODE>ECANCELED</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is in fact <CODE>lio_listio64</CODE> since the LFS interface
transparently replaces the normal implementation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>lio_listio64</B> <I>(int <VAR>mode</VAR>, struct aiocb *const <VAR>list</VAR>, int <VAR>nent</VAR>, struct sigevent *<VAR>sig</VAR>)</I>
<DD><A NAME="IDX1078"></A>
This function is similar to the <CODE>aio_listio</CODE> function.  The only
difference is that only 32 bits machines the file descriptor should
be opened in the large file mode.  Internally <CODE>lio_listio64</CODE> uses
functionality equivalent to <CODE>lseek64</CODE> (see section <A HREF="libc_217.html#SEC224">Setting the File Position of a Descriptor</A>) to position the file descriptor correctly for the reading or
writing, as opposed to <CODE>lseek</CODE> functionality used in
<CODE>lio_listio</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this
function is available under the name <CODE>lio_listio</CODE> and so
transparently replaces the interface for small files on 32 bits
machines.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_227.html">previous</A>, <A HREF="libc_229.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
