<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - General Time String Parsing</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_402.html">previous</A>, <A HREF="libc_404.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC410" HREF="libc_toc.html#TOC410">A user-friendlier way to parse times and dates</A></H4>

<P>
The Unix standard defines another function to parse date strings.  The
interface is, mildly said, weird.  But if this function fits into the
application to be written it is just fine.  It is a problem when using
this function in multi-threaded programs or in libraries since it
returns a pointer to a static variable, uses a global variable, and a
global state (an environment variable).

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>getdate_err</B>
<DD><A NAME="IDX2334"></A>
This variable of type <CODE>int</CODE> will contain the error code of the last
unsuccessful call of the <CODE>getdate</CODE> function.  Defined values are:

</P>
<DL COMPACT>

<DT>@math{1}
<DD>
The environment variable <CODE>DATEMSK</CODE> is not defined or null.
<DT>@math{2}
<DD>
The template file denoted by the <CODE>DATEMSK</CODE> environment variable
cannot be opened.
<DT>@math{3}
<DD>
Information about the template file cannot retrieved.
<DT>@math{4}
<DD>
The template file is no regular file.
<DT>@math{5}
<DD>
An I/O error occurred while reading the template file.
<DT>@math{6}
<DD>
Not enough memory available to execute the function.
<DT>@math{7}
<DD>
The template file contains no matching template.
<DT>@math{8}
<DD>
The input string is invalid for a template which would match otherwise.
This includes error like February 31st, or return values which can be
represented using <CODE>time_t</CODE>.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> struct tm * <B>getdate</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX2335"></A>
The interface of the <CODE>getdate</CODE> function is the simplest possible
for a function to parse a string and return the value.  <VAR>string</VAR> is
the input string and the result is passed to the user in a statically
allocated variable.

</P>
<P>
The details about how the string is processed is hidden from the user.
In fact, it can be outside the control of the program.  Which formats
are recognized is controlled by the file named by the environment
variable <CODE>DATEMSK</CODE>.  The content of the named file should contain
lines of valid format strings which could be passed to <CODE>strptime</CODE>.

</P>
<P>
The <CODE>getdate</CODE> function reads these format strings one after the
other and tries to match the input string.  The first line which
completely matches the input string is used.

</P>
<P>
Elements which were not initialized through the format string get
assigned the values of the time the <CODE>getdate</CODE> function is called.

</P>
<P>
The format elements recognized by <CODE>getdate</CODE> are the same as for
<CODE>strptime</CODE>.  See above for an explanation.  There are only a few
extension to the <CODE>strptime</CODE> behavior:

</P>

<UL>
<LI>

If the <CODE>%Z</CODE> format is given the broken-down time is based on the
current time in the timezone matched, not in the current timezone of the
runtime environment.

<EM>Note</EM>: This is not implemented (currently).  The problem is that
timezone names are not unique.  If a fixed timezone is assumed for a
given string (say <CODE>EST</CODE> meaning US East Coast time) uses for
countries other than the USA will fail.  So far we have found no good
solution for this.

<LI>

If only the weekday is specified the selected day depends on the current
date.  If the current weekday is greater or equal to the <CODE>tm_wday</CODE>
value this weeks day is selected.  Otherwise next weeks day.

<LI>

A similar heuristic is used if only the month is given, not the year.
For value corresponding to the current or a later month the current year
s used.  Otherwise the next year.  The first day of the month is assumed
if it is not explicitly specified.

<LI>

The current hour, minute, and second is used if the appropriate value is
not set through the format.

<LI>

If no date is given the date for the next day is used if the time is
smaller than the current time.  Otherwise it is the same day.
</UL>

<P>
It should be noted that the format in the template file need not only
contain format elements.  The following is a list of possible format
strings (taken from the Unix standard):

</P>

<PRE>
%m
%A %B %d, %Y %H:%M:%S
%A
%B
%m/%d/%y %I %p
%d,%m,%Y %H:%M
at %A the %dst of %B in %Y
run job at %I %p,%B %dnd
%A den %d. %B %Y %H.%M Uhr
</PRE>

<P>
As one can see the template list can contain very specific strings like
<CODE>run job at %I %p,%B %dnd</CODE>.  Using the above list of templates and
assuming the current time is Mon Sep 22 12:19:47 EDT 1986 we can get the
following results for the given input.

</P>
<P>
@multitable {xxxxxxxxxxxx} {xxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}
<LI>Mon @tab       %a @tab    Mon Sep 22 12:19:47 EDT 1986

<LI>Sun @tab       %a @tab    Sun Sep 28 12:19:47 EDT 1986

<LI>Fri @tab       %a @tab    Fri Sep 26 12:19:47 EDT 1986

<LI>September @tab %B @tab    Mon Sep 1 12:19:47 EDT 1986

<LI>January @tab   %B @tab    Thu Jan 1 12:19:47 EST 1987

<LI>December @tab  %B @tab    Mon Dec 1 12:19:47 EST 1986

<LI>Sep Mon @tab   %b %a @tab Mon Sep 1 12:19:47 EDT 1986

<LI>Jan Fri @tab   %b %a @tab Fri Jan 2 12:19:47 EST 1987

<LI>Dec Mon @tab   %b %a @tab Mon Dec 1 12:19:47 EST 1986

<LI>Jan Wed 1989 @tab  %b %a %Y @tab Wed Jan 4 12:19:47 EST 1989

<LI>Fri 9 @tab     %a %H @tab Fri Sep 26 09:00:00 EDT 1986

<LI>Feb 10:30 @tab %b %H:%S @tab Sun Feb 1 10:00:30 EST 1987

<LI>10:30 @tab     %H:%M @tab Tue Sep 23 10:30:00 EDT 1986

<LI>13:30 @tab     %H:%M @tab Mon Sep 22 13:30:00 EDT 1986

The return value of the function is a pointer to a static variable of
type <CODE>struct tm</CODE> or a null pointer if an error occurred.  The
result in the variable pointed to by the return value is only valid
until the next <CODE>getdate</CODE> call which makes this function unusable in
multi-threaded applications.

The <CODE>errno</CODE> variable is <EM>not</EM> changed.  Error conditions are
signalled using the global variable <CODE>getdate_err</CODE>.  See the
description above for a list of the possible error values.

<EM>Warning:</EM> The <CODE>getdate</CODE> function should <EM>never</EM> be
used in SUID-programs.  The reason is obvious: using the
<CODE>DATEMSK</CODE> environment variable one can get the function to open
any arbitrary file and chances are high that with some bogus input
(such as a binary file) the program will crash.
</DL>

<DL>
<DT><U>Function:</U> int <B>getdate_r</B> <I>(const char *<VAR>string</VAR>, struct tm *<VAR>tp</VAR>)</I>
<DD><A NAME="IDX2336"></A>
The <CODE>getdate_r</CODE> function is the reentrant counterpart of
<CODE>getdate</CODE>.  It does not use the global variable <CODE>getdate_err</CODE>
to signal the error but instead the return value now is this error code.
The same error codes as described in the <CODE>getdate_err</CODE>
documentation above are used.

<CODE>getdate_r</CODE> also does not store the broken-down time in a static
variable.  Instead it takes an second argument which must be a pointer
to a variable of type <CODE>struct tm</CODE> where the broken-down can be
stored.

This function is not defined in the Unix standard.  Nevertheless it is
available on some other Unix systems as well.

As for <CODE>getdate</CODE> the warning for using this function in
SUID-programs applies to <CODE>getdate_r</CODE> as well.
</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_402.html">previous</A>, <A HREF="libc_404.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
