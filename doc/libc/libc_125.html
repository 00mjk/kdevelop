<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Tree Search Function</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_124.html">previous</A>, <A HREF="libc_126.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC132" HREF="libc_toc.html#TOC132">The <CODE>tsearch</CODE> function.</A></H2>

<P>
Another common form to organize data for efficient search is to use
trees.  The <CODE>tsearch</CODE> function family provides a nice interface to
functions to organize possibly large amounts of data by providing a mean
access time proportional to the logarithm of the number of elements.
The GNU C library implementation even guarantees that this bound is
never exceeded even for input data which cause problems for simple
binary tree implementations.

</P>
<P>
The functions described in the chapter are all described in the System
V and X/Open specifications and are therefore quite portable.

</P>
<P>
In contrast to the <CODE>hsearch</CODE> functions the <CODE>tsearch</CODE> functions
can be used with arbitrary data and not only zero-terminated strings.

</P>
<P>
The <CODE>tsearch</CODE> functions have the advantage that no function to
initialize data structures is necessary.  A simple pointer of type
<CODE>void *</CODE> initialized to <CODE>NULL</CODE> is a valid tree and can be
extended or searched.

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>tsearch</B> <I>(const void *<VAR>key</VAR>, void **<VAR>rootp</VAR>, comparison_fn_t <VAR>compar</VAR>)</I>
<DD><A NAME="IDX716"></A>
The <CODE>tsearch</CODE> function searches in the tree pointed to by
<CODE>*<VAR>rootp</VAR></CODE> for an element matching <VAR>key</VAR>.  The function
pointed to by <VAR>compar</VAR> is used to determine whether two elements
match.  See section <A HREF="libc_120.html#SEC127">Defining the Comparison Function</A>, for a specification of the functions
which can be used for the <VAR>compar</VAR> parameter.

</P>
<P>
If the tree does not contain a matching entry the <VAR>key</VAR> value will
be added to the tree.  <CODE>tsearch</CODE> does not make a copy of the object
pointed to by <VAR>key</VAR> (how could it since the size is unknown).
Instead it adds a reference to this object which means the object must
be available as long as the tree data structure is used.

</P>
<P>
The tree is represented by a pointer to a pointer since it is sometimes
necessary to change the root node of the tree.  So it must not be
assumed that the variable pointed to by <VAR>rootp</VAR> has the same value
after the call.  This also shows that it is not safe to call the
<CODE>tsearch</CODE> function more than once at the same time using the same
tree.  It is no problem to run it more than once at a time on different
trees.

</P>
<P>
The return value is a pointer to the matching element in the tree.  If a
new element was created the pointer points to the new data (which is in
fact <VAR>key</VAR>).  If an entry had to be created and the program ran out
of space <CODE>NULL</CODE> is returned.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>tfind</B> <I>(const void *<VAR>key</VAR>, void *const *<VAR>rootp</VAR>, comparison_fn_t <VAR>compar</VAR>)</I>
<DD><A NAME="IDX717"></A>
The <CODE>tfind</CODE> function is similar to the <CODE>tsearch</CODE> function.  It
locates an element matching the one pointed to by <VAR>key</VAR> and returns
a pointer to this element.  But if no matching element is available no
new element is entered (note that the <VAR>rootp</VAR> parameter points to a
constant pointer).  Instead the function returns <CODE>NULL</CODE>.
</DL>

</P>
<P>
Another advantage of the <CODE>tsearch</CODE> function in contrast to the
<CODE>hsearch</CODE> functions is that there is an easy way to remove
elements.

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>tdelete</B> <I>(const void *<VAR>key</VAR>, void **<VAR>rootp</VAR>, comparison_fn_t <VAR>compar</VAR>)</I>
<DD><A NAME="IDX718"></A>
To remove a specific element matching <VAR>key</VAR> from the tree
<CODE>tdelete</CODE> can be used.  It locates the matching element using the
same method as <CODE>tfind</CODE>.  The corresponding element is then removed
and the data if this tree node is returned by the function.  If there is
no matching entry in the tree nothing can be deleted and the function
returns <CODE>NULL</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>tdestroy</B> <I>(void *<VAR>vroot</VAR>, __free_fn_t <VAR>freefct</VAR>)</I>
<DD><A NAME="IDX719"></A>
If the complete search tree has to be removed one can use
<CODE>tdestroy</CODE>.  It frees all resources allocated by the <CODE>tsearch</CODE>
function to generate the tree pointed to by <VAR>vroot</VAR>.

</P>
<P>
For the data in each tree node the function <VAR>freefct</VAR> is called.
The pointer to the data is passed as the argument to the function.  If
no such work is necessary <VAR>freefct</VAR> must point to a function doing
nothing.  It is called in any case.

</P>
<P>
This function is a GNU extension and not covered by the System V or
X/Open specifications.
</DL>

</P>
<P>
In addition to the function to create and destroy the tree data
structure there is another function which allows to apply a function on
all elements of the tree.  The function must have this type:

</P>

<PRE>
void __action_fn_t (const void *nodep, VISIT value, int level);
</PRE>

<P>
The <VAR>nodep</VAR> is the data value of the current node (once given as the
<VAR>key</VAR> argument to <CODE>tsearch</CODE>).  <VAR>level</VAR> is a numeric value
which corresponds to the depth of the current node in the tree.  The
root node has the depth @math{0} and its children have a depth of
@math{1} and so on.  The <CODE>VISIT</CODE> type is an enumeration type.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>VISIT</B>
<DD><A NAME="IDX720"></A>
The <CODE>VISIT</CODE> value indicates the status of the current node in the
tree and how the function is called.  The status of a node is either
`leaf' or `internal node'.  For each leaf node the function is called
exactly once, for each internal node it is called three times: before
the first child is processed, after the first child is processed and
after both children are processed.  This makes it possible to handle all
three methods of tree traversal (or even a combination of them).

</P>
<DL COMPACT>

<DT><CODE>preorder</CODE>
<DD>
The current node is an internal node and the function is called before
the first child was processed.
<DT><CODE>endorder</CODE>
<DD>
The current node is an internal node and the function is called after
the first child was processed.
<DT><CODE>postorder</CODE>
<DD>
The current node is an internal node and the function is called after
the second child was processed.
<DT><CODE>leaf</CODE>
<DD>
The current node is a leaf.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> void <B>twalk</B> <I>(const void *<VAR>root</VAR>, __action_fn_t <VAR>action</VAR>)</I>
<DD><A NAME="IDX721"></A>
For each node in the tree with a node pointed to by <VAR>root</VAR> the
<CODE>twalk</CODE> function calls the function provided by the parameter
<VAR>action</VAR>.  For leaf nodes the function is called exactly once with
<VAR>value</VAR> set to <CODE>leaf</CODE>.  For internal nodes the function is
called three times, setting the <VAR>value</VAR> parameter or <VAR>action</VAR> to
the appropriate value.  The <VAR>level</VAR> argument for the <VAR>action</VAR>
function is computed while descending the tree with increasing the value
by one for the descend to a child, starting with the value @math{0} for
the root node.

</P>
<P>
Since the functions used for the <VAR>action</VAR> parameter to <CODE>twalk</CODE>
must not modify the tree data it is safe to run <CODE>twalk</CODE> is more
than one thread at the same time working on the same tree.  It is also
safe to call <CODE>tfind</CODE> in parallel.  Functions which modify the tree
must not be used.  Otherwise the behaviour is undefined.
</DL>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_124.html">previous</A>, <A HREF="libc_126.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
