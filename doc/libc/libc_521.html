<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Process Creation Example</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_520.html">previous</A>, <A HREF="libc_522.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC529" HREF="libc_toc.html#TOC529">Process Creation Example</A></H2>

<P>
Here is an example program showing how you might write a function
similar to the built-in <CODE>system</CODE>.  It executes its <VAR>command</VAR>
argument using the equivalent of <SAMP>`sh -c <VAR>command</VAR>'</SAMP>.

</P>

<PRE>
#include &#60;stddef.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;unistd.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;sys/wait.h&#62;

/* Execute the command using this shell program.  */
#define SHELL "/bin/sh"

int
my_system (const char *command)
{
  int status;
  pid_t pid;

  pid = fork ();
  if (pid == 0)
    {
      /* This is the child process.  Execute the shell command. */
      execl (SHELL, SHELL, "-c", command, NULL);
      _exit (EXIT_FAILURE);
    }
  else if (pid &#60; 0)
    /* The fork failed.  Report failure.  */
    status = -1;
  else
    /* This is the parent process.  Wait for the child to complete.  */
    if (waitpid (pid, &#38;status, 0) != pid)
      status = -1;
  return status;
}
</PRE>

<P>
There are a couple of things you should pay attention to in this
example.

</P>
<P>
Remember that the first <CODE>argv</CODE> argument supplied to the program
represents the name of the program being executed.  That is why, in the
call to <CODE>execl</CODE>, <CODE>SHELL</CODE> is supplied once to name the program
to execute and a second time to supply a value for <CODE>argv[0]</CODE>.

</P>
<P>
The <CODE>execl</CODE> call in the child process doesn't return if it is
successful.  If it fails, you must do something to make the child
process terminate.  Just returning a bad status code with <CODE>return</CODE>
would leave two processes running the original program.  Instead, the
right behavior is for the child process to report failure to its parent
process.

</P>
<P>
Call <CODE>_exit</CODE> to accomplish this.  The reason for using <CODE>_exit</CODE>
instead of <CODE>exit</CODE> is to avoid flushing fully buffered streams such
as <CODE>stdout</CODE>.  The buffers of these streams probably contain data
that was copied from the parent process by the <CODE>fork</CODE>, data that
will be output eventually by the parent process.  Calling <CODE>exit</CODE> in
the child would output the data twice.  See section <A HREF="libc_511.html#SEC519">Termination Internals</A>.
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_520.html">previous</A>, <A HREF="libc_522.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
