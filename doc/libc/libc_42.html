<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Preparing for Obstacks</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_41.html">previous</A>, <A HREF="libc_43.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC42" HREF="libc_toc.html#TOC42">Preparing for Using Obstacks</A></H3>

<P>
Each source file in which you plan to use the obstack functions
must include the header file <TT>`obstack.h'</TT>, like this:

</P>

<PRE>
#include &#60;obstack.h&#62;
</PRE>

<P>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>
Also, if the source file uses the macro <CODE>obstack_init</CODE>, it must
declare or define two functions or macros that will be called by the
obstack library.  One, <CODE>obstack_chunk_alloc</CODE>, is used to allocate
the chunks of memory into which objects are packed.  The other,
<CODE>obstack_chunk_free</CODE>, is used to return chunks when the objects in
them are freed.  These macros should appear before any use of obstacks
in the source file.

</P>
<P>
Usually these are defined to use <CODE>malloc</CODE> via the intermediary
<CODE>xmalloc</CODE> (see section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>).  This is done with
the following pair of macro definitions:

</P>

<PRE>
#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
</PRE>

<P>
Though the storage you get using obstacks really comes from <CODE>malloc</CODE>,
using obstacks is faster because <CODE>malloc</CODE> is called less often, for
larger blocks of memory.  See section <A HREF="libc_50.html#SEC50">Obstack Chunks</A>, for full details.

</P>
<P>
At run time, before the program can use a <CODE>struct obstack</CODE> object
as an obstack, it must initialize the obstack by calling
<CODE>obstack_init</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>obstack_init</B> <I>(struct obstack *<VAR>obstack-ptr</VAR>)</I>
<DD><A NAME="IDX263"></A>
Initialize obstack <VAR>obstack-ptr</VAR> for allocation of objects.  This
function calls the obstack's <CODE>obstack_chunk_alloc</CODE> function.  If
allocation of memory fails, the function pointed to by
<CODE>obstack_alloc_failed_handler</CODE> is called.  The <CODE>obstack_init</CODE>
function always returns 1 (Compatibility notice: Former versions of
obstack returned 0 if allocation failed).
</DL>

</P>
<P>
Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:

</P>

<PRE>
static struct obstack myobstack;
...
obstack_init (&#38;myobstack);
</PRE>

<P>
Second, an obstack that is itself dynamically allocated:

</P>

<PRE>
struct obstack *myobstack_ptr
  = (struct obstack *) xmalloc (sizeof (struct obstack));

obstack_init (myobstack_ptr);
</PRE>

<P>
<DL>
<DT><U>Variable:</U> <B>obstack_alloc_failed_handler</B>
<DD><A NAME="IDX264"></A>
The value of this variable is a pointer to a function that
<CODE>obstack</CODE> uses when <CODE>obstack_chunk_alloc</CODE> fails to allocate
memory.  The default action is to print a message and abort.
You should supply a function that either calls <CODE>exit</CODE>
(see section <A HREF="libc_506.html#SEC514">Program Termination</A>) or <CODE>longjmp</CODE> (see section <A HREF="libc_413.html#SEC420">Non-Local Exits</A>) and doesn't return.

</P>

<PRE>
void my_obstack_alloc_failed (void)
...
obstack_alloc_failed_handler = &#38;my_obstack_alloc_failed;
</PRE>

</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_41.html">previous</A>, <A HREF="libc_43.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
