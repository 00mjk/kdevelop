<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - File Position Primitive</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_216.html">previous</A>, <A HREF="libc_218.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC224" HREF="libc_toc.html#TOC224">Setting the File Position of a Descriptor</A></H2>

<P>
Just as you can set the file position of a stream with <CODE>fseek</CODE>, you
can set the file position of a descriptor with <CODE>lseek</CODE>.  This
specifies the position in the file for the next <CODE>read</CODE> or
<CODE>write</CODE> operation.  See section <A HREF="libc_197.html#SEC204">File Positioning</A>, for more information
on the file position and what it means.

</P>
<P>
To read the current file position value from a descriptor, use
<CODE>lseek (<VAR>desc</VAR>, 0, SEEK_CUR)</CODE>.

</P>
<P>
<A NAME="IDX1002"></A>
<A NAME="IDX1003"></A>
<A NAME="IDX1004"></A>
<DL>
<DT><U>Function:</U> off_t <B>lseek</B> <I>(int <VAR>filedes</VAR>, off_t <VAR>offset</VAR>, int <VAR>whence</VAR>)</I>
<DD><A NAME="IDX1005"></A>
The <CODE>lseek</CODE> function is used to change the file position of the
file with descriptor <VAR>filedes</VAR>.

</P>
<P>
The <VAR>whence</VAR> argument specifies how the <VAR>offset</VAR> should be
interpreted in the same way as for the <CODE>fseek</CODE> function, and must be
one of the symbolic constants <CODE>SEEK_SET</CODE>, <CODE>SEEK_CUR</CODE>, or
<CODE>SEEK_END</CODE>.

</P>
<DL COMPACT>

<DT><CODE>SEEK_SET</CODE>
<DD>
Specifies that <VAR>whence</VAR> is a count of characters from the beginning
of the file.

<DT><CODE>SEEK_CUR</CODE>
<DD>
Specifies that <VAR>whence</VAR> is a count of characters from the current
file position.  This count may be positive or negative.

<DT><CODE>SEEK_END</CODE>
<DD>
Specifies that <VAR>whence</VAR> is a count of characters from the end of
the file.  A negative count specifies a position within the current
extent of the file; a positive count specifies a position past the
current end.  If you set the position past the current end, and
actually write data, you will extend the file with zeros up to that
position.
</DL>

<P>
The return value from <CODE>lseek</CODE> is normally the resulting file
position, measured in bytes from the beginning of the file.
You can use this feature together with <CODE>SEEK_CUR</CODE> to read the
current file position.

</P>
<P>
If you want to append to the file, setting the file position to the
current end of file with <CODE>SEEK_END</CODE> is not sufficient.  Another
process may write more data after you seek but before you write,
extending the file so the position you write onto clobbers their data.
Instead, use the <CODE>O_APPEND</CODE> operating mode; see section <A HREF="libc_239.html#SEC246">I/O Operating Modes</A>.

</P>
<P>
You can set the file position past the current end of the file.  This
does not by itself make the file longer; <CODE>lseek</CODE> never changes the
file.  But subsequent output at that position will extend the file.
Characters between the previous end of file and the new position are
filled with zeros.  Extending the file in this way can create a
"hole": the blocks of zeros are not actually allocated on disk, so the
file takes up less space than it appears so; it is then called a
"sparse file".
<A NAME="IDX1006"></A>
<A NAME="IDX1007"></A>

</P>
<P>
If the file position cannot be changed, or the operation is in some way
invalid, <CODE>lseek</CODE> returns a value of @math{-1}.  The following
<CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>filedes</VAR> is not a valid file descriptor.

<DT><CODE>EINVAL</CODE>
<DD>
The <VAR>whence</VAR> argument value is not valid, or the resulting
file offset is not valid.  A file offset is invalid.

<DT><CODE>ESPIPE</CODE>
<DD>
The <VAR>filedes</VAR> corresponds to an object that cannot be positioned,
such as a pipe, FIFO or terminal device.  (POSIX.1 specifies this error
only for pipes and FIFOs, but in the GNU system, you always get
<CODE>ESPIPE</CODE> if the object is not seekable.)
</DL>

<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> the
<CODE>lseek</CODE> function is in fact <CODE>lseek64</CODE> and the type
<CODE>off_t</CODE> has 64 bits which makes it possible to handle files up to
@math{2^63} bytes in length.

</P>
<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>lseek</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>lseek</CODE> should be
protected using cancelation handlers.

</P>
<P>
The <CODE>lseek</CODE> function is the underlying primitive for the
<CODE>fseek</CODE>, <CODE>fseeko</CODE>, <CODE>ftell</CODE>, <CODE>ftello</CODE> and
<CODE>rewind</CODE> functions, which operate on streams instead of file
descriptors.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> off64_t <B>lseek64</B> <I>(int <VAR>filedes</VAR>, off64_t <VAR>offset</VAR>, int <VAR>whence</VAR>)</I>
<DD><A NAME="IDX1008"></A>
This function is similar to the <CODE>lseek</CODE> function.  The difference
is that the <VAR>offset</VAR> parameter is of type <CODE>off64_t</CODE> instead of
<CODE>off_t</CODE> which makes it possible on 32 bits machines to address
files larger than @math{2^31} bytes and up to @math{2^63} bytes.  The
file descriptor <CODE>filedes</CODE> must be opened using <CODE>open64</CODE> since
otherwise the large offsets possible with <CODE>off64_t</CODE> will lead to
errors with a descriptor in small file mode.

</P>
<P>
When the source file is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits machine this function is actually available under the name
<CODE>lseek</CODE> and so transparently replaces the 32 bits interface.
</DL>

</P>
<P>
You can have multiple descriptors for the same file if you open the file
more than once, or if you duplicate a descriptor with <CODE>dup</CODE>.
Descriptors that come from separate calls to <CODE>open</CODE> have independent
file positions; using <CODE>lseek</CODE> on one descriptor has no effect on the
other.  For example,

</P>

<PRE>
{
  int d1, d2;
  char buf[4];
  d1 = open ("foo", O_RDONLY);
  d2 = open ("foo", O_RDONLY);
  lseek (d1, 1024, SEEK_SET);
  read (d2, buf, 4);
}
</PRE>

<P>
will read the first four characters of the file <TT>`foo'</TT>.  (The
error-checking code necessary for a real program has been omitted here
for brevity.)

</P>
<P>
By contrast, descriptors made by duplication share a common file
position with the original descriptor that was duplicated.  Anything
which alters the file position of one of the duplicates, including
reading or writing data, affects all of them alike.  Thus, for example,

</P>

<PRE>
{
  int d1, d2, d3;
  char buf1[4], buf2[4];
  d1 = open ("foo", O_RDONLY);
  d2 = dup (d1);
  d3 = dup (d2);
  lseek (d3, 1024, SEEK_SET);
  read (d1, buf1, 4);
  read (d2, buf2, 4);
}
</PRE>

<P>
will read four characters starting with the 1024'th character of
<TT>`foo'</TT>, and then four more characters starting with the 1028'th
character.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>off_t</B>
<DD><A NAME="IDX1009"></A>
This is an arithmetic data type used to represent file sizes.
In the GNU system, this is equivalent to <CODE>fpos_t</CODE> or <CODE>long int</CODE>.

</P>
<P>
If the source is compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> this type
is transparently replaced by <CODE>off64_t</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>off64_t</B>
<DD><A NAME="IDX1010"></A>
This type is used similar to <CODE>off_t</CODE>.  The difference is that even
on 32 bits machines, where the <CODE>off_t</CODE> type would have 32 bits,
<CODE>off64_t</CODE> has 64 bits and so is able to address files up to
@math{2^63} bytes in length.

</P>
<P>
When compiling with <CODE>_FILE_OFFSET_BITS == 64</CODE> this type is
available under the name <CODE>off_t</CODE>.
</DL>

</P>
<P>
These aliases for the <SAMP>`SEEK_...'</SAMP> constants exist for the sake
of compatibility with older BSD systems.  They are defined in two
different header files: <TT>`fcntl.h'</TT> and <TT>`sys/file.h'</TT>.

</P>
<DL COMPACT>

<DT><CODE>L_SET</CODE>
<DD>
An alias for <CODE>SEEK_SET</CODE>.

<DT><CODE>L_INCR</CODE>
<DD>
An alias for <CODE>SEEK_CUR</CODE>.

<DT><CODE>L_XTND</CODE>
<DD>
An alias for <CODE>SEEK_END</CODE>.
</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_216.html">previous</A>, <A HREF="libc_218.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
