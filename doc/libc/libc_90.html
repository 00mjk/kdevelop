<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Generic Conversion Interface</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_89.html">previous</A>, <A HREF="libc_91.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC90" HREF="libc_toc.html#TOC90">Generic Character Set Conversion Interface</A></H3>

<P>
This set of functions follows the traditional cycle of using a resource:
open--use--close.  The interface consists of three functions, each of
which implement one step.

</P>
<P>
Before the interfaces are described it is necessary to introduce a
datatype.  Just like other open--use--close interface the functions
introduced here work using a handles and the <TT>`iconv.h'</TT> header
defines a special type for the handles used.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>iconv_t</B>
<DD><A NAME="IDX558"></A>
This data type is an abstract type defined in <TT>`iconv.h'</TT>.  The user
must not assume anything about the definition of this type, it must be
completely opaque.

</P>
<P>
Objects of this type can get assigned handles for the conversions using
the <CODE>iconv</CODE> functions.  The objects themselves need not be freed but
the conversions for which the handles stand for have to.
</DL>

</P>
<P>
The first step is the function to create a handle.

</P>
<P>
<DL>
<DT><U>Function:</U> iconv_t <B>iconv_open</B> <I>(const char *<VAR>tocode</VAR>, const char *<VAR>fromcode</VAR>)</I>
<DD><A NAME="IDX559"></A>
The <CODE>iconv_open</CODE> function has to be used before starting a
conversion.  The two parameters this function takes determine the
source and destination character set for the conversion and if the
implementation has the possibility to perform such a conversion the
function returns a handle.

</P>
<P>
If the wanted conversion is not available the function returns
<CODE>(iconv_t) -1</CODE>.  In this case the global variable <CODE>errno</CODE> can
have the following values:

</P>
<DL COMPACT>

<DT><CODE>EMFILE</CODE>
<DD>
The process already has <CODE>OPEN_MAX</CODE> file descriptors open.
<DT><CODE>ENFILE</CODE>
<DD>
The system limit of open file is reached.
<DT><CODE>ENOMEM</CODE>
<DD>
Not enough memory to carry out the operation.
<DT><CODE>EINVAL</CODE>
<DD>
The conversion from <VAR>fromcode</VAR> to <VAR>tocode</VAR> is not supported.
</DL>

<P>
It is not possible to use the same descriptor in different threads to
perform independent conversions.  Within the data structures associated
with the descriptor there is information about the conversion state.
This must not be messed up by using it in different conversions.

</P>
<P>
An <CODE>iconv</CODE> descriptor is like a file descriptor as for every use a
new descriptor must be created.  The descriptor does not stand for all
of the conversions from <VAR>fromset</VAR> to <VAR>toset</VAR>.

</P>
<P>
The GNU C library implementation of <CODE>iconv_open</CODE> has one
significant extension to other implementations.  To ease the extension
of the set of available conversions the implementation allows storing
the necessary files with data and code in arbitrarily many directories.
How this extension has to be written will be explained below
(see section <A HREF="libc_93.html#SEC93">The <CODE>iconv</CODE> Implementation in the GNU C library</A>).  Here it is only important to say
that all directories mentioned in the <CODE>GCONV_PATH</CODE> environment
variable are considered if they contain a file <TT>`gconv-modules'</TT>.
These directories need not necessarily be created by the system
administrator.  In fact, this extension is introduced to help users
writing and using their own, new conversions.  Of course this does not work
for security reasons in SUID binaries; in this case only the system
directory is considered and this normally is
<TT>`<VAR>prefix</VAR>/lib/gconv'</TT>.  The <CODE>GCONV_PATH</CODE> environment
variable is examined exactly once at the first call of the
<CODE>iconv_open</CODE> function.  Later modifications of the variable have no
effect.

</P>
<P>
<A NAME="IDX560"></A>
This function got introduced early in the X/Open Portability Guide,
version 2.  It is supported by all commercial Unices as it is
required for the Unix branding.  However, the quality and completeness
of the implementation varies widely.  The function is declared in
<TT>`iconv.h'</TT>.
</DL>

</P>
<P>
The <CODE>iconv</CODE> implementation can associate large data structure with
the handle returned by <CODE>iconv_open</CODE>.  Therefore it is crucial to
free all the resources once all conversions are carried out and the
conversion is not needed anymore.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>iconv_close</B> <I>(iconv_t <VAR>cd</VAR>)</I>
<DD><A NAME="IDX561"></A>
The <CODE>iconv_close</CODE> function frees all resources associated with the
handle <VAR>cd</VAR> which must have been returned by a successful call to
the <CODE>iconv_open</CODE> function.

</P>
<P>
If the function call was successful the return value is @math{0}.
Otherwise it is @math{-1} and <CODE>errno</CODE> is set appropriately.
Defined error are:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The conversion descriptor is invalid.
</DL>

<P>
<A NAME="IDX562"></A>
This function was introduced together with the rest of the <CODE>iconv</CODE>
functions in XPG2 and it is declared in <TT>`iconv.h'</TT>.
</DL>

</P>
<P>
The standard defines only one actual conversion function.  This has
therefore the most general interface: it allows conversion from one
buffer to another.  Conversion from a file to a buffer, vice versa, or
even file to file can be implemented on top of it.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>iconv</B> <I>(iconv_t <VAR>cd</VAR>, const char **<VAR>inbuf</VAR>, size_t *<VAR>inbytesleft</VAR>, char **<VAR>outbuf</VAR>, size_t *<VAR>outbytesleft</VAR>)</I>
<DD><A NAME="IDX563"></A>
<A NAME="IDX564"></A>
The <CODE>iconv</CODE> function converts the text in the input buffer
according to the rules associated with the descriptor <VAR>cd</VAR> and
stores the result in the output buffer.  It is possible to call the
function for the same text several times in a row since for stateful
character sets the necessary state information is kept in the data
structures associated with the descriptor.

</P>
<P>
The input buffer is specified by <CODE>*<VAR>inbuf</VAR></CODE> and it contains
<CODE>*<VAR>inbytesleft</VAR></CODE> bytes.  The extra indirection is necessary for
communicating the used input back to the caller (see below).  It is
important to note that the buffer pointer is of type <CODE>char</CODE> and the
length is measured in bytes even if the input text is encoded in wide
characters.

</P>
<P>
The output buffer is specified in a similar way.  <CODE>*<VAR>outbuf</VAR></CODE>
points to the beginning of the buffer with at least
<CODE>*<VAR>outbytesleft</VAR></CODE> bytes room for the result.  The buffer
pointer again is of type <CODE>char</CODE> and the length is measured in
bytes.  If <VAR>outbuf</VAR> or <CODE>*<VAR>outbuf</VAR></CODE> is a null pointer the
conversion is performed but no output is available.

</P>
<P>
If <VAR>inbuf</VAR> is a null pointer the <CODE>iconv</CODE> function performs the
necessary action to put the state of the conversion into the initial
state.  This is obviously a no-op for non-stateful encodings, but if the
encoding has a state such a function call might put some byte sequences
in the output buffer which perform the necessary state changes.  The
next call with <VAR>inbuf</VAR> not being a null pointer then simply goes on
from the initial state.  It is important that the programmer never makes
any assumption on whether the conversion has to deal with states or not.
Even if the input and output character sets are not stateful the
implementation might still have to keep states.  This is due to the
implementation chosen for the GNU C library as it is described below.
Therefore an <CODE>iconv</CODE> call to reset the state should always be
performed if some protocol requires this for the output text.

</P>
<P>
The conversion stops for three reasons.  The first is that all
characters from the input buffer are converted.  This actually can mean
two things: really all bytes from the input buffer are consumed or
there are some bytes at the end of the buffer which possibly can form a
complete character but the input is incomplete.  The second reason for a
stop is when the output buffer is full.  And the third reason is that
the input contains invalid characters.

</P>
<P>
In all these cases the buffer pointers after the last successful
conversion, for input and output buffer, are stored in <VAR>inbuf</VAR> and
<VAR>outbuf</VAR> and the available room in each buffer is stored in
<VAR>inbytesleft</VAR> and <VAR>outbytesleft</VAR>.

</P>
<P>
Since the character sets selected in the <CODE>iconv_open</CODE> call can be
almost arbitrary there can be situations where the input buffer contains
valid characters which have no identical representation in the output
character set.  The behavior in this situation is undefined.  The
<EM>current</EM> behavior of the GNU C library in this situation is to
return with an error immediately.  This certainly is not the most
desirable solution.  Therefore future versions will provide better ones
but they are not yet finished.

</P>
<P>
If all input from the input buffer is successfully converted and stored
in the output buffer the function returns the number of non-reversible
conversions performed.  In all other cases the return value is
<CODE>(size_t) -1</CODE> and <CODE>errno</CODE> is set appropriately.  In this case
the value pointed to by <VAR>inbytesleft</VAR> is nonzero.

</P>
<DL COMPACT>

<DT><CODE>EILSEQ</CODE>
<DD>
The conversion stopped because of an invalid byte sequence in the input.
After the call <CODE>*<VAR>inbuf</VAR></CODE> points at the first byte of the
invalid byte sequence.

<DT><CODE>E2BIG</CODE>
<DD>
The conversion stopped because it ran out of space in the output buffer.

<DT><CODE>EINVAL</CODE>
<DD>
The conversion stopped because of an incomplete byte sequence at the end
of the input buffer.

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>cd</VAR> argument is invalid.
</DL>

<P>
<A NAME="IDX565"></A>
This function was introduced in the XPG2 standard and is declared in the
<TT>`iconv.h'</TT> header.
</DL>

</P>
<P>
The definition of the <CODE>iconv</CODE> function is quite good overall.  It
provides quite flexible functionality.  The only problems lie in the
boundary cases which are incomplete byte sequences at the end of the
input buffer and invalid input.  A third problem, which is not really
a design problem, is the way conversions are selected.  The standard
does not say anything about the legitimate names, a minimal set of
available conversions.  We will see how this negatively impacts other
implementations, as is demonstrated below.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_89.html">previous</A>, <A HREF="libc_91.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
