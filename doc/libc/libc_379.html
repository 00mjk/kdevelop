<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Normalization Functions</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_378.html">previous</A>, <A HREF="libc_380.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC386" HREF="libc_toc.html#TOC386">Normalization Functions</A></H3>
<P>
<A NAME="IDX2109"></A>

</P>
<P>
The functions described in this section are primarily provided as a way
to efficiently perform certain low-level manipulations on floating point
numbers that are represented internally using a binary radix;
see section <A HREF="libc_631.html#SEC639">Floating Point Representation Concepts</A>.  These functions are required to
have equivalent behavior even if the representation does not use a radix
of 2, but of course they are unlikely to be particularly efficient in
those cases.

</P>
<P>
<A NAME="IDX2110"></A>
All these functions are declared in <TT>`math.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>frexp</B> <I>(double <VAR>value</VAR>, int *<VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2111"></A>
<DT><U>Function:</U> float <B>frexpf</B> <I>(float <VAR>value</VAR>, int *<VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2112"></A>
<DT><U>Function:</U> long double <B>frexpl</B> <I>(long double <VAR>value</VAR>, int *<VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2113"></A>
These functions are used to split the number <VAR>value</VAR>
into a normalized fraction and an exponent.

</P>
<P>
If the argument <VAR>value</VAR> is not zero, the return value is <VAR>value</VAR>
times a power of two, and is always in the range 1/2 (inclusive) to 1
(exclusive).  The corresponding exponent is stored in
<CODE>*<VAR>exponent</VAR></CODE>; the return value multiplied by 2 raised to this
exponent equals the original number <VAR>value</VAR>.

</P>
<P>
For example, <CODE>frexp (12.8, &#38;exponent)</CODE> returns <CODE>0.8</CODE> and
stores <CODE>4</CODE> in <CODE>exponent</CODE>.

</P>
<P>
If <VAR>value</VAR> is zero, then the return value is zero and
zero is stored in <CODE>*<VAR>exponent</VAR></CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>ldexp</B> <I>(double <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2114"></A>
<DT><U>Function:</U> float <B>ldexpf</B> <I>(float <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2115"></A>
<DT><U>Function:</U> long double <B>ldexpl</B> <I>(long double <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2116"></A>
These functions return the result of multiplying the floating-point
number <VAR>value</VAR> by 2 raised to the power <VAR>exponent</VAR>.  (It can
be used to reassemble floating-point numbers that were taken apart
by <CODE>frexp</CODE>.)

</P>
<P>
For example, <CODE>ldexp (0.8, 4)</CODE> returns <CODE>12.8</CODE>.
</DL>

</P>
<P>
The following functions, which come from BSD, provide facilities
equivalent to those of <CODE>ldexp</CODE> and <CODE>frexp</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>logb</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2117"></A>
<DT><U>Function:</U> float <B>logbf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2118"></A>
<DT><U>Function:</U> long double <B>logbl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2119"></A>
These functions return the integer part of the base-2 logarithm of
<VAR>x</VAR>, an integer value represented in type <CODE>double</CODE>.  This is
the highest integer power of <CODE>2</CODE> contained in <VAR>x</VAR>.  The sign of
<VAR>x</VAR> is ignored.  For example, <CODE>logb (3.5)</CODE> is <CODE>1.0</CODE> and
<CODE>logb (4.0)</CODE> is <CODE>2.0</CODE>.

</P>
<P>
When <CODE>2</CODE> raised to this power is divided into <VAR>x</VAR>, it gives a
quotient between <CODE>1</CODE> (inclusive) and <CODE>2</CODE> (exclusive).

</P>
<P>
If <VAR>x</VAR> is zero, the return value is minus infinity if the machine
supports infinities, and a very small number if it does not.  If <VAR>x</VAR>
is infinity, the return value is infinity.

</P>
<P>
For finite <VAR>x</VAR>, the value returned by <CODE>logb</CODE> is one less than
the value that <CODE>frexp</CODE> would store into <CODE>*<VAR>exponent</VAR></CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>scalb</B> <I>(double <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2120"></A>
<DT><U>Function:</U> float <B>scalbf</B> <I>(float <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2121"></A>
<DT><U>Function:</U> long double <B>scalbl</B> <I>(long double <VAR>value</VAR>, int <VAR>exponent</VAR>)</I>
<DD><A NAME="IDX2122"></A>
The <CODE>scalb</CODE> function is the BSD name for <CODE>ldexp</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>scalbn</B> <I>(double <VAR>x</VAR>, int n)</I>
<DD><A NAME="IDX2123"></A>
<DT><U>Function:</U> long long int <B>scalbnf</B> <I>(float <VAR>x</VAR>, int n)</I>
<DD><A NAME="IDX2124"></A>
<DT><U>Function:</U> long long int <B>scalbnl</B> <I>(long double <VAR>x</VAR>, int n)</I>
<DD><A NAME="IDX2125"></A>
<CODE>scalbn</CODE> is identical to <CODE>scalb</CODE>, except that the exponent
<VAR>n</VAR> is an <CODE>int</CODE> instead of a floating-point number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>scalbln</B> <I>(double <VAR>x</VAR>, long int n)</I>
<DD><A NAME="IDX2126"></A>
<DT><U>Function:</U> long long int <B>scalblnf</B> <I>(float <VAR>x</VAR>, long int n)</I>
<DD><A NAME="IDX2127"></A>
<DT><U>Function:</U> long long int <B>scalblnl</B> <I>(long double <VAR>x</VAR>, long int n)</I>
<DD><A NAME="IDX2128"></A>
<CODE>scalbln</CODE> is identical to <CODE>scalb</CODE>, except that the exponent
<VAR>n</VAR> is a <CODE>long int</CODE> instead of a floating-point number.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> long long int <B>significand</B> <I>(double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2129"></A>
<DT><U>Function:</U> long long int <B>significandf</B> <I>(float <VAR>x</VAR>)</I>
<DD><A NAME="IDX2130"></A>
<DT><U>Function:</U> long long int <B>significandl</B> <I>(long double <VAR>x</VAR>)</I>
<DD><A NAME="IDX2131"></A>
<CODE>significand</CODE> returns the mantissa of <VAR>x</VAR> scaled to the range
@math{[1, 2)}.
It is equivalent to <CODE>scalb (<VAR>x</VAR>, (double) -ilogb (<VAR>x</VAR>))</CODE>.

</P>
<P>
This function exists mainly for use in certain standardized tests
of IEEE 754 conformance.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_378.html">previous</A>, <A HREF="libc_380.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
