<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Cancellation</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_604.html">previous</A>, <A HREF="libc_606.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC613" HREF="libc_toc.html#TOC613">Cancellation</A></H2>

<P>
Cancellation is the mechanism by which a thread can terminate the
execution of another thread. More precisely, a thread can send a
cancellation request to another thread. Depending on its settings, the
target thread can then either ignore the request, honor it immediately,
or defer it till it reaches a cancellation point.  When threads are
first created by <CODE>pthread_create</CODE>, they always defer cancellation
requests.

</P>
<P>
When a thread eventually honors a cancellation request, it behaves as if
<CODE>pthread_exit(PTHREAD_CANCELED)</CODE> was called.  All cleanup handlers
are executed in reverse order, finalization functions for
thread-specific data are called, and finally the thread stops executing.
If the cancelled thread was joinable, the return value
<CODE>PTHREAD_CANCELED</CODE> is provided to whichever thread calls
<VAR>pthread_join</VAR> on it. See <CODE>pthread_exit</CODE> for more information.

</P>
<P>
Cancellation points are the points where the thread checks for pending
cancellation requests and performs them.  The POSIX threads functions
<CODE>pthread_join</CODE>, <CODE>pthread_cond_wait</CODE>,
<CODE>pthread_cond_timedwait</CODE>, <CODE>pthread_testcancel</CODE>,
<CODE>sem_wait</CODE>, and <CODE>sigwait</CODE> are cancellation points.  In
addition, these system calls are cancellation points:

</P>
<P>
@multitable @columnfractions .33 .33 .33
<LI><TT>accept</TT>	@tab <TT>open</TT>		@tab <TT>sendmsg</TT>

<LI><TT>close</TT>		@tab <TT>pause</TT>		@tab <TT>sendto</TT>

<LI><TT>connect</TT>	@tab <TT>read</TT>		@tab <TT>system</TT>

<LI><TT>fcntl</TT>		@tab <TT>recv</TT>		@tab <TT>tcdrain</TT>

<LI><TT>fsync</TT>		@tab <TT>recvfrom</TT>	@tab <TT>wait</TT>

<LI><TT>lseek</TT>		@tab <TT>recvmsg</TT>	@tab <TT>waitpid</TT>

<LI><TT>msync</TT>		@tab <TT>send</TT>		@tab <TT>write</TT>

<LI><TT>nanosleep</TT>

All library functions that call these functions (such as
<CODE>printf</CODE>) are also cancellation points.

<DL>
<DT><U>Function:</U> int <B>pthread_setcancelstate</B> <I>(int <VAR>state</VAR>, int *<VAR>oldstate</VAR>)</I>
<DD><A NAME="IDX3150"></A>
<CODE>pthread_setcancelstate</CODE> changes the cancellation state for the
calling thread -- that is, whether cancellation requests are ignored or
not. The <VAR>state</VAR> argument is the new cancellation state: either
<CODE>PTHREAD_CANCEL_ENABLE</CODE> to enable cancellation, or
<CODE>PTHREAD_CANCEL_DISABLE</CODE> to disable cancellation (cancellation
requests are ignored).

If <VAR>oldstate</VAR> is not <CODE>NULL</CODE>, the previous cancellation state is
stored in the location pointed to by <VAR>oldstate</VAR>, and can thus be
restored later by another call to <CODE>pthread_setcancelstate</CODE>.

If the <VAR>state</VAR> argument is not <CODE>PTHREAD_CANCEL_ENABLE</CODE> or
<CODE>PTHREAD_CANCEL_DISABLE</CODE>, <CODE>pthread_setcancelstate</CODE> fails and
returns <CODE>EINVAL</CODE>.  Otherwise it returns 0.
</DL>

<DL>
<DT><U>Function:</U> int <B>pthread_setcanceltype</B> <I>(int <VAR>type</VAR>, int *<VAR>oldtype</VAR>)</I>
<DD><A NAME="IDX3151"></A>
<CODE>pthread_setcanceltype</CODE> changes the type of responses to
cancellation requests for the calling thread: asynchronous (immediate)
or deferred.  The <VAR>type</VAR> argument is the new cancellation type:
either <CODE>PTHREAD_CANCEL_ASYNCHRONOUS</CODE> to cancel the calling thread
as soon as the cancellation request is received, or
<CODE>PTHREAD_CANCEL_DEFERRED</CODE> to keep the cancellation request pending
until the next cancellation point. If <VAR>oldtype</VAR> is not <CODE>NULL</CODE>,
the previous cancellation state is stored in the location pointed to by
<VAR>oldtype</VAR>, and can thus be restored later by another call to
<CODE>pthread_setcanceltype</CODE>.

If the <VAR>type</VAR> argument is not <CODE>PTHREAD_CANCEL_DEFERRED</CODE> or
<CODE>PTHREAD_CANCEL_ASYNCHRONOUS</CODE>, <CODE>pthread_setcanceltype</CODE> fails
and returns <CODE>EINVAL</CODE>.  Otherwise it returns 0.
</DL>

<DL>
<DT><U>Function:</U> void <B>pthread_testcancel</B> <I>(<VAR>void</VAR>)</I>
<DD><A NAME="IDX3152"></A>
<CODE>pthread_testcancel</CODE> does nothing except testing for pending
cancellation and executing it. Its purpose is to introduce explicit
checks for cancellation in long sequences of code that do not call
cancellation point functions otherwise.
</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_604.html">previous</A>, <A HREF="libc_606.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
