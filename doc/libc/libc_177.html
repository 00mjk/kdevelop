<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Parsing a Template String</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_176.html">previous</A>, <A HREF="libc_178.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC184" HREF="libc_toc.html#TOC184">Parsing a Template String</A></H3>
<P>
<A NAME="IDX842"></A>

</P>
<P>
You can use the function <CODE>parse_printf_format</CODE> to obtain
information about the number and types of arguments that are expected by
a given template string.  This function permits interpreters that
provide interfaces to <CODE>printf</CODE> to avoid passing along invalid
arguments from the user's program, which could cause a crash.

</P>
<P>
All the symbols described in this section are declared in the header
file <TT>`printf.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>parse_printf_format</B> <I>(const char *<VAR>template</VAR>, size_t <VAR>n</VAR>, int *<VAR>argtypes</VAR>)</I>
<DD><A NAME="IDX843"></A>
This function returns information about the number and types of
arguments expected by the <CODE>printf</CODE> template string <VAR>template</VAR>.
The information is stored in the array <VAR>argtypes</VAR>; each element of
this array describes one argument.  This information is encoded using
the various <SAMP>`PA_'</SAMP> macros, listed below.

</P>
<P>
The <VAR>n</VAR> argument specifies the number of elements in the array
<VAR>argtypes</VAR>.  This is the most elements that
<CODE>parse_printf_format</CODE> will try to write.

</P>
<P>
<CODE>parse_printf_format</CODE> returns the total number of arguments required
by <VAR>template</VAR>.  If this number is greater than <VAR>n</VAR>, then the
information returned describes only the first <VAR>n</VAR> arguments.  If you
want information about more than that many arguments, allocate a bigger
array and call <CODE>parse_printf_format</CODE> again.
</DL>

</P>
<P>
The argument types are encoded as a combination of a basic type and
modifier flag bits.

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>PA_FLAG_MASK</B>
<DD><A NAME="IDX844"></A>
This macro is a bitmask for the type modifier flag bits.  You can write
the expression <CODE>(argtypes[i] &#38; PA_FLAG_MASK)</CODE> to extract just the
flag bits for an argument, or <CODE>(argtypes[i] &#38; ~PA_FLAG_MASK)</CODE> to
extract just the basic type code.
</DL>

</P>
<P>
Here are symbolic constants that represent the basic types; they stand
for integer values.

</P>
<DL COMPACT>

<DT><CODE>PA_INT</CODE>
<DD>
<A NAME="IDX845"></A>
This specifies that the base type is <CODE>int</CODE>.

<DT><CODE>PA_CHAR</CODE>
<DD>
<A NAME="IDX846"></A>
This specifies that the base type is <CODE>int</CODE>, cast to <CODE>char</CODE>.

<DT><CODE>PA_STRING</CODE>
<DD>
<A NAME="IDX847"></A>
This specifies that the base type is <CODE>char *</CODE>, a null-terminated string.

<DT><CODE>PA_POINTER</CODE>
<DD>
<A NAME="IDX848"></A>
This specifies that the base type is <CODE>void *</CODE>, an arbitrary pointer.

<DT><CODE>PA_FLOAT</CODE>
<DD>
<A NAME="IDX849"></A>
This specifies that the base type is <CODE>float</CODE>.

<DT><CODE>PA_DOUBLE</CODE>
<DD>
<A NAME="IDX850"></A>
This specifies that the base type is <CODE>double</CODE>.

<DT><CODE>PA_LAST</CODE>
<DD>
<A NAME="IDX851"></A>
You can define additional base types for your own programs as offsets
from <CODE>PA_LAST</CODE>.  For example, if you have data types <SAMP>`foo'</SAMP>
and <SAMP>`bar'</SAMP> with their own specialized <CODE>printf</CODE> conversions,
you could define encodings for these types as:


<PRE>
#define PA_FOO  PA_LAST
#define PA_BAR  (PA_LAST + 1)
</PRE>

</DL>

<P>
Here are the flag bits that modify a basic type.  They are combined with
the code for the basic type using inclusive-or.

</P>
<DL COMPACT>

<DT><CODE>PA_FLAG_PTR</CODE>
<DD>
<A NAME="IDX852"></A>
If this bit is set, it indicates that the encoded type is a pointer to
the base type, rather than an immediate value.
For example, <SAMP>`PA_INT|PA_FLAG_PTR'</SAMP> represents the type <SAMP>`int *'</SAMP>.

<DT><CODE>PA_FLAG_SHORT</CODE>
<DD>
<A NAME="IDX853"></A>
If this bit is set, it indicates that the base type is modified with
<CODE>short</CODE>.  (This corresponds to the <SAMP>`h'</SAMP> type modifier.)

<DT><CODE>PA_FLAG_LONG</CODE>
<DD>
<A NAME="IDX854"></A>
If this bit is set, it indicates that the base type is modified with
<CODE>long</CODE>.  (This corresponds to the <SAMP>`l'</SAMP> type modifier.)

<DT><CODE>PA_FLAG_LONG_LONG</CODE>
<DD>
<A NAME="IDX855"></A>
If this bit is set, it indicates that the base type is modified with
<CODE>long long</CODE>.  (This corresponds to the <SAMP>`L'</SAMP> type modifier.)

<DT><CODE>PA_FLAG_LONG_DOUBLE</CODE>
<DD>
<A NAME="IDX856"></A>
This is a synonym for <CODE>PA_FLAG_LONG_LONG</CODE>, used by convention with
a base type of <CODE>PA_DOUBLE</CODE> to indicate a type of <CODE>long double</CODE>.
</DL>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_176.html">previous</A>, <A HREF="libc_178.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
