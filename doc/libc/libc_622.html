<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Argument Macros</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_621.html">previous</A>, <A HREF="libc_623.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC630" HREF="libc_toc.html#TOC630">Argument Access Macros</A></H4>

<P>
Here are descriptions of the macros used to retrieve variable arguments.
These macros are defined in the header file <TT>`stdarg.h'</TT>.
<A NAME="IDX3220"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>va_list</B>
<DD><A NAME="IDX3221"></A>
The type <CODE>va_list</CODE> is used for argument pointer variables.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>va_start</B> <I>(va_list <VAR>ap</VAR>, <VAR>last-required</VAR>)</I>
<DD><A NAME="IDX3222"></A>
This macro initializes the argument pointer variable <VAR>ap</VAR> to point
to the first of the optional arguments of the current function;
<VAR>last-required</VAR> must be the last required argument to the function.

</P>
<P>
See section <A HREF="libc_624.html#SEC632">Old-Style Variadic Functions</A>, for an alternate definition of <CODE>va_start</CODE>
found in the header file <TT>`varargs.h'</TT>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <VAR>type</VAR> <B>va_arg</B> <I>(va_list <VAR>ap</VAR>, <VAR>type</VAR>)</I>
<DD><A NAME="IDX3223"></A>
The <CODE>va_arg</CODE> macro returns the value of the next optional argument,
and modifies the value of <VAR>ap</VAR> to point to the subsequent argument.
Thus, successive uses of <CODE>va_arg</CODE> return successive optional
arguments.

</P>
<P>
The type of the value returned by <CODE>va_arg</CODE> is <VAR>type</VAR> as
specified in the call.  <VAR>type</VAR> must be a self-promoting type (not
<CODE>char</CODE> or <CODE>short int</CODE> or <CODE>float</CODE>) that matches the type
of the actual argument.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>va_end</B> <I>(va_list <VAR>ap</VAR>)</I>
<DD><A NAME="IDX3224"></A>
This ends the use of <VAR>ap</VAR>.  After a <CODE>va_end</CODE> call, further
<CODE>va_arg</CODE> calls with the same <VAR>ap</VAR> may not work.  You should invoke
<CODE>va_end</CODE> before returning from the function in which <CODE>va_start</CODE>
was invoked with the same <VAR>ap</VAR> argument.

</P>
<P>
In the GNU C library, <CODE>va_end</CODE> does nothing, and you need not ever
use it except for reasons of portability.
</DL>

</P>
<P>
Sometimes it is necessary to parse the list of parameters more than once
or one wants to remember a certain position in the parameter list.  To
do this one will have to make a copy of the current value of the
argument.  But <CODE>va_list</CODE> is an opaque type and it is not guaranteed
that one can simply assign the value of a variable to another one of
type <CODE>va_list</CODE>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>__va_copy</B> <I>(va_list <VAR>dest</VAR>, va_list <VAR>src</VAR>)</I>
<DD><A NAME="IDX3225"></A>
The <CODE>__va_copy</CODE> macro allows copying of objects of type
<CODE>va_list</CODE> even if this is no integral type.  The argument pointer
in <VAR>dest</VAR> is initialized to point to the same argument as the
pointer in <VAR>src</VAR>.

</P>
<P>
This macro is a GNU extension but it will hopefully also be available in
the next update of the ISO C standard.
</DL>

</P>
<P>
If you want to use <CODE>__va_copy</CODE> you should always be prepared that
this macro is not available.  On architectures where a simple assignment
is invalid it hopefully is and so one should always write something like
this:

</P>

<PRE>
{
  va_list ap, save;
  ...
#ifdef __va_copy
  __va_copy (save, ap);
#else
  save = ap;
#endif
  ...
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_621.html">previous</A>, <A HREF="libc_623.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
