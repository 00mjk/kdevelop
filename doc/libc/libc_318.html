<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Out-of-Band Data</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_317.html">previous</A>, <A HREF="libc_319.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC325" HREF="libc_toc.html#TOC325">Out-of-Band Data</A></H3>

<P>
<A NAME="IDX1568"></A>
<A NAME="IDX1569"></A>
Streams with connections permit <STRONG>out-of-band</STRONG> data that is
delivered with higher priority than ordinary data.  Typically the
reason for sending out-of-band data is to send notice of an
exceptional condition.  The way to send out-of-band data is using
<CODE>send</CODE>, specifying the flag <CODE>MSG_OOB</CODE> (see section <A HREF="libc_313.html#SEC320">Sending Data</A>).

</P>
<P>
Out-of-band data is received with higher priority because the
receiving process need not read it in sequence; to read the next
available out-of-band data, use <CODE>recv</CODE> with the <CODE>MSG_OOB</CODE>
flag (see section <A HREF="libc_314.html#SEC321">Receiving Data</A>).  Ordinary read operations do not read
out-of-band data; they read only the ordinary data.

</P>
<P>
<A NAME="IDX1570"></A>
When a socket finds that out-of-band data is on its way, it sends a
<CODE>SIGURG</CODE> signal to the owner process or process group of the
socket.  You can specify the owner using the <CODE>F_SETOWN</CODE> command
to the <CODE>fcntl</CODE> function; see section <A HREF="libc_242.html#SEC249">Interrupt-Driven Input</A>.  You must
also establish a handler for this signal, as described in section <A HREF="libc_417.html#SEC424">Signal Handling</A>, in order to take appropriate action such as reading the
out-of-band data.

</P>
<P>
Alternatively, you can test for pending out-of-band data, or wait
until there is out-of-band data, using the <CODE>select</CODE> function; it
can wait for an exceptional condition on the socket.  See section <A HREF="libc_225.html#SEC232">Waiting for Input or Output</A>, for more information about <CODE>select</CODE>.

</P>
<P>
Notification of out-of-band data (whether with <CODE>SIGURG</CODE> or with
<CODE>select</CODE>) indicates that out-of-band data is on the way; the data
may not actually arrive until later.  If you try to read the
out-of-band data before it arrives, <CODE>recv</CODE> fails with an
<CODE>EWOULDBLOCK</CODE> error.

</P>
<P>
Sending out-of-band data automatically places a "mark" in the stream
of ordinary data, showing where in the sequence the out-of-band data
"would have been".  This is useful when the meaning of out-of-band
data is "cancel everything sent so far".  Here is how you can test,
in the receiving process, whether any ordinary data was sent before
the mark:

</P>

<PRE>
success = ioctl (socket, SIOCATMARK, &#38;atmark);
</PRE>

<P>
The <CODE>integer</CODE> variable <VAR>atmark</VAR> is set to a nonzero value if
the socket's read pointer has reached the "mark".

</P>

<P>
Here's a function to discard any ordinary data preceding the
out-of-band mark:

</P>

<PRE>
int
discard_until_mark (int socket)
{
  while (1)
    {
      /* This is not an arbitrary limit; any size will do.  */
      char buffer[1024];
      int atmark, success;

      /* If we have reached the mark, return.  */
      success = ioctl (socket, SIOCATMARK, &#38;atmark);
      if (success &#60; 0)
        perror ("ioctl");
      if (result)
        return;

      /* Otherwise, read a bunch of ordinary data and discard it.
         This is guaranteed not to read past the mark
         if it starts before the mark.  */
      success = read (socket, buffer, sizeof buffer);
      if (success &#60; 0)
        perror ("read");
    }
}
</PRE>

<P>
If you don't want to discard the ordinary data preceding the mark, you
may need to read some of it anyway, to make room in internal system
buffers for the out-of-band data.  If you try to read out-of-band data
and get an <CODE>EWOULDBLOCK</CODE> error, try reading some ordinary data
(saving it so that you can use it when you want it) and see if that
makes room.  Here is an example:

</P>

<PRE>
struct buffer
{
  char *buffer;
  int size;
  struct buffer *next;
};

/* Read the out-of-band data from SOCKET and return it
   as a `struct buffer', which records the address of the data
   and its size.

   It may be necessary to read some ordinary data
   in order to make room for the out-of-band data.
   If so, the ordinary data is saved as a chain of buffers
   found in the `next' field of the value.  */

struct buffer *
read_oob (int socket)
{
  struct buffer *tail = 0;
  struct buffer *list = 0;

  while (1)
    {
      /* This is an arbitrary limit.
         Does anyone know how to do this without a limit?  */
      char *buffer = (char *) xmalloc (1024);
      int success;
      int atmark;

      /* Try again to read the out-of-band data.  */
      success = recv (socket, buffer, sizeof buffer, MSG_OOB);
      if (success &#62;= 0)
        {
          /* We got it, so return it.  */
          struct buffer *link
            = (struct buffer *) xmalloc (sizeof (struct buffer));
          link-&#62;buffer = buffer;
          link-&#62;size = success;
          link-&#62;next = list;
          return link;
        }

      /* If we fail, see if we are at the mark.  */
      success = ioctl (socket, SIOCATMARK, &#38;atmark);
      if (success &#60; 0)
        perror ("ioctl");
      if (atmark)
        {
          /* At the mark; skipping past more ordinary data cannot help.
             So just wait a while.  */
          sleep (1);
          continue;
        }

      /* Otherwise, read a bunch of ordinary data and save it.
         This is guaranteed not to read past the mark
         if it starts before the mark.  */
      success = read (socket, buffer, sizeof buffer);
      if (success &#60; 0)
        perror ("read");

      /* Save this data in the buffer list.  */
      {
        struct buffer *link
          = (struct buffer *) xmalloc (sizeof (struct buffer));
        link-&#62;buffer = buffer;
        link-&#62;size = success;

        /* Add the new link to the end of the list.  */
        if (tail)
          tail-&#62;next = link;
        else
          list = link;
        tail = link;
      }
    }
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_317.html">previous</A>, <A HREF="libc_319.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
