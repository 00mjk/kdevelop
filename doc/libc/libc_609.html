<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - POSIX Semaphores</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_608.html">previous</A>, <A HREF="libc_610.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC617" HREF="libc_toc.html#TOC617">POSIX Semaphores</A></H2>

<P>
<A NAME="IDX3174"></A>
Semaphores are counters for resources shared between threads. The
basic operations on semaphores are: increment the counter atomically,
and wait until the counter is non-null and decrement it atomically.

</P>
<P>
Semaphores have a maximum value past which they cannot be incremented.
The macro <CODE>SEM_VALUE_MAX</CODE> is defined to be this maximum value.  In
the GNU C library, <CODE>SEM_VALUE_MAX</CODE> is equal to <CODE>INT_MAX</CODE>
(see section <A HREF="libc_629.html#SEC637">Range of an Integer Type</A>), but it may be much smaller on other systems.

</P>
<P>
The pthreads library implements POSIX 1003.1b semaphores.  These should
not be confused with System V semaphores (<CODE>ipc</CODE>, <CODE>semctl</CODE> and
<CODE>semop</CODE>).

</P>
<P>
All the semaphore functions and macros are defined in <TT>`semaphore.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sem_init</B> <I>(sem_t *<VAR>sem</VAR>, int <VAR>pshared</VAR>, unsigned int <VAR>value</VAR>)</I>
<DD><A NAME="IDX3175"></A>
<CODE>sem_init</CODE> initializes the semaphore object pointed to by
<VAR>sem</VAR>. The count associated with the semaphore is set initially to
<VAR>value</VAR>. The <VAR>pshared</VAR> argument indicates whether the semaphore
is local to the current process (<VAR>pshared</VAR> is zero) or is to be
shared between several processes (<VAR>pshared</VAR> is not zero).

</P>
<P>
On success <CODE>sem_init</CODE> returns 0.  On failure it returns -1 and sets
<VAR>errno</VAR> to one of the following values:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
<VAR>value</VAR> exceeds the maximal counter value <CODE>SEM_VALUE_MAX</CODE>

<DT><CODE>ENOSYS</CODE>
<DD>
<VAR>pshared</VAR> is not zero.  LinuxThreads currently does not support
process-shared semaphores.  (This will eventually change.)
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>sem_destroy</B> <I>(sem_t * <VAR>sem</VAR>)</I>
<DD><A NAME="IDX3176"></A>
<CODE>sem_destroy</CODE> destroys a semaphore object, freeing the resources it
might hold.  If any threads are waiting on the semaphore when
<CODE>sem_destroy</CODE> is called, it fails and sets <VAR>errno</VAR> to
<CODE>EBUSY</CODE>.

</P>
<P>
In the LinuxThreads implementation, no resources are associated with
semaphore objects, thus <CODE>sem_destroy</CODE> actually does nothing except
checking that no thread is waiting on the semaphore.  This will change
when process-shared semaphores are implemented.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sem_wait</B> <I>(sem_t * <VAR>sem</VAR>)</I>
<DD><A NAME="IDX3177"></A>
<CODE>sem_wait</CODE> suspends the calling thread until the semaphore pointed
to by <VAR>sem</VAR> has non-zero count. It then atomically decreases the
semaphore count.

</P>
<P>
<CODE>sem_wait</CODE> is a cancellation point.  It always returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sem_trywait</B> <I>(sem_t * <VAR>sem</VAR>)</I>
<DD><A NAME="IDX3178"></A>
<CODE>sem_trywait</CODE> is a non-blocking variant of <CODE>sem_wait</CODE>. If the
semaphore pointed to by <VAR>sem</VAR> has non-zero count, the count is
atomically decreased and <CODE>sem_trywait</CODE> immediately returns 0.  If
the semaphore count is zero, <CODE>sem_trywait</CODE> immediately returns -1
and sets errno to <CODE>EAGAIN</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sem_post</B> <I>(sem_t * <VAR>sem</VAR>)</I>
<DD><A NAME="IDX3179"></A>
<CODE>sem_post</CODE> atomically increases the count of the semaphore pointed to
by <VAR>sem</VAR>. This function never blocks.

</P>
<P>
On processors supporting atomic compare-and-swap (Intel 486, Pentium and
later, Alpha, PowerPC, MIPS II, Motorola 68k, Ultrasparc), the
<CODE>sem_post</CODE> function is can safely be called from signal handlers.
This is the only thread synchronization function provided by POSIX
threads that is async-signal safe.  On the Intel 386 and earlier Sparc
chips, the current LinuxThreads implementation of <CODE>sem_post</CODE> is not
async-signal safe, because the hardware does not support the required
atomic operations.

</P>
<P>
<CODE>sem_post</CODE> always succeeds and returns 0, unless the semaphore
count would exceed <CODE>SEM_VALUE_MAX</CODE> after being incremented.  In
that case <CODE>sem_post</CODE> returns -1 and sets <VAR>errno</VAR> to
<CODE>EINVAL</CODE>.  The semaphore count is left unchanged.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sem_getvalue</B> <I>(sem_t * <VAR>sem</VAR>, int * <VAR>sval</VAR>)</I>
<DD><A NAME="IDX3180"></A>
<CODE>sem_getvalue</CODE> stores in the location pointed to by <VAR>sval</VAR> the
current count of the semaphore <VAR>sem</VAR>.  It always returns 0.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_608.html">previous</A>, <A HREF="libc_610.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
