<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Thread-Specific Data</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_609.html">previous</A>, <A HREF="libc_611.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC618" HREF="libc_toc.html#TOC618">Thread-Specific Data</A></H2>

<P>
Programs often need global or static variables that have different
values in different threads. Since threads share one memory space, this
cannot be achieved with regular variables. Thread-specific data is the
POSIX threads answer to this need.

</P>
<P>
Each thread possesses a private memory block, the thread-specific data
area, or TSD area for short. This area is indexed by TSD keys. The TSD
area associates values of type <CODE>void *</CODE> to TSD keys. TSD keys are
common to all threads, but the value associated with a given TSD key can
be different in each thread.

</P>
<P>
For concreteness, the TSD areas can be viewed as arrays of <CODE>void *</CODE>
pointers, TSD keys as integer indices into these arrays, and the value
of a TSD key as the value of the corresponding array element in the
calling thread.

</P>
<P>
When a thread is created, its TSD area initially associates <CODE>NULL</CODE>
with all keys.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_key_create</B> <I>(pthread_key_t *<VAR>key</VAR>, void (*destr_function) (void *))</I>
<DD><A NAME="IDX3181"></A>
<CODE>pthread_key_create</CODE> allocates a new TSD key. The key is stored in
the location pointed to by <VAR>key</VAR>. There is a limit of
<CODE>PTHREAD_KEYS_MAX</CODE> on the number of keys allocated at a given
time. The value initially associated with the returned key is
<CODE>NULL</CODE> in all currently executing threads.

</P>
<P>
The <VAR>destr_function</VAR> argument, if not <CODE>NULL</CODE>, specifies a
destructor function associated with the key. When a thread terminates
via <CODE>pthread_exit</CODE> or by cancellation, <VAR>destr_function</VAR> is
called on the value associated with the key in that thread. The
<VAR>destr_function</VAR> is not called if a key is deleted with
<CODE>pthread_key_delete</CODE> or a value is changed with
<CODE>pthread_setspecific</CODE>.  The order in which destructor functions are
called at thread termination time is unspecified.

</P>
<P>
Before the destructor function is called, the <CODE>NULL</CODE> value is
associated with the key in the current thread.  A destructor function
might, however, re-associate non-<CODE>NULL</CODE> values to that key or some
other key.  To deal with this, if after all the destructors have been
called for all non-<CODE>NULL</CODE> values, there are still some
non-<CODE>NULL</CODE> values with associated destructors, then the process is
repeated.  The LinuxThreads implementation stops the process after
<CODE>PTHREAD_DESTRUCTOR_ITERATIONS</CODE> iterations, even if some
non-<CODE>NULL</CODE> values with associated descriptors remain.  Other
implementations may loop indefinitely.

</P>
<P>
<CODE>pthread_key_create</CODE> returns 0 unless <CODE>PTHREAD_KEYS_MAX</CODE> keys
have already been allocated, in which case it fails and returns
<CODE>EAGAIN</CODE>.
</DL>

</P>

<P>
<DL>
<DT><U>Function:</U> int <B>pthread_key_delete</B> <I>(pthread_key_t <VAR>key</VAR>)</I>
<DD><A NAME="IDX3182"></A>
<CODE>pthread_key_delete</CODE> deallocates a TSD key. It does not check
whether non-<CODE>NULL</CODE> values are associated with that key in the
currently executing threads, nor call the destructor function associated
with the key.

</P>
<P>
If there is no such key <VAR>key</VAR>, it returns <CODE>EINVAL</CODE>.  Otherwise
it returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>pthread_setspecific</B> <I>(pthread_key_t <VAR>key</VAR>, const void *<VAR>pointer</VAR>)</I>
<DD><A NAME="IDX3183"></A>
<CODE>pthread_setspecific</CODE> changes the value associated with <VAR>key</VAR>
in the calling thread, storing the given <VAR>pointer</VAR> instead.

</P>
<P>
If there is no such key <VAR>key</VAR>, it returns <CODE>EINVAL</CODE>.  Otherwise
it returns 0.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void * <B>pthread_getspecific</B> <I>(pthread_key_t <VAR>key</VAR>)</I>
<DD><A NAME="IDX3184"></A>
<CODE>pthread_getspecific</CODE> returns the value currently associated with
<VAR>key</VAR> in the calling thread.

</P>
<P>
If there is no such key <VAR>key</VAR>, it returns <CODE>NULL</CODE>.
</DL>

</P>
<P>
The following code fragment allocates a thread-specific array of 100
characters, with automatic reclaimation at thread exit:

</P>

<PRE>
/* Key for the thread-specific buffer */
static pthread_key_t buffer_key;

/* Once-only initialisation of the key */
static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;

/* Allocate the thread-specific buffer */
void buffer_alloc(void)
{
  pthread_once(&#38;buffer_key_once, buffer_key_alloc);
  pthread_setspecific(buffer_key, malloc(100));
}

/* Return the thread-specific buffer */
char * get_buffer(void)
{
  return (char *) pthread_getspecific(buffer_key);
}

/* Allocate the key */
static void buffer_key_alloc()
{
  pthread_key_create(&#38;buffer_key, buffer_destroy);
}

/* Free the thread-specific buffer */
static void buffer_destroy(void * buf)
{
  free(buf);
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_609.html">previous</A>, <A HREF="libc_611.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
