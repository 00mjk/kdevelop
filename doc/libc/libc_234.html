<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Duplicating Descriptors</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_233.html">previous</A>, <A HREF="libc_235.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC241" HREF="libc_toc.html#TOC241">Duplicating Descriptors</A></H2>

<P>
<A NAME="IDX1096"></A>
<A NAME="IDX1097"></A>

</P>
<P>
You can <STRONG>duplicate</STRONG> a file descriptor, or allocate another file
descriptor that refers to the same open file as the original.  Duplicate
descriptors share one file position and one set of file status flags
(see section <A HREF="libc_236.html#SEC243">File Status Flags</A>), but each has its own set of file descriptor
flags (see section <A HREF="libc_235.html#SEC242">File Descriptor Flags</A>).

</P>
<P>
The major use of duplicating a file descriptor is to implement
<STRONG>redirection</STRONG> of input or output:  that is, to change the
file or pipe that a particular file descriptor corresponds to.

</P>
<P>
You can perform this operation using the <CODE>fcntl</CODE> function with the
<CODE>F_DUPFD</CODE> command, but there are also convenient functions
<CODE>dup</CODE> and <CODE>dup2</CODE> for duplicating descriptors.

</P>
<P>
<A NAME="IDX1098"></A>
<A NAME="IDX1099"></A>
The <CODE>fcntl</CODE> function and flags are declared in <TT>`fcntl.h'</TT>,
while prototypes for <CODE>dup</CODE> and <CODE>dup2</CODE> are in the header file
<TT>`unistd.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>dup</B> <I>(int <VAR>old</VAR>)</I>
<DD><A NAME="IDX1100"></A>
This function copies descriptor <VAR>old</VAR> to the first available
descriptor number (the first number not currently open).  It is
equivalent to <CODE>fcntl (<VAR>old</VAR>, F_DUPFD, 0)</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>dup2</B> <I>(int <VAR>old</VAR>, int <VAR>new</VAR>)</I>
<DD><A NAME="IDX1101"></A>
This function copies the descriptor <VAR>old</VAR> to descriptor number
<VAR>new</VAR>.

</P>
<P>
If <VAR>old</VAR> is an invalid descriptor, then <CODE>dup2</CODE> does nothing; it
does not close <VAR>new</VAR>.  Otherwise, the new duplicate of <VAR>old</VAR>
replaces any previous meaning of descriptor <VAR>new</VAR>, as if <VAR>new</VAR>
were closed first.

</P>
<P>
If <VAR>old</VAR> and <VAR>new</VAR> are different numbers, and <VAR>old</VAR> is a
valid descriptor number, then <CODE>dup2</CODE> is equivalent to:

</P>

<PRE>
close (<VAR>new</VAR>);
fcntl (<VAR>old</VAR>, F_DUPFD, <VAR>new</VAR>)
</PRE>

<P>
However, <CODE>dup2</CODE> does this atomically; there is no instant in the
middle of calling <CODE>dup2</CODE> at which <VAR>new</VAR> is closed and not yet a
duplicate of <VAR>old</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>F_DUPFD</B>
<DD><A NAME="IDX1102"></A>
This macro is used as the <VAR>command</VAR> argument to <CODE>fcntl</CODE>, to
copy the file descriptor given as the first argument.

</P>
<P>
The form of the call in this case is:

</P>

<PRE>
fcntl (<VAR>old</VAR>, F_DUPFD, <VAR>next-filedes</VAR>)
</PRE>

<P>
The <VAR>next-filedes</VAR> argument is of type <CODE>int</CODE> and specifies that
the file descriptor returned should be the next available one greater
than or equal to this value.

</P>
<P>
The return value from <CODE>fcntl</CODE> with this command is normally the value
of the new file descriptor.  A return value of @math{-1} indicates an
error.  The following <CODE>errno</CODE> error conditions are defined for
this command:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
The <VAR>old</VAR> argument is invalid.

<DT><CODE>EINVAL</CODE>
<DD>
The <VAR>next-filedes</VAR> argument is invalid.

<DT><CODE>EMFILE</CODE>
<DD>
There are no more file descriptors available--your program is already
using the maximum.  In BSD and GNU, the maximum is controlled by a
resource limit that can be changed; see section <A HREF="libc_411.html#SEC418">Limiting Resource Usage</A>, for
more information about the <CODE>RLIMIT_NOFILE</CODE> limit.
</DL>

<P>
<CODE>ENFILE</CODE> is not a possible error code for <CODE>dup2</CODE> because
<CODE>dup2</CODE> does not create a new opening of a file; duplicate
descriptors do not count toward the limit which <CODE>ENFILE</CODE>
indicates.  <CODE>EMFILE</CODE> is possible because it refers to the limit on
distinct descriptor numbers in use in one process.
</DL>

</P>
<P>
Here is an example showing how to use <CODE>dup2</CODE> to do redirection.
Typically, redirection of the standard streams (like <CODE>stdin</CODE>) is
done by a shell or shell-like program before calling one of the
<CODE>exec</CODE> functions (see section <A HREF="libc_517.html#SEC525">Executing a File</A>) to execute a new
program in a child process.  When the new program is executed, it
creates and initializes the standard streams to point to the
corresponding file descriptors, before its <CODE>main</CODE> function is
invoked.

</P>
<P>
So, to redirect standard input to a file, the shell could do something
like:

</P>

<PRE>
pid = fork ();
if (pid == 0)
  {
    char *filename;
    char *program;
    int file;
    ...
    file = TEMP_FAILURE_RETRY (open (filename, O_RDONLY));
    dup2 (file, STDIN_FILENO);
    TEMP_FAILURE_RETRY (close (file));
    execv (program, NULL);
  }
</PRE>

<P>
There is also a more detailed example showing how to implement redirection
in the context of a pipeline of processes in section <A HREF="libc_531.html#SEC539">Launching Jobs</A>.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_233.html">previous</A>, <A HREF="libc_235.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
