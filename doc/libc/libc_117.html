<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Using gettextized software</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_116.html">previous</A>, <A HREF="libc_118.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC124" HREF="libc_toc.html#TOC124">User influence on <CODE>gettext</CODE></A></H4>

<P>
The last sections described what the programmer can do to
internationalize the messages of the program.  But it is finally up to
the user to select the message s/he wants to see.  S/He must understand
them.

</P>
<P>
The POSIX locale model uses the environment variables <CODE>LC_COLLATE</CODE>,
<CODE>LC_CTYPE</CODE>, <CODE>LC_MESSAGES</CODE>, <CODE>LC_MONETARY</CODE>, <CODE>NUMERIC</CODE>,
and <CODE>LC_TIME</CODE> to select the locale which is to be used.  This way
the user can influence lots of functions.  As we mentioned above the
<CODE>gettext</CODE> functions also take advantage of this.

</P>
<P>
To understand how this happens it is necessary to take a look at the
various components of the filename which gets computed to locate a
message catalog.  It is composed as follows:

</P>

<PRE>
<VAR>dir_name</VAR>/<VAR>locale</VAR>/LC_<VAR>category</VAR>/<VAR>domain_name</VAR>.mo
</PRE>

<P>
The default value for <VAR>dir_name</VAR> is system specific.  It is computed
from the value given as the prefix while configuring the C library.
This value normally is <TT>`/usr'</TT> or <TT>`/'</TT>.  For the former the
complete <VAR>dir_name</VAR> is:

</P>

<PRE>
/usr/share/locale
</PRE>

<P>
We can use <TT>`/usr/share'</TT> since the <TT>`.mo'</TT> files containing the
message catalogs are system independent, all systems can use the same
files.  If the program executed the <CODE>bindtextdomain</CODE> function for
the message domain that is currently handled the <CODE>dir_name</CODE>
component is the exactly the value which was given to the function as
the second parameter.  I.e., <CODE>bindtextdomain</CODE> allows to overwrite
the only system dependent and fixed value to make it possible to
address file everywhere in the filesystem.

</P>
<P>
The <VAR>category</VAR> is the name of the locale category which was selected
in the program code.  For <CODE>gettext</CODE> and <CODE>dgettext</CODE> this is
always <CODE>LC_MESSAGES</CODE>, for <CODE>dcgettext</CODE> this is selected by the
value of the third parameter.  As said above it should be avoided to
ever use a category other than <CODE>LC_MESSAGES</CODE>.

</P>
<P>
The <VAR>locale</VAR> component is computed based on the category used.  Just
like for the <CODE>setlocale</CODE> function here comes the user selection
into the play.  Some environment variables are examined in a fixed order
and the first environment variable set determines the return value of
the lookup process.  In detail, for the category <CODE>LC_xxx</CODE> the
following variables in this order are examined:

</P>
<DL COMPACT>

<DT><CODE>LANGUAGE</CODE>
<DD>
<DT><CODE>LC_ALL</CODE>
<DD>
<DT><CODE>LC_xxx</CODE>
<DD>
<DT><CODE>LANG</CODE>
<DD>
</DL>

<P>
This looks very familiar.  With the exception of the <CODE>LANGUAGE</CODE>
environment variable this is exactly the lookup order the
<CODE>setlocale</CODE> function uses.  But why introducing the <CODE>LANGUAGE</CODE>
variable?

</P>
<P>
The reason is that the syntax of the values these variables can have is
different to what is expected by the <CODE>setlocale</CODE> function.  If we
would set <CODE>LC_ALL</CODE> to a value following the extended syntax that
would mean the <CODE>setlocale</CODE> function will never be able to use the
value of this variable as well.  An additional variable removes this
problem plus we can select the language independently of the locale
setting which sometimes is useful.

</P>
<P>
While for the <CODE>LC_xxx</CODE> variables the value should consist of
exactly one specification of a locale the <CODE>LANGUAGE</CODE> variable's
value can consist of a colon separated list of locale names.  The
attentive reader will realize that this is the way we manage to
implement one of our additional demands above: we want to be able to
specify an ordered list of language.

</P>
<P>
Back to the constructed filename we have only one component missing.
The <VAR>domain_name</VAR> part is the name which was either registered using
the <CODE>textdomain</CODE> function or which was given to <CODE>dgettext</CODE> or
<CODE>dcgettext</CODE> as the first parameter.  Now it becomes obvious that a
good choice for the domain name in the program code is a string which is
closely related to the program/package name.  E.g., for the GNU C
Library the domain name is <CODE>libc</CODE>.

</P>
<P>
A limit piece of example code should show how the programmer is supposed
to work:

</P>

<PRE>
{
  textdomain ("test-package");
  bindtextdomain ("test-package", "/usr/local/share/locale");
  puts (gettext ("Hello, world!");
}
</PRE>

<P>
At the program start the default domain is <CODE>messages</CODE>.  The
<CODE>textdomain</CODE> call changes this to <CODE>test-package</CODE>.  The
<CODE>bindtextdomain</CODE> call specifies that the message catalogs for the
domain <CODE>test-package</CODE> can be found below the directory
<TT>`/usr/local/share/locale'</TT>.

</P>
<P>
If now the user set in her/his environment the variable <CODE>LANGUAGE</CODE>
to <CODE>de</CODE> the <CODE>gettext</CODE> function will try to use the
translations from the file

</P>

<PRE>
/usr/local/share/locale/de/LC_MESSAGES/test-package.mo
</PRE>

<P>
From the above descriptions it should be clear which component of this
filename is determined by which source.

</P>
<P>
In the above example we assumed that the <CODE>LANGUAGE</CODE> environment
variable to <CODE>de</CODE>.  This might be an appropriate selection but what
happens if the user wants to use <CODE>LC_ALL</CODE> because of the wider
usability and here the required value is <CODE>de_DE.ISO-8859-1</CODE>?  We
already mentioned above that a situation like this is not infrequent.
E.g., a person might prefer reading a dialect and if this is not
available fall back on the standard language.

</P>
<P>
The <CODE>gettext</CODE> functions know about situations like this and can
handle them gracefully.  The functions recognize the format of the value
of the environment variable.  It can split the value is different pieces
and by leaving out the only or the other part it can construct new
values.  This happens of course in a predictable way.  To understand
this one must know the format of the environment variable value.  There
are to more or less standardized forms:

</P>
<DL COMPACT>

<DT><EM>X/Open Format</EM>
<DD>
<CODE>language[_territory[.codeset]][@modifier]</CODE>

<DT><EM>CEN Format (European Community Standard)</EM>
<DD>
<CODE>language[_territory][+audience][+special][,[sponsor][_revision]]</CODE>
</DL>

<P>
The functions will automatically recognize which format is used.  Less
specific locale names will be stripped of in the order of the following
list:

</P>

<OL>
<LI>

<CODE>revision</CODE>
<LI>

<CODE>sponsor</CODE>
<LI>

<CODE>special</CODE>
<LI>

<CODE>codeset</CODE>
<LI>

<CODE>normalized codeset</CODE>
<LI>

<CODE>territory</CODE>
<LI>

<CODE>audience</CODE>/<CODE>modifier</CODE>
</OL>

<P>
From the last entry one can see that the meaning of the <CODE>modifier</CODE>
field in the X/Open format and the <CODE>audience</CODE> format have the same
meaning.  Beside one can see that the <CODE>language</CODE> field for obvious
reasons never will be dropped.

</P>
<P>
The only new thing is the <CODE>normalized codeset</CODE> entry.  This is
another goodie which is introduced to help reducing the chaos which
derives from the inability of the people to standardize the names of
character sets.  Instead of ISO-8859-1 one can often see 8859-1,
88591, iso8859-1, or iso_8859-1.  The <CODE>normalized
codeset</CODE> value is generated from the user-provided character set name by
applying the following rules:

</P>

<OL>
<LI>

Remove all characters beside numbers and letters.
<LI>

Fold letters to lowercase.
<LI>

If the same only contains digits prepend the string <CODE>"iso"</CODE>.
</OL>

<P>
So all of the above name will be normalized to <CODE>iso88591</CODE>.  This
allows the program user much more freely choosing the locale name.

</P>
<P>
Even this extended functionality still does not help to solve the
problem that completely different names can be used to denote the same
locale (e.g., <CODE>de</CODE> and <CODE>german</CODE>).  To be of help in this
situation the locale implementation and also the <CODE>gettext</CODE>
functions know about aliases.

</P>
<P>
The file <TT>`/usr/share/locale/locale.alias'</TT> (replace <TT>`/usr'</TT> with
whatever prefix you used for configuring the C library) contains a
mapping of alternative names to more regular names.  The system manager
is free to add new entries to fill her/his own needs.  The selected
locale from the environment is compared with the entries in the first
column of this file ignoring the case.  If they match the value of the
second column is used instead for the further handling.

</P>
<P>
In the description of the format of the environment variables we already
mentioned the character set as a factor in the selection of the message
catalog.  In fact, only catalogs which contain text written using the
character set of the system/program can be used (directly; there will
come a solution for this some day).  This means for the user that s/he
will always have to take care for this.  If in the collection of the
message catalogs there are files for the same language but coded using
different character sets the user has to be careful.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_116.html">previous</A>, <A HREF="libc_118.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
