<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - How Unread</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_164.html">previous</A>, <A HREF="libc_166.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC172" HREF="libc_toc.html#TOC172">Using <CODE>ungetc</CODE> To Do Unreading</A></H3>

<P>
The function to unread a character is called <CODE>ungetc</CODE>, because it
reverses the action of <CODE>getc</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>ungetc</B> <I>(int <VAR>c</VAR>, FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX809"></A>
The <CODE>ungetc</CODE> function pushes back the character <VAR>c</VAR> onto the
input stream <VAR>stream</VAR>.  So the next input from <VAR>stream</VAR> will
read <VAR>c</VAR> before anything else.

</P>
<P>
If <VAR>c</VAR> is <CODE>EOF</CODE>, <CODE>ungetc</CODE> does nothing and just returns
<CODE>EOF</CODE>.  This lets you call <CODE>ungetc</CODE> with the return value of
<CODE>getc</CODE> without needing to check for an error from <CODE>getc</CODE>.

</P>
<P>
The character that you push back doesn't have to be the same as the last
character that was actually read from the stream.  In fact, it isn't
necessary to actually read any characters from the stream before
unreading them with <CODE>ungetc</CODE>!  But that is a strange way to write
a program; usually <CODE>ungetc</CODE> is used only to unread a character
that was just read from the same stream.

</P>
<P>
The GNU C library only supports one character of pushback--in other
words, it does not work to call <CODE>ungetc</CODE> twice without doing input
in between.  Other systems might let you push back multiple characters;
then reading from the stream retrieves the characters in the reverse
order that they were pushed.

</P>
<P>
Pushing back characters doesn't alter the file; only the internal
buffering for the stream is affected.  If a file positioning function
(such as <CODE>fseek</CODE>, <CODE>fseeko</CODE> or <CODE>rewind</CODE>; see section <A HREF="libc_197.html#SEC204">File Positioning</A>) is called, any pending pushed-back characters are
discarded.

</P>
<P>
Unreading a character on a stream that is at end of file clears the
end-of-file indicator for the stream, because it makes the character of
input available.  After you read that character, trying to read again
will encounter end of file.
</DL>

</P>
<P>
Here is an example showing the use of <CODE>getc</CODE> and <CODE>ungetc</CODE> to
skip over whitespace characters.  When this function reaches a
non-whitespace character, it unreads that character to be seen again on
the next read operation on the stream.

</P>

<PRE>
#include &#60;stdio.h&#62;
#include &#60;ctype.h&#62;

void
skip_whitespace (FILE *stream)
{
  int c;
  do
    /* No need to check for <CODE>EOF</CODE> because it is not
       <CODE>isspace</CODE>, and <CODE>ungetc</CODE> ignores <CODE>EOF</CODE>.  */
    c = getc (stream);
  while (isspace (c));
  ungetc (c, stream);
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_164.html">previous</A>, <A HREF="libc_166.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
