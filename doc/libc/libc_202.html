<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Controlling Buffering</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_201.html">previous</A>, <A HREF="libc_203.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC209" HREF="libc_toc.html#TOC209">Controlling Which Kind of Buffering</A></H3>

<P>
After opening a stream (but before any other operations have been
performed on it), you can explicitly specify what kind of buffering you
want it to have using the <CODE>setvbuf</CODE> function.
<A NAME="IDX925"></A>

</P>
<P>
The facilities listed in this section are declared in the header
file <TT>`stdio.h'</TT>.
<A NAME="IDX926"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>setvbuf</B> <I>(FILE *<VAR>stream</VAR>, char *<VAR>buf</VAR>, int <VAR>mode</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX927"></A>
This function is used to specify that the stream <VAR>stream</VAR> should
have the buffering mode <VAR>mode</VAR>, which can be either <CODE>_IOFBF</CODE>
(for full buffering), <CODE>_IOLBF</CODE> (for line buffering), or
<CODE>_IONBF</CODE> (for unbuffered input/output).

</P>
<P>
If you specify a null pointer as the <VAR>buf</VAR> argument, then <CODE>setvbuf</CODE>
allocates a buffer itself using <CODE>malloc</CODE>.  This buffer will be freed
when you close the stream.

</P>
<P>
Otherwise, <VAR>buf</VAR> should be a character array that can hold at least
<VAR>size</VAR> characters.  You should not free the space for this array as
long as the stream remains open and this array remains its buffer.  You
should usually either allocate it statically, or <CODE>malloc</CODE>
(see section <A HREF="libc_22.html#SEC22">Unconstrained Allocation</A>) the buffer.  Using an automatic array
is not a good idea unless you close the file before exiting the block
that declares the array.

</P>
<P>
While the array remains a stream buffer, the stream I/O functions will
use the buffer for their internal purposes.  You shouldn't try to access
the values in the array directly while the stream is using it for
buffering.

</P>
<P>
The <CODE>setvbuf</CODE> function returns zero on success, or a nonzero value
if the value of <VAR>mode</VAR> is not valid or if the request could not
be honored.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>_IOFBF</B>
<DD><A NAME="IDX928"></A>
The value of this macro is an integer constant expression that can be
used as the <VAR>mode</VAR> argument to the <CODE>setvbuf</CODE> function to
specify that the stream should be fully buffered.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>_IOLBF</B>
<DD><A NAME="IDX929"></A>
The value of this macro is an integer constant expression that can be
used as the <VAR>mode</VAR> argument to the <CODE>setvbuf</CODE> function to
specify that the stream should be line buffered.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>_IONBF</B>
<DD><A NAME="IDX930"></A>
The value of this macro is an integer constant expression that can be
used as the <VAR>mode</VAR> argument to the <CODE>setvbuf</CODE> function to
specify that the stream should be unbuffered.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>BUFSIZ</B>
<DD><A NAME="IDX931"></A>
The value of this macro is an integer constant expression that is good
to use for the <VAR>size</VAR> argument to <CODE>setvbuf</CODE>.  This value is
guaranteed to be at least <CODE>256</CODE>.

</P>
<P>
The value of <CODE>BUFSIZ</CODE> is chosen on each system so as to make stream
I/O efficient.  So it is a good idea to use <CODE>BUFSIZ</CODE> as the size
for the buffer when you call <CODE>setvbuf</CODE>.

</P>
<P>
Actually, you can get an even better value to use for the buffer size
by means of the <CODE>fstat</CODE> system call: it is found in the
<CODE>st_blksize</CODE> field of the file attributes.  See section <A HREF="libc_261.html#SEC268">What the File Attribute Values Mean</A>.

</P>
<P>
Sometimes people also use <CODE>BUFSIZ</CODE> as the allocation size of
buffers used for related purposes, such as strings used to receive a
line of input with <CODE>fgets</CODE> (see section <A HREF="libc_161.html#SEC168">Character Input</A>).  There is no
particular reason to use <CODE>BUFSIZ</CODE> for this instead of any other
integer, except that it might lead to doing I/O in chunks of an
efficient size.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>setbuf</B> <I>(FILE *<VAR>stream</VAR>, char *<VAR>buf</VAR>)</I>
<DD><A NAME="IDX932"></A>
If <VAR>buf</VAR> is a null pointer, the effect of this function is
equivalent to calling <CODE>setvbuf</CODE> with a <VAR>mode</VAR> argument of
<CODE>_IONBF</CODE>.  Otherwise, it is equivalent to calling <CODE>setvbuf</CODE>
with <VAR>buf</VAR>, and a <VAR>mode</VAR> of <CODE>_IOFBF</CODE> and a <VAR>size</VAR>
argument of <CODE>BUFSIZ</CODE>.

</P>
<P>
The <CODE>setbuf</CODE> function is provided for compatibility with old code;
use <CODE>setvbuf</CODE> in all new programs.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>setbuffer</B> <I>(FILE *<VAR>stream</VAR>, char *<VAR>buf</VAR>, size_t <VAR>size</VAR>)</I>
<DD><A NAME="IDX933"></A>
If <VAR>buf</VAR> is a null pointer, this function makes <VAR>stream</VAR> unbuffered.
Otherwise, it makes <VAR>stream</VAR> fully buffered using <VAR>buf</VAR> as the
buffer.  The <VAR>size</VAR> argument specifies the length of <VAR>buf</VAR>.

</P>
<P>
This function is provided for compatibility with old BSD code.  Use
<CODE>setvbuf</CODE> instead.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>setlinebuf</B> <I>(FILE *<VAR>stream</VAR>)</I>
<DD><A NAME="IDX934"></A>
This function makes <VAR>stream</VAR> be line buffered, and allocates the
buffer for you.

</P>
<P>
This function is provided for compatibility with old BSD code.  Use
<CODE>setvbuf</CODE> instead.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_201.html">previous</A>, <A HREF="libc_203.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
