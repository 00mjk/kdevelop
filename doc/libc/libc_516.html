<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Creating a Process</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_515.html">previous</A>, <A HREF="libc_517.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC524" HREF="libc_toc.html#TOC524">Creating a Process</A></H2>

<P>
The <CODE>fork</CODE> function is the primitive for creating a process.
It is declared in the header file <TT>`unistd.h'</TT>.
<A NAME="IDX2770"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> pid_t <B>fork</B> <I>(void)</I>
<DD><A NAME="IDX2771"></A>
The <CODE>fork</CODE> function creates a new process.

</P>
<P>
If the operation is successful, there are then both parent and child
processes and both see <CODE>fork</CODE> return, but with different values: it
returns a value of <CODE>0</CODE> in the child process and returns the child's
process ID in the parent process.

</P>
<P>
If process creation failed, <CODE>fork</CODE> returns a value of <CODE>-1</CODE> in
the parent process.  The following <CODE>errno</CODE> error conditions are
defined for <CODE>fork</CODE>:

</P>
<DL COMPACT>

<DT><CODE>EAGAIN</CODE>
<DD>
There aren't enough system resources to create another process, or the
user already has too many processes running.  This means exceeding the
<CODE>RLIMIT_NPROC</CODE> resource limit, which can usually be increased;
see section <A HREF="libc_411.html#SEC418">Limiting Resource Usage</A>.

<DT><CODE>ENOMEM</CODE>
<DD>
The process requires more space than the system can supply.
</DL>
</DL>

<P>
The specific attributes of the child process that differ from the
parent process are:

</P>

<UL>
<LI>

The child process has its own unique process ID.

<LI>

The parent process ID of the child process is the process ID of its
parent process.

<LI>

The child process gets its own copies of the parent process's open file
descriptors.  Subsequently changing attributes of the file descriptors
in the parent process won't affect the file descriptors in the child,
and vice versa.  See section <A HREF="libc_233.html#SEC240">Control Operations on Files</A>.  However, the file position
associated with each descriptor is shared by both processes;
see section <A HREF="libc_149.html#SEC156">File Position</A>.

<LI>

The elapsed processor times for the child process are set to zero;
see section <A HREF="libc_393.html#SEC400">Processor Time</A>.

<LI>

The child doesn't inherit file locks set by the parent process.
See section <A HREF="libc_233.html#SEC240">Control Operations on Files</A>.

<LI>

The child doesn't inherit alarms set by the parent process.
See section <A HREF="libc_408.html#SEC415">Setting an Alarm</A>.

<LI>

The set of pending signals (see section <A HREF="libc_421.html#SEC428">How Signals Are Delivered</A>) for the child
process is cleared.  (The child process inherits its mask of blocked
signals and signal actions from the parent process.)
</UL>

<P>
<DL>
<DT><U>Function:</U> pid_t <B>vfork</B> <I>(void)</I>
<DD><A NAME="IDX2772"></A>
The <CODE>vfork</CODE> function is similar to <CODE>fork</CODE> but on some systems
it is more efficient; however, there are restrictions you must follow to
use it safely.

</P>
<P>
While <CODE>fork</CODE> makes a complete copy of the calling process's address
space and allows both the parent and child to execute independently,
<CODE>vfork</CODE> does not make this copy.  Instead, the child process
created with <CODE>vfork</CODE> shares its parent's address space until it
calls <CODE>_exit</CODE> or one of the <CODE>exec</CODE> functions.  In the
meantime, the parent process suspends execution.

</P>
<P>
You must be very careful not to allow the child process created with
<CODE>vfork</CODE> to modify any global data or even local variables shared
with the parent.  Furthermore, the child process cannot return from (or
do a long jump out of) the function that called <CODE>vfork</CODE>!  This
would leave the parent process's control information very confused.  If
in doubt, use <CODE>fork</CODE> instead.

</P>
<P>
Some operating systems don't really implement <CODE>vfork</CODE>.  The GNU C
library permits you to use <CODE>vfork</CODE> on all systems, but actually
executes <CODE>fork</CODE> if <CODE>vfork</CODE> isn't available.  If you follow
the proper precautions for using <CODE>vfork</CODE>, your program will still
work even if the system uses <CODE>fork</CODE> instead.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_515.html">previous</A>, <A HREF="libc_517.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
