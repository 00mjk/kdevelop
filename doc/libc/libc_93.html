<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - glibc iconv Implementation</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_92.html">previous</A>, <A HREF="libc_94.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC93" HREF="libc_toc.html#TOC93">The <CODE>iconv</CODE> Implementation in the GNU C library</A></H3>

<P>
After reading about the problems of <CODE>iconv</CODE> implementations in the
last section it is certainly good to note that the implementation in
the GNU C library has none of the problems mentioned above.  What
follows is a step-by-step analysis of the points raised above.  The
evaluation is based on the current state of the development (as of
January 1999).  The development of the <CODE>iconv</CODE> functions is not
complete, but basic functionality has solidified.

</P>
<P>
The GNU C library's <CODE>iconv</CODE> implementation uses shared loadable
modules to implement the conversions.  A very small number of
conversions are built into the library itself but these are only rather
trivial conversions.

</P>
<P>
All the benefits of loadable modules are available in the GNU C library
implementation.  This is especially appealing since the interface is
well documented (see below) and it therefore is easy to write new
conversion modules.  The drawback of using loadable objects is not a
problem in the GNU C library, at least on ELF systems.  Since the
library is able to load shared objects even in statically linked
binaries this means that static linking needs not to be forbidden in
case one wants to use <CODE>iconv</CODE>.

</P>
<P>
The second mentioned problem is the number of supported conversions.
Currently, the GNU C library supports more than 150 character sets.  The
way the implementation is designed the number of supported conversions
is greater than 22350 (@math{150} times @math{149}).  If any conversion
from or to a character set is missing it can easily be added.

</P>
<P>
Particularly impressive as it may be, this high number is due to the
fact that the GNU C library implementation of <CODE>iconv</CODE> does not have
the third problem mentioned above.  I.e., whenever there is a conversion
from a character set @math{@cal{A}} to @math{@cal{B}} and from
@math{@cal{B}} to @math{@cal{C}} it is always possible to convert from
@math{@cal{A}} to @math{@cal{C}} directly.  If the <CODE>iconv_open</CODE>
returns an error and sets <CODE>errno</CODE> to <CODE>EINVAL</CODE> this really
means there is no known way, directly or indirectly, to perform the
wanted conversion.

</P>
<P>
<A NAME="IDX567"></A>
This is achieved by providing for each character set a conversion from
and to UCS4 encoded ISO 10646.  Using ISO 10646 as an
intermediate representation it is possible to <STRONG>triangulate</STRONG>, i.e.,
converting with an intermediate representation.

</P>
<P>
There is no inherent requirement to provide a conversion to ISO
10646 for a new character set and it is also possible to provide other
conversions where neither source nor destination character set is ISO
10646.  The currently existing set of conversions is simply meant to
cover all conversions which might be of interest.

</P>
<P>
<A NAME="IDX568"></A>
<A NAME="IDX569"></A>
All currently available conversions use the triangulation method above,
making conversion run unnecessarily slow.  If, e.g., somebody often
needs the conversion from ISO-2022-JP to EUC-JP, a quicker solution
would involve direct conversion between the two character sets, skipping
the input to ISO 10646 first.  The two character sets of interest
are much more similar to each other than to ISO 10646.

</P>
<P>
In such a situation one can easy write a new conversion and provide it
as a better alternative.  The GNU C library <CODE>iconv</CODE> implementation
would automatically use the module implementing the conversion if it is
specified to be more efficient.

</P>


<H4><A NAME="SEC94" HREF="libc_toc.html#TOC94">Format of <TT>`gconv-modules'</TT> files</A></H4>

<P>
All information about the available conversions comes from a file named
<TT>`gconv-modules'</TT> which can be found in any of the directories along
the <CODE>GCONV_PATH</CODE>.  The <TT>`gconv-modules'</TT> files are line-oriented
text files, where each of the lines has one of the following formats:

</P>

<UL>
<LI>

If the first non-whitespace character is a <KBD>#</KBD> the line contains
only comments and is ignored.

<LI>

Lines starting with <CODE>alias</CODE> define an alias name for a character
set.  There are two more words expected on the line.  The first one
defines the alias name and the second defines the original name of the
character set.  The effect is that it is possible to use the alias name
in the <VAR>fromset</VAR> or <VAR>toset</VAR> parameters of <CODE>iconv_open</CODE> and
achieve the same result as when using the real character set name.

This is quite important as a character set has often many different
names.  There is normally always an official name but this need not
correspond to the most popular name.  Beside this many character sets
have special names which are somehow constructed.  E.g., all character
sets specified by the ISO have an alias of the form
<CODE>ISO-IR-<VAR>nnn</VAR></CODE> where <VAR>nnn</VAR> is the registration number.
This allows programs which know about the registration number to
construct character set names and use them in <CODE>iconv_open</CODE> calls.
More on the available names and aliases follows below.

<LI>

Lines starting with <CODE>module</CODE> introduce an available conversion
module.  These lines must contain three or four more words.

The first word specifies the source character set, the second word the
destination character set of conversion implemented in this module.  The
third word is the name of the loadable module.  The filename is
constructed by appending the usual shared object suffix (normally
<TT>`.so'</TT>) and this file is then supposed to be found in the same
directory the <TT>`gconv-modules'</TT> file is in.  The last word on the
line, which is optional, is a numeric value representing the cost of the
conversion.  If this word is missing a cost of @math{1} is assumed.  The
numeric value itself does not matter that much; what counts are the
relative values of the sums of costs for all possible conversion paths.
Below is a more precise description of the use of the cost value.
</UL>

<P>
Returning to the example above where one has written a module to directly
convert from ISO-2022-JP to EUC-JP and back.  All what has to be done is
to put the new module, be its name ISO2022JP-EUCJP.so, in a directory
and add a file <TT>`gconv-modules'</TT> with the following content in the
same directory:

</P>

<PRE>
module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
</PRE>

<P>
To see why this is sufficient, it is necessary to understand how the
conversion used by <CODE>iconv</CODE> (and described in the descriptor) is
selected.  The approach to this problem is quite simple.

</P>
<P>
At the first call of the <CODE>iconv_open</CODE> function the program reads
all available <TT>`gconv-modules'</TT> files and builds up two tables: one
containing all the known aliases and another which contains the
information about the conversions and which shared object implements
them.

</P>


<H4><A NAME="SEC95" HREF="libc_toc.html#TOC95">Finding the conversion path in <CODE>iconv</CODE></A></H4>

<P>
The set of available conversions form a directed graph with weighted
edges.  The weights on the edges are the costs specified in the
<TT>`gconv-modules'</TT> files.  The <CODE>iconv_open</CODE> function uses an
algorithm suitable for search for the best path in such a graph and so
constructs a list of conversions which must be performed in succession
to get the transformation from the source to the destination character
set.

</P>
<P>
Explaining why the above <TT>`gconv-modules'</TT> files allows the
<CODE>iconv</CODE> implementation to resolve the specific ISO-2022-JP to
EUC-JP conversion module instead of the conversion coming with the
library itself is straightforward.  Since the latter conversion takes two
steps (from ISO-2022-JP to ISO 10646 and then from ISO 10646 to
EUC-JP) the cost is @math{1+1 = 2}.  But the above <TT>`gconv-modules'</TT>
file specifies that the new conversion modules can perform this
conversion with only the cost of @math{1}.

</P>
<P>
A mysterious piece about the <TT>`gconv-modules'</TT> file above (and also
the file coming with the GNU C library) are the names of the character
sets specified in the <CODE>module</CODE> lines.  Why do almost all the names
end in <CODE>//</CODE>?  And this is not all: the names can actually be
regular expressions.  At this point of time this mystery should not be
revealed, unless you have the relevant spell-casting materials: ashes
from an original DOS 6.2 boot disk burnt in effigy, a crucifix
blessed by St. Emacs, assorted herbal roots from Central America, sand
from Cebu, etc.  Sorry!  <STRONG>The part of the implementation where
this is used is not yet finished.  For now please simply follow the
existing examples.  It'll become clearer once it is. --drepper</STRONG>

</P>
<P>
A last remark about the <TT>`gconv-modules'</TT> is about the names not
ending with <CODE>//</CODE>.  There often is a character set named
<CODE>INTERNAL</CODE> mentioned.  From the discussion above and the chosen
name it should have become clear that this is the name for the
representation used in the intermediate step of the triangulation.  We
have said that this is UCS4 but actually it is not quite right.  The
UCS4 specification also includes the specification of the byte ordering
used.  Since a UCS4 value consists of four bytes a stored value is
effected by byte ordering.  The internal representation is <EM>not</EM>
the same as UCS4 in case the byte ordering of the processor (or at least
the running process) is not the same as the one required for UCS4.  This
is done for performance reasons as one does not want to perform
unnecessary byte-swapping operations if one is not interested in actually
seeing the result in UCS4.  To avoid trouble with endianess the internal
representation consistently is named <CODE>INTERNAL</CODE> even on big-endian
systems where the representations are identical.

</P>


<H4><A NAME="SEC96" HREF="libc_toc.html#TOC96"><CODE>iconv</CODE> module data structures</A></H4>

<P>
So far this section described how modules are located and considered to
be used.  What remains to be described is the interface of the modules
so that one can write new ones.  This section describes the interface as
it is in use in January 1999.  The interface will change in future a bit
but hopefully only in an upward compatible way.

</P>
<P>
The definitions necessary to write new modules are publicly available
in the non-standard header <TT>`gconv.h'</TT>.  The following text will
therefore describe the definitions from this header file.  But first it
is necessary to get an overview.

</P>
<P>
From the perspective of the user of <CODE>iconv</CODE> the interface is quite
simple: the <CODE>iconv_open</CODE> function returns a handle which can be
used in calls to <CODE>iconv</CODE> and finally the handle is freed with a call
to <CODE>iconv_close</CODE>.  The problem is: the handle has to be able to
represent the possibly long sequences of conversion steps and also the
state of each conversion since the handle is all which is passed to the
<CODE>iconv</CODE> function.  Therefore the data structures are really the
elements to understanding the implementation.

</P>
<P>
We need two different kinds of data structures.  The first describes the
conversion and the second describes the state etc.  There are really two
type definitions like this in <TT>`gconv.h'</TT>.
<A NAME="IDX570"></A>

</P>
<P>
<DL>
<DT><U>Data type:</U> <B>struct gconv_step</B>
<DD><A NAME="IDX571"></A>
This data structure describes one conversion a module can perform.  For
each function in a loaded module with conversion functions there is
exactly one object of this type.  This object is shared by all users of
the conversion.  I.e., this object does not contain any information
corresponding to an actual conversion.  It only describes the conversion
itself.

</P>
<DL COMPACT>

<DT><CODE>struct gconv_loaded_object *shlib_handle</CODE>
<DD>
<DT><CODE>const char *modname</CODE>
<DD>
<DT><CODE>int counter</CODE>
<DD>
All these elements of the structure are used internally in the C library
to coordinate loading and unloading the shared.  One must not expect any
of the other elements be available or initialized.

<DT><CODE>const char *from_name</CODE>
<DD>
<DT><CODE>const char *to_name</CODE>
<DD>
<CODE>from_name</CODE> and <CODE>to_name</CODE> contain the names of the source and
destination character sets.  They can be used to identify the actual
conversion to be carried out since one module might implement
conversions for more than one character set and/or direction.

<DT><CODE>gconv_fct fct</CODE>
<DD>
<DT><CODE>gconv_init_fct init_fct</CODE>
<DD>
<DT><CODE>gconv_end_fct end_fct</CODE>
<DD>
These elements contain pointers to the functions in the loadable module.
The interface will be explained below.

<DT><CODE>int min_needed_from</CODE>
<DD>
<DT><CODE>int max_needed_from</CODE>
<DD>
<DT><CODE>int min_needed_to</CODE>
<DD>
<DT><CODE>int max_needed_to;</CODE>
<DD>
These values have to be filled in the init function of the module.
The <CODE>min_needed_from</CODE> value specifies how many bytes a character of
the source character set at least needs.  The <CODE>max_needed_from</CODE>
specifies the maximum value which also includes possible shift
sequences.

The <CODE>min_needed_to</CODE> and <CODE>max_needed_to</CODE> values serve the same
purpose but this time for the destination character set.

It is crucial that these values are accurate since otherwise the
conversion functions will have problems or not work at all.

<DT><CODE>int stateful</CODE>
<DD>
This element must also be initialized by the init function.  It is
nonzero if the source character set is stateful.  Otherwise it is zero.

<DT><CODE>void *data</CODE>
<DD>
This element can be used freely by the conversion functions in the
module.  It can be used to communicate extra information from one call
to another.  It need not be initialized if not needed at all.  If this
element gets assigned a pointer to dynamically allocated memory
(presumably in the init function) it has to be made sure that the end
function deallocates the memory.  Otherwise the application will leak
memory.

It is important to be aware that this data structure is shared by all
users of this specification conversion and therefore the <CODE>data</CODE>
element must not contain data specific to one specific use of the
conversion function.
</DL>
</DL>

<P>
<DL>
<DT><U>Data type:</U> <B>struct gconv_step_data</B>
<DD><A NAME="IDX572"></A>
This is the data structure which contains the information specific to
each use of the conversion functions.

</P>
<DL COMPACT>

<DT><CODE>char *outbuf</CODE>
<DD>
<DT><CODE>char *outbufend</CODE>
<DD>
These elements specify the output buffer for the conversion step.  The
<CODE>outbuf</CODE> element points to the beginning of the buffer and
<CODE>outbufend</CODE> points to the byte following the last byte in the
buffer.  The conversion function must not assume anything about the size
of the buffer but it can be safely assumed the there is room for at
least one complete character in the output buffer.

Once the conversion is finished and the conversion is the last step the
<CODE>outbuf</CODE> element must be modified to point after last last byte
written into the buffer to signal how much output is available.  If this
conversion step is not the last one the element must not be modified.
The <CODE>outbufend</CODE> element must not be modified.

<DT><CODE>int is_last</CODE>
<DD>
This element is nonzero if this conversion step is the last one.  This
information is necessary for the recursion.  See the description of the
conversion function internals below.  This element must never be
modified.

<DT><CODE>int invocation_counter</CODE>
<DD>
The conversion function can use this element to see how many calls of
the conversion function already happened.  Some character sets require
when generating output a certain prolog and by comparing this value with
zero one can find out whether it is the first call and therefore the
prolog should be emitted or not.  This element must never be modified.

<DT><CODE>int internal_use</CODE>
<DD>
This element is another one rarely used but needed in certain
situations.  It got assigned a nonzero value in case the conversion
functions are used to implement <CODE>mbsrtowcs</CODE> et.al.  I.e., the
function is not used directly through the <CODE>iconv</CODE> interface.

This sometimes makes a difference as it is expected that the
<CODE>iconv</CODE> functions are used to translate entire texts while the
<CODE>mbsrtowcs</CODE> functions are normally only used to convert single
strings and might be used multiple times to convert entire texts.

But in this situation we would have problem complying with some rules of
the character set specification.  Some character sets require a prolog
which must appear exactly once for an entire text.  If a number of
<CODE>mbsrtowcs</CODE> calls are used to convert the text only the first call
must add the prolog.  But since there is no communication between the
different calls of <CODE>mbsrtowcs</CODE> the conversion functions have no
possibility to find this out.  The situation is different for sequences
of <CODE>iconv</CODE> calls since the handle allows to access the needed
information.

This element is mostly used together with <CODE>invocation_counter</CODE> in a
way like this:


<PRE>
if (!data-&#62;internal_use &#38;&#38; data-&#62;invocation_counter == 0)
  /* Emit prolog.  */
  ...
</PRE>

This element must never be modified.

<DT><CODE>mbstate_t *statep</CODE>
<DD>
The <CODE>statep</CODE> element points to an object of type <CODE>mbstate_t</CODE>
(see section <A HREF="libc_81.html#SEC81">Representing the state of the conversion</A>).  The conversion of an stateful character
set must use the object pointed to by this element to store information
about the conversion state.  The <CODE>statep</CODE> element itself must never
be modified.

<DT><CODE>mbstate_t __state</CODE>
<DD>
This element <EM>never</EM> must be used directly.  It is only part of
this structure to have the needed space allocated.
</DL>
</DL>



<H4><A NAME="SEC97" HREF="libc_toc.html#TOC97"><CODE>iconv</CODE> module interfaces</A></H4>

<P>
With the knowledge about the data structures we now can describe the
conversion functions itself.  To understand the interface a bit of
knowledge about the functionality in the C library which loads the
objects with the conversions is necessary.

</P>
<P>
It is often the case that one conversion is used more than once.  I.e.,
there are several <CODE>iconv_open</CODE> calls for the same set of character
sets during one program run.  The <CODE>mbsrtowcs</CODE> et.al. functions in
the GNU C library also use the <CODE>iconv</CODE> functionality which
increases the number of uses of the same functions even more.

</P>
<P>
For this reason the modules do not get loaded exclusively for one
conversion.  Instead a module once loaded can be used by arbitrarily many
<CODE>iconv</CODE> or <CODE>mbsrtowcs</CODE> calls at the same time.  The splitting
of the information between conversion function specific information and
conversion data makes this possible.  The last section showed the two
data structures used to do this.

</P>
<P>
This is of course also reflected in the interface and semantics of the
functions the modules must provide.  There are three functions which
must have the following names:

</P>
<DL COMPACT>

<DT><CODE>gconv_init</CODE>
<DD>
The <CODE>gconv_init</CODE> function initializes the conversion function
specific data structure.  This very same object is shared by all
conversion which use this conversion and therefore no state information
about the conversion itself must be stored in here.  If a module
implements more than one conversion the <CODE>gconv_init</CODE> function will be
called multiple times.

<DT><CODE>gconv_end</CODE>
<DD>
The <CODE>gconv_end</CODE> function is responsible to free all resources
allocated by the <CODE>gconv_init</CODE> function.  If there is nothing to do
this function can be missing.  Special care must be taken if the module
implements more than one conversion and the <CODE>gconv_init</CODE> function
does not allocate the same resources for all conversions.

<DT><CODE>gconv</CODE>
<DD>
This is the actual conversion function.  It is called to convert one
block of text.  It gets passed the conversion step information
initialized by <CODE>gconv_init</CODE> and the conversion data, specific to
this use of the conversion functions.
</DL>

<P>
There are three data types defined for the three module interface
function and these define the interface.

</P>
<P>
<DL>
<DT><U>Data type:</U> int <B>(*gconv_init_fct)</B> <I>(struct gconv_step *)</I>
<DD><A NAME="IDX573"></A>
This specifies the interface of the initialization function of the
module.  It is called exactly once for each conversion the module
implements.

</P>
<P>
As explained int the description of the <CODE>struct gconv_step</CODE> data
structure above the initialization function has to initialize parts of
it.

</P>
<DL COMPACT>

<DT><CODE>min_needed_from</CODE>
<DD>
<DT><CODE>max_needed_from</CODE>
<DD>
<DT><CODE>min_needed_to</CODE>
<DD>
<DT><CODE>max_needed_to</CODE>
<DD>
These elements must be initialized to the exact numbers of the minimum
and maximum number of bytes used by one character in the source and
destination character set respectively.  If the characters all have the
same size the minimum and maximum values are the same.

<DT><CODE>stateful</CODE>
<DD>
This element must be initialized to an nonzero value if the source
character set is stateful.  Otherwise it must be zero.
</DL>

<P>
If the initialization function needs to communication some information
to the conversion function this can happen using the <CODE>data</CODE> element
of the <CODE>gconv_step</CODE> structure.  But since this data is shared by
all the conversion is must not be modified by the conversion function.
How this can be used is shown in the example below.

</P>

<PRE>
#define MIN_NEEDED_FROM         1
#define MAX_NEEDED_FROM         4
#define MIN_NEEDED_TO           4
#define MAX_NEEDED_TO           4

int
gconv_init (struct gconv_step *step)
{
  /* Determine which direction.  */
  struct iso2022jp_data *new_data;
  enum direction dir = illegal_dir;
  enum variant var = illegal_var;
  int result;

  if (__strcasecmp (step-&#62;from_name, "ISO-2022-JP//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&#62;to_name, "ISO-2022-JP//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&#62;from_name, "ISO-2022-JP-2//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp2;
    }
  else if (__strcasecmp (step-&#62;to_name, "ISO-2022-JP-2//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp2;
    }

  result = GCONV_NOCONV;
  if (dir != illegal_dir)
    {
      new_data = (struct iso2022jp_data *)
        malloc (sizeof (struct iso2022jp_data));

      result = GCONV_NOMEM;
      if (new_data != NULL)
        {
          new_data-&#62;dir = dir;
          new_data-&#62;var = var;
          step-&#62;data = new_data;

          if (dir == from_iso2022jp)
	    {
              step-&#62;min_needed_from = MIN_NEEDED_FROM;
              step-&#62;max_needed_from = MAX_NEEDED_FROM;
              step-&#62;min_needed_to = MIN_NEEDED_TO;
              step-&#62;max_needed_to = MAX_NEEDED_TO;
	    }
          else
            {
              step-&#62;min_needed_from = MIN_NEEDED_TO;
              step-&#62;max_needed_from = MAX_NEEDED_TO;
              step-&#62;min_needed_to = MIN_NEEDED_FROM;
              step-&#62;max_needed_to = MAX_NEEDED_FROM + 2;
            }

          /* Yes, this is a stateful encoding.  */
          step-&#62;stateful = 1;

          result = GCONV_OK;
        }
    }

  return result;
}
</PRE>

<P>
The function first checks which conversion is wanted.  The module from
which this function is taken implements four different conversion and
which one is selected can be determined by comparing the names.  The
comparison should always be done without paying attention to the case.

</P>
<P>
Then a data structure is allocated which contains the necessary
information about which conversion is selected.  The data structure
<CODE>struct iso2022jp_data</CODE> is locally defined since outside the module
this data is not used at all.  Please note that if all four conversions
this modules supports are requested there are four data blocks.

</P>
<P>
One interesting thing is the initialization of the <CODE>min_</CODE> and
<CODE>max_</CODE> elements of the step data object.  A single ISO-2022-JP
character can consist of one to four bytes.  Therefore the
<CODE>MIN_NEEDED_FROM</CODE> and <CODE>MAX_NEEDED_FROM</CODE> macros are defined
this way.  The output is always the <CODE>INTERNAL</CODE> character set (aka
UCS4) and therefore each character consists of exactly four bytes.  For
the conversion from <CODE>INTERNAL</CODE> to ISO-2022-JP we have to take into
account that escape sequences might be necessary to switch the character
sets.  Therefore the <CODE>max_needed_to</CODE> element for this direction
gets assigned <CODE>MAX_NEEDED_FROM + 2</CODE>.  This takes into account the
two bytes needed for the escape sequences to single the switching.  The
asymmetry in the maximum values for the two directions can be explained
easily: when reading ISO-2022-JP text escape sequences can be handled
alone.  I.e., it is not necessary to process a real character since the
effect of the escape sequence can be recorded in the state information.
The situation is different for the other direction.  Since it is in
general not known which character comes next one cannot emit escape
sequences to change the state in advance.  This means the escape
sequences which have to be emitted together with the next character.
Therefore one needs more room then only for the character itself.

</P>
<P>
The possible return values of the initialization function are:

</P>
<DL COMPACT>

<DT><CODE>GCONV_OK</CODE>
<DD>
The initialization succeeded
<DT><CODE>GCONV_NOCONV</CODE>
<DD>
The requested conversion is not supported in the module.  This can
happen if the <TT>`gconv-modules'</TT> file has errors.
<DT><CODE>GCONV_NOMEM</CODE>
<DD>
Memory required to store additional information could not be allocated.
</DL>
</DL>

<P>
The functions called before the module is unloaded is significantly
easier.  It often has nothing at all to do in which case it can be left
out completely.

</P>
<P>
<DL>
<DT><U>Data type:</U> void <B>(*gconv_end_fct)</B> <I>(struct gconv_step *)</I>
<DD><A NAME="IDX574"></A>
The task of this function is it to free all resources allocated in the
initialization function.  Therefore only the <CODE>data</CODE> element of the
object pointed to by the argument is of interest.  Continuing the
example from the initialization function, the finalization function
looks like this:

</P>

<PRE>
void
gconv_end (struct gconv_step *data)
{
  free (data-&#62;data);
}
</PRE>

</DL>

<P>
The most important function is the conversion function itself.  It can
get quite complicated for complex character sets.  But since this is not
of interest here we will only describe a possible skeleton for the
conversion function.

</P>
<P>
<DL>
<DT><U>Data type:</U> int <B>(*gconv_fct)</B> <I>(struct gconv_step *, struct gconv_step_data *, const char **, const char *, size_t *, int)</I>
<DD><A NAME="IDX575"></A>
The conversion function can be called for two basic reason: to convert
text or to reset the state.  From the description of the <CODE>iconv</CODE>
function it can be seen why the flushing mode is necessary.  What mode
is selected is determined by the sixth argument, an integer.  If it is
nonzero it means that flushing is selected.

</P>
<P>
Common to both mode is where the output buffer can be found.  The
information about this buffer is stored in the conversion step data.  A
pointer to this is passed as the second argument to this function.  The
description of the <CODE>struct gconv_step_data</CODE> structure has more
information on this.

</P>
<P>
<A NAME="IDX576"></A>
What has to be done for flushing depends on the source character set.
If it is not stateful nothing has to be done.  Otherwise the function
has to emit a byte sequence to bring the state object in the initial
state.  Once this all happened the other conversion modules in the chain
of conversions have to get the same chance.  Whether another step
follows can be determined from the <CODE>is_last</CODE> element of the step
data structure to which the first parameter points.

</P>
<P>
The more interesting mode is when actually text has to be converted.
The first step in this case is to convert as much text as possible from
the input buffer and store the result in the output buffer.  The start
of the input buffer is determined by the third argument which is a
pointer to a pointer variable referencing the beginning of the buffer.
The fourth argument is a pointer to the byte right after the last byte
in the buffer.

</P>
<P>
The conversion has to be performed according to the current state if the
character set is stateful.  The state is stored in an object pointed to
by the <CODE>statep</CODE> element of the step data (second argument).  Once
either the input buffer is empty or the output buffer is full the
conversion stops.  At this point the pointer variable referenced by the
third parameter must point to the byte following the last processed
byte.  I.e., if all of the input is consumed this pointer and the fourth
parameter have the same value.

</P>
<P>
What now happens depends on whether this step is the last one or not.
If it is the last step the only thing which has to be done is to update
the <CODE>outbuf</CODE> element of the step data structure to point after the
last written byte.  This gives the caller the information on how much
text is available in the output buffer.  Beside this the variable
pointed to by the fifth parameter, which is of type <CODE>size_t</CODE>, must
be incremented by the number of characters (<EM>not bytes</EM>) which were
converted in a non-reversible way.  Then the function can return.

</P>
<P>
In case the step is not the last one the later conversion functions have
to get a chance to do their work.  Therefore the appropriate conversion
function has to be called.  The information about the functions is
stored in the conversion data structures, passed as the first parameter.
This information and the step data are stored in arrays so the next
element in both cases can be found by simple pointer arithmetic:

</P>

<PRE>
int
gconv (struct gconv_step *step, struct gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct gconv_step *next_step = step + 1;
  struct gconv_step_data *next_data = data + 1;
  ...
</PRE>

<P>
The <CODE>next_step</CODE> pointer references the next step information and
<CODE>next_data</CODE> the next data record.  The call of the next function
therefore will look similar to this:

</P>

<PRE>
  next_step-&#62;fct (next_step, next_data, &#38;outerr, outbuf, written, 0)
</PRE>

<P>
But this is not yet all.  Once the function call returns the conversion
function might have some more to do.  If the return value of the
function is <CODE>GCONV_EMPTY_INPUT</CODE> this means there is more room in
the output buffer.  Unless the input buffer is empty the conversion
functions start all over again and processes the rest of the input
buffer.  If the return value is not <CODE>GCONV_EMPTY_INPUT</CODE> something
went wrong and we have to recover from this.

</P>
<P>
A requirement for the conversion function is that the input buffer
pointer (the third argument) always points to the last character which
was put in the converted form in the output buffer.  This is trivial
true after the conversion performed in the current step.  But if the
conversion functions deeper down the stream stop prematurely not all
characters from the output buffer are consumed and therefore the input
buffer pointers must be backed of to the right position.

</P>
<P>
This is easy to do if the input and output character sets have a fixed
width for all characters.  In this situation we can compute how many
characters are left in the output buffer and therefore can correct the
input buffer pointer appropriate with a similar computation.  Things are
getting tricky if either character set has character represented with
variable length byte sequences and it gets even more complicated if the
conversion has to take care of the state.  In these cases the conversion
has to be performed once again, from the known state before the initial
conversion.  I.e., if necessary the state of the conversion has to be
reset and the conversion loop has to be executed again.  The difference
now is that it is known how much input must be created and the
conversion can stop before converting the first unused character.  Once
this is done the input buffer pointers must be updated again and the
function can return.

</P>
<P>
One final thing should be mentioned.  If it is necessary for the
conversion to know whether it is the first invocation (in case a prolog
has to be emitted) the conversion function should just before returning
to the caller increment the <CODE>invocation_counter</CODE> element of the
step data structure.  See the description of the <CODE>struct
gconv_step_data</CODE> structure above for more information on how this can be
used.

</P>
<P>
The return value must be one of the following values:

</P>
<DL COMPACT>

<DT><CODE>GCONV_EMPTY_INPUT</CODE>
<DD>
All input was consumed and there is room left in the output buffer.
<DT><CODE>GCONV_OUTPUT_FULL</CODE>
<DD>
No more room in the output buffer.  In case this is not the last step
this value is propagated down from the call of the next conversion
function in the chain.
<DT><CODE>GCONV_INCOMPLETE_INPUT</CODE>
<DD>
The input buffer is not entirely empty since it contains an incomplete
character sequence.
</DL>

<P>
The following example provides a framework for a conversion function.
In case a new conversion has to be written the holes in this
implementation have to be filled and that is it.

</P>

<PRE>
int
gconv (struct gconv_step *step, struct gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct gconv_step *next_step = step + 1;
  struct gconv_step_data *next_data = data + 1;
  gconv_fct fct = next_step-&#62;fct;
  int status;

  /* If the function is called with no input this means we have
     to reset to the initial state.  The possibly partly
     converted input is dropped.  */
  if (do_flush)
    {
      status = GCONV_OK;

      /* Possible emit a byte sequence which put the state object
         into the initial state.  */

      /* Call the steps down the chain if there are any but only
         if we successfully emitted the escape sequence.  */
      if (status == GCONV_OK &#38;&#38; ! data-&#62;is_last)
        status = fct (next_step, next_data, NULL, NULL,
                      written, 1);
    }
  else
    {
      /* We preserve the initial values of the pointer variables.  */
      const char *inptr = *inbuf;
      char *outbuf = data-&#62;outbuf;
      char *outend = data-&#62;outbufend;
      char *outptr;

      do
        {
          /* Remember the start value for this round.  */
          inptr = *inbuf;
          /* The outbuf buffer is empty.  */
          outptr = outbuf;

          /* For stateful encodings the state must be safe here.  */

          /* Run the conversion loop.  <CODE>status</CODE> is set
             appropriately afterwards.  */

          /* If this is the last step leave the loop, there is
             nothing we can do.  */
          if (data-&#62;is_last)
            {
              /* Store information about how many bytes are
                 available.  */
              data-&#62;outbuf = outbuf;

             /* If any non-reversible conversions were performed,
                add the number to <CODE>*written</CODE>.  */

             break;
           }

          /* Write out all output which was produced.  */
          if (outbuf &#62; outptr)
            {
              const char *outerr = data-&#62;outbuf;
              int result;

              result = fct (next_step, next_data, &#38;outerr,
                            outbuf, written, 0);

              if (result != GCONV_EMPTY_INPUT)
                {
                  if (outerr != outbuf)
                    {
                      /* Reset the input buffer pointer.  We
                         document here the complex case.  */
                      size_t nstatus;

                      /* Reload the pointers.  */
                      *inbuf = inptr;
                      outbuf = outptr;

                      /* Possibly reset the state.  */

                      /* Redo the conversion, but this time
                         the end of the output buffer is at
                         <CODE>outerr</CODE>.  */
                    }

                  /* Change the status.  */
                  status = result;
                }
              else
                /* All the output is consumed, we can make
                    another run if everything was ok.  */
                if (status == GCONV_FULL_OUTPUT)
                  status = GCONV_OK;
           }
        }
      while (status == GCONV_OK);

      /* We finished one use of this step.  */
      ++data-&#62;invocation_counter;
    }

  return status;
}
</PRE>

</DL>

<P>
This information should be sufficient to write new modules.  Anybody
doing so should also take a look at the available source code in the GNU
C library sources.  It contains many examples of working and optimized
modules.
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_92.html">previous</A>, <A HREF="libc_94.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
