<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Portable Positioning</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_197.html">previous</A>, <A HREF="libc_199.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC205" HREF="libc_toc.html#TOC205">Portable File-Position Functions</A></H2>

<P>
On the GNU system, the file position is truly a character count.  You
can specify any character count value as an argument to <CODE>fseek</CODE> or
<CODE>fseeko</CODE> and get reliable results for any random access file.
However, some ISO C systems do not represent file positions in this
way.

</P>
<P>
On some systems where text streams truly differ from binary streams, it
is impossible to represent the file position of a text stream as a count
of characters from the beginning of the file.  For example, the file
position on some systems must encode both a record offset within the
file, and a character offset within the record.

</P>
<P>
As a consequence, if you want your programs to be portable to these
systems, you must observe certain rules:

</P>

<UL>
<LI>

The value returned from <CODE>ftell</CODE> on a text stream has no predictable
relationship to the number of characters you have read so far.  The only
thing you can rely on is that you can use it subsequently as the
<VAR>offset</VAR> argument to <CODE>fseek</CODE> or <CODE>fseeko</CODE> to move back to
the same file position.

<LI>

In a call to <CODE>fseek</CODE> or <CODE>fseeko</CODE> on a text stream, either the
<VAR>offset</VAR> must either be zero; or <VAR>whence</VAR> must be
<CODE>SEEK_SET</CODE> and the <VAR>offset</VAR> must be the result of an earlier
call to <CODE>ftell</CODE> on the same stream.

<LI>

The value of the file position indicator of a text stream is undefined
while there are characters that have been pushed back with <CODE>ungetc</CODE>
that haven't been read or discarded.  See section <A HREF="libc_163.html#SEC170">Unreading</A>.
</UL>

<P>
But even if you observe these rules, you may still have trouble for long
files, because <CODE>ftell</CODE> and <CODE>fseek</CODE> use a <CODE>long int</CODE> value
to represent the file position.  This type may not have room to encode
all the file positions in a large file.  Using the <CODE>ftello</CODE> and
<CODE>fseeko</CODE> functions might help here since the <CODE>off_t</CODE> type is
expected to be able to hold all file position values but this still does
not help to handle additional information which must be associated with
a file position.

</P>
<P>
So if you do want to support systems with peculiar encodings for the
file positions, it is better to use the functions <CODE>fgetpos</CODE> and
<CODE>fsetpos</CODE> instead.  These functions represent the file position
using the data type <CODE>fpos_t</CODE>, whose internal representation varies
from system to system.

</P>
<P>
These symbols are declared in the header file <TT>`stdio.h'</TT>.
<A NAME="IDX911"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>fpos_t</B>
<DD><A NAME="IDX912"></A>
This is the type of an object that can encode information about the
file position of a stream, for use by the functions <CODE>fgetpos</CODE> and
<CODE>fsetpos</CODE>.

</P>
<P>
In the GNU system, <CODE>fpos_t</CODE> is equivalent to <CODE>off_t</CODE> or
<CODE>long int</CODE>.  In other systems, it might have a different internal
representation.

</P>
<P>
When compiling with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32 bits machine
this type is in fact equivalent to <CODE>off64_t</CODE> since the LFS
interface transparently replaced the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>fpos64_t</B>
<DD><A NAME="IDX913"></A>
This is the type of an object that can encode information about the
file position of a stream, for use by the functions <CODE>fgetpos64</CODE> and
<CODE>fsetpos64</CODE>.

</P>
<P>
In the GNU system, <CODE>fpos64_t</CODE> is equivalent to <CODE>off64_t</CODE> or
<CODE>long long int</CODE>.  In other systems, it might have a different internal
representation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fgetpos</B> <I>(FILE *<VAR>stream</VAR>, fpos_t *<VAR>position</VAR>)</I>
<DD><A NAME="IDX914"></A>
This function stores the value of the file position indicator for the
stream <VAR>stream</VAR> in the <CODE>fpos_t</CODE> object pointed to by
<VAR>position</VAR>.  If successful, <CODE>fgetpos</CODE> returns zero; otherwise
it returns a nonzero value and stores an implementation-defined positive
value in <CODE>errno</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system the function is in fact <CODE>fgetpos64</CODE>.  I.e., the LFS
interface transparently replaced the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fgetpos64</B> <I>(FILE *<VAR>stream</VAR>, fpos64_t *<VAR>position</VAR>)</I>
<DD><A NAME="IDX915"></A>
This function is similar to <CODE>fgetpos</CODE> but the file position is
returned in a variable of type <CODE>fpos64_t</CODE> to which <VAR>position</VAR>
points.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>fgetpos</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fsetpos</B> <I>(FILE *<VAR>stream</VAR>, const fpos_t *<VAR>position</VAR>)</I>
<DD><A NAME="IDX916"></A>
This function sets the file position indicator for the stream <VAR>stream</VAR>
to the position <VAR>position</VAR>, which must have been set by a previous
call to <CODE>fgetpos</CODE> on the same stream.  If successful, <CODE>fsetpos</CODE>
clears the end-of-file indicator on the stream, discards any characters
that were "pushed back" by the use of <CODE>ungetc</CODE>, and returns a value
of zero.  Otherwise, <CODE>fsetpos</CODE> returns a nonzero value and stores
an implementation-defined positive value in <CODE>errno</CODE>.

</P>
<P>
When the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a
32 bits system the function is in fact <CODE>fsetpos64</CODE>.  I.e., the LFS
interface transparently replaced the old interface.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>fsetpos64</B> <I>(FILE *<VAR>stream</VAR>, const fpos64_t *<VAR>position</VAR>)</I>
<DD><A NAME="IDX917"></A>
This function is similar to <CODE>fsetpos</CODE> but the file position used
for positioning is provided in a variable of type <CODE>fpos64_t</CODE> to
which <VAR>position</VAR> points.

</P>
<P>
If the sources are compiled with <CODE>_FILE_OFFSET_BITS == 64</CODE> on a 32
bits machine this function is available under the name <CODE>fsetpos</CODE>
and so transparently replaces the old interface.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_197.html">previous</A>, <A HREF="libc_199.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
