<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Waiting for I/O</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_224.html">previous</A>, <A HREF="libc_226.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC232" HREF="libc_toc.html#TOC232">Waiting for Input or Output</A></H2>
<P>
<A NAME="IDX1052"></A>
<A NAME="IDX1053"></A>
<A NAME="IDX1054"></A>

</P>
<P>
Sometimes a program needs to accept input on multiple input channels
whenever input arrives.  For example, some workstations may have devices
such as a digitizing tablet, function button box, or dial box that are
connected via normal asynchronous serial interfaces; good user interface
style requires responding immediately to input on any device.  Another
example is a program that acts as a server to several other processes
via pipes or sockets.

</P>
<P>
You cannot normally use <CODE>read</CODE> for this purpose, because this
blocks the program until input is available on one particular file
descriptor; input on other channels won't wake it up.  You could set
nonblocking mode and poll each file descriptor in turn, but this is very
inefficient.

</P>
<P>
A better solution is to use the <CODE>select</CODE> function.  This blocks the
program until input or output is ready on a specified set of file
descriptors, or until a timer expires, whichever comes first.  This
facility is declared in the header file <TT>`sys/types.h'</TT>.
<A NAME="IDX1055"></A>

</P>
<P>
In the case of a server socket (see section <A HREF="libc_309.html#SEC316">Listening for Connections</A>), we say that
"input" is available when there are pending connections that could be
accepted (see section <A HREF="libc_310.html#SEC317">Accepting Connections</A>).  <CODE>accept</CODE> for server
sockets blocks and interacts with <CODE>select</CODE> just as <CODE>read</CODE> does
for normal input.

</P>
<P>
<A NAME="IDX1056"></A>
The file descriptor sets for the <CODE>select</CODE> function are specified
as <CODE>fd_set</CODE> objects.  Here is the description of the data type
and some macros for manipulating these objects.

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>fd_set</B>
<DD><A NAME="IDX1057"></A>
The <CODE>fd_set</CODE> data type represents file descriptor sets for the
<CODE>select</CODE> function.  It is actually a bit array.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>FD_SETSIZE</B>
<DD><A NAME="IDX1058"></A>
The value of this macro is the maximum number of file descriptors that a
<CODE>fd_set</CODE> object can hold information about.  On systems with a
fixed maximum number, <CODE>FD_SETSIZE</CODE> is at least that number.  On
some systems, including GNU, there is no absolute limit on the number of
descriptors open, but this macro still has a constant value which
controls the number of bits in an <CODE>fd_set</CODE>; if you get a file
descriptor with a value as high as <CODE>FD_SETSIZE</CODE>, you cannot put
that descriptor into an <CODE>fd_set</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>FD_ZERO</B> <I>(fd_set *<VAR>set</VAR>)</I>
<DD><A NAME="IDX1059"></A>
This macro initializes the file descriptor set <VAR>set</VAR> to be the
empty set.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>FD_SET</B> <I>(int <VAR>filedes</VAR>, fd_set *<VAR>set</VAR>)</I>
<DD><A NAME="IDX1060"></A>
This macro adds <VAR>filedes</VAR> to the file descriptor set <VAR>set</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>FD_CLR</B> <I>(int <VAR>filedes</VAR>, fd_set *<VAR>set</VAR>)</I>
<DD><A NAME="IDX1061"></A>
This macro removes <VAR>filedes</VAR> from the file descriptor set <VAR>set</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>FD_ISSET</B> <I>(int <VAR>filedes</VAR>, fd_set *<VAR>set</VAR>)</I>
<DD><A NAME="IDX1062"></A>
This macro returns a nonzero value (true) if <VAR>filedes</VAR> is a member
of the file descriptor set <VAR>set</VAR>, and zero (false) otherwise.
</DL>

</P>
<P>
Next, here is the description of the <CODE>select</CODE> function itself.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>select</B> <I>(int <VAR>nfds</VAR>, fd_set *<VAR>read-fds</VAR>, fd_set *<VAR>write-fds</VAR>, fd_set *<VAR>except-fds</VAR>, struct timeval *<VAR>timeout</VAR>)</I>
<DD><A NAME="IDX1063"></A>
The <CODE>select</CODE> function blocks the calling process until there is
activity on any of the specified sets of file descriptors, or until the
timeout period has expired.

</P>
<P>
The file descriptors specified by the <VAR>read-fds</VAR> argument are
checked to see if they are ready for reading; the <VAR>write-fds</VAR> file
descriptors are checked to see if they are ready for writing; and the
<VAR>except-fds</VAR> file descriptors are checked for exceptional
conditions.  You can pass a null pointer for any of these arguments if
you are not interested in checking for that kind of condition.

</P>
<P>
A file descriptor is considered ready for reading if it is not at end of
file.  A server socket is considered ready for reading if there is a
pending connection which can be accepted with <CODE>accept</CODE>;
see section <A HREF="libc_310.html#SEC317">Accepting Connections</A>.  A client socket is ready for writing when
its connection is fully established; see section <A HREF="libc_308.html#SEC315">Making a Connection</A>.

</P>
<P>
"Exceptional conditions" does not mean errors--errors are reported
immediately when an erroneous system call is executed, and do not
constitute a state of the descriptor.  Rather, they include conditions
such as the presence of an urgent message on a socket.  (See section <A HREF="libc_278.html#SEC285">Sockets</A>,
for information on urgent messages.)

</P>
<P>
The <CODE>select</CODE> function checks only the first <VAR>nfds</VAR> file
descriptors.  The usual thing is to pass <CODE>FD_SETSIZE</CODE> as the value
of this argument.

</P>
<P>
The <VAR>timeout</VAR> specifies the maximum time to wait.  If you pass a
null pointer for this argument, it means to block indefinitely until one
of the file descriptors is ready.  Otherwise, you should provide the
time in <CODE>struct timeval</CODE> format; see section <A HREF="libc_398.html#SEC405">High-Resolution Calendar</A>.  Specify zero as the time (a <CODE>struct timeval</CODE> containing
all zeros) if you want to find out which descriptors are ready without
waiting if none are ready.

</P>
<P>
The normal return value from <CODE>select</CODE> is the total number of ready file
descriptors in all of the sets.  Each of the argument sets is overwritten
with information about the descriptors that are ready for the corresponding
operation.  Thus, to see if a particular descriptor <VAR>desc</VAR> has input,
use <CODE>FD_ISSET (<VAR>desc</VAR>, <VAR>read-fds</VAR>)</CODE> after <CODE>select</CODE> returns.

</P>
<P>
If <CODE>select</CODE> returns because the timeout period expires, it returns
a value of zero.

</P>
<P>
Any signal will cause <CODE>select</CODE> to return immediately.  So if your
program uses signals, you can't rely on <CODE>select</CODE> to keep waiting
for the full time specified.  If you want to be sure of waiting for a
particular amount of time, you must check for <CODE>EINTR</CODE> and repeat
the <CODE>select</CODE> with a newly calculated timeout based on the current
time.  See the example below.  See also section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.

</P>
<P>
If an error occurs, <CODE>select</CODE> returns <CODE>-1</CODE> and does not modify
the argument file descriptor sets.  The following <CODE>errno</CODE> error
conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EBADF</CODE>
<DD>
One of the file descriptor sets specified an invalid file descriptor.

<DT><CODE>EINTR</CODE>
<DD>
The operation was interrupted by a signal.  See section <A HREF="libc_449.html#SEC456">Primitives Interrupted by Signals</A>.

<DT><CODE>EINVAL</CODE>
<DD>
The <VAR>timeout</VAR> argument is invalid; one of the components is negative
or too large.
</DL>
</DL>

<P>
<STRONG>Portability Note:</STRONG>  The <CODE>select</CODE> function is a BSD Unix
feature.

</P>
<P>
Here is an example showing how you can use <CODE>select</CODE> to establish a
timeout period for reading from a file descriptor.  The <CODE>input_timeout</CODE>
function blocks the calling process until input is available on the
file descriptor, or until the timeout period expires.

</P>

<PRE>
#include &#60;stdio.h&#62;
#include &#60;unistd.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;sys/time.h&#62;

int 
input_timeout (int filedes, unsigned int seconds)
{
  fd_set set;
  struct timeval timeout;

  /* Initialize the file descriptor set. */
  FD_ZERO (&#38;set);
  FD_SET (filedes, &#38;set);

  /* Initialize the timeout data structure. */
  timeout.tv_sec = seconds;
  timeout.tv_usec = 0;

  /* <CODE>select</CODE> returns 0 if timeout, 1 if input available, -1 if error. */
  return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                     &#38;set, NULL, NULL,
                                     &#38;timeout));
}

int
main (void)
{
  fprintf (stderr, "select returned %d.\n",
           input_timeout (STDIN_FILENO, 5));
  return 0;
}
</PRE>

<P>
There is another example showing the use of <CODE>select</CODE> to multiplex
input from multiple sockets in section <A HREF="libc_317.html#SEC324">Byte Stream Connection Server Example</A>.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_224.html">previous</A>, <A HREF="libc_226.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
