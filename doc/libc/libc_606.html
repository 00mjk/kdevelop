<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Cleanup Handlers</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_605.html">previous</A>, <A HREF="libc_607.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC614" HREF="libc_toc.html#TOC614">Cleanup Handlers</A></H2>

<P>
Cleanup handlers are functions that get called when a thread terminates,
either by calling <CODE>pthread_exit</CODE> or because of
cancellation. Cleanup handlers are installed and removed following a
stack-like discipline.

</P>
<P>
The purpose of cleanup handlers is to free the resources that a thread
may hold at the time it terminates. In particular, if a thread exits or
is cancelled while it owns a locked mutex, the mutex will remain locked
forever and prevent other threads from executing normally. The best way
to avoid this is, just before locking the mutex, to install a cleanup
handler whose effect is to unlock the mutex. Cleanup handlers can be
used similarly to free blocks allocated with <CODE>malloc</CODE> or close file
descriptors on thread termination.

</P>
<P>
Here is how to lock a mutex <VAR>mut</VAR> in such a way that it will be
unlocked if the thread is canceled while <VAR>mut</VAR> is locked:

</P>

<PRE>
pthread_cleanup_push(pthread_mutex_unlock, (void *) &#38;mut);
pthread_mutex_lock(&#38;mut);
/* do some work */
pthread_mutex_unlock(&#38;mut);
pthread_cleanup_pop(0);
</PRE>

<P>
Equivalently, the last two lines can be replaced by

</P>

<PRE>
pthread_cleanup_pop(1);
</PRE>

<P>
Notice that the code above is safe only in deferred cancellation mode
(see <CODE>pthread_setcanceltype</CODE>). In asynchronous cancellation mode, a
cancellation can occur between <CODE>pthread_cleanup_push</CODE> and
<CODE>pthread_mutex_lock</CODE>, or between <CODE>pthread_mutex_unlock</CODE> and
<CODE>pthread_cleanup_pop</CODE>, resulting in both cases in the thread trying
to unlock a mutex not locked by the current thread. This is the main
reason why asynchronous cancellation is difficult to use.

</P>
<P>
If the code above must also work in asynchronous cancellation mode,
then it must switch to deferred mode for locking and unlocking the
mutex:

</P>

<PRE>
pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &#38;oldtype);
pthread_cleanup_push(pthread_mutex_unlock, (void *) &#38;mut);
pthread_mutex_lock(&#38;mut);
/* do some work */
pthread_cleanup_pop(1);
pthread_setcanceltype(oldtype, NULL);
</PRE>

<P>
The code above can be rewritten in a more compact and efficient way,
using the non-portable functions <CODE>pthread_cleanup_push_defer_np</CODE>
and <CODE>pthread_cleanup_pop_restore_np</CODE>:

</P>

<PRE>
pthread_cleanup_push_defer_np(pthread_mutex_unlock, (void *) &#38;mut);
pthread_mutex_lock(&#38;mut);
/* do some work */
pthread_cleanup_pop_restore_np(1);
</PRE>

<P>
<DL>
<DT><U>Function:</U> void <B>pthread_cleanup_push</B> <I>(void (*<VAR>routine</VAR>) (void *), void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX3153"></A>

</P>
<P>
<CODE>pthread_cleanup_push</CODE> installs the <VAR>routine</VAR> function with
argument <VAR>arg</VAR> as a cleanup handler. From this point on to the
matching <CODE>pthread_cleanup_pop</CODE>, the function <VAR>routine</VAR> will be
called with arguments <VAR>arg</VAR> when the thread terminates, either
through <CODE>pthread_exit</CODE> or by cancellation. If several cleanup
handlers are active at that point, they are called in LIFO order: the
most recently installed handler is called first.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>pthread_cleanup_pop</B> <I>(int <VAR>execute</VAR>)</I>
<DD><A NAME="IDX3154"></A>
<CODE>pthread_cleanup_pop</CODE> removes the most recently installed cleanup
handler. If the <VAR>execute</VAR> argument is not 0, it also executes the
handler, by calling the <VAR>routine</VAR> function with arguments
<VAR>arg</VAR>. If the <VAR>execute</VAR> argument is 0, the handler is only
removed but not executed.
</DL>

</P>
<P>
Matching pairs of <CODE>pthread_cleanup_push</CODE> and
<CODE>pthread_cleanup_pop</CODE> must occur in the same function, at the same
level of block nesting.  Actually, <CODE>pthread_cleanup_push</CODE> and
<CODE>pthread_cleanup_pop</CODE> are macros, and the expansion of
<CODE>pthread_cleanup_push</CODE> introduces an open brace <CODE>{</CODE> with the
matching closing brace <CODE>}</CODE> being introduced by the expansion of the
matching <CODE>pthread_cleanup_pop</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>pthread_cleanup_push_defer_np</B> <I>(void (*<VAR>routine</VAR>) (void *), void *<VAR>arg</VAR>)</I>
<DD><A NAME="IDX3155"></A>
<CODE>pthread_cleanup_push_defer_np</CODE> is a non-portable extension that
combines <CODE>pthread_cleanup_push</CODE> and <CODE>pthread_setcanceltype</CODE>.
It pushes a cleanup handler just as <CODE>pthread_cleanup_push</CODE> does,
but also saves the current cancellation type and sets it to deferred
cancellation. This ensures that the cleanup mechanism is effective even
if the thread was initially in asynchronous cancellation mode.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>pthread_cleanup_pop_restore_np</B> <I>(int <VAR>execute</VAR>)</I>
<DD><A NAME="IDX3156"></A>
<CODE>pthread_cleanup_pop_restore_np</CODE> pops a cleanup handler introduced
by <CODE>pthread_cleanup_push_defer_np</CODE>, and restores the cancellation
type to its value at the time <CODE>pthread_cleanup_push_defer_np</CODE> was
called.
</DL>

</P>
<P>
<CODE>pthread_cleanup_push_defer_np</CODE> and
<CODE>pthread_cleanup_pop_restore_np</CODE> must occur in matching pairs, at
the same level of block nesting.

</P>
<P>
The sequence

</P>

<PRE>
pthread_cleanup_push_defer_np(routine, arg);
...
pthread_cleanup_pop_defer_np(execute);
</PRE>

<P>
is functionally equivalent to (but more compact and efficient than)

</P>

<PRE>
{
  int oldtype;
  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &#38;oldtype);
  pthread_cleanup_push(routine, arg);
  ...
  pthread_cleanup_pop(execute);
  pthread_setcanceltype(oldtype, NULL);
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_605.html">previous</A>, <A HREF="libc_607.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
