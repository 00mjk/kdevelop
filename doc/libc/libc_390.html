<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Parsing of Floats</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_389.html">previous</A>, <A HREF="libc_391.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC397" HREF="libc_toc.html#TOC397">Parsing of Floats</A></H3>

<P>
<A NAME="IDX2269"></A>
These functions are declared in <TT>`stdlib.h'</TT>.

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>strtod</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>)</I>
<DD><A NAME="IDX2270"></A>
The <CODE>strtod</CODE> ("string-to-double") function converts the initial
part of <VAR>string</VAR> to a floating-point number, which is returned as a
value of type <CODE>double</CODE>.

</P>
<P>
This function attempts to decompose <VAR>string</VAR> as follows:

</P>

<UL>
<LI>

A (possibly empty) sequence of whitespace characters.  Which characters
are whitespace is determined by the <CODE>isspace</CODE> function
(see section <A HREF="libc_58.html#SEC58">Classification of Characters</A>).  These are discarded.

<LI>

An optional plus or minus sign (<SAMP>`+'</SAMP> or <SAMP>`-'</SAMP>).

<LI>

A nonempty sequence of digits optionally containing a decimal-point
character--normally <SAMP>`.'</SAMP>, but it depends on the locale
(see section <A HREF="libc_102.html#SEC106">Generic Numeric Formatting Parameters</A>).

<LI>

An optional exponent part, consisting of a character <SAMP>`e'</SAMP> or
<SAMP>`E'</SAMP>, an optional sign, and a sequence of digits.

<LI>

Any remaining characters in the string.  If <VAR>tailptr</VAR> is not a null
pointer, a pointer to this tail of the string is stored in
<CODE>*<VAR>tailptr</VAR></CODE>.
</UL>

<P>
If the string is empty, contains only whitespace, or does not contain an
initial substring that has the expected syntax for a floating-point
number, no conversion is performed.  In this case, <CODE>strtod</CODE> returns
a value of zero and the value returned in <CODE>*<VAR>tailptr</VAR></CODE> is the
value of <VAR>string</VAR>.

</P>
<P>
In a locale other than the standard <CODE>"C"</CODE> or <CODE>"POSIX"</CODE> locales,
this function may recognize additional locale-dependent syntax.

</P>
<P>
If the string has valid syntax for a floating-point number but the value
is outside the range of a <CODE>double</CODE>, <CODE>strtod</CODE> will signal
overflow or underflow as described in section <A HREF="libc_374.html#SEC381">Error Reporting by Mathematical Functions</A>.

</P>
<P>
<CODE>strtod</CODE> recognizes four special input strings.  The strings
<CODE>"inf"</CODE> and <CODE>"infinity"</CODE> are converted to @math{@infinity{}},
or to the largest representable value if the floating-point format
doesn't support infinities.  You can prepend a <CODE>"+"</CODE> or <CODE>"-"</CODE>
to specify the sign.  Case is ignored when scanning these strings.

</P>
<P>
The strings <CODE>"nan"</CODE> and <CODE>"nan(<VAR>chars...</VAR>)"</CODE> are converted
to NaN.  Again, case is ignored.  If <VAR>chars...</VAR> are provided, they
are used in some unspecified fashion to select a particular
representation of NaN (there can be several).

</P>
<P>
Since zero is a valid result as well as the value returned on error, you
should check for errors in the same way as for <CODE>strtol</CODE>, by
examining <VAR>errno</VAR> and <VAR>tailptr</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>strtof</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>)</I>
<DD><A NAME="IDX2271"></A>
<DT><U>Function:</U> long double <B>strtold</B> <I>(const char *<VAR>string</VAR>, char **<VAR>tailptr</VAR>)</I>
<DD><A NAME="IDX2272"></A>
These functions are analogous to <CODE>strtod</CODE>, but return <CODE>float</CODE>
and <CODE>long double</CODE> values respectively.  They report errors in the
same way as <CODE>strtod</CODE>.  <CODE>strtof</CODE> can be substantially faster
than <CODE>strtod</CODE>, but has less precision; conversely, <CODE>strtold</CODE>
can be much slower but has more precision (on systems where <CODE>long
double</CODE> is a separate type).

</P>
<P>
These functions are GNU extensions.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>atof</B> <I>(const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX2273"></A>
This function is similar to the <CODE>strtod</CODE> function, except that it
need not detect overflow and underflow errors.  The <CODE>atof</CODE> function
is provided mostly for compatibility with existing code; using
<CODE>strtod</CODE> is more robust.
</DL>

</P>
<P>
The GNU C library also provides <SAMP>`_l'</SAMP> versions of these functions,
which take an additional argument, the locale to use in conversion.
See section <A HREF="libc_389.html#SEC396">Parsing of Integers</A>.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_389.html">previous</A>, <A HREF="libc_391.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
