<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Receiving Arguments</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_618.html">previous</A>, <A HREF="libc_620.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H4><A NAME="SEC627" HREF="libc_toc.html#TOC627">Receiving the Argument Values</A></H4>
<P>
<A NAME="IDX3209"></A>
<A NAME="IDX3210"></A>

</P>
<P>
Ordinary fixed arguments have individual names, and you can use these
names to access their values.  But optional arguments have no
names--nothing but <SAMP>`...'</SAMP>.  How can you access them?

</P>
<P>
<A NAME="IDX3211"></A>
The only way to access them is sequentially, in the order they were
written, and you must use special macros from <TT>`stdarg.h'</TT> in the
following three step process:

</P>

<OL>
<LI>

You initialize an argument pointer variable of type <CODE>va_list</CODE> using
<CODE>va_start</CODE>.  The argument pointer when initialized points to the
first optional argument.

<LI>

You access the optional arguments by successive calls to <CODE>va_arg</CODE>.
The first call to <CODE>va_arg</CODE> gives you the first optional argument,
the next call gives you the second, and so on.

You can stop at any time if you wish to ignore any remaining optional
arguments.  It is perfectly all right for a function to access fewer
arguments than were supplied in the call, but you will get garbage
values if you try to access too many arguments.

<LI>

You indicate that you are finished with the argument pointer variable by
calling <CODE>va_end</CODE>.

(In practice, with most C compilers, calling <CODE>va_end</CODE> does nothing
and you do not really need to call it.  This is always true in the GNU C
compiler.  But you might as well call <CODE>va_end</CODE> just in case your
program is someday compiled with a peculiar compiler.)
</OL>

<P>
See section <A HREF="libc_622.html#SEC630">Argument Access Macros</A>, for the full definitions of <CODE>va_start</CODE>,
<CODE>va_arg</CODE> and <CODE>va_end</CODE>.

</P>
<P>
Steps 1 and 3 must be performed in the function that accepts the
optional arguments.  However, you can pass the <CODE>va_list</CODE> variable
as an argument to another function and perform all or part of step 2
there.

</P>
<P>
You can perform the entire sequence of the three steps multiple times
within a single function invocation.  If you want to ignore the optional
arguments, you can do these steps zero times.

</P>
<P>
You can have more than one argument pointer variable if you like.  You
can initialize each variable with <CODE>va_start</CODE> when you wish, and
then you can fetch arguments with each argument pointer as you wish.
Each argument pointer variable will sequence through the same set of
argument values, but at its own pace.

</P>
<P>
<STRONG>Portability note:</STRONG> With some compilers, once you pass an
argument pointer value to a subroutine, you must not keep using the same
argument pointer value after that subroutine returns.  For full
portability, you should just pass it to <CODE>va_end</CODE>.  This is actually
an ISO C requirement, but most ANSI C compilers work happily
regardless.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_618.html">previous</A>, <A HREF="libc_620.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
