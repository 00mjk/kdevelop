<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Merged Signals</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_442.html">previous</A>, <A HREF="libc_444.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC450" HREF="libc_toc.html#TOC450">Signals Close Together Merge into One</A></H3>
<P>
<A NAME="IDX2546"></A>
<A NAME="IDX2547"></A>
<A NAME="IDX2548"></A>

</P>
<P>
If multiple signals of the same type are delivered to your process
before your signal handler has a chance to be invoked at all, the
handler may only be invoked once, as if only a single signal had
arrived.  In effect, the signals merge into one.  This situation can
arise when the signal is blocked, or in a multiprocessing environment
where the system is busy running some other processes while the signals
are delivered.  This means, for example, that you cannot reliably use a
signal handler to count signals.  The only distinction you can reliably
make is whether at least one signal has arrived since a given time in
the past.

</P>
<P>
Here is an example of a handler for <CODE>SIGCHLD</CODE> that compensates for
the fact that the number of signals received may not equal the number of
child processes generate them.  It assumes that the program keeps track
of all the child processes with a chain of structures as follows:

</P>

<PRE>
struct process
{
  struct process *next;
  /* The process ID of this child.  */
  int pid;
  /* The descriptor of the pipe or pseudo terminal
     on which output comes from this child.  */
  int input_descriptor;
  /* Nonzero if this process has stopped or terminated.  */
  sig_atomic_t have_status;
  /* The status of this child; 0 if running,
     otherwise a status value from <CODE>waitpid</CODE>.  */
  int status;
};

struct process *process_list;
</PRE>

<P>
This example also uses a flag to indicate whether signals have arrived
since some time in the past--whenever the program last cleared it to
zero.

</P>

<PRE>
/* Nonzero means some child's status has changed
   so look at <CODE>process_list</CODE> for the details.  */
int process_status_change;
</PRE>

<P>
Here is the handler itself:

</P>

<PRE>
void
sigchld_handler (int signo)
{
  int old_errno = errno;

  while (1) {
    register int pid;
    int w;
    struct process *p;

    /* Keep asking for a status until we get a definitive result.  */
    do
      {
        errno = 0;
        pid = waitpid (WAIT_ANY, &#38;w, WNOHANG | WUNTRACED);
      }
    while (pid &#60;= 0 &#38;&#38; errno == EINTR);

    if (pid &#60;= 0) {
      /* A real failure means there are no more
         stopped or terminated child processes, so return.  */
      errno = old_errno;
      return;
    }

    /* Find the process that signaled us, and record its status.  */

    for (p = process_list; p; p = p-&#62;next)
      if (p-&#62;pid == pid) {
        p-&#62;status = w;
        /* Indicate that the <CODE>status</CODE> field
           has data to look at.  We do this only after storing it.  */
        p-&#62;have_status = 1;

        /* If process has terminated, stop waiting for its output.  */
        if (WIFSIGNALED (w) || WIFEXITED (w))
          if (p-&#62;input_descriptor)
            FD_CLR (p-&#62;input_descriptor, &#38;input_wait_mask);

        /* The program should check this flag from time to time
           to see if there is any news in <CODE>process_list</CODE>.  */
        ++process_status_change;
      }

    /* Loop around to handle all the processes
       that have something to tell us.  */
  }
}
</PRE>

<P>
Here is the proper way to check the flag <CODE>process_status_change</CODE>:

</P>

<PRE>
if (process_status_change) {
  struct process *p;
  process_status_change = 0;
  for (p = process_list; p; p = p-&#62;next)
    if (p-&#62;have_status) {
      ... Examine <CODE>p-&#62;status</CODE> ...
    }
}
</PRE>

<P>
It is vital to clear the flag before examining the list; otherwise, if a
signal were delivered just before the clearing of the flag, and after
the appropriate element of the process list had been checked, the status
change would go unnoticed until the next signal arrived to set the flag
again.  You could, of course, avoid this problem by blocking the signal
while scanning the list, but it is much more elegant to guarantee
correctness by doing things in the right order.

</P>
<P>
The loop which checks process status avoids examining <CODE>p-&#62;status</CODE>
until it sees that status has been validly stored.  This is to make sure
that the status cannot change in the middle of accessing it.  Once
<CODE>p-&#62;have_status</CODE> is set, it means that the child process is stopped
or terminated, and in either case, it cannot stop or terminate again
until the program has taken notice.  See section <A HREF="libc_448.html#SEC455">Atomic Usage Patterns</A>, for more
information about coping with interruptions during accesses of a
variable.

</P>
<P>
Here is another way you can test whether the handler has run since the
last time you checked.  This technique uses a counter which is never
changed outside the handler.  Instead of clearing the count, the program
remembers the previous value and sees whether it has changed since the
previous check.  The advantage of this method is that different parts of
the program can check independently, each part checking whether there
has been a signal since that part last checked.

</P>

<PRE>
sig_atomic_t process_status_change;

sig_atomic_t last_process_status_change;

...
{
  sig_atomic_t prev = last_process_status_change;
  last_process_status_change = process_status_change;
  if (last_process_status_change != prev) {
    struct process *p;
    for (p = process_list; p; p = p-&#62;next)
      if (p-&#62;have_status) {
        ... Examine <CODE>p-&#62;status</CODE> ...
      }
  }
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_442.html">previous</A>, <A HREF="libc_444.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
