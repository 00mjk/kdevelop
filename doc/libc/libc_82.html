<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Converting a Character</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_81.html">previous</A>, <A HREF="libc_83.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC82" HREF="libc_toc.html#TOC82">Converting Single Characters</A></H3>

<P>
The most fundamental of the conversion functions are those dealing with
single characters.  Please note that this does not always mean single
bytes.  But since there is very often a subset of the multibyte
character set which consists of single byte sequences there are
functions to help with converting bytes.  One very important and often
applicable scenario is where ASCII is a subpart of the multibyte
character set.  I.e., all ASCII characters stand for itself and all
other characters have at least a first byte which is beyond the range
@math{0} to @math{127}.

</P>
<P>
<DL>
<DT><U>Function:</U> wint_t <B>btowc</B> <I>(int <VAR>c</VAR>)</I>
<DD><A NAME="IDX534"></A>
The <CODE>btowc</CODE> function ("byte to wide character") converts a valid
single byte character <VAR>c</VAR> in the initial shift state into the wide
character equivalent using the conversion rules from the currently
selected locale of the <CODE>LC_CTYPE</CODE> category.

</P>
<P>
If <CODE>(unsigned char) <VAR>c</VAR></CODE> is no valid single byte multibyte
character or if <VAR>c</VAR> is <CODE>EOF</CODE> the function returns <CODE>WEOF</CODE>.

</P>
<P>
Please note the restriction of <VAR>c</VAR> being tested for validity only in
the initial shift state.  There is no <CODE>mbstate_t</CODE> object used from
which the state information is taken and the function also does not use
any static state.

</P>
<P>
<A NAME="IDX535"></A>
This function was introduced in the second amendment of ISO C89 and
is declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
Despite the limitation that the single byte value always is interpreted
in the initial state this function is actually useful most of the time.
Most characters are either entirely single-byte character sets or they
are extension to ASCII.  But then it is possible to write code like this
(not that this specific example is very useful):

</P>

<PRE>
wchar_t *
itow (unsigned long int val)
{
  static wchar_t buf[30];
  wchar_t *wcp = &#38;buf[29];
  *wcp = L'\0';
  while (val != 0)
    {
      *--wcp = btowc ('0' + val % 10);
      val /= 10;
    }
  if (wcp == &#38;buf[29])
    *--wcp = L'0';
  return wcp;
}
</PRE>

<P>
Why is it necessary to use such a complicated implementation and not
simply cast <CODE>'0' + val % 10</CODE> to a wide character?  The answer is
that there is no guarantee that one can perform this kind of arithmetic
on the character of the character set used for <CODE>wchar_t</CODE>
representation.  In other situations the bytes are not constant at
compile time and so the compiler cannot do the work.  In situations like
this it is necessary <CODE>btowc</CODE>.

</P>
<P>
There also is a function for the conversion in the other direction.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>wctob</B> <I>(wint_t <VAR>c</VAR>)</I>
<DD><A NAME="IDX536"></A>
The <CODE>wctob</CODE> function ("wide character to byte") takes as the
parameter a valid wide character.  If the multibyte representation for
this character in the initial state is exactly one byte long the return
value of this function is this character.  Otherwise the return value is
<CODE>EOF</CODE>.

</P>
<P>
<A NAME="IDX537"></A>
This function was introduced in the second amendment of ISO C89 and
is declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
There are more general functions to convert single character from
multibyte representation to wide characters and vice versa.  These
functions pose no limit on the length of the multibyte representation
and they also do not require it to be in the initial state.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>mbrtowc</B> <I>(wchar_t *restrict <VAR>pwc</VAR>, const char *restrict <VAR>s</VAR>, size_t <VAR>n</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX538"></A>
<A NAME="IDX539"></A>
The <CODE>mbrtowc</CODE> function ("multibyte restartable to wide
character") converts the next multibyte character in the string pointed
to by <VAR>s</VAR> into a wide character and stores it in the wide character
string pointed to by <VAR>pwc</VAR>.  The conversion is performed according
to the locale currently selected for the <CODE>LC_CTYPE</CODE> category.  If
the conversion for the character set used in the locale requires a state
the multibyte string is interpreted in the state represented by the
object pointed to by <VAR>ps</VAR>.  If <VAR>ps</VAR> is a null pointer an static,
internal state variable used only by the <CODE>mbrtowc</CODE> variable is
used.

</P>
<P>
If the next multibyte character corresponds to the NUL wide character
the return value of the function is @math{0} and the state object is
afterwards in the initial state.  If the next <VAR>n</VAR> or fewer bytes
form a correct multibyte character the return value is the number of
bytes starting from <VAR>s</VAR> which form the multibyte character.  The
conversion state is updated according to the bytes consumed in the
conversion.  In both cases the wide character (either the <CODE>L'\0'</CODE>
or the one found in the conversion) is stored in the string pointer to
by <VAR>pwc</VAR> iff <VAR>pwc</VAR> is not null.

</P>
<P>
If the first <VAR>n</VAR> bytes of the multibyte string possibly form a valid
multibyte character but there are more than <VAR>n</VAR> bytes needed to
complete it the return value of the function is <CODE>(size_t) -2</CODE> and
no value is stored.  Please note that this can happen even if <VAR>n</VAR>
has a value greater or equal to <CODE>MB_CUR_MAX</CODE> since the input might
contain redundant shift sequences.

</P>
<P>
If the first <CODE>n</CODE> bytes of the multibyte string cannot possibly form
a valid multibyte character also no value is stored, the global variable
<CODE>errno</CODE> is set to the value <CODE>EILSEQ</CODE> and the function returns
<CODE>(size_t) -1</CODE>.  The conversion state is afterwards undefined.

</P>
<P>
<A NAME="IDX540"></A>
This function was introduced in the second amendment to ISO C89 and
is declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
Using this function is straight forward.  A function which copies a
multibyte string into a wide character string while at the same time
converting all lowercase character into uppercase could look like this
(this is not the final version, just an example; it has no error
checking, and leaks sometimes memory):

</P>

<PRE>
wchar_t *
mbstouwcs (const char *s)
{
  size_t len = strlen (s);
  wchar_t *result = malloc ((len + 1) * sizeof (wchar_t));
  wchar_t *wcp = result;
  wchar_t tmp[1];
  mbstate_t state;
  memset (&#38;state, '\0', sizeof (state));
  size_t nbytes;
  while ((nbytes = mbrtowc (tmp, s, len, &#38;state)) &#62; 0)
    {
      if (nbytes &#62;= (size_t) -2)
        /* Invalid input string.  */
        return NULL;
      *result++ = towupper (tmp[0]);
      len -= nbytes;
      s += nbytes;
    }
  return result;
}
</PRE>

<P>
The use of <CODE>mbrtowc</CODE> should be clear.  A single wide character is
stored in <CODE><VAR>tmp</VAR>[0]</CODE> and the number of consumed bytes is stored
in the variable <VAR>nbytes</VAR>.  In case the the conversion was successful
the uppercase variant of the wide character is stored in the
<VAR>result</VAR> array and the pointer to the input string and the number of
available bytes is adjusted.

</P>
<P>
The only non-obvious thing about the function might be the way memory is
allocated for the result.  The above code uses the fact that there can
never be more wide characters in the converted results than there are
bytes in the multibyte input string.  This method yields to a
pessimistic guess about the size of the result and if many wide
character strings have to be constructed this way or the strings are
long, the extra memory required allocated because the input string
contains multibyte characters might be significant.  It would be
possible to resize the allocated memory block to the correct size before
returning it.  A better solution might be to allocate just the right
amount of space for the result right away.  Unfortunately there is no
function to compute the length of the wide character string directly
from the multibyte string.  But there is a function which does part of
the work.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>mbrlen</B> <I>(const char *restrict <VAR>s</VAR>, size_t <VAR>n</VAR>, mbstate_t *<VAR>ps</VAR>)</I>
<DD><A NAME="IDX541"></A>
The <CODE>mbrlen</CODE> function ("multibyte restartable length") computes
the number of at most <VAR>n</VAR> bytes starting at <VAR>s</VAR> which form the
next valid and complete multibyte character.

</P>
<P>
If the next multibyte character corresponds to the NUL wide character
the return value is @math{0}.  If the next <VAR>n</VAR> bytes form a valid
multibyte character the number of bytes belonging to this multibyte
character byte sequence is returned.

</P>
<P>
If the the first <VAR>n</VAR> bytes possibly form a valid multibyte
character but it is incomplete the return value is <CODE>(size_t) -2</CODE>.
Otherwise the multibyte character sequence is invalid and the return
value is <CODE>(size_t) -1</CODE>.

</P>
<P>
The multibyte sequence is interpreted in the state represented by the
object pointer to by <VAR>ps</VAR>.  If <VAR>ps</VAR> is a null pointer an state
object local to <CODE>mbrlen</CODE> is used.

</P>
<P>
<A NAME="IDX542"></A>
This function was introduced in the second amendment to ISO C89 and
is declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
The tentative reader now will of course note that <CODE>mbrlen</CODE> can be
implemented as

</P>

<PRE>
mbrtowc (NULL, s, n, ps != NULL ? ps : &#38;internal)
</PRE>

<P>
This is true and in fact is mentioned in the official specification.
Now, how can this function be used to determine the length of the wide
character string created from a multibyte character string?  It is not
directly usable but we can define a function <CODE>mbslen</CODE> using it:

</P>

<PRE>
size_t
mbslen (const char *s)
{
  mbstate_t state;
  size_t result = 0;
  size_t nbytes;
  memset (&#38;state, '\0', sizeof (state));
  while ((nbytes = mbrlen (s, MB_LEN_MAX, &#38;state)) &#62; 0)
    {
      if (nbytes &#62;= (size_t) -2)
        /* Something is wrong.  */
        return (size_t) -1;
      s += nbytes;
      ++result;
    }
  return result;
}
</PRE>

<P>
This function simply calls <CODE>mbrlen</CODE> for each multibyte character
in the string and counts the number of function calls.  Please note that
we here use <CODE>MB_LEN_MAX</CODE> as the size argument in the <CODE>mbrlen</CODE>
call.  This is OK since a) this value is larger then the length of the
longest multibyte character sequence and b) because we know that the
string <VAR>s</VAR> ends with a NUL byte which cannot be part of any other
multibyte character sequence but the one representing the NUL wide
character.  Therefore the <CODE>mbrlen</CODE> function will never read invalid
memory.

</P>
<P>
Now that this function is available (just to make this clear, this
function is <EM>not</EM> part of the GNU C library) we can compute the
number of wide character required to store the converted multibyte
character string <VAR>s</VAR> using

</P>

<PRE>
wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
</PRE>

<P>
Please note that the <CODE>mbslen</CODE> function is quite inefficient.  The
implementation of <CODE>mbstouwcs</CODE> implemented using <CODE>mbslen</CODE> would
have to perform the conversion of the multibyte character input string
twice and this conversion might be quite expensive.  So it is necessary
to think about the consequences of using the easier but imprecise method
before doing the work twice.

</P>
<P>
<DL>
<DT><U>Function:</U> size_t <B>wcrtomb</B> <I>(char *restrict <VAR>s</VAR>, wchar_t <VAR>wc</VAR>, mbstate_t *restrict <VAR>ps</VAR>)</I>
<DD><A NAME="IDX543"></A>
The <CODE>wcrtomb</CODE> function ("wide character restartable to
multibyte") converts a single wide character into a multibyte string
corresponding to that wide character.

</P>
<P>
If <VAR>s</VAR> is a null pointer the function resets the the state stored in
the objects pointer to by <VAR>ps</VAR> (or the internal <CODE>mbstate_t</CODE>
object) to the initial state.  This can also be achieved by a call like
this:

</P>

<PRE>
wcrtombs (temp_buf, L'\0', ps)
</PRE>

<P>
since if <VAR>s</VAR> is a null pointer <CODE>wcrtomb</CODE> performs as if it
writes into an internal buffer which is guaranteed to be large enough.

</P>
<P>
If <VAR>wc</VAR> is the NUL wide character <CODE>wcrtomb</CODE> emits, if
necessary, a shift sequence to get the state <VAR>ps</VAR> into the initial
state followed by a single NUL byte is stored in the string <VAR>s</VAR>.

</P>
<P>
Otherwise a byte sequence (possibly including shift sequences) is
written into the string <VAR>s</VAR>.  This of only happens if <VAR>wc</VAR> is a
valid wide character, i.e., it has a multibyte representation in the
character set selected by locale of the <CODE>LC_CTYPE</CODE> category.  If
<VAR>wc</VAR> is no valid wide character nothing is stored in the strings
<VAR>s</VAR>, <CODE>errno</CODE> is set to <CODE>EILSEQ</CODE>, the conversion state in
<VAR>ps</VAR> is undefined and the return value is <CODE>(size_t) -1</CODE>.

</P>
<P>
If no error occurred the function returns the number of bytes stored in
the string <VAR>s</VAR>.  This includes all byte representing shift
sequences.

</P>
<P>
One word about the interface of the function: there is no parameter
specifying the length of the array <VAR>s</VAR>.  Instead the function
assumes that there are at least <CODE>MB_CUR_MAX</CODE> bytes available since
this is the maximum length of any byte sequence representing a single
character.  So the caller has to make sure that there is enough space
available, otherwise buffer overruns can occur.

</P>
<P>
<A NAME="IDX544"></A>
This function was introduced in the second amendment to ISO C and is
declared in <TT>`wchar.h'</TT>.
</DL>

</P>
<P>
Using this function is as easy as using <CODE>mbrtowc</CODE>.  The following
example appends a wide character string to a multibyte character string.
Again, the code is not really useful (and correct), it is simply here to
demonstrate the use and some problems.

</P>

<PRE>
char *
mbscatwc (char *s, size_t len, const wchar_t *ws)
{
  mbstate_t state;
  /* Find the end of the existing string.  */
  char *wp = strchr (s, '\0');
  len -= wp - s;
  memset (&#38;state, '\0', sizeof (state));
  do
    {
      size_t nbytes;
      if (len &#60; MB_CUR_LEN)
        {
          /* We cannot guarantee that the next
             character fits into the buffer, so
             return an error.  */
          errno = E2BIG;
          return NULL;
        }
      nbytes = wcrtomb (wp, *ws, &#38;state);
      if (nbytes == (size_t) -1)
        /* Error in the conversion.  */
        return NULL;
      len -= nbytes;
      wp += nbytes;
    }
  while (*ws++ != L'\0');
  return s;
}
</PRE>

<P>
First the function has to find the end of the string currently in the
array <VAR>s</VAR>.  The <CODE>strchr</CODE> call does this very efficiently since a
requirement for multibyte character representations is that the NUL byte
never is used except to represent itself (and in this context, the end
of the string).

</P>
<P>
After initializing the state object the loop is entered where the first
task is to make sure there is enough room in the array <VAR>s</VAR>.  We
abort if there are not at least <CODE>MB_CUR_LEN</CODE> bytes available.  This
is not always optimal but we have no other choice.  We might have less
than <CODE>MB_CUR_LEN</CODE> bytes available but the next multibyte character
might also be only one byte long.  At the time the <CODE>wcrtomb</CODE> call
returns it is too late to decide whether the buffer was large enough or
not.  If this solution is really unsuitable there is a very slow but
more accurate solution.

</P>

<PRE>
  ...
  if (len &#60; MB_CUR_LEN)
    {
      mbstate_t temp_state;
      memcpy (&#38;temp_state, &#38;state, sizeof (state));
      if (wcrtomb (NULL, *ws, &#38;temp_state) &#62; len)
        {
          /* We cannot guarantee that the next
             character fits into the buffer, so
             return an error.  */
          errno = E2BIG;
          return NULL;
        }
    }
  ...
</PRE>

<P>
Here we do perform the conversion which might overflow the buffer so
that we are afterwards in the position to make an exact decision about
the buffer size.  Please note the <CODE>NULL</CODE> argument for the
destination buffer in the new <CODE>wcrtomb</CODE> call; since we are not
interested in the converted text at this point this is a nice way to
express this.  The most unusual thing about this piece of code certainly
is the duplication of the conversion state object.  But think about
this: if a change of the state is necessary to emit the next multibyte
character we want to have the same shift state change performed in the
real conversion.  Therefore we have to preserve the initial shift state
information.

</P>
<P>
There are certainly many more and even better solutions to this problem.
This example is only meant for educational purposes.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_81.html">previous</A>, <A HREF="libc_83.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
