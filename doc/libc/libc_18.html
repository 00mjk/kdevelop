<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Error Messages</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_17.html">previous</A>, <A HREF="libc_19.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC18" HREF="libc_toc.html#TOC18">Error Messages</A></H2>

<P>
The library has functions and variables designed to make it easy for
your program to report informative error messages in the customary
format about the failure of a library call.  The functions
<CODE>strerror</CODE> and <CODE>perror</CODE> give you the standard error message
for a given error code; the variable
<CODE>program_invocation_short_name</CODE> gives you convenient access to the
name of the program that encountered the error.

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strerror</B> <I>(int <VAR>errnum</VAR>)</I>
<DD><A NAME="IDX202"></A>
The <CODE>strerror</CODE> function maps the error code (see section <A HREF="libc_16.html#SEC16">Checking for Errors</A>) specified by the <VAR>errnum</VAR> argument to a descriptive error
message string.  The return value is a pointer to this string.

</P>
<P>
The value <VAR>errnum</VAR> normally comes from the variable <CODE>errno</CODE>.

</P>
<P>
You should not modify the string returned by <CODE>strerror</CODE>.  Also, if
you make subsequent calls to <CODE>strerror</CODE>, the string might be
overwritten.  (But it's guaranteed that no library function ever calls
<CODE>strerror</CODE> behind your back.)

</P>
<P>
The function <CODE>strerror</CODE> is declared in <TT>`string.h'</TT>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char * <B>strerror_r</B> <I>(int <VAR>errnum</VAR>, char *<VAR>buf</VAR>, size_t <VAR>n</VAR>)</I>
<DD><A NAME="IDX203"></A>
The <CODE>strerror_r</CODE> function works like <CODE>strerror</CODE> but instead of
returning the error message in a statically allocated buffer shared by
all threads in the process, it returns a private copy for the
thread. This might be either some permanent global data or a message
string in the user supplied buffer starting at <VAR>buf</VAR> with the
length of <VAR>n</VAR> bytes.

</P>
<P>
At most <VAR>n</VAR> characters are written (including the NUL byte) so it is
up to the user to select the buffer large enough.

</P>
<P>
This function should always be used in multi-threaded programs since
there is no way to guarantee the string returned by <CODE>strerror</CODE>
really belongs to the last call of the current thread.

</P>
<P>
This function <CODE>strerror_r</CODE> is a GNU extension and it is declared in
<TT>`string.h'</TT>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>perror</B> <I>(const char *<VAR>message</VAR>)</I>
<DD><A NAME="IDX204"></A>
This function prints an error message to the stream <CODE>stderr</CODE>;
see section <A HREF="libc_157.html#SEC164">Standard Streams</A>.

</P>
<P>
If you call <CODE>perror</CODE> with a <VAR>message</VAR> that is either a null
pointer or an empty string, <CODE>perror</CODE> just prints the error message
corresponding to <CODE>errno</CODE>, adding a trailing newline.

</P>
<P>
If you supply a non-null <VAR>message</VAR> argument, then <CODE>perror</CODE>
prefixes its output with this string.  It adds a colon and a space
character to separate the <VAR>message</VAR> from the error string corresponding
to <CODE>errno</CODE>.

</P>
<P>
The function <CODE>perror</CODE> is declared in <TT>`stdio.h'</TT>.
</DL>

</P>
<P>
<CODE>strerror</CODE> and <CODE>perror</CODE> produce the exact same message for any
given error code; the precise text varies from system to system.  On the
GNU system, the messages are fairly short; there are no multi-line
messages or embedded newlines.  Each error message begins with a capital
letter and does not include any terminating punctuation.

</P>
<P>
<STRONG>Compatibility Note:</STRONG>  The <CODE>strerror</CODE> function is a new
feature of ISO C.  Many older C systems do not support this function
yet.

</P>
<P>
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>
Many programs that don't read input from the terminal are designed to
exit if any system call fails.  By convention, the error message from
such a program should start with the program's name, sans directories.
You can find that name in the variable
<CODE>program_invocation_short_name</CODE>; the full file name is stored the
variable <CODE>program_invocation_name</CODE>:

</P>
<P>
<DL>
<DT><U>Variable:</U> char * <B>program_invocation_name</B>
<DD><A NAME="IDX207"></A>
This variable's value is the name that was used to invoke the program
running in the current process.  It is the same as <CODE>argv[0]</CODE>.  Note
that this is not necessarily a useful file name; often it contains no
directory names.  See section <A HREF="libc_472.html#SEC479">Program Arguments</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> char * <B>program_invocation_short_name</B>
<DD><A NAME="IDX208"></A>
This variable's value is the name that was used to invoke the program
running in the current process, with directory names removed.  (That is
to say, it is the same as <CODE>program_invocation_name</CODE> minus
everything up to the last slash, if any.)
</DL>

</P>
<P>
The library initialization code sets up both of these variables before
calling <CODE>main</CODE>.

</P>
<P>
<STRONG>Portability Note:</STRONG> These two variables are GNU extensions.  If
you want your program to work with non-GNU libraries, you must save the
value of <CODE>argv[0]</CODE> in <CODE>main</CODE>, and then strip off the directory
names yourself.  We added these extensions to make it possible to write
self-contained error-reporting subroutines that require no explicit
cooperation from <CODE>main</CODE>.

</P>
<P>
Here is an example showing how to handle failure to open a file
correctly.  The function <CODE>open_sesame</CODE> tries to open the named file
for reading and returns a stream if successful.  The <CODE>fopen</CODE>
library function returns a null pointer if it couldn't open the file for
some reason.  In that situation, <CODE>open_sesame</CODE> constructs an
appropriate error message using the <CODE>strerror</CODE> function, and
terminates the program.  If we were going to make some other library
calls before passing the error code to <CODE>strerror</CODE>, we'd have to
save it in a local variable instead, because those other library
functions might overwrite <CODE>errno</CODE> in the meantime.

</P>

<PRE>
#include &#60;errno.h&#62;
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;

FILE *
open_sesame (char *name)
{
  FILE *stream;

  errno = 0;
  stream = fopen (name, "r");
  if (stream == NULL)
    {
      fprintf (stderr, "%s: Couldn't open file %s; %s\n",
               program_invocation_short_name, name, strerror (errno));
      exit (EXIT_FAILURE);
    }
  else
    return stream;
}
</PRE>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_17.html">previous</A>, <A HREF="libc_19.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
