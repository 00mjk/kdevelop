<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Socket Concepts</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_278.html">previous</A>, <A HREF="libc_280.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC286" HREF="libc_toc.html#TOC286">Socket Concepts</A></H2>

<P>
<A NAME="IDX1386"></A>
<A NAME="IDX1387"></A>
When you create a socket, you must specify the style of communication
you want to use and the type of protocol that should implement it.
The <STRONG>communication style</STRONG> of a socket defines the user-level
semantics of sending and receiving data on the socket.  Choosing a
communication style specifies the answers to questions such as these:

</P>

<UL>
<LI>

<A NAME="IDX1388"></A>
<A NAME="IDX1389"></A>
<A NAME="IDX1390"></A>
<STRONG>What are the units of data transmission?</STRONG>  Some communication
styles regard the data as a sequence of bytes, with no larger
structure; others group the bytes into records (which are known in
this context as <STRONG>packets</STRONG>).

<LI>

<A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>
<STRONG>Can data be lost during normal operation?</STRONG>  Some communication
styles guarantee that all the data sent arrives in the order it was
sent (barring system or network crashes); other styles occasionally
lose data as a normal part of operation, and may sometimes deliver
packets more than once or in the wrong order.

Designing a program to use unreliable communication styles usually
involves taking precautions to detect lost or misordered packets and
to retransmit data as needed.

<LI>

<STRONG>Is communication entirely with one partner?</STRONG>  Some
communication styles are like a telephone call--you make a
<STRONG>connection</STRONG> with one remote socket, and then exchange data
freely.  Other styles are like mailing letters--you specify a
destination address for each message you send.
</UL>

<P>
<A NAME="IDX1393"></A>
<A NAME="IDX1394"></A>
<A NAME="IDX1395"></A>
<A NAME="IDX1396"></A>
You must also choose a <STRONG>namespace</STRONG> for naming the socket.  A socket
name ("address") is meaningful only in the context of a particular
namespace.  In fact, even the data type to use for a socket name may
depend on the namespace.  Namespaces are also called "domains", but we
avoid that word as it can be confused with other usage of the same
term.  Each namespace has a symbolic name that starts with <SAMP>`PF_'</SAMP>.
A corresponding symbolic name starting with <SAMP>`AF_'</SAMP> designates the
address format for that namespace.

</P>
<P>
<A NAME="IDX1397"></A>
<A NAME="IDX1398"></A>
<A NAME="IDX1399"></A>
<A NAME="IDX1400"></A>
Finally you must choose the <STRONG>protocol</STRONG> to carry out the
communication.  The protocol determines what low-level mechanism is used
to transmit and receive data.  Each protocol is valid for a particular
namespace and communication style; a namespace is sometimes called a
<STRONG>protocol family</STRONG> because of this, which is why the namespace names
start with <SAMP>`PF_'</SAMP>.

</P>
<P>
The rules of a protocol apply to the data passing between two programs,
perhaps on different computers; most of these rules are handled by the
operating system, and you need not know about them.  What you do need to
know about protocols is this:

</P>

<UL>
<LI>

In order to have communication between two sockets, they must specify
the <EM>same</EM> protocol.

<LI>

Each protocol is meaningful with particular style/namespace
combinations and cannot be used with inappropriate combinations.  For
example, the TCP protocol fits only the byte stream style of
communication and the Internet namespace.

<LI>

For each combination of style and namespace, there is a <STRONG>default
protocol</STRONG> which you can request by specifying 0 as the protocol
number.  And that's what you should normally do--use the default.
</UL>

<P>
Throughout the following description at various places
variables/parameters to denote sizes are required.  And here the trouble
starts.  In the first implementations the type of these variables was
simply <CODE>int</CODE>.  This type was on almost all machines of this time 32
bits wide and so a de-factor standard required 32 bit variables.  This
is important since references to variables of this type are passed to
the kernel.

</P>
<P>
But then the POSIX people came and unified the interface with the words
"all size values are of type <CODE>size_t</CODE>".  But on 64 bit machines
<CODE>size_t</CODE> is 64 bits wide, and so variable references are not anymore
possible.

</P>
<P>
The Unix98 specification provides a solution by introducing a type
<CODE>socklen_t</CODE>.  This type is used in all of the cases that POSIX
changed to use <CODE>size_t</CODE>.  The only requirement of this type is that
it be an unsigned type of at least 32 bits.  Therefore, implementations
which require that references to 32 bit variables be passed can be as
happy as implementations which use 64 bit values.

</P>

<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_278.html">previous</A>, <A HREF="libc_280.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
