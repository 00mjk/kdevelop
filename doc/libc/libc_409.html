<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Sleeping</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_408.html">previous</A>, <A HREF="libc_410.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC416" HREF="libc_toc.html#TOC416">Sleeping</A></H2>

<P>
The function <CODE>sleep</CODE> gives a simple way to make the program wait
for short periods of time.  If your program doesn't use signals (except
to terminate), then you can expect <CODE>sleep</CODE> to wait reliably for
the specified amount of time.  Otherwise, <CODE>sleep</CODE> can return sooner
if a signal arrives; if you want to wait for a given period regardless
of signals, use <CODE>select</CODE> (see section <A HREF="libc_225.html#SEC232">Waiting for Input or Output</A>) and don't
specify any descriptors to wait for.

</P>
<P>
<DL>
<DT><U>Function:</U> unsigned int <B>sleep</B> <I>(unsigned int <VAR>seconds</VAR>)</I>
<DD><A NAME="IDX2375"></A>
The <CODE>sleep</CODE> function waits for <VAR>seconds</VAR> or until a signal
is delivered, whichever happens first.

</P>
<P>
If <CODE>sleep</CODE> function returns because the requested time has
elapsed, it returns a value of zero.  If it returns because of delivery
of a signal, its return value is the remaining time in the sleep period.

</P>
<P>
The <CODE>sleep</CODE> function is declared in <TT>`unistd.h'</TT>.
</DL>

</P>
<P>
Resist the temptation to implement a sleep for a fixed amount of time by
using the return value of <CODE>sleep</CODE>, when nonzero, to call
<CODE>sleep</CODE> again.  This will work with a certain amount of accuracy as
long as signals arrive infrequently.  But each signal can cause the
eventual wakeup time to be off by an additional second or so.  Suppose a
few signals happen to arrive in rapid succession by bad luck--there is
no limit on how much this could shorten or lengthen the wait.

</P>
<P>
Instead, compute the time at which the program should stop waiting, and
keep trying to wait until that time.  This won't be off by more than a
second.  With just a little more work, you can use <CODE>select</CODE> and
make the waiting period quite accurate.  (Of course, heavy system load
can cause unavoidable additional delays--unless the machine is
dedicated to one application, there is no way you can avoid this.)

</P>
<P>
On some systems, <CODE>sleep</CODE> can do strange things if your program uses
<CODE>SIGALRM</CODE> explicitly.  Even if <CODE>SIGALRM</CODE> signals are being
ignored or blocked when <CODE>sleep</CODE> is called, <CODE>sleep</CODE> might
return prematurely on delivery of a <CODE>SIGALRM</CODE> signal.  If you have
established a handler for <CODE>SIGALRM</CODE> signals and a <CODE>SIGALRM</CODE>
signal is delivered while the process is sleeping, the action taken
might be just to cause <CODE>sleep</CODE> to return instead of invoking your
handler.  And, if <CODE>sleep</CODE> is interrupted by delivery of a signal
whose handler requests an alarm or alters the handling of <CODE>SIGALRM</CODE>,
this handler and <CODE>sleep</CODE> will interfere.

</P>
<P>
On the GNU system, it is safe to use <CODE>sleep</CODE> and <CODE>SIGALRM</CODE> in
the same program, because <CODE>sleep</CODE> does not work by means of
<CODE>SIGALRM</CODE>.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>nanosleep</B> <I>(const struct timespec *<VAR>requested_time</VAR>, struct timespec *<VAR>remaining</VAR>)</I>
<DD><A NAME="IDX2376"></A>
If the resolution of seconds is not enough the <CODE>nanosleep</CODE> function
can be used.  As the name suggests the sleeping period can be specified
in nanoseconds.  The actual period of waiting time might be longer since
the requested time in the <VAR>requested_time</VAR> parameter is rounded up
to the next integer multiple of the actual resolution of the system.

</P>
<P>
If the function returns because the time has elapsed the return value is
zero.  If the function return @math{-1} the global variable <VAR>errno</VAR>
is set to the following values:

</P>
<DL COMPACT>

<DT><CODE>EINTR</CODE>
<DD>
The call was interrupted because a signal was delivered to the thread.
If the <VAR>remaining</VAR> parameter is not the null pointer the structure
pointed to by <VAR>remaining</VAR> is updated to contain the remaining time.

<DT><CODE>EINVAL</CODE>
<DD>
The nanosecond value in the <VAR>requested_time</VAR> parameter contains an
illegal value.  Either the value is negative or greater than or equal to
1000 million.
</DL>

<P>
This function is a cancelation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <CODE>nanosleep</CODE> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <CODE>nanosleep</CODE> should
be protected using cancelation handlers.

</P>
<P>
The <CODE>nanosleep</CODE> function is declared in <TT>`time.h'</TT>.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_408.html">previous</A>, <A HREF="libc_410.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
