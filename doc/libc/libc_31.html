<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Heap Consistency Checking</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_30.html">previous</A>, <A HREF="libc_32.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC31" HREF="libc_toc.html#TOC31">Heap Consistency Checking</A></H3>

<P>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>

</P>
<P>
You can ask <CODE>malloc</CODE> to check the consistency of dynamic storage by
using the <CODE>mcheck</CODE> function.  This function is a GNU extension,
declared in <TT>`mcheck.h'</TT>.
<A NAME="IDX240"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>mcheck</B> <I>(void (*<VAR>abortfn</VAR>) (enum mcheck_status <VAR>status</VAR>))</I>
<DD><A NAME="IDX241"></A>
Calling <CODE>mcheck</CODE> tells <CODE>malloc</CODE> to perform occasional
consistency checks.  These will catch things such as writing
past the end of a block that was allocated with <CODE>malloc</CODE>.

</P>
<P>
The <VAR>abortfn</VAR> argument is the function to call when an inconsistency
is found.  If you supply a null pointer, then <CODE>mcheck</CODE> uses a
default function which prints a message and calls <CODE>abort</CODE>
(see section <A HREF="libc_510.html#SEC518">Aborting a Program</A>).  The function you supply is called with
one argument, which says what sort of inconsistency was detected; its
type is described below.

</P>
<P>
It is too late to begin allocation checking once you have allocated
anything with <CODE>malloc</CODE>.  So <CODE>mcheck</CODE> does nothing in that
case.  The function returns <CODE>-1</CODE> if you call it too late, and
<CODE>0</CODE> otherwise (when it is successful).

</P>
<P>
The easiest way to arrange to call <CODE>mcheck</CODE> early enough is to use
the option <SAMP>`-lmcheck'</SAMP> when you link your program; then you don't
need to modify your program source at all.  Alternately you might use
a debugger to insert a call to <CODE>mcheck</CODE> whenever the program is
started, for example these gdb commands will automatically call <CODE>mcheck</CODE>
whenever the program starts:

</P>

<PRE>
(gdb) break main
Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
&#62;call mcheck(0)
&#62;continue
&#62;end
(gdb) ...
</PRE>

<P>
This will however only work if no initialization function of any object
involved calls any of the <CODE>malloc</CODE> functions since <CODE>mcheck</CODE>
must be called before the first such function.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> enum mcheck_status <B>mprobe</B> <I>(void *<VAR>pointer</VAR>)</I>
<DD><A NAME="IDX242"></A>
The <CODE>mprobe</CODE> function lets you explicitly check for inconsistencies
in a particular allocated block.  You must have already called
<CODE>mcheck</CODE> at the beginning of the program, to do its occasional
checks; calling <CODE>mprobe</CODE> requests an additional consistency check
to be done at the time of the call.

</P>
<P>
The argument <VAR>pointer</VAR> must be a pointer returned by <CODE>malloc</CODE>
or <CODE>realloc</CODE>.  <CODE>mprobe</CODE> returns a value that says what
inconsistency, if any, was found.  The values are described below.
</DL>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>enum mcheck_status</B>
<DD><A NAME="IDX243"></A>
This enumerated type describes what kind of inconsistency was detected
in an allocated block, if any.  Here are the possible values:

</P>
<DL COMPACT>

<DT><CODE>MCHECK_DISABLED</CODE>
<DD>
<CODE>mcheck</CODE> was not called before the first allocation.
No consistency checking can be done.
<DT><CODE>MCHECK_OK</CODE>
<DD>
No inconsistency detected.
<DT><CODE>MCHECK_HEAD</CODE>
<DD>
The data immediately before the block was modified.
This commonly happens when an array index or pointer
is decremented too far.
<DT><CODE>MCHECK_TAIL</CODE>
<DD>
The data immediately after the block was modified.
This commonly happens when an array index or pointer
is incremented too far.
<DT><CODE>MCHECK_FREE</CODE>
<DD>
The block was already freed.
</DL>
</DL>

<P>
Another possibility to check for and guard against bugs in the use of
<CODE>malloc</CODE>, <CODE>realloc</CODE> and <CODE>free</CODE> is to set the environment
variable <CODE>MALLOC_CHECK_</CODE>.  When <CODE>MALLOC_CHECK_</CODE> is set, a
special (less efficient) implementation is used which is designed to be
tolerant against simple errors, such as double calls of <CODE>free</CODE> with
the same argument, or overruns of a single byte (off-by-one bugs).  Not
all such errors can be protected against, however, and memory leaks can
result.  If <CODE>MALLOC_CHECK_</CODE> is set to <CODE>0</CODE>, any detected heap
corruption is silently ignored; if set to <CODE>1</CODE>, a diagnostic is
printed on <CODE>stderr</CODE>; if set to <CODE>2</CODE>, <CODE>abort</CODE> is called
immediately.  This can be useful because otherwise a crash may happen
much later, and the true cause for the problem is then very hard to
track down.

</P>
<P>
So, what's the difference between using <CODE>MALLOC_CHECK_</CODE> and linking
with <SAMP>`-lmcheck'</SAMP>?  <CODE>MALLOC_CHECK_</CODE> is orthogonal with respect to
<SAMP>`-lmcheck'</SAMP>.  <SAMP>`-lmcheck'</SAMP> has been added for backward
compatibility.  Both <CODE>MALLOC_CHECK_</CODE> and <SAMP>`-lmcheck'</SAMP> should
uncover the same bugs - but using <CODE>MALLOC_CHECK_</CODE> you don't need to
recompile your application.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_30.html">previous</A>, <A HREF="libc_32.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
