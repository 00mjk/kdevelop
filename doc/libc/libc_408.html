<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Setting an Alarm</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_407.html">previous</A>, <A HREF="libc_409.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC415" HREF="libc_toc.html#TOC415">Setting an Alarm</A></H2>

<P>
The <CODE>alarm</CODE> and <CODE>setitimer</CODE> functions provide a mechanism for a
process to interrupt itself at some future time.  They do this by setting a
timer; when the timer expires, the process receives a signal.

</P>
<P>
<A NAME="IDX2356"></A>
<A NAME="IDX2357"></A>
<A NAME="IDX2358"></A>
<A NAME="IDX2359"></A>
Each process has three independent interval timers available:

</P>

<UL>
<LI>

A real-time timer that counts clock time.  This timer sends a
<CODE>SIGALRM</CODE> signal to the process when it expires.
<A NAME="IDX2360"></A>
<A NAME="IDX2361"></A>

<LI>

A virtual timer that counts CPU time used by the process.  This timer
sends a <CODE>SIGVTALRM</CODE> signal to the process when it expires.
<A NAME="IDX2362"></A>
<A NAME="IDX2363"></A>

<LI>

A profiling timer that counts both CPU time used by the process, and CPU
time spent in system calls on behalf of the process.  This timer sends a
<CODE>SIGPROF</CODE> signal to the process when it expires.
<A NAME="IDX2364"></A>
<A NAME="IDX2365"></A>

This timer is useful for profiling in interpreters.  The interval timer
mechanism does not have the fine granularity necessary for profiling
native code.
</UL>

<P>
You can only have one timer of each kind set at any given time.  If you
set a timer that has not yet expired, that timer is simply reset to the
new value.

</P>
<P>
You should establish a handler for the appropriate alarm signal using
<CODE>signal</CODE> or <CODE>sigaction</CODE> before issuing a call to <CODE>setitimer</CODE>
or <CODE>alarm</CODE>.  Otherwise, an unusual chain of events could cause the
timer to expire before your program establishes the handler, and in that
case it would be terminated, since that is the default action for the alarm
signals.  See section <A HREF="libc_417.html#SEC424">Signal Handling</A>.

</P>
<P>
The <CODE>setitimer</CODE> function is the primary means for setting an alarm.
This facility is declared in the header file <TT>`sys/time.h'</TT>.  The
<CODE>alarm</CODE> function, declared in <TT>`unistd.h'</TT>, provides a somewhat
simpler interface for setting the real-time timer.
<A NAME="IDX2366"></A>
<A NAME="IDX2367"></A>

</P>
<P>
<DL>
<DT><U>Data Type:</U> <B>struct itimerval</B>
<DD><A NAME="IDX2368"></A>
This structure is used to specify when a timer should expire.  It contains
the following members:
<DL COMPACT>

<DT><CODE>struct timeval it_interval</CODE>
<DD>
This is the interval between successive timer interrupts.  If zero, the
alarm will only be sent once.

<DT><CODE>struct timeval it_value</CODE>
<DD>
This is the interval to the first timer interrupt.  If zero, the alarm is
disabled.
</DL>

<P>
The <CODE>struct timeval</CODE> data type is described in section <A HREF="libc_398.html#SEC405">High-Resolution Calendar</A>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>setitimer</B> <I>(int <VAR>which</VAR>, struct itimerval *<VAR>new</VAR>, struct itimerval *<VAR>old</VAR>)</I>
<DD><A NAME="IDX2369"></A>
The <CODE>setitimer</CODE> function sets the timer specified by <VAR>which</VAR>
according to <VAR>new</VAR>.  The <VAR>which</VAR> argument can have a value of
<CODE>ITIMER_REAL</CODE>, <CODE>ITIMER_VIRTUAL</CODE>, or <CODE>ITIMER_PROF</CODE>.

</P>
<P>
If <VAR>old</VAR> is not a null pointer, <CODE>setitimer</CODE> returns information
about any previous unexpired timer of the same kind in the structure it
points to.

</P>
<P>
The return value is <CODE>0</CODE> on success and <CODE>-1</CODE> on failure.  The
following <CODE>errno</CODE> error conditions are defined for this function:

</P>
<DL COMPACT>

<DT><CODE>EINVAL</CODE>
<DD>
The timer interval was too large.
</DL>
</DL>

<P>
<DL>
<DT><U>Function:</U> int <B>getitimer</B> <I>(int <VAR>which</VAR>, struct itimerval *<VAR>old</VAR>)</I>
<DD><A NAME="IDX2370"></A>
The <CODE>getitimer</CODE> function stores information about the timer specified
by <VAR>which</VAR> in the structure pointed at by <VAR>old</VAR>.

</P>
<P>
The return value and error conditions are the same as for <CODE>setitimer</CODE>.
</DL>

</P>
<DL COMPACT>

<DT><CODE>ITIMER_REAL</CODE>
<DD>
<A NAME="IDX2371"></A>
This constant can be used as the <VAR>which</VAR> argument to the
<CODE>setitimer</CODE> and <CODE>getitimer</CODE> functions to specify the real-time
timer.

<DT><CODE>ITIMER_VIRTUAL</CODE>
<DD>
<A NAME="IDX2372"></A>
This constant can be used as the <VAR>which</VAR> argument to the
<CODE>setitimer</CODE> and <CODE>getitimer</CODE> functions to specify the virtual
timer.

<DT><CODE>ITIMER_PROF</CODE>
<DD>
<A NAME="IDX2373"></A>
This constant can be used as the <VAR>which</VAR> argument to the
<CODE>setitimer</CODE> and <CODE>getitimer</CODE> functions to specify the profiling
timer.
</DL>

<P>
<DL>
<DT><U>Function:</U> unsigned int <B>alarm</B> <I>(unsigned int <VAR>seconds</VAR>)</I>
<DD><A NAME="IDX2374"></A>
The <CODE>alarm</CODE> function sets the real-time timer to expire in
<VAR>seconds</VAR> seconds.  If you want to cancel any existing alarm, you
can do this by calling <CODE>alarm</CODE> with a <VAR>seconds</VAR> argument of
zero.

</P>
<P>
The return value indicates how many seconds remain before the previous
alarm would have been sent.  If there is no previous alarm, <CODE>alarm</CODE>
returns zero.
</DL>

</P>
<P>
The <CODE>alarm</CODE> function could be defined in terms of <CODE>setitimer</CODE>
like this:

</P>

<PRE>
unsigned int
alarm (unsigned int seconds)
{
  struct itimerval old, new;
  new.it_interval.tv_usec = 0;
  new.it_interval.tv_sec = 0;
  new.it_value.tv_usec = 0;
  new.it_value.tv_sec = (long int) seconds;
  if (setitimer (ITIMER_REAL, &#38;new, &#38;old) &#60; 0)
    return 0;
  else
    return old.it_value.tv_sec;
}
</PRE>

<P>
There is an example showing the use of the <CODE>alarm</CODE> function in
section <A HREF="libc_439.html#SEC446">Signal Handlers that Return</A>.

</P>
<P>
If you simply want your process to wait for a given number of seconds,
you should use the <CODE>sleep</CODE> function.  See section <A HREF="libc_409.html#SEC416">Sleeping</A>.

</P>
<P>
You shouldn't count on the signal arriving precisely when the timer
expires.  In a multiprocessing environment there is typically some
amount of delay involved.

</P>
<P>
<STRONG>Portability Note:</STRONG> The <CODE>setitimer</CODE> and <CODE>getitimer</CODE>
functions are derived from BSD Unix, while the <CODE>alarm</CODE> function is
specified by the POSIX.1 standard.  <CODE>setitimer</CODE> is more powerful than
<CODE>alarm</CODE>, but <CODE>alarm</CODE> is more widely used.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_407.html">previous</A>, <A HREF="libc_409.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
