<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from libc.texinfo on 28 March 2001 -->

<TITLE>The GNU C Library - Sigsuspend</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_465.html">previous</A>, <A HREF="libc_467.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC473" HREF="libc_toc.html#TOC473">Using <CODE>sigsuspend</CODE></A></H3>

<P>
The clean and reliable way to wait for a signal to arrive is to block it
and then use <CODE>sigsuspend</CODE>.  By using <CODE>sigsuspend</CODE> in a loop,
you can wait for certain kinds of signals, while letting other kinds of
signals be handled by their handlers.

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>sigsuspend</B> <I>(const sigset_t *<VAR>set</VAR>)</I>
<DD><A NAME="IDX2595"></A>
This function replaces the process's signal mask with <VAR>set</VAR> and then
suspends the process until a signal is delivered whose action is either
to terminate the process or invoke a signal handling function.  In other
words, the program is effectively suspended until one of the signals that
is not a member of <VAR>set</VAR> arrives.

</P>
<P>
If the process is woken up by deliver of a signal that invokes a handler
function, and the handler function returns, then <CODE>sigsuspend</CODE> also
returns.

</P>
<P>
The mask remains <VAR>set</VAR> only as long as <CODE>sigsuspend</CODE> is waiting.
The function <CODE>sigsuspend</CODE> always restores the previous signal mask
when it returns.

</P>
<P>
The return value and error conditions are the same as for <CODE>pause</CODE>.
</DL>

</P>
<P>
With <CODE>sigsuspend</CODE>, you can replace the <CODE>pause</CODE> or <CODE>sleep</CODE>
loop in the previous section with something completely reliable:

</P>

<PRE>
sigset_t mask, oldmask;

...

/* Set up the mask of signals to temporarily block. */
sigemptyset (&#38;mask);
sigaddset (&#38;mask, SIGUSR1);

...

/* Wait for a signal to arrive. */
sigprocmask (SIG_BLOCK, &#38;mask, &#38;oldmask);
while (!usr_interrupt)
  sigsuspend (&#38;oldmask);
sigprocmask (SIG_UNBLOCK, &#38;mask, NULL);
</PRE>

<P>
This last piece of code is a little tricky.  The key point to remember
here is that when <CODE>sigsuspend</CODE> returns, it resets the process's
signal mask to the original value, the value from before the call to
<CODE>sigsuspend</CODE>---in this case, the <CODE>SIGUSR1</CODE> signal is once
again blocked.  The second call to <CODE>sigprocmask</CODE> is
necessary to explicitly unblock this signal.

</P>
<P>
One other point: you may be wondering why the <CODE>while</CODE> loop is
necessary at all, since the program is apparently only waiting for one
<CODE>SIGUSR1</CODE> signal.  The answer is that the mask passed to
<CODE>sigsuspend</CODE> permits the process to be woken up by the delivery of
other kinds of signals, as well--for example, job control signals.  If
the process is woken up by a signal that doesn't set
<CODE>usr_interrupt</CODE>, it just suspends itself again until the "right"
kind of signal eventually arrives.

</P>
<P>
This technique takes a few more lines of preparation, but that is needed
just once for each kind of wait criterion you want to use.  The code
that actually waits is just four lines.

</P>
<P><HR><P>
Go to the <A HREF="libc_1.html">first</A>, <A HREF="libc_465.html">previous</A>, <A HREF="libc_467.html">next</A>, <A HREF="libc_654.html">last</A> section, <A HREF="libc_toc.html">table of contents</A>.
</BODY>
</HTML>
