<!DOCTYPE LINUXDOC PUBLIC "-//GMD//DTD linuxdoc//EN">
<linuxdoc>
<book>
<titlepag>
<title>O Manual de Programação do KDevelop
<subtitle>O Guia do Utilizador para Desenvolvimento de Aplicações C++ para o Ambiente de Trabalho K (KDE) com o ambiente de trabalho KDevelop, Versão
2.1</subtitle></title>
<author>
<name>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">
<inst>A Equipa do KDevelop
<date>Versão 2.1 , 7 de Julho, 1999
<abstract>
Este manual em si é parte do Ambiente de Desenvolvimento Integrado (IDE) KDevelop e é assim também licenciado sob a Licença Geral Pública
GNU; veja <ref id="Copyright" name="Copyright"> para mais informação.
</abstract>

<toc>

<chapt>Introdução
<p>
Como os Sistemas Unix estão a tornar-se mais e mais populares mesmo para iniciados no trabalho com computadores, devido às suas vantagens no
que toca a estabilidade e functionalidade, muitos estão de certo modo desapontados, porque as aplicações não têm um aspecto consistente e cada uma se
comporta de forma diferente das restantes. Com o KDE, os programadores têm uma forma quase perfeita de criar aplicações de primeira classe para ambientes de trabalho Unix
para obterem uma comunidade de utilizadores mais vasta apenas pela qualidade que as suas aplicações oferecem. Assim, o KDE torna-se mais e mais
popular como uma base para o desenvolvimento de aplicações, e os programadores desejam retirar vantagens das possibilidades que o sistema tem para oferecer.


<sect>O que já deve saber neste momento
<p>
Para obter a melhor utilização deste manual de programação, nós assumimos que você já conhece a linguagem de programação C++; se não, deve
familiarizar-se com ela primeiro. Informação sobre C++ está disponível através de várias fontes quer em formato impresso na sua
livraria local ou através de tutores encontrados na Internet. Conhecimentos sobre o desenho de Interfaces Gráficos de Utilizador não são requeridos, já
que este manual tenta cobrir o desenho de aplicações para programas KDE, o que também inclui uma introdução ao conjunto de ferramentas <idx/Qt/ bem como
às <idx/bibliotecas KDE/ e ao desenho de Interfaces de Utilizador. Também, já se deve ter familiarizado com o KDevelop tendo lido
<htmlurl url="index.html" name="O Manual do Utilizador do KDevelop">, que contém uma revisão descritiva das funcionalidades disponibilizadas pelo
ambiente de desenvolvimento (IDE).

<sect>Sobre este Manual
<p>
Este manual foi escrito para dar aos programadores uma introdução ao desenvolvimento de aplicações para o KDE utilizando o Ambiente de Desenvolvimento
Integrado KDevelop.

Os capítulos seguintes dão-lhe assim uma introdução sobre como criar projectos, explica o código fonte já gerado e mostra
como ampliar o código fornecido em vários aspectos tais como as barras de <idx/ferramentas/, barras de menu e áreas de vista.

Depois é discutido em detalhe o editor de diálogos, explicando como os widgets são criados e cobre a definição de propriedades dos widget's em detalhe
para todos os widgets disponibilizados.

Finalmente, você irá aprender sobre vários tópicos que irão completar o seu conhecimento no que respeita ao desenho de projectos e o ajuda a resolver
problemas adicionais para além de programar tais como adicionar documentação <idx/API/ e extender os manuais electrónicos.

<bf/No capítulo seguinte/

iremos observar as bibliotecas <idx/Qt/ e <idx/KDE/, mostrando conceitos basicos e porque são as coisas do modo que são.
Também, iremos discutir como criar as aplicações de tutor disponibilizadas com o conjunto de ferramentas <idx/Qt/ utilizando o KDevelop, para que os iniciados possam ver
já os primeiros resultados com alguns passos, e assim aprender como utilizar algumas das melhores funcionalidades do KDevelop.

<bf/Nos capítulos seguintes/ você irá aprender:
<itemize>
<item>como criar uma aplicação com o KAppWizard,
<item>o que o esqueleto do projecto já disponibiliza,
<item>o que o código já criado significa,
<item>como criar as suas próprias vistas,
<item>como aumentar as funcionalidades da sua aplicação através de diálogos e barras de menu e <idx/ferramentas/
<item>como tornar a sua aplicação amiga do utilizador disponibilizando funções de ajuda e
<item>como escrever documentação electrónica em <idx/SGML/.
</itemize>


<sect>Informação Adicional
<p>
Informação adicional sobre programação <idx/Qt//KDE é disponibilizada por várias fontes:

<itemize>
<item><em/Programar com a <idx/Qt// por Matthias Kalle Dalheimer, publicado por O'Reilly (veja <url url="http://www.oreilly.com" >, cobrindo
quase todos os aspectos do conjunto de ferramentas GUI <idx/Qt/ e contendo também exemplos.
<item><htmlurl url="index.html" name="O Manual do Utilizador do KDevelop">, disponibilizado com o IDE KDevelop,
<item><em/Referência Electrónica/ para a biblioteca <idx/Qt/, disponibilizada com a sua cópia do conjunto de ferramentas <idx/Qt/ em
HTML e disponível em PostScript em <url url="http://www.troll.no">
<item>Na Internet, veja
  <itemize>
  <item>a página da Troll Tech em <url url="http://www.troll.no">,
  <item>a página do KDE em <url url="http://www.kde.org">,
  <item>a página do programador KDE em <url url="http://developer.kde.org">
  <item>a página do KDevelop em <url url="http://www.kdevelop.org">
  </itemize>
</itemize>

Adicionalmente, deverá procurar ajuda subscrevendo-se nas várias listas de discussão por e-mail, cujos endereços estão disponíveis nas páginas
mencionadas, e nos grupos de notícias da Usenet dedicados aos utilizadores do KDE e Sistemas Unix bem como sobre a linguagem de programação C e C++.

Para obter ajuda sobre o IDE KDevelop, deverá enviar pedidos para a nossa lista de discussão em <htmlurl
url="mailto:kdevelop@fara3.cs.uni-potsdam.de" name="kdevelop@fara3.cs.uni-potsdam.de">. Lembre-se que a equipa do KDevelop é dedicada a
oferecer-lhe os meios para lhe permitir programar aplicações e assim não tem como objectivo ser uma equipa de suporte técnico em casos em que as
aplicações que está a desenvolver não funcionam devido a erros de implementação ou más configurações do seu sistema operativo. Posto isto, nós pedimos
a todos os utilizadores para aproveitarem a lista de discussão em todos os casos em que encontrarem problemas com a utilização do IDE em si, bem como
para reportar erros (bugs) e sugestões para melhorar a funcionalidade do ambiente de desenvolvimento.

<chapt>As Bibliotecas KDE e <idx/Qt/
<p>
A empresa Norueguesa Troll Tech (<url url="http://www.troll.no">) disponibiliza um chamado conjunto de ferramentas de GUI, chamado <idx/Qt/. Assim, GUI significa
"<bf/G/raphical <bf/U/ser <bf/I/nterface - Interface Gráfico de Utilizador", e assim, as aplicações baseadas na <idx/Qt/ representam-se com botões, janelas etc,
permitindo inserção de dados do utilizador visualizando as funções que a aplicação disponibiliza. Este conjunto de ferramentas é necessário para o desenvolvimento de
aplicações gráficas que corram no Interface X-Window em Sistemas Unix, porque o X não contém um interface de utilizador pré-definido em si.
Apesar de outros conjuntos de ferramentas estarem também disponíveis para criar Interfaces de Utilizador, a <idx/Qt/ oferece algumas vantagens técnicas que tornam o desenho de aplicações
muito fácil. Adicionalmente, o conjunto de ferramentas <idx/Qt/ também está disponível para o sistema Microsoft Windows, o que permite aos programadores disponibilizarem
as suas aplicações para ambas as plataformas.

A Equipa KDE (<url url="http://www.kde.org">) juntou-se com o objectivo de tornar a utilização de Sistemas Unix
mais amigável, e decidiu utilizar o conjunto de ferramentas <idx/Qt/ para o desenvolvimento de um gestor de janelas no X-Window, mais uma variedade de ferramentas
incluídas com os pacotes KDE. O Ambiente de Trabalho K  contém assim o gestor de janelas <em/kwm/, o gestor de ficheiros <em/kfm/ e
o painel de controlo <em/kpanel/ como sendo os componentes principais mais uma variedade de utilitários e aplicações de primeira classe. Depois do KDE ter saido, muitos
dos programadores voltaram os seus olhos no sentido deste novo ambiente e do que tem para lhes oferecer. As <idx/bibliotecas KDE/ estão a disponibilizar
métodos e classes fundamentais que fazem com que todas as aplicações desenhadas com elas tenham um aspecto similar e consistente, e o utilizador tem a grande vantagem
de apenas ter de se acostumar com a utilização específica de uma aplicação, não com o manuseamento de diálogos ou botões. Também, os programas KDE integram-se
no ambiente de trabalho e são capazes de interagir com o gestor de ficheiros através do <idx/arrastar e largar/ (drag and drop), oferecer gestão de sessões e muito mais,
se todas as funcionalidades oferecidas pelas <idx/bibliotecas KDE/ forem utilizadas.

Ambos, o conjunto de ferramentas <idx/Qt/ e as <idx/bibliotecas KDE/, são implementadas na linguagem de programação C++; assim aplicações que façam uso
destas bibliotecas são também maioritariamente escritas em C++. No capítulo seguinte, faremos uma breve viagem através das bibliotecas para ver o que
já é disponibilizado e como as aplicações <idx/Qt/ e <idx/KDE/ são criadas em geral.

<sect>O Conjunto de Ferramentas GUI <idx/Qt/
<p>
Como foi dito, a biblioteca <idx/Qt/ é um conjunto de ferramentas que oferece elementos gráficos que são utilizados para criar GUI's de aplicações e são necessárias
para programação X-Window. Adicionalmente, este conjunto de ferramentas oferece:

<itemize>
<item>Um conjunto completo de classes e métodos prontos a utilizar para questões de programação não-gráfica,
<item>Uma boa solução no sentido da interacção do utilizador através de métodos virtuais e mecanismos sinal/espaço,
<item>Um conjunto de elementos GUI pré-definidos, chamados "widgets", que podem ser facilmente utilizados para criar elementos visíveis
<item>Diálogos adicionais completamente pré-definidos que são muitas vezes utilizados em aplicaçãis tais como diálogos de progresso e de ficheiros.
</itemize>

Posto isto conhecer as classes <idx/Qt/ é essêncial, mesmo se você apenas deseja programar aplicações KDE. Para ter uma ideia do conceito
basico sobre como as aplicações GUI são construidas e compiladas, iremos primeiro observar um programa exemplo apenas <idx/Qt/; depois extende-lo-emos
para um programa KDE.

<sect1>A Primeira Aplicação <idx/Qt/
<p>
Como normalmente, programas em C++ têm de conter a função <tt/main()/, que é o ponto de partida para a execução da aplicação. Como queremos que
seja graficamente visível em janelas e ofereça interacção do utilizador, temos primeiro que saber, como se podem mostrar a si próprias ao
utilizador. Por exemplo, iremos observar o primeiro programa de tutor incluido com a Documentação Electrónica de Referência <idx/Qt/ e explicar os passos de
execução básicos; também como e porquê as janelas da aplicação aparecem:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</code></tscreen>

Esta aplicação meramente pinta uma janela contendo um botão com "Hello world" ("Olá Mundo") como texto. Como todas as aplicações baseadas na <idx/Qt/, primeiro
tem de declarar uma instância da classe <tt/<cdx/QApplication//, representada por <tt/a/.

Depois, o programa cria uma instância da classe <tt/QPushButton/ chamada <tt/hello/, isto será o botão. O constructor do
<tt/hello/ obtém uma string (conjunto de caracteres) como parâmetro, que é o conteudo do widget visível como sendo o texto do botão.

Depois o método <tt/resize()/ é chamado sobre o botão <tt/hello/. Isto muda o tamanho de defeito que um widget (que é neste caso
o QPushButton) tem quando criado para o comprimento de 100 pixels e a altura de 30 pixels. Finalmente, o método <tt/setMainWidget()/
é chamado para <tt/a/ e o método <tt/show()/ para <tt/hello/. A <tt/<cdx/QApplication// é finalmente executada por <tt/a.exec()/,
entra no ciclo de acontecimento principal e aguarda até que tenha de devolver um valor inteiro para a camada do Sistema Operativo assinalando que
a aplicação terminou.

<sect1>A Documentação de Referência para a <idx/Qt/
<p>
Agora, vamos observar rapidamente a documentação de referência da biblioteca <idx/Qt/. Para fazer isto, inicie o KDevelop e seleccione "biblioteca <idx/Qt/" a partir
do menu "Ajuda" na barra de menu. O navegador de documentação abre e mostra-lhe a página inicial da referência <idx/Qt/. Isto irá ser o seu
primeiro local para obter informação sobre a <idx/Qt/, suas classes e as funções disponíveis que oferece. Também, o programa acima mostrado é o primeiro
que é incluído na secção dos tutores. Para obter as classes que desejamos observar, <tt/<cdx/QApplication// e <tt/QPushButton/,
seleccione "Lista Alfabética de Classes" e procure os nomes correspondentes. Siga qualquer uma delas para observar a <idx/documentação de classes/.

Para a <tt/<cdx/QApplication//, verá o construtor e todos os outros métodos que esta classe disponibiliza. Se seguir uma hiper-ligação, irá obter mais
informação sobre a utilização e significado dos métodos, o que é muito útil quando você às vezes não consegue detectar a utilização correcta
ou deseja ver um exemplo. Isto também vale para a documentação da biblioteca KDE, que utiliza um tipo de documentação similar; assim isto é
praticamente tudo o que tem de saber sobre a utilização da referência de classes com o navegador de documentação.

<sect1>Interpretação do Exemplo
<p>
Começando com a <tt/<cdx/QApplication//, você irá ver todos os métodos utilizados no nosso primeiro exemplo:

<itemize>
<item>o construtor <tt/<cdx/QApplication/()/,
<item>o método <tt/setMainWidget()/ e
<item>o método <tt/exec()/.
</itemize>

A interpretação sobre porque utilizamos estes métodos é muito simples:

<enum>
<item>primeiro criamos uma instância da classe <tt/<cdx/QApplication// com o construtor, para que possamos utilizar os elementos GUI disponibilizados pela
<idx/Qt/,
<item>criamos um widget que será o contentor da janela do nosso programa,
<item>definimos o widget como sendo o widget principal para <tt/a/,
<item>executamos a instância <tt/a/ da <tt/<cdx/QApplication//.
</enum>

O segundo objecto do nosso programa é o botão, como uma instância da classe <tt/QPushButton/. Dos dois construtores dados para
criar uma instância, nós utilizamos o segundo: este aceita um texto, que é a etiqueta do conteudo do botão; aqui, a etiqueta é o texto "Hello
world!". Depois chamamos o método <tt/resize()/ para modificar o tamanho do botão de acordo com o seu conteudo- o botão tem de ser maior
para tornar o texto completamente visível.

Mas e então o método <tt/show()/? Agora, você vê que tal como a maior parte dos outros widgets, <tt/QPushButton/ é baseado numa herança única-
aqui, a documentação diz, <em/Herda/ <tt/<cdx/QButton//. Siga a hiper-ligação para a classe <tt/<cdx/QButton//. Isto irá mostrar-lhe imensos outros
métodos que são herdados pelo QPushButton, que iremos utilizar mais tarde para explicar o mecanismo sinal/espaço. De qualquer modo, o método <tt/show()/
não está listado, pelo que, tem de ser um método que é disponibilizado também por herança. A classe que o <tt/<cdx/QButton// herda, é
<tt/<cdx/QWidget//. Basta seguir de novo a hiper-ligação, e irá ver imensos métodos que a classe <tt/<cdx/QWidget// disponibiliza; incluindo o
método <tt/show()/. Agora nós compreendemos o que foi feito no exemplo com o botão:

<enum>
<item>criar uma instância do <tt/QPushButton/, utilizar uma segunda construção para definir o texto do botão,
<item>redimensionar o widget para o seu conteudo,
<item>definir o widget como sendo o widget principal da instância <tt/a/ da <tt/<cdx/QApplication//,
<item>dizer ao widget para se mostrar no ecrã chamando <tt/show()/, um método herdado de <tt/<cdx/QWidget//.
</enum>

Após chamar o método <tt/exec()/, a aplicação é visível para o utilizador, mostrando uma janela com um botão apresentando "Hello world!".
Agora, programas GUI comportam-se de um modo ligeiramenta diferente das aplicações processuais. A coisa principal aqui é que a aplicação entra num
chamado "ciclo de evento principal". Isto significa que o programa tem de aguardar por acções do utilizador e depois reagir a estas, também que para uma aplicação
<idx/Qt/, o programa tem de estar no ciclo de evento principal para iniciar o manuseamento de eventos. A secção seguinte diz-lhe de forma breve o que isto
significa para o utilizador e o que a <idx/Qt/ oferece para processar eventos do utilizador.

(Para utilizadores já avançados: O botão não tem pai declarado no construtor, por isso é por si só um widget de nível superior e corre num
ciclo de evento local que não tem de aguardar pelo ciclo de evento principal, veja a <idx/documentação de classe/ <tt/<cdx/QWidget// e <htmlurl
url="kde_libref.html" name="O Guia de Referência da Biblioteca KDE">)

<bf/Sumário:/

Uma aplicação <idx/Qt/ tem sempre de ter uma instância da classe <tt/<cdx/QApplication//. Isto permite que possamos criar janelas que são a
representação gráfica de programas para o utilizador final e permitem interacção. O conteudo da janela em si é chamado o "Widget Principal", significando
que todos os elementos gráficos são baseados na classe <tt/<cdx/QWidget// e podem ser qualquer tipo de widget que sirva as necessidades da aplicação para
comunicar com o utilizador. Assim, todos os elementos de utilizador têm de herdar de uma forma ou de outra <tt/<cdx/QWidget// para serem visíveis.

<sect1>Interacção do Utilizador<label id="User Interaction">
<p>
Após ler as secções anteriores, você já deverá saber:
<itemize>
<item>o que a biblioteca <idx/Qt/ disponibiliza em termos de aplicações GUI,
<item>como é que um programa que utilize a <idx/Qt/ é criado e
<item>onde e como obter informação sobre classes que deseja utilizar com o navegador de documentação
</itemize>

Agora iremos começar a dar "vida" à aplicação através do processamento de eventos do utilizador. Geralmente, o utilizador tem duas formas de interagir com o programa:
o rato e o teclado. Para ambas as formas, um interface gráfico de utilizador (GUI) tem de disponibilizar métodos que detectem acções e métodos que façam
alguma coisa como reacção a estas acções.

O sistema de Janelas assim envia todos os eventos de interacção para a respectiva aplicação. A <cdx/QApplication/ envia-os então para a janela
activa como um <tt/<cdx/QEvent// e os prórpios widgets têm de decidir o que fazer com os eventos. Um widget recebe o evento e processa
<tt/<cdx/QWidget//::event(<cdx/QEvent/*)/, que então decide que evento foi executado e como reagir; event() é assim quem faz o manuseamento
principal de eventos. Depois, a função <tt/event()/ passa o evento para os chamados filtros de eventos, que determinam que aconteceu e o que fazer com
o evento. Se nenhum filtro encontra um responsável pelo evento, os manuseadores especializados de eventos são chamados. Assim podemos decidir entre:

<bf/a) Eventos de Teclado -- teclas TAB e Shift-TAB:/

muda o focus de entrada do teclado do widget actual para o widget seguinte na ordem de focus. O focus pode ser atribuido aos widgets
chamando <tt/setFocusPolicy<ncdx/setFocusPolicy()/()/ e processar os seguintes indicadores de eventos:

<itemize>
<item><tt/virtual void focusInEvent<ncdx/focusInEvent()/ ( <cdx/QFocusEvent/ * )/
<item><tt/virtual void focusOutEvent<ncdx/focusOutEvent()/ ( <cdx/QFocusEvent/ * )/
</itemize>

<bf/b) todos os restantes eventos de teclado:/
<itemize>
<item><tt/virtual void keyPressEvent<ncdx/keyPressEvent()/ ( <cdx/QKeyEvent/ * )/
<item><tt/virtual void keyReleaseEvent<ncdx/keyReleaseEvent()/ ( <cdx/QKeyEvent/ * )/
</itemize>

<bf/c) movimentos do rato:/
<itemize>
<item><tt/virtual void mouseMoveEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void enterEvent ( <cdx/QEvent/ * )/
<item><tt/virtual void leaveEvent ( <cdx/QEvent/ * )/
</itemize>

<bf/d) acções de botões do rato:/
<itemize>
<item><tt/virtual void mousePressEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseReleaseEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseDoubleClickEvent ( <cdx/QMouseEvent/ * )/
</itemize>

<bf/e) eventos da janela que contém o widget:/
<itemize>
<item><tt/virtual void moveEvent ( <cdx/QMoveEvent/ * )/
<item><tt/virtual void resizeEvent ( <cdx/QResizeEvent/ * )/
<item><tt/virtual void closeEvent ( <cdx/QCloseEvent/ * )/
</itemize>


Note que todas as funções de eventos são virtuais e protegidas; assim você pode re-implementar os eventos que necessitar nos seus próprios
widgets e especificar como o seu widget tem de reagir. O <tt/<cdx/QWidget// também contém alguns outros métodos virtuais que podem ser úteis nos seus
programas; de qualquer modo, é suficiente saber sobre o <tt/<cdx/QWidget// de uma forma geral.

<sect1>Interacção de Objectos através de Sinais e Espaços
<p>
Agora estamos a chegar às vantagens mais óbvias do conjunto de ferramentas <idx/Qt/: o mecanismo sinal/espaço. Isto oferece uma solução bastante "à-mão"
e útil para interacção de objectos, que é normalmente resolvido através de funções de <tt/callback/ para conjuntos de ferramentas X-Window. Como esta comunicação
requer uma programação estrita e às vezes torna a criação de interfaces gráficos muito difícil (como referido pela documentação <idx/Qt/ e
explicado em <em/Programação com <idx/Qt// por K.Dalheimer), a Troll Tech inventou um novo sistema onde objectos podem emitir sinais que podem ser
conectados a métodos declarados como espaços. Para a parte C++ do programador, ele apenas tem de saber algumas coisas sobre este mecanismo:

<enum>
<item>a declaração de classe da classe que utiliza sinais/espaços tem de conter a macro <tt/Q_OBJECT/ no início (sem o
ponto e vírgula); e tem de derivar da classe <tt/QObject/,
<item>um sinal pode ser emitido por uma palavra-chave <tt/emit/, por ex. <tt/emit signal(parâmetros);/ a partir de qualquer função membra
de uma classe que permita sinais/espaços,
<item>todos os sinais utilizados pelas classes que não são herdadas têm de ser adicionados à declaração da classe através de uma secção <tt/signals:/,
<item>todos os métodos que podem ser conectados com um sinal são declarados em secções com a palavra-chave adicional <tt/slot/, por ex.
<tt/<bf/public/ slots:/ dentro da declaração da classe,
<item>o compilador de meta-objectos <tt/moc/ tem de correr sobre o ficheiro header para expandir as macros e produzir a implementação (que
não é necessário saber.). Os ficheiros resultantes do <tt/moc/ são compilados também pelo compilador C++.
</enum>

Outra forma de utilizar sinais sem derivar de <tt/QObject/ é utilizar a classe <tt/QSignal/- veja a documentação de referência para
mais informação e exemplos de utilização. Nos exemplos seguintes, nós assumimos que você está a derivar da <tt/QObject/.


Desta forma, a sua classe é capaz de enviar sinais para qualquer lado e de disponibilizar espaços a onde se possam conectar sinais. Utilizando os sinais, você não
tem de se preocupar com quem os está a receber- você apenas tem de emitir o sinal e qualquer que seja o espaço que lhe queira conectar poderá reagir à
emissão. Também os espaços podem ser utilizados como métodos normais durante a implementação.

Agora, para conectar um sinal a um espaço, tem de utilizar os métodos <tt/connect()/ que são disponibilizados através do <tt/QObject/ ou, onde disponível,
métodos especiais que os objectos disponibilizam para definir a conecção para um certo sinal.


<sect2>Exemplo de Utilização
<p>
Para explicar a forma como definir interacção de objectos, iremos agarrar de novo no nosso primeiro exemplo e extende-lo através de uma conecção simples:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

Como vê, a única adição para dar ao botão mais interacção é utilizar um método <tt/connect()/:
<tt/connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );/ é tudo o que temos de acrescentar. Qual é o significado agora? A declaração
da classe de <tt/QObject/ diz sobre o método <tt/connect()/:

<tt/bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )/

Isto significa, você tem de especificar um ponteiro de uma instância de QObject que é o emissor do sinal, significando que pode emitir este sinal como
primeiro parâmetro; depois você tem de especificar o sinal a que se deseja conectar. Os dois últimos parâmetros são o objecto receptor que
disponibiliza um espaço, seguido pela função membro que <em/é/ na realidade o espaço que será executado aquando da emissão do sinal.

Utilizando sinais e espaços, os objectos do seu programa podem interagir entre eles facilmente sem dependerem explicitamente do tipo
de objecto receptor. Você irá aprender mais sobre a utilização deste mecanismo para utilização produtiva mais tarde neste manual. Mais informação sobre
o mecanismo Sinal/Espaço pode ser encontrado no <htmlurl url="kde_libref.html" name="Guia de Referência da Biblioteca KDE"> e na referência electrónica <idx/Qt/.

<sect>O que o KDE disponibiliza
<p>
<sect1>As bibliotecas KDE 1.1.x
<p>
À altura deste documento e devido ao facto de o KDevelop utilizar KDE 1.1, referimo-nos ao estado das <idx/bibliotecas KDE/ nessa
distribuição. As <idx/bibliotecas KDE/ principaos que irá utilizar para criar as suas próprias <idx/aplicações KDE/ são:

<itemize>
<item>a biblioteca KDE-Core, contendo todas as classes que são elementos não-visíveis e disponibilizam funcionalidades que a sua aplicação pode utilizar.
<item>a biblioteca KDE-UI, contendo elementos de interface com o utilizador tais como barras de menu, de <idx/ferramenta/s e afins,
<item>a biblioteca KFile, contendo diálogos de selecção de ficheiros,
</itemize>

Adicionalmente, para soluções específicas o KDE oferece as seguintes bibliotecas:

<itemize>
<item>a biblioteca KHTMLW, oferecendo um completo widget de interpretação HTML que é utilizado por vários programas como o <idx/KDEHelp/, KFM, KDevelop,
<item>a biblioteca KFM, permitindo a utilização do gestor de ficheiros do KDE a partir de dentro da sua aplicação.
<item>a biblioteca KAb, o KAddressBook. Disponibiliza acesso a livro de endereços para por ex. aplicações de e-mail
<item>a biblioteca KSpell, oferecendo widgets e funcionalidades para integrar a utilização do Ispell, o corrector ortográfico comum, em aplicações
tais como editores; utilizado na aplicação KEdit.
</itemize>

De seguida, iremos observar o que é necessário para tornar a nossa primeira aplicação <idx/Qt/ numa KDE.

<sect1>Aplicação KDE Exemplo
<p>
No seguinte código, irá ver que escrever uma aplicação KDE não é muito mais difícil que uma aplicação <idx/Qt/. Para a utilização das características
do KDE, apenas tem de utilizar algumas outras classes, e está quase tudo feito. Como um exemplo, iremos discutir a versão alterada do exemplo
<idx/Qt/ dado acima:

<tscreen><code>
#include <kapp.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() );

hello.show();
return a.exec();
}
</code></tscreen>

Pode ver que primeiro alteramos de <tt/<cdx/QApplication// para <tt/<cdx/KApplication//. Além disso, tivemos de modificar o método <tt/setMainWidget()/
anteriormente utilizado para <tt/setTopWidget/, que a <tt/<cdx/KApplication// utiliza para definir o widget principal. E é tudo! A sua primeira
aplicação KDE está pronta- apenas tem de dizer ao compilador o caminho dos ficheiros include do KDE e ao linker para ligar a biblioteca KDE-Core com
-lkdecore.

Como você agora saber o que pelo menos a função main() disponibiliza de forma geral e como uma aplicação se torna visível e permite a interacção de utilizadores e
objectos, iremos continuar com o capítulo seguinte, onde a nossa primeira aplicação é feita com o KDevelop- aí poderá também testar tudo o
que foi mencionado anteriormente e verificar os resultados.

O que deverá ter consultado adicionalmente até agora é a documentação de referência da <idx/Qt/, especialmente as classes <tt/<cdx/QApplication//,
<tt/<cdx/QWidget// e <tt/QObject/ e a documentação da biblioteca KDE-Core para a classe <tt/<cdx/KApplication//. O manual de <htmlurl
url="kde_libref-3.html" name="Referência da Biblioteca KDE"> também cobre uma descrição completa sobre a invocação dos construtores
<tt/<cdx/QApplication// e <tt/<cdx/KApplication// incluindo processamento de argumentos de linha de comandos.

<chapt>Criar Novas Aplicações<label id="Creating new Applications">
<p>
O KAppWizard, ou também denominado Assistente de Aplicações KDE, destina-se a permitir-lhe começar a trabalhar em novos projectos com o KDevelop.
Assim, todos os seus projectos são primeiro criados através do assistente; depois você pode começar a construi-los e extender o código do esqueleto já
disponibilizado. O KAppWizard também permite escolher entre vários tipos de projectos de acordo com os objectivos do seu projecto:

<itemize>
<item>Aplicação KDE Normal: inclui código fonte para uma moldura de estrutura completa de uma aplicação KDE standard com suporte para o
modelo Controlador-de-Vista-de-Documento, uma barra de menu, <idx/ferramentas/ e estados bem como um conjunto de documentação baseado em <idx/SGML/, hiper-ligações KDE
e icons de aplicações. Este é o tipo de aplicação normalmente necessária para um novo projecto KDE.
<item>Mini-Aplicação KDE: contém a mesma estrutura geral que a Aplicação KDE Normal mas com a diferença que o
código da aplicação apenas disponibiliza um widget como uma janela.
<item>Aplicação <idx/Qt/ Normal: trabalha como a Aplicação KDE Normal através do seu código com a diferença de que o projecto é baseado na biblioteca
<idx/Qt/ apenas e não contém suporte KDE. É destinado a projectos que têm de ser portáveis para plataformas Windows ou que não querem requerer
as <idx/bibliotecas KDE/ por parte do utilizador final.
<item>Aplicação C: É baseada apenas no compilador C e corre numa consola.
<item>Aplicação C++: É baseada apenas no compilador C++ e corre numa consola tal como a aplicação C, pelo que não requer
o X-Window.
<item>Projecto Costumizável: cria um projecto vazio sem qualquer código fonte. Este destina-se a projectos já existentes para serem
convertidos para o KDevelop ou para projectos onde deseja começar de raiz. Lembre-se que tem de tomar conta dos ficheiros makefiles e dos scripts de configuração
sozinho.
</itemize>

Neste capítulo veremos como o KAppWizard pode ser invocado e o que tem de ser feito para gerar um projecto de aplicação KDE. Isto irá ser
também o passo inicial da nossa cobertura, onde iremos criar a versão inicial do projecto de exemplo. Para todos os outros tipos de projectos os
passos são normalmente os mesmos, apenas que poderá não necessitar de ter certas opções disponíveis.

<sect>Invocar o KAppWizard e a Geração do Projecto
<p>
<sect1>Iniciar o KAppWizard e a Primeira Página
<p>
Para começar com a sua primeira aplicação KDE, abra o KDevelop. Depois seleccione "Novo..." a partir do menu "Projecto". O KAppWizard inicia-se, e você
vê uma árvore na primeira página, contendo os tipos de projectos. Quando um tipo é seleccionado, você vê uma antevisão de como irá funcionar após o
processo inicial de construção. Escolha o ramo KDE, tipo Normal. Depois prima o botão "Seguinte" no fundo da primeira página do assistente. Isto
mudará para a página seguinte, onde você tem de definir as opções gerais do projecto.

<sect1>A Página de Geração de Definições
<p>
Para a nossa aplicação de exemplo, nos escolhemos o nome de projecto <tt/KScribble/; pelo que deverá inserir isto no campo "Nome do Projecto". Depois seleccione
o directório onde quer que o projecto seja construido; o defeito é o seu directório principal (home). Pode introduzir o caminho manualmente ou pode também
premir o botão à direita para seleccionar o directório através de um diálogo.

De seguida, tem de introduzir o número da Versão. Para a primeira versão, defina esta como <tt/0.1/. É normal numerar novas aplicações que estão
em desenvolvimento para a primeira distribuição abaixo de 1, e como a versão inicial irá apenas conter a estrutura standard, diremos que esta é
a versão 0.1.

Finalmente, adicione o seu nome ao campo "Autor" e o seu endereço de e-mail. Pode deixar todas as outras opções nos seus valores de defeito.

Para lhe dar algumas informações sobre outras opções, pode premir o botão direito do rato sobre as opções, e obterá uma janela de ajuda rápida
que descreve o objectivo da opção.

Estes são:
<itemize>
<item><bf/gerar código e headers:/  gera o código fonte da aplicação
<item><bf/Ficheiros-Standard-GNU:/  adiciona uma cópia da Licença Pública Geral (GPL) GNU ao projecto bem como alguns outros ficheiros standard para informação
do utilizador quando distribuir o pacote.
<item><bf/Documentação do Utilizador:/ o manual do utilizador em <idx/SGML/, já preparado para o seu projecto.
<item><bf/Documentação-<idx/API/:/ cria um conjunto de documentação HTML inicial para o <bf/I/nterface de <bf/P/rogramação da <bf/A/plicação (API).
<item><bf/Ficheiro-lsm:/ o Mapa de Aplicações Linux, utilizado pelos servidores de distribuição e contém uma breve informação sobre os objectivos do projecto e
requerimentos.
<item><bf/Ficheiro-<idx/.kdelnk/: / um atalho KDE que irá instalar a sua aplicação na árvore "Aplicações" no Painel de Controlo KDE.
<item><bf/Icon de Programa: / um Icon que representa o seu projecto e pode ser utilizado para criar um atalho para o ambiente de trabalho.
<item><bf/Mini-Icon: / uma versão-Mini do icon de programa que representa a sua aplicação para além do nome dela no Painel de Controlo KDE e é
mostrado nos diálogos e janela principal da sua aplicação no canto superior esquerdo.
</itemize>

Agora vamos para a página seguinte premindo o botão "Seguinte" de novo para definir o modelo para os ficheiros header do seu projecto.


<sect1>Os Modelos de Header e Código
<p>
A página de modelo de header permite-lhe incluir automaticamente um prefácio nos seus ficheiros header, contendo o nome do ficheiro, a data de construção, 
o ano do copyright, também o seu nome e endereço de e-mail. Você não tem de mudar essas partes em maiusculas por si, pois o
KAppWizard faz isto automaticamente e guarda o modelo para este projecto, para que possa ser utilizado de novo mais tarde para criar novos ficheiros.

A segunda parte do modelo de header de defeito contém uma informação de licença. Por defeito, o seu projecto está sob a Licença Pública Geral
GNU, que também é incluida no pacote. Esta licença é utilizada para proteger o seu código fonte contra qualquer pessoa que apenas
copie o seu código para os seus propósitos. A Licença Pública Geral (GPL) oferece-lhe esta licença gratuitamente e assim protege os seus direitos
como autor, e é comum para aplicações de distribuição livre. Para obter mais informação sobre a licença, deverá ler mais tarde o ficheiro
COPYING no directório base do seu novo projecto que é uma cópia da GPL e é já enviada com a sua aplicação.

De qualquer modo, você pode escolher outra licença ou outro modelo de header que já esteja a utilizar para os seus projectos. Sendo assim você pode
editar directamente o modelo de defeito dado. Para fazer isto, é-lhe dado o modelo numa janela de edição. Para limpar a página de defeito,
seleccione "Novo", para utilizar outro modelo, seleccione "Ler...", que lhe permite escolher um ficheiro de modelo.

Quando tiver terminado, vá para a página seguinte premindo "Seguinte". Esta é a página de modelo para os seus ficheiros de código fonte e é geralmente a mesma
que a página de modelo de header. A única diferença é que este modelo é utilizado para os seus ficheiros de implementação.

<sect1>Criar o Projecto
<p>

Agora que já definiu todas as opções para o <em/KScribble/, seleccione "Seguinte" e prima o botão "Gerar" no fundo da janela do assistente.
Se o botão não estiver disponível, você não definiu todas as opções correctamente. Para corrigir quaisquer erros, volte atrás no Assistente com "Regressar".

Depois você verá o que o KAppWizard faz- ele copia todos os modelos para o directório do seu projecto e cria o novo projecto. Após o KAppWizard
terminar, o botão "Cancelar" muda para um botão "Sair" para deixar o assistente.

Após este último passo, você terminou a criação do novo projecto. O KDevelop lê-o então e a vista de árvore permite-lhe navegar através
ficheiros e classes do projecto.


Na próxima secção, iremos discutir como construir e correr a sua primeira versão do <em/KScribble/ e como o código fonte está organizado.

<sect>A Primeira Construção
<p>
Após o seu projecto ser gerado, iremos primeiro fazer uma viagem através do código fonte para obter um entendimento geral de como funciona o esqueleto
da aplicação. Isto não só ajudará a começar como também saberemos onde mudar o quê em passos futuros.

Quando abrimos a página do VLF (Visualizador Lógico de Ficheiros)  na vista de árvore, você vê algumas pastas que já ordenam os ficheiros do projecto relevantes para
o programador. As duas primeiras pastas são "Header" e "Código". A pasta-Header assim sendo contém logicamente todos os ficheiros header do
projecto, a pasta-Código todo o código fonte. Todas as outras pastas não são de interesse por agora, pelo que voltaremos aqui mais tarde para ver o
que contêm.

Essas duas pastas contêm então os seguintes ficheiros:

<bf/Headers:/
<itemize>
<item><bf/kscribble.h :/ contém a declaração de classe para a classe <bf/KScribbleApp/.
<item><bf/kscribbledoc.h :/ contém a declaração de classe para a classe <bf/KScribbleDoc/.
<item><bf/kscribbleview.h :/ contém a declaração de classe para a classe <bf/KScribbleView/.
<item><bf/resource.h :/ contém uma colecção de macro para os menu-ID's
</itemize>

<bf/Código:/
<itemize>
<item><bf/kscribble.cpp :/ contém a implementação da classe <bf/KScribbleApp/.
<item><bf/kscribbledoc.cpp :/ contém a implementação da classe <bf/KScribbleDoc/.
<item><bf/kscribbleview.cpp :/ contém a implementação da classe <bf/KScribbleView/.
<item><bf/main.cpp :/ contém a implementação da função <bf/main()/.
</itemize>

Mas antes de mergulharmos no código, vamos deixar o KDevelop construir e correr a nossa nova aplicação. Para fazer isto, seleccione "Make" a partir do menu "Construir"
ou prima o botão correspondente na <idx/barra de ferramentas/. A janela de output abre na base do KDevelop e deixa-o ver o que o <tt/make/ está a fazer
através das mensagens que nos dá:

<tscreen><code>
1   Making all in docs
2   make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
3   Making all in en
4   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
5   make[2]: Nothing to be done for `all'.
6   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
7   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
8   make[2]: Nothing to be done for `all-am'.
9   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
10  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
11  make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble'
12  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.cpp
13  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.cpp
14  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c 		
    kscribble.cpp
15  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    main.cpp
16  /usr/bin/moc ./kscribble.h -o kscribble.moc.cpp
17  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribble.moc.cpp 		
18  /usr/bin/moc ./kscribbledoc.h -o kscribbledoc.moc.cpp
19  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.moc.cpp
20  /usr/bin/moc ./kscribbleview.h -o kscribbleview.moc.cpp
21  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.moc.cpp

22  /bin/sh ../libtool --silent --mode=link g++  -O0 -g -Wall   -o kscribble -L/opt/kde/lib  -L/usr/X11R6/lib -rpath /opt/kde/lib
    -rpath /usr/X11R6/lib kscribbleview.o kscribbledoc.o kscribble.o main.o kscribble.moc.o kscribbledoc.moc.o kscribbleview.moc.o
    -lkfile -lkfm -lkdeui -lkdecore -lqt -lXext -lX11

23  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble'
</code></tscreen>
<p>
Como pode ver, numeramos todas as linhas, o que não irá surgir no seu output; apenas torna mais fácil descrever agora o que
aconteceu durante a construção. Primeiro que tudo, o <tt/make/ trabalha recursivamente. Isto é, comça no directório em que foi invocado e
então vai para os subdirectórios primeiro, regressa e processa o subdirectório seguinte. Finalmente, o directório em que foi iniciado é processado
e o <tt/make/ termina. Assim, o <tt/make/ começou primeiro no directório principal do projecto contendo o código. Nas linhas 1 e 2, você
vê como o processo <tt/make/ entra no directório <tt/docs/, depois no subdirectório <tt/en/. Como não existe nada para fazer, ele
deixa estes directórios até regressar ao directório fonte <tt/kscribble/ na linha 11. Depois, o verdadeiro trabalho começa: o <tt/make/
invoca o compilador, aqui o <tt/g++/ para compilar o ficheiro de código <tt/kscribbleview.cpp/. A macro <tt/-DHAVE_CONFIG_H/ diz que o ficheiro
<tt/config.h/ deverá ser utilizado. Este é um ficheiro que contém macros para a plataforma e aplicação específicas e está localizado no
directório principal do projecto. Os comandos <tt/-I/ seguintes adicionam o caminho include onde o <tt/g++/ pode encontrar os includes de que necessita. O caminho é o
directório corrente, o directório principal do projecto (através de <tt/-I../) e o caminho include para o KDE, <idx/Qt/ e ficheiros header da biblioteca X11. Os
directórios para estes ficheiros include foram determinados pelo script <tt/configure/ e definidos nos Makefiles, pelo que, o compilador
sabe onde estes se encontram. Finalmente, <tt/-O0/ define a optimização para zero (sem optimização), <tt/-g/ permite a depuração, <tt/-Wall/
define os avisos do compilador para <tt/todos/ e <tt/-c/ diz ao compilador para produzir um ficheiro de objecto, ou seja apenas compilar o ficheiro.

Isto é feito também para os outros ficheiros de código do nosso projecto nas linhas 13-15. Obviamente, o nosso código é compilado, mas em vez de
ligar os ficheiros objecto do código ao binário final, nós vemos alguns outros comandos. Na linha 16, você vê que o programa "moc" é
chamado para processar o ficheiro header <tt/kscribble.h/, com o seu resultado em <tt/kscribble.moc.cpp/. Depois, na linha 17, este ficheiro de código é
também compilado. O mesmo acontece com os outros ficheiros header do projecto até à linha 21. Agora, como o conjunto de ferramentas <idx/Qt/ contém o mecanismo
sinal/espaço, mas continua a ser uma implementação C++, você está a utilizar algumas palavras-chave que não são originalmente linguagem C++, tais como
as declarações <tt/signals:/ e <tt/slots:/ nas suas classes. Isto dá-lhe a possibilidade de permitir facilmente comunicação entre objectos para todas
as classes de objectos que herdem a classe <tt/QObject/, pelo que pode evitar os normais ponteiros para funções de chamada (callback). Assim, a aplicação
necessita do código que implementa esta funcionalidade, e é por isto que o <tt/moc/ é chamado. <tt/Moc/ é o Compilador de Objectos Meta (Meta Object Compiler) do conjunto de
ferramentas <idx/Qt/ e constroi a implementação para mecanismos de sinais e espaços percorrendo os ficheiros header e produzindo um código de resultado que
tem de ser compilado no binário. Como os projectos do KDevelop utilizam o <tt/automoc/ para determinar, que ficheiro header necessita de ser processado, você
não tem de se preocupar com nenhuma chamada ao <tt/moc/ nem com o compilador C++ no ficheiro moc de resultado. Lembre-se apenas da regra que faz uma
classe utilizar os sinais e espaços- hereditariedade da <tt/QObject/ ou qualquer classe que herde em si a <tt/QObject/, inclusão da
macro <tt/Q_OBJECT/ (sem ponto e vírgula !) no início da declaração de classe e a declaração para os sinais e espaços.

Finalmente, o seu binário é construido pelo compilador. O binário de resultado é chamado <tt/kscribble/, o linkador inclui o caminho para as bibliotecas
KDE e X11 e liga o código contra as bibliotecas <tt/kfile, kfm, kdeui, kdecore, qt, Xext/ e <tt/X11/. Depois tudo está feito e
o make termina.

<sect>O Esqueleto de Código
<p>

Para obter um conceito de como uma aplicação KDE funciona, teremos primeiro que olhar muito atentamente para o esqueleto de código já disponibilizado pelo
Assistente de Aplicação. Como nós já vimos, temos um conjunto de ficheiros de código e header que constroem o código inicial para a aplicação
e a tornam pronta-a-correr. Assim, a maneira mais fácil de explicar o código é seguir a implementação linha a linha como é
processado durante a execução do programa até entrar no ciclo principal de evento e está pronto a receber interacção do utilizador. Depois, iremos observar a
functionalidade que permite a interacção do utilizador e como certas coisas funcionam. Esta é provavelmente a melhor forma de explicar o esqueleto
e, como é similar a quase todas as <idx/aplicações KDE/, irá permitir-lhe ler também o código fonte de outros projectos; adicionalmente,
você saberá aqui onde alterar que parte do código para fazer com que as suas aplicações se comportem da forma para que foram desenhadas.

<sect1>A Função <tt/main()/<label id="The main() Function">
<p>
Como a aplicação inicia a sua execução entrando na função <tt/main()/, este será o ponto de partida do nosso exame ao código. A
função <tt/main()/ do <em/KScribble/ é implementada no ficheiro <tt/main.cpp/ e pode também ser encontrada utilizando o Navegador de Classes
seleccionando a pasta "Globais", sub-pasta "Funções":

<tscreen><code>
1  #include "kscribble.h"
2
3  int main(int argc, char* argv[]) {
4    KApplication app(argc,argv,"KScribble");
5
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
10   else
11   {
12      KScribbleApp* kscribble = new KScribbleApp;
13      kscribble->show();
14      if(argc > 1){
15        kscribble->openFile(argv[1]);
16      }
17    }
18    return app.exec();
19  }
</code></tscreen>

Agora, o que acontece primeiro é a normal criação do objecto <tt/<cdx/KApplication//, que obtém o nome da nossa aplicação <em/KScribble/ como terceiro
parâmetro. Quando se cria um novo <tt/<cdx/KApplication//, uma nova instância de <tt/<cdx/KConfig// é criada também que é conectada ao ficheiro de
configuração em $HOME/.kde/share/config/appname + rc que guarda toda a informação que queremos utilizar quando iniciamos janelas da aplicação. O nome que
passamos ao construtor de <tt/app/ será utilizado como o título da janela mais tarde.

Apesar do código de exemplo para tornar a primeira aplicação <idx/Qt/ numa KDE, o código seguinte é ligeiramente diferente. Após o
objecto <tt/<cdx/KApplication// estar presente, nós testamos se a aplicação é iniciada através do gestor de sessões do <tt/kwm/ ou manualmente através
do utilizador. Isto pode ser descoberto quando se chama <tt/isRestored()/ no objecto <tt/app/, que retorna <tt/true (verdade)/ para gestão de sessão
e <tt/false (falso)/ para um início normal.

Como a gestão de sessão é uma característica principal das <idx/aplicações KDE/ e vastamente utilizada pelo esqueleto mas com muito mais para explicar, nós vamos
seguir a secção <tt/else{}/ primeiro; depois voltaremos e explicaremos a funcionalidade de sessão num passo seguinte.

<sect1>Aplicação Iniciada pelo Utilizador
<p>
A secção <tt/else{}/ agora cria uma instância da classe <tt/KScribbleApp/ na linha 12. Este objecto é chamado para se mostrar a sí próprio na linha
13 como normal; a linha 14 determina se um argumento de linha de comando foi passado e, como isto é normalmente o nome de um ficheiro, chama o
objecto <tt/kscribble/ para o abrir com <tt/openFile()/.

Note que nós não chamamos o método <tt/setTopWidget(kscribble)/ para a nossa aplicação- isto já foi feito pela classe que o <tt/KScribbleApp/
herda. Agora vamos observar o nosso objecto <tt/KScribbleApp/- o que é e o que é que já disponibiliza? A única coisa que nós sabemos
até agora é que tem de ser um Widget para representar o interface do utilizador na janela principal. Vamos ver a implementação da classe de
<tt/KScribbleApp/, que pode ser encontrada no ficheiro <tt/kscribble.cpp/ ou através de um clique no icon da classe no Navegador de Classes. Como a
instância é criada pelo construtor.
Primeiro que tudo, vemos que herda a classe <tt/<cdx/KTMainWindow//, que é parte da biblioteca <tt/kdeui/. Esta classe em sí
herda <tt/<cdx/QWidget//, pelo que, como normal, nós temos um widget normal como sendo a janela de topo. O <tt/<cdx/KTMainWindow// contém imensas functionalidades
de que a classe <tt/KScribbleApp/ tira proveito. Disponibiliza barras de menu, <idx/ferramentas/, estados e suporte para gestão de sessões. A única coisa
que temos que fazer quando a criar sub-classes da <tt/<cdx/KTMainWindow// é criar todos os objectos de que necessitamos e criar outro widget que é gerido pela
instância <tt/<cdx/KTMainWindow// como a vista principal no centro da janela; normalmente este é o local onde o utilizador trabalha tal como
numa vista de edição de texto.

<sect2>O Construtor
<p>
Vamos observar o código para o construtor e ver como a instância é criada:

<tscreen><code>
1   KScribbleApp::KScribbleApp()
2   {
3     config=kapp->getConfig();
4	
5
6     ///////////////////////////////////////////////////////////////////
7     // chama inits para invocar todas as outras partes de construção
8     initMenuBar();
9     initToolBar();
10    initStatusBar();
11    initKeyAccel();
12    initDocument();
13    initView();
14
15    readOptions();
16
17    ///////////////////////////////////////////////////////////////////
18    // desactiva itens de menu e barra de ferramentas no arranque
19    disableCommand(ID_FILE_SAVE);
20    disableCommand(ID_FILE_SAVE_AS);
21    disableCommand(ID_FILE_PRINT);
22
23    disableCommand(ID_EDIT_CUT);
24    disableCommand(ID_EDIT_COPY);
25    disableCommand(ID_EDIT_PASTE);
26  }
</code></tscreen>

Nós vemos que a nossa instância de configuração do <tt/<cdx/KConfig// aponta agora para a configuração da aplicação, pelo que podemos operar
mais tarde com as entradas de configuração do ficheiro.

Depois, todas as partes da aplicação que são necessárias são criadas pela sua correspondente função membro que é especificada na nossa janela
principal:

<itemize>
<item><bf/initMenuBar():/  constroi a barra de menu,
<item><bf/initToolBar():/  constroi a barra de <idx/ferramentas/,
<item><bf/initStatusBar():/ cria a barra de estados,
<item><bf/initKeyAccel():/  define todos os atalhos de teclado<nidx/accelerator/ para a nossa aplicação através da configuração de teclado global e específica
da aplicação
<item><bf/initDocument():/ cria o objecto documento para a janela da aplicação
<item><bf/initView():/      cria o widget principal para a nossa vista dentro da janela principal
<item><bf/readOptions():/  lê todas as definições específicas da aplicação a partir do ficheiro de configuração e inicializa o resto da
aplicação tal como a lista de ficheiros recentes, as posições das barras e tamanho da janela.
</itemize>

Finalmente, nós desactivamos alguns comandos que o utilizador pode realizar, porque não podem estar disponíveis no estado actual da aplicação.
Como temos agora uma visão genérica de como a janela da aplicação é criada, iremos olhar para os detalhes de como os elementos do utilizador são
construidos seguindo os métodos acima.

<sect2>A Barra de Menu
<p>
Como mostrado acima, a barra de menu do <em/KScribble/ é criada pelo método <tt/initMenuBar()/. Aí, nós criamos um conjunto de
<tt/<cdx/QPopupMenu//s que surgem quando o utilizador selecciona uma entrada de menu. Depois, nós inserimo-las na barra de menu e conectamo-las com as entradas.

Primeiro, nós criamos o nosso <tt/recent_file_menu/, que irá conter os nomes dos últimos 5 ficheiros abertos. Temos de fazer isto primeiro, porque
esta entrada de menu é inserida no <tt/file_menu/. Quando adicionamos a conecção directamente- apenas obtemos o sinal que é emitido pela
entrada de menu com o seu número de entrada e chamamos a <tt/slotFileOpenRecent( int )/, que então chama o ficheiro correcto a partir da lista de ficheiros recentes
para ser aberto.

Depois criamos o nosso menu "Ficheiro". Este será o menu que irá ser visível na barra de menu. As acções standard são então inseridas no
menu de popup uma a uma- primeiro os comandos para criar um novo ficheiro, abrir um ficheiro, fechar um ficheiro etc., finalmente "S&amp;ir" para fechar a
aplicação. Todas as entradas de menu têm de ser criadas na ordem em que surgem mais tarde, pelo que temos de manter um olho no que queremos ter
em que lugar. Como um exemplo, nós olhamos para as seguintes entradas:

<tscreen><verb>
file_menu->insertItem(Icon("fileopen.xpm"), i18n("&amp;Open..."), ID_FILE_OPEN );
file_menu->insertItem(i18n("Open &amp;recent"), recent_files_menu, ID_FILE_OPEN_RECENT );
</verb></tscreen>

A primeira insere a entrada "Abrir...". Como nós queremos te-la como um icon, nós utilizamos o método <tt/insertItem()/ com o nome do
icon. Para entender o processo de leitura do icon, nós necessitamos de saber o que ou onde <tt/Icon()/ é declarada- de facto, é uma macro disponibilizada
pela classe <tt/<cdx/KApplication//:

<tscreen><verb>
#define Icon(x) kapp->getIconLoader()->loadIcon(x)
</verb></tscreen>
Adicionalmente, utiliza a seguinte macro internamente para obter acesso ao objecto da aplicação:
<tscreen><verb>
#define kapp KApplication::getKApplication()
</verb></tscreen>

Isto significa que o objecto <tt/<cdx/KApplication// já contém uma instância de um leitor de Icons- nós apenas temos de ter acesso a ela; depois irá ler
o icon correspondente. Como os nossos icons são todos das <idx/bibliotecas KDE/, nós não temos de nos preocupar com mais nada- eles são instalados no
sistema automaticamente, pelo que também não temos de os incluir no pacote da nossa aplicação para os utilizar.

Após o parâmetro do icon (que é opcional), nós inserimos o nome da entrada de menu através de <tt/i18n("&amp;Abrir...")/. Aí, nós temos de observar duas
coisas: primeiro, a entrada é inserida com o método <tt/i18n()/. Tal como a entrada <tt/Icon()/, é uma macro também definida em <tt/<cdx/kapp.h//
e chama o objecto <tt/KLocale/ da <tt/<cdx/KApplication// para traduzir a entrada para o idioma actualmente utilizado:

<tscreen><verb>
#define i18n(X) KApplication::getKApplication()->getLocale()->translate(X)
</verb></tscreen>

Chegando aqui, deverá ser mencionado que uma pessoa poderia pensar "Eu não quero utilizar macros"- você pode fazer isso a maior parte dos casos. Mas aqui é
imprescindível a utilização da <tt/i18n()/ porque para a internacionalização os ficheiros de idioma respectivos têm de ser construidos. Como este processo
de construção depende da string (conjunto de caracteres) <tt/i18n/, você tem de utilizar a macro.

Como já deve ter adivinhado, o & (i comercial) dentro das entradas de menu é mais tarde interpretado como uma linha por baixo da letra seguinte na
entrada de menu. isto permite um acesso rápido ao comando de menu através do teclado quando o utilizador prime a tecla <tt/Alt/ em conjunto com a
letra sublinhada.

Finalmente, nós damos um ID (número identificativo) à entrada de menu, que é um número inteiro através do qual podemos encontrar a entrada mais tarde. Para
manter um controlo sobre os valores utilizados, estes são definidos através de macros e são coleccionados no ficheiro <tt/resource.h/ dentro do seu projecto. Por
consistência, estas macros são todas maiúsculas e começam por ID_, depois o nome do menu seguido pela entrada. Isto torna muito fácil
lembramo-nos do sentido de cada entrada em qualquer ponto do código, pelo que não temos de voltar à implementação da barra de menu de novo para
observar as entradas.

A segunda entrada de exemplo mostra outra variante do método <tt/insertItem()/. Aqui, nós acrescentamos o menu de popup recent_files_menu como
um item de menu. Isto significa, que a entrada mostra-se a sí própria com a string dada "Abrir recentes", seguida de uma seta para a direita. Na selecção, o
menu de popup de ficheiros recentes surge e o utilizador pode escolher o último ficheiro.

Por fim mas não menos importante existem muitas outras formas de inserir items de menu- o esqueleto de aplicação mantém isto o mais simples possível. Mais informação
pode ser obtida na documentação <idx/Qt/ sobre a classe <tt/<cdx/QMenuData//.

Agora, após termos criado os menus de popup <tt/file_menu, edit_menu/ e <tt/view_menu/, temos de incluir também um menu "Ajuda". Nós podiamos
fazer isto tal como os outros, mas a classe <tt/<cdx/KApplication// oferece um método mais rápido e agradável para cobrir isto:

<tscreen><verb>
help_menu = kapp->getHelpMenu(true, i18n("KScribble\n" VERSION ));
</verb></tscreen>

Isto é tudo o que temos de fazer para obter um menu de ajuda que contenha uma entrada para o conteudo da ajuda com o atalho<nidx/shortcuts/ de teclado F1, uma caixa-sobre
para a aplicação e uma caixa-sobre para o KDE (que pode ser desactivada chamando <tt/getHelpMenu(false,...);/). O conteudo para a
caixa-sobre da nossa aplicação é definida de novo com a string <tt/i18n()/ - VERSION fica com a macro que é definida para a numeração de versão do projecto
no ficheiro <tt/config.h/, pelo que não temos de modificar isto manualmente de cada vez que queremos fazer uma nova distribuição. Esteja à vontade para
adicionar aqui qualquer informação sobre a sua aplicação, por ex. o seu nome, endereço email, copyright e afins.

Agora apenas temos de inserir os pop-ups na barra de menu. Como o <tt/<cdx/KTMainWindow// já constroi uma barra de menu para nós, nós apenas os inserimos
chamando <tt/menuBar()->insertItem();/.

O que resta fazer é conectar as entradas de menu com os métodos que irão executar. Assim, nós conectamos cada menu de popup através do seu
sinal <tt/activated( int )/ a um método <tt/commandCallback( int )/, que contém uma frase <tt/switch/ que chama o método correspondente
para as entradas de menu. Adicionalmente, nós conectamos os pop-ups através do seu sinal <tt/highlighted( int )/ para disponibilizar ajuda de barra de estados
para cada entrada. Sempre que o utilizador move o seu rato ou <idx/focus de teclado/ para uma entrada, a barra de estados mostra então a correspondente mensagem de ajuda.

Após termos terminado com a barra de menu, podemos continuar com a <idx/barra de ferramentas/ na secção seguinte. Lembre-se que uma instância de
<tt/<cdx/KTMainWindow// apenas pode ter uma barra de menu visível de cada vez; assim se deseja construir diversas barras de menu, você tem de cria-las
separadamente com instâncias de <tt/<cdx/KMenuBar// e definir uma delas através dos métodos correspondentes de <tt/<cdx/KTMainWindow// como sendo a barra
de menu actual. Veja a <idx/documentação de classes/ da <tt/<cdx/KMenuBar// para informação mais detalhada sobre como extender as características, veja também <ref
id="Configuring Menubars and Toolbars" name="Configurar Barras de Menu e Ferramentas">.

<sect2>A Barra de Ferramentas
<p>
A criação de barras de <idx/ferramenta/s é agora ainda mais simples que a das barras de menu. Como a <tt/<cdx/KTMainWindow// já disponibiliza barras de <idx/ferramenta/s, que são criadas
pela primeira inserção, você é livre de criar várias. Basta adicionar os botões para as funções que deseja disponibilizar:

<tscreen><verb>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</verb></tscreen>

Isto adiciona um botão alinhado à esquerda com o icon "filenew.xpm" com o respectivo ID para a barra de <idx/ferramentas/. O terceiro parâmetro decide se o
botão deverá estar activo ou não; por defeito nós definimos isto para <tt/true (verdade)/, porque o nosso método <tt/disableCommand()/ no final do
construtor faz isto por nós automaticamente tanto para as entradas do menu como da barra de <idx/ferramentas/. Finalmente, o último parâmetro é utilizado como uma
"Dica Rápida"- quando o utilizador move o ponteiro do rato sobre o botão de forma a ficar iluminado, uma pequena janela surge que contém uma
pequena mensagem de ajuda, cujo conteudo pode ser definido aqui.

Finalmente, todos os botões da <idx/barra de ferramentas/ estão conectados novamente ao nosso método  <tt/commandCallback()/ através do seu sinal <tt/clicked()/. Ao sinal
<tt/pressed()/, nós permitimos ao utilizador receber a mensagem de ajuda correspondente na barra de estados.

<bf/Informação Adicional:/

Como as <idx/barras de ferramentas/ são criadas utilizando a classe <tt/<cdx/KToolBar//, você deverá ler a respectiva documentação. Com a
<tt/<cdx/KToolBar//, imensas coisas necessárias na <idx/barra de ferramentas/ podem ser realizadas tais como pop-ups demorados se o seu botão deseja fazer surgir um menu
quando o botão é mantido premido ou até mesmo widgets como caixas de escolha. Também, por defeito, a <idx/barra de ferramentas/ preenche a largura total da
janela, o que a faz ter um aspecto melhor utilizando apenas uma barra. Quando se usa mais do que uma, você deverá também pensar na hipótese de definir o tamanho da
barra para terminar a seguir ao botão mais à direita, para que outras barras possam ser apresentadas na mesma linha por baixo da barra de menu. Iremos discutir algumas
tecnicas sobre desing e extensão de <idx/barras de ferramentas/ na secção <ref id="Configuring Menubars and Toolbars" name="Configurar
Barras de Menu e Ferramentas">.

<sect2>A Barra de Estados
<p>
A barra de estados é, bem como as outras barras, já disponibilizada pela instância <tt/<cdx/KTMainWindow//, pelo que apenas temos de inserir os nossos itens
como quisermos. Por defeito, o esqueleto contém apenas uma entrada que mostra a ajuda de barra de estados. Para muitas aplicações isto pode não
chegar; então você inserirá as entradas que necessite para mostrar por ex. coordenadas e afins.

Também, uma aplicação pode apenas ter uma barra de estados de cada vez como as barras de menu. Se desejar construir várias, deverá cria-las
separadamente e definir a barra corrente através do método correspondente da <tt/<cdx/KTMainWindow//. A barra de estados também permite inserir widgets,
que podem ser utilizador para produzir bons hábitos de apresentar barras de progresso como o KDevelop faz. Verifique a <idx/documentação de classes/ da
<tt/KStatusBar/.

<sect2>Atalhos de Teclado
<p>
Ao atingir o método <tt/initKeyAccel()/, já construimos os itens standard da janela principal de uma aplicação- as barras de menu,
<idx/ferramentas/ e estados. Na verdade, não definimos nenhuns <nidx/atalhos/ de teclado através dos quais utilizadores avançados que apenas queiram
trabalhar com o teclado possam aceder rapidamente a certos comandos que são utilizados mais frequentemente durante a utilização do programa. Para o fazer, nós
podiamos ter inserido as teclas de <nidx/atalhos/ na inserção dos itens de menu por exemplo, mas o KDE oferece uma boa
solução para construir e manter <nidx/atalhos/ de teclado. Imensos utilizadores querem te-los configuráveis por um lado
e por outro os <nidx/atalhos/ standard deverão ser os mesmos em todas as aplicações. Assim, o Centro de Controlo do KDE
permite configurar <nidx/atalhos/ de teclado standard globalmente através da utilização da classe <tt/<cdx/KAccel//. Adicionalmente, as
<idx/bibliotecas KDE/ contêm um widget que permite aos utilizadores configurar <nidx/atalhos/ de teclado específicos da aplicação facilmente. Como o
esqueleto da aplicação apenas utiliza itens de menu que têm acções standard tais como "Novo" ou "Sair", estes são definidos pelo método
<tt/initKeyAccel()/. Acções standard apenas têm de ser conectadas, para os valores de teclado específicos da sua aplicação, têm de os inserir
primeiro especificando o nome do <nidx/atalho/ de teclado e depois conecta-lo. como os nossos <nidx/atalhos/ estão
todos presentes na barra de menu, temos de modificar os <nidx/atalhos/ para as entradas de popup. Finalmente chamamos
<tt/readSettings()/, que lê as definições correntes a partir da janela principal do KDE contendo as configurações de <nidx/atalhos/ standard,
e depois as definições de <nidx/atalhos/ específicos do ficheiro de configuração da aplicação. Quando
nós aprofundarmos mais o nosso projecto de exemplo, iremos também falar sobre como configurar os <nidx/atalhos/ específicos da nossa aplicação
através de um diálogo de configuração, veja <ref id="Configuring Menubars and Toolbars" name="Configurar Barras de Menu
e Ferramentas"> para essa parte do processo de desenvolvimento.

<sect2>O Modelo de Vista de Documento
<p>
As duas próximas chamadas de funções membros, <tt/initDocument()/ e <tt/initView()/, vão finalmente construir a parte que é suposto as
janelas da aplicação disponibilizarem ao utilizador: um interface para trabalhar com os dados que é suposto a aplicação manipular; e essa é também a
razão pela qual o esqueleto da aplicação contém três classes, uma classe <tt/*App/, <tt/*View/ e <tt/*Doc/. Para entender, porque esta
estrutura é útil, iremos olhar um pouco à margem do código e introduzir alguma teoria, depois voltaremos ao programa de novo para ver
como o esqueleto feito pelo KDevelop suporta esse modelo.

Basicamente, tudo o que tem sido explicado até agora sobre a estrutura é que necessitamos de uma instância de aplicação que contenha a janela principal. Esta
janela é responsável por disponibilizar o interface basico para o utilizador- contém as barras de menu, <idx/ferramentas/ e estados e o controlo
de eventos para a interacção do utilizador. Também, contém uma área, que é descrita como uma "vista". Agora, o objecto da visra é genericamente,
mostrar os dados que o utilizador pode manipular, por ex. uma parte de um ficheiro de texto. Apesar do ficheiro de texto ser provavelmente maior que a vista é
capaz de mostrar no ecrã, disponibiliza ao utilizador a possibilidade de ir para a parte que deseja ver (pelo que é uma vista), e aí o utilizador
pode modificar os dados do conteudo do ficheiro. Para dar ao programador uma maneira melhor de separar as partes da aplicação através do código, o
Modelo Vista-Documento foi inventado. Apesar de não ser um standard, disponibiliza uma estrutura de como uma aplicação deveria funcionar:

<itemize>
<item> A aplicação contém um objecto controlador,
<item> um objecto de Vista que mostra os dados com que o utilizador trabalha
<item> e um objecto Documento que contém na realidade os dados a serem manipulados.
</itemize>

De regresso ao exemplo de trabalhar com um ficheiro de texto- aí, este modelo iria funcionar de forma a que o Documento leria o conteudo do ficheiro e
disponibilizar os métodos para modificar os dados bem como para gravar o ficheiro de novo. A Vista então processa os eventos que o utilizador produz através do
teclado e rato e utiliza os métodos do objecto Documento para manipular os dados do documento.

Finalmente, o objecto controlador é responsável pela interacção do utilizador disponibilizando os objectos de Vista e de Documento bem como os
interfaces para enviar comandos tais como abrir e gravar. Adicionalmente, certos métodos do objecto Vista podem ser disponibilizados por comandos que
podem ser acedidos através de <nidx/atalhos/ de teclado ou pelo rato ou barras de menu e <idx/ferramentas/.

Este Modelo Vista Documento tem algumas vantagens- separa o código do programa de uma forma mais orientada por objectos e por isso oferece mais flexibilidade
em geral, por ex. o mesmo objecto documento poderia ser apresentadps por duas vistas ao mesmo tempo; quer através de uma nova vista numa nova janela ou através
de mosaico da janela corrente que contém dois objectos vista que constroem a região de vista da janela actual.

Agora, se você vem dos sistemas MS-Windows poderá teralguma experiência com isso- o MFC já disponibiliza um modelo de documento que está
pronto a utilizar. Para as aplicações KDE e <idx/Qt/, as coisas são ligeiramente diferentes. A <idx/Qt/ é um poderoso conjunto de ferramentas pois disponibiliza as classes
mais necessárias, widgets etc. Mas não existiu nenhuma intenção de tomar conta do modelo documento-vista, e como o KDE herda a <idx/Qt/,
também não existiram nenhumas tendências de introduzir este modelo. Isto de certa forma tem a sua justificação no facto de que normalmente as aplicações X
não funcionam com um MDI (Interface de Documento Multiplo). Cada janela principal é responsável pelos seus dados e isso reduz a necessidade de
um modelo de documento pelo facto de que métodos para trabalhar em documentos são sempre implícitos em widgets. A única excepção a isto actualmente é
o projecto <em/KOffice/ que tenciona disponibilizar um conjunto de aplicações de produtividade completo tais como um processador de texto, uma folha de cálculo etc.
Tecnicamente, isto é realizado com duas alterações à utilização normal da <idx/Qt/ e KDE:

<itemize>
<item>o KOffice utiliza KOM e a implementação gratuita de CORBA chamada MICO para comunicação de objectos,
<item>as aplicações KOffice utilizam o modelo documento-vista para permitir a todas as aplicações trabalhar com quaisquer objectos de dados do KOffice
</itemize>

Mas como o KDevelop actualmente se foca na utilização das actuasi bibliotecas do KDE 1.1.x e a <idx/Qt/ 1.4x, nós não podemos utilizar este modelo por defeito-
isto virá em distribuições futuras de um KDE 2, que irá (esperamos) conter duas modificações principais em relação à situação
actual:
<enum>
<item>um interface MDI para a <cdx/KTMainWindow/
<item>as bibliotecas KOM que disponibilizam um modelo de documento
</enum>

Assim, a forma actual para os programadores de aplicações pode ser ou implementarem todos os métodos de documentos necessários dentro da sua vista ou
tentarem reproduzir um modelo de documento por si. O KDevelop assim contém essa reprodução disponibilizando as classes necessárias e
os métodos básicos que são geralmente utilizados para o Modelo Documento-Vista com a estrutura de aplicações para <idx/Qt/ e KDE.

De regresso ao código, você pode agora imaginar o propósito dos dois métodos que mencionamos no início desta secção: as
funções <tt/initDocument()/ e <tt/initView()/. O <tt/initDocument()/ constroi o objecto documento que representa a
janela de dados da aplicação e inicializa atributos básicos tais como definir o bit de modificação que indica se os dados correntemente
em utilização foram modificados pelo utilizador. Depois, o método <tt/initView()/ constroi o widget <tt/*View/, conecta-o com o documento e
chama o método <tt/setView()/ de <tt/<cdx/KTMainWindow// para dizer à janela <tt/*App/ para utilizar o widget <tt/*View/ como a sua vista central.

Para o programador, é importante saber que durante o processo de desenvolvimento ele tem de:

<itemize>
<item>re-implementar os métodos virtuais para eventos de rato e teclado disponibilizados pela <tt/<cdx/QWidget// no objecto <tt/*View/ para disponibilizar
meios de manipular os dados,
<item>re-implementar o <tt/paintEvent()/ da <tt/<cdx/QWidget// no objecto <tt/*View/ para repaint() (re-desenhar) a cista após modificações,
<item>completar a implementação para imprimir o documento através do método de impressão do objecto <tt/*View/,
<item>adicionar a serialização para o objecto <tt/*Doc/ para disponibilizar abertura e gravação de ficheiros,
<item>adicionar a implementação da estrutura de dados do documento ao objecto <tt/*Doc/ que está a representar os dados do documento logicamente em
memória.
<item>adicionar quaiquer métodos que tenham de ser acessíveis pelo utilizador através de <nidx/atalhos/ de teclado e menus/barras de <idx/ferramentas/.
</itemize>


<sect2>Configuração da Aplicação
<p>
Agora, depois de termos criado todas as instâncias da instância <tt/<cdx/KTMainWindow// da nossa aplicação para criar a primeira janela, nós temos de
inicializar alguns valores que influenciam a aparência do programa. Para isto, chamamos <tt/readOptions()/, que obtém todos os valores e chama
os métodos necessários para definir os atributos correspondentes. A biblioteca KDE-Core contém a classe <tt/<cdx/KConfig// que disponibiliza uma boa
possibilidade de guardar valores em ficheiros de configuração bem como de os ler novamente. Também, como cada instância <tt/<cdx/KApplication//
já cria o seu ficheiro de recursos, apenas temos de aceder a este ficheiro e criar os nossos valores. Como o <tt/<cdx/KConfig// nos disponibiliza o objecto
de ficheiro, temos de utilizar a classe <tt/<cdx/KConfigBase// para ler e escrever todas as entradas. Como escreve-lo é muito fácil de fazer com
métodos <tt/writeEntry()/, ler depende do tipo de atributo que queremos inicializar. Geralmente, uma entrada no ficheiro de
configuração contém um nome de valor e o valor. Valores que pertençam conjuntamente num contexto podem ser coleccionados em grupos, pelo que temos de
definir o nome do grupo antes de acedermos ao seu valor; o grupo tem de ser definido apenas uma vez para ler um conjunto de atributos que estão no
mesmo grupo. Vamos observar o que queremos ler:

<tscreen><code>
1   void KScribbleApp::readOptions()
2   {
3
4      config->setGroup("General Options");
5
6      // bar status settings
7      bool bViewToolbar = config->readBoolEntry("Show Toolbar", true);
8      view_menu->setItemChecked(ID_VIEW_TOOLBAR, bViewToolbar);
9      if(!bViewToolbar)
10       enableToolBar(KToolBar::Hide);
11
12     bool bViewStatusbar = config->readBoolEntry("Show Statusbar", true);
13     view_menu->setItemChecked(ID_VIEW_STATUSBAR, bViewStatusbar);
14     if(!bViewStatusbar)
15       enableStatusBar(KStatusBar::Hide);
16
17     // bar position settings
18     KMenuBar::menuPosition menu_bar_pos;
19     menu_bar_pos=(KMenuBar::menuPosition)config->readNumEntry("MenuBar Position", KMenuBar::Top);
20
21     KToolBar::BarPosition tool_bar_pos;
22     tool_bar_pos=(KToolBar::BarPosition)config->readNumEntry("ToolBar Position", KToolBar::Top);
23
24     menuBar()->setMenuBarPos(menu_bar_pos);
25     toolBar()->setBarPos(tool_bar_pos);
26
27     // initialize the recent file list
28     recent_files.setAutoDelete(TRUE);
29     config->readListEntry("Recent Files",recent_files);
30
31     uint i;
32     for ( i =0 ; i < recent_files.count(); i++){
33       recent_files_menu->insertItem(recent_files.at(i));
34     }
35
36     QSize size=config->readSizeEntry("Geometry");
37     if(!size.isEmpty())
38       resize(size);
39   }
</code></tscreen>

Como vimos numa das partes de código acima, a primeira acção que o nosso construtor faz é:

<tscreen><verb>
config=kapp->getConfig();
</verb></tscreen>

que define o ponteiro <tt/config/ tipp <tt/<cdx/KConfig// para a configuração da aplicação. Assim, não temos de nos preocupar com a localização do
ficheiro de configuração. Na verdade, o ficheiro está, de acordo com o Standard de Sistema de Ficheiros KDE (KDE FSS), localizado em
<tt>&dollar;HOME/.kde/share/config/</tt>; iremos observar mais atentamente o KDE FSS num passo futuro quando estivermos a definir localizações de ficheiros
do projecto para instalação. Como o ficheiro de configuração é colocado no directório principal do utilizador, cada utilizador tem a sua aparência personalizada
da aplicação excepto para valores que estão localizados num ficheiro de configuração para todo o sistema que pode ser criado opcionalmente e instalado pelo
programador no directório do KDE. Mas, apesar de isto poder ajudar nalguns casos, devemos evitar quaiquer dependências da nossa aplicação no sentido
da existência de entradas de ficheiro. Assim, todos os métodos de leitura disponibilizados pelo <tt/<cdx/KConfigBase// permitem adicionar um valor de defeito a ser
utilizado quando a entrada não existe. Outra coisa importante para um programador é que o ficheiro de configuração é guardado em texto simples, e isto
é também por algumas razões pois tem de ter em atenção alguns critérios:

<itemize>
<item>o utilizador pode modificar o ficheiro de configuração através de um simples editor de texto
<item>se o utilizador quiser modificar valores manualmente, as entradas deverão ser muito transparentes para determinar o seu propósito
<item>para entradas que tenham de ser gravadas, mas são criticas em termos de segurança tal como chaves de acesso, você tem de procurar uma solução adequada
para assegurar a segurança.
</itemize>

Agora que sabemos os básicos, vamos analizar o código. Como dissemos, apenas temos de utilizar o nosso ponteiro config para aceder aos valores.
Primeiro, na linha 4, nós definimos o grupo actual para "Opções Gerais". Isto indica que os valores estão de certo modo atributos gerais
para a aplicação. Depois nós lemos os valores para a barra de <idx/ferramentas/ e estados- estes têm de ser gravados quando a aplicação fecha para
repor os seus estadps de novo quando o utilizador reiniciar o programa. Como as barras apenas podem estar ligadas ou desligadas, nós utilizamos um valor boolean, pelo que,
o nosso método é <tt/readBoolEntry()/. O processo é idêntico para ambas as barras, pelo que apenas temos de olhar para as linhas 7-10 para observar o que está
a acontecer para a barra de <idx/ferramentas/. Primeiro, nós lemos o valor para uma variável temporária <tt/bViewToolbar/ na linha 7. O nome do valor no
ficheiro é "Mostrar Barra de Ferramentas" e, se o valor não estiver presente (o que seria o caso na primeira vez que a aplicação iniciasse), o
valor de defeito é definido para <tt/true (verdade)/. De seguida, nos definimos a marca de verificação da entrada de menu para (des)activar a barra de <idx/ferramentas/ através deste valor:
nós chamamos <tt/setItemChecked()/ no menu ver, entrada <tt/ID_VIEW_TOOLBAR/ com o nosso atributo. Finalmente, definimos a barra de <idx/ferramentas/ para utilizar
o valor. Por defeito, a barra de <idx/ferramentas/ é visível, pelo que, apenas temos de fazer algo se <tt/bViewToolbar/ for <tt/false (falso)/. Com
<tt/enableToolBar()/ (linha 10) estamos a definir a barra para se esconder automaticamente se for desactivada.

De seguida, temos de ler as posições da barra. Como o utilizador pode ter modificado a posição da barra arrastando-a com o rato para outra
área de cista, esta tem de ser gravada também e o seu estado reposto. Olhando para as classes <tt/<cdx/KToolBar// e
<tt/<cdx/KMenuBar//, vemos que as posições da barra podem ser:

<tscreen><verb>
enum BarPosition {Top, Left, Bottom, Right, Floating, Flat}
/* {Topo, Esquerda, Baixo, Direita, Flutuante, Fixa} */
</verb></tscreen>

Como este valor foi escrito num valor numérico, temos de o ler com <tt/readNumEntry()/ e converte-lo num valor de posição. Com
<tt/setMenuBarPos()/ e <tt/setBarPos()/ dizemos às barrass ode aparecerem.

Agora provavelmente notou que o nosso menu "Ficheiro" contém um menu para ficheiros utilizados recentemente. Os nomes de ficheiros são guardados numa lista de
strings (conjunto de caracteres), que tem de ser gravado ao fecho da aplicação e agora tem de ser lido para repor o menu. Primeiro, inicializamos a lista com
as entradas guardadas utilizando o <tt/readListEntry()/. Depois, num ciclo <tt/for/, criamos uma entrada de menu para cada item da lista.

Finalmente, apenas temos de tomar conta da geometria da nossa janela. Nós lemos na aparência através de uma variável <tt/QSize/ contendo um valor x
e y para o comprimento e altura da janela. Como a janela é inicializada através da <tt/<cdx/KTMainWindow//, não temos de nos preocupar com o
valor de defeito e apenas utilizamos <tt/resize()/ se a entrada não estiver vazia.

O que resta explicar na construção da nossa aplicação é que inicialmente temos de desactivar comandos do utilizador disponíveis que o não podem estar
no caso de algumas instâncias não corresponderem aos critérios necessários. Estes são gravação de ficheiros e operações que utilizem a área de transferência. Durante
o tempo de vida da aplicação, temos de tomar conta destes várias vezes, mas isso é bastante fácil. A estrutura apenas nos dá dois
métodos para (des)activar itens de barras de menu e <idx/ferramentas/ com apenas uma chamada de método de cada vez.

<sect2>Executar
<p>
Durante a secção anterior, apenas veriicaos o que acontecia durante a chamada de construção da nossa instância do <tt/KScribbleApp/ que nos disponibiliza
a janela principal. Após regressar à função <tt/main()/, temos de chamar <tt/show()/ para mostrar a janela. O que é diferente de
qualquer <tt/<cdx/KApplication// ou <tt/<cdx/QApplication// aqui é que quando estamos a utilizar <tt/<cdx/KTMainWindow// como a instância para o nosso
widget principal, não temos de o definir com <tt/setMainWidget()/. isto é feito pelo próprio <tt/<cdx/KTMainWindow// e não temos de nos
preocupar com isso.
A única coisa que resta então é interpretar a linha de comandos. Obtemos a opção de linha de comandos e perguntamos, se <tt/int argc/ é > 1, o que
indica que o utilizador chamou a nossa aplicação com <tt/kscribble filename_to_open/. A nossa janela recebe então o pedido de abertura do ficheiro pelo
se nome e chama <tt/openDocumentFile()/ com o nome do ficheiro.

A última linha da função <tt/main()/ faz o trabalho conhecido: executa a instância da aplicação e o programa entra no ciclo de
evento.

Agora, na secção <ref id="The main() Function" name="A Função main()">, nós começamos a separar o processo de execução através de
<tt/if( app.isRestored() )/ e descrevemos o processo normal de invocação. De seguida daremos uma introdução à gestão de
sessão e como a nossa aplicação a utiliza.

<sect1>Invocação por Gestão de Sessão
<p>
Como dissemos, a função <tt/main()/ testa, se a aplicação foi invocada pelo gostor de sessão. O gestor de sessão é responsável por
gravar o estado actual de todas as janelas de aplicação abertas no ambiente de trabalho do utilizador e tem de os repor quando o utilizador entrar da próxima
vez, o que significa que a aplicação não é iniciada pelo utilizador mas invocada automaticamente. A parte do código executado
foi:
<tscreen><verb>
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
</verb></tscreen>

Em <ref id="The main() Function" name="A Função main()">, nós afirmamos que nós testamos a invocação perguntando à
<tt/app.isRestored()/. Depois a linha 8 é executada. Parece uma afirmação simples, mas de facto irá resultar num processo de execução
complexo que queremos seguir nesta secção.

A própria RESTORE() é uma macro disponibilizada pela <tt/<cdx/KTMainWindow//. Expande-se para o seguinte código:

<tscreen><verb>
if (app.isRestored()){
  int n = 1;
  while (KTMainWindow::canBeRestored(n)){
    (new KScribbleApp)->restore(n);
    n++;
  }
}
</verb></tscreen>

Isto irá repor todas as janelas de aplicação da classe <tt/KScribbleApp/ criando as instâncias e chamando <tt/restore()/ para a
nova janela. É importante compreender que se a nossa aplicação utiliza vários widgets diferentes que herdam <tt/<cdx/KTMainWindow//, você tem de
expandir a macro e determinar o tipo de widgets de topo utilizando <tt/<cdx/KTMainWindow/::classNameOfToplevel(n)/ em vez da classe
<tt/KScribbleApp/.
O método <tt/restore()/ lê então a parte do ficheiro de sessão que contém a informação sobre a janela. Como a <tt/<cdx/KTMainWindow//
guarda tudo isto por nós, não temos de nos preocupar com mais nada. Apenas informação que pertence à nossa instância específica do
<tt/KScribbleApp/ tem de ser então encontrada. Normalmente isto seria um ficheiro temporário que foi criado para guardar o documento ou outra
initialização de que poderiamos necessitar. Para obter esta informação de reposição, nós apenas temos de passar por cima de dois métodos virtuais de
<tt/<cdx/KTMainWindow//, <tt/saveProperties()/ e <tt/readProperties()/. A informação que temos de gravar no final da sessão é se o documento
correntemente aberto está ou não modificado e o nome do ficheiro. Se o ficheiro estiver modificado, obteremos um nome de ficheiro temporário para o gravar. No
início da sessão, esta informação é agora utilizada para repor o conteudo do documento:

<tscreen><verb>
void KScribbleApp::readProperties(KConfig*)
{
  QString filename = config->readEntry("filename","");
  bool modified = config->readBoolEntry("modified",false);
  if( modified ){
    bool b_canRecover;
    QString tempname = kapp->checkRecoverFile(filename,b_canRecover);

    if(b_canRecover){
      doc->openDocument(tempname);
      doc->setModified();
      QFileInfo info(filename);
      doc->pathName(info.absFilePath());
      doc->title(info.fileName());
      QFile::remove(tempname);
    }
  }
  else if(!filename.isEmpty()){
  doc->openDocument(filename);
  }
  setCaption(kapp->appName()+": "+doc->getTitle());
}		
</verb></tscreen>
Aqui, a linha <tt/kapp->checkRecoverFile()/ parece um pouco estranha, pois o <tt/b_canRecover/ não está inicializado. Isto é feito pelo método
que o define para <tt/true/, se existir um ficheiro de reposição. Como apenas gravamos um documento num ficheiro de recuperação se foi modificado, definimos o
bit de modificado directamente para indicar que a informação não foi gravada para o ficheiro correspondente. Também temos de ter em conta que
o ficheiro de recuperação tem outro nome de ficheiro diferente do ficheiro original que foi aberto. Assim, temos de colocar o nome de ficheiro e caminho do antigo
nome de ficheiro. Finalmente, temos a informação que queriamos recuperar e podemos apagar o ficheiro temporário através do gestor de sessão.

<bf/Sumário:/

Durante este capítulo, ficou a saber como a aplicação se inicia quer por invocação normal do utilizador ou pelo gestor de sessão. Verificamos
todo o código para aprender como as partes do interface visual da aplicação são construidas bem como inicializar os
atributos através de entradas em ficheiros de configuração. Agora podemos executar a aplicação esqueleto para testar estas funções e ver como a
janela do programa reage.

<sect>Conteudos Adicionais de Projectos KDevelop
<p>
Além do código fonte disponibilizado, os projectos KDevelop contêm imensas outras partes adicionais que são do interesse do programador. Estas
são:
<itemize>
<item>um icon de programa
<item>um mini-icon de programa
<item>um ficheiro <idx/.kdelnk/
<item>um ficheiro de documentação <idx/SGML/ de exemplo
<item>um conjunto de documentação <idx/API/ gerada a partir do código do esqueleto
</itemize>

Excepto a documentação <idx/API/, estes elementos do projecto serão instalados juntamente com o binário da aplicação. Como o esqueleto do
projecto tem de ser o mais aberto possível, tem de adaptar estas partes no sentido dos objectivos do seu projecto. Estas são primeiro editar os icons
disponibilizados. Isto dará à sua aplicação um identificador único através do qual o utilizador pode determinar a sua aplicação visualmente em menus de
gestão de janelas. O ficheiro <idx/.kdelnk/ é um ficheiro que instala a sua aplicação no <tt/kpanel/ no menu <tt/Aplicações/. Este tem
de ser editado definindo o caminho de instalação que será discutido mais tarde neste manual. Finalmente, a documentação que você irá
disponibilizar ao utilizador está escrita em <idx/SGML/. Isto torna muito fácil criar várias apresentações diferentes para a mesma fonte. Por defeito,
o KDevelop pode criar um conjunto de ficheiros HTML a partir desta fonte, para projectos KDE isto irá automaticamente utilizar o programa <tt/<idx/ksgml2html//
para adicionar uma aparência e utilização consistente tipo KDE à documentação. Numa secção posterior, iremos ver como a fonte <idx/SGML/ é editada e
o que temos de observar na instalação no utilizador final.

Finalmente, a documentação <idx/API/ (Interface de Programação da Aplicação) permite-lhe e a outros programadores entender rapidamente o código e utilizar as
classes sem terem de adivinhar qual o objectivo de cada classe. Iremos aprender como expandir a documentação <idx/API/ num passo posterior,
por ora basta saber que a documentação é gerada pelo programa <tt/<idx/KDoc//, que processa os ficheiros de cabeçalho e cria o
resultado final em HTML, pelo que toda a documentação é colocada nos cabeçalhos.

<chapt>Desenho de Vista de Aplicação
<p>
Quando se está a desenvolver uma aplicação com um interface gráfico de utilização, o trabalho principal é feito a disponibilizar a chamada "vista" para a
aplicação. A vista geralmente é um widget que apresenta os dados de um documento e disponibiliza métodos para manipular o conteudo do
documento. Isto pode ser feito pelo utilizador através de eventos que emite pelo teclado ou rato; operações mais complexas são muitas vezes
processadas pelas barras de <idx/ferramentas/ e menus que interagem com a vista e o documento. A barra de estados apresenta informação sobre o estado
do documento, vista ou aplicação. Como exemplo, olhamos para como um editor está construido e onde podemos encontrar cada parte.

Um editor é suposto geralmente disponibilizar um interface para o utilizador ver e/ou modificar o conteudo de um documento de texto. Se você
iniciar o <em/KEdit/, vê o interface visual da seguinte forma:

<itemize>
<item>A barra de menu: disponibiliza operações complexas bem como abrir, gravar e fechar ficheiros e sair da aplicação.
<item>A barra de <idx/ferramentas/: oferece icons que permitem um acesso rápido para as funções mais necessárias,
<item>A barra de estados: apresenta o estado da posição do cursor através da linha e coluna actuais,
<item>A vista no centro da janela, apresentando um documento e oferecendo um cursor conectado ao teclado e rato
para trabalhar sobre os dados.
</itemize>

Agora é fácil compreender, que uma vista é uma parte única da aplicação e que o desenho da vista decide sobre a
usabilidade e aceitação de uma aplicação. Isto significa que um dos primeiros passos no desenvolvimento é determinar o objectivo da
aplicação e que tipo de desenho lhe iria mais de encontro para permitir a qualquer utilizador trabalhar com a aplicação com um mínimo de
trabalho de aprendizagem de como utilizar o interface gráfico.

Para alguns objectivos como edição de texto e apresentação de ficheiros HTML, as vistas são disponibilizadas pelas bibliotecas <idx/Qt/ e <idx/KDE/; iremos discutir alguns
aspectos destes widgets de alto-nível na próxima secção. Mas para a maioria das aplicações novos widgets têm de ser desenhados e implementados. É
isso que faz um programador e também um desenhador e onde as suas capacidades em criatividade são necessárias. De qualquer modo, deverá procurar a
intuição primeiro. Lembre-se que imensos utilizadores não aceitarão uma aplicação que não seja

<itemize>
<item>bonita graficamente,
<item>oferece imensas funcionalidades,
<item>fácil de utilizar,
<item>rápida de aprender como utilizar.
</itemize>
Desnecessário dizer que a estabilidade é um dos objectivos principais. Ninguém pode impedir erros de código, mas um mínimo pode ser atingido pelo menos por objectivos de desenho
inteligentes e a utilização de desenho orientado por objectos. C++ torna a programação um prazer se você souber como explorar as suas capacidades- hereditariedade,
ocultação de informação e reutilização de código já existente.

Quando se cria um projecto KDE ou <idx/Qt/, você tem sempre de ter uma vista que herda <tt/<cdx/QWidget//, quer por herança directa ou porque
a biblioteca do widget que quer utilizar herda <tt/<cdx/QWidget//. Assim, o Assistente de Aplicação já constroi a vista que é uma
instância da classe <tt/&lt;yourapp&gt;View/, que já herda <tt/<cdx/QWidget//. A aplicação cria a sua vista no método
<tt/initView()/, onde uma instãncia é criada e conectada com o widget principal como sua vista com  <tt/KTMainWidget::setView()/.

Este capítulo descreve assim como utilizar bibliotecas de widgets para criar vistas de aplicações KDE ou <idx/Qt/ que são geradas com o
KDevelop, depois iremos observar as bibliotecas e que tipos de vistas são já oferecidas.

<sect>Utilizar Bibliotecas de Vistas
<p>
Quando o desenho da sua aplicação estiver definido, você deverá primeiro procurar código já existente que fará a sua vida muito mais simples. Uma
parte desta busca é a procura de um widget que possa ser utilizado como vista ou pelo menos parte dela; quer directamente ou por hereditariedade.
As bibliotecas KDE e <idx/Qt/ já contêm um conjunto de widgets que podem ser utilizados para este propósito. Para os utilizar, você tem duas opções:

<enum>
<item> remover a nova classe de cista e criar uma instância de um widget de biblioteca; depois defini-lo como vista,
<item> modificar a hereditariedade da classe de vista disponibilizada para a classe do widget de biblioteca a utilizar.
</enum>

De qualquer uma das formas, é importante saber que se a estrutura de aplicação não está actualmente ligada a nenhuma biblioteca que contenha o
widget, o linker irá falhar. Depois de se decidir a utilizar um certo widget, procure a biblioteca a linkar; depois abra
"Projecto"->"Opções" na barra de menu do KDevelop. Vá para a página "Opções do Linker" e procure as caixas de selecção que indiquem as
bibliotecas que estão correntemente a serem utilizadas. Se a biblioteca do seu widget de vista já estiver seleccionada, pode deixar as opções do projecto intocadas
e começar a fazer as alterações necessárias devido à sua escolha. Caso contrário, a opção de linker permite adicionar a biblioteca através de uma caixa de selecção,
active-a e prima "OK" para sair de novo do diálogo de opções do projecto. Em qualquer outro caso, adicione a biblioteca na linha de edição por baixo da
opção <tt/-l/. Para bibliotecas que a sua aplicação tem de procurar antes de preparar os ficheiros Makefiles através do script <tt/configure/ na
máquina do utilizador final, adicione a seguinte macro de procura ao ficheiro <tt/configure.in/  localizado na raiz do directório do seu projecto e
adicione a macro à linha de edição. Lembre-se que tem de correr "Construir"->"Autoconf e automake" e "Construir"->"Configurar" antes
dos Makefiles conterem as expansões correctas para a macro de biblioteca.

Também, se os ficheiros inclued para a biblioteca a adicionar não estiverem no caminho actual de include (que pode ser visto pela opção <tt/-I/ na
janela de output ao fazer "Make"), tem de adicionar o caminho no diálogo de Opções de Projecto -página "Opções de Compilador" com a opção <tt/-I/
ou a correspondente macro de automake na linha de edição para "Opções Adicionais".

<sect1><idx/Qt/ Views
<p>
Looking at the first page of the <idx/Qt/ online documentation, you will find a link to "Widget Screenshots" where you can have a look at
how the widgets <idx/Qt/ contains look like. These are ready to use and can be combined together to form complex widgets to create
application views or dialogs. In the following, we'll discuss some of these which are very usable for creating application views, but
keep in mind that the <idx/KDE libraries/ sometimes contain other widgets for the same purpose; those will be reviewed in the next section.

Here are a set of hints for what purpose you could use which <idx/Qt/ component:
<enum>
<item>if your view area isn't big enough to display all your data, the user must be enabled to scroll over the document with bars on
the left and bottom of the view. For this, <idx/Qt/ provides the class <tt/QScrollView/, which offers a scrollable child area. As explained,
you could inherit your own widget from <tt/QScrollView/ or use an instance to manage your document's view widget.
<item>to create a ScrollView yourself, inherit the View widget from <tt/<cdx/QWidget// and add vertical and horizontal <tt/QScrollBar/s.
(this is done by KDE`s KHTMLView widget).
<item>for text processing, use <tt/QMultiLineEdit/. This class provides a complete text editor widget that is already capable to cut,
copy and paste text and is managed by a scrollview.
<item>use <tt/QTableView/ to display data that is arranged in a table. As <tt/QTableView/ is managed by scrollbars as well, it offers a
good solution for table calculation applications.
<item>to display two different widgets or two widget instances at the same time, use <tt/QSplitter/. This allows to tile views by
horizontal or vertical dividers. Netscape's Mail window is a good example how this would look like- the main view is separated by a
splitter vertically, the right window then is divided again horizontally.
<item><tt/QListView/ displays information in a list and tree. This is useful for creating file trees or any other hierarchical
information you want to interact with.
</enum>

You see that <idx/Qt/ alone offers a whole set of widgets which are ready to use so you don't have to invent new solutions if these match
your needs. The sideffect when using standard widgets is that users already know how to handle them and only have to concentrate on
the displayed data.

<sect1>KDE Views
<p>
The <idx/KDE libraries/ were invented to make designing applications for the K Desktop Environment easier and capable of more functionality
than what <idx/Qt/ alone is offering. To see what's available, we have a look at the documentation tree in KDevelop. You see that the KDE
libraries start with <tt/kdecore/, which is a base for all <idx/KDE applications/. Then,<tt/kdeui/ offers user interface elements. This is
where we will find some useful things first. For creating new applications, the <tt/kdeui/ library offers:

<enum>
<item><tt/<cdx/KTabListBox//: offers a multi-column list box where the user can change the rows with <idx/drag'n drop/.
<item><tt/<cdx/KTreeList//: inherited from <tt/<cdx/QTableView//, offering a collapsible tree. This could be used instead of
<tt/QListView/.
<item><tt/<cdx/KEdit//: the base classes for the <em/KEdit/ application offered with KDE. This could be used instead of
<tt/<cdx/QMultiLineEdit//.
<item><tt/<cdx/KNewPanner//: manage two child widgets like <tt/<cdx/QSplitter//.
</enum>

The <tt/khtmlw/ library on the other hand offers a complete HTML-interpreting widget that is ready to use. It is scrollable already,
so you don't even have to take care for that. A possible use could be to integrate it as a preview widget for an HTML editor; used by
applications such as KFM, <idx/KDEHelp/ and KDevelop to display HTML files.


<sect>Creating your own Views<label id="Creating your own Views">
<p>
Now that you have a general overview of what is already provided, you may notice that for a lot of purposes already existing widgets
can be used or combined together. KMail is an example as well as KDevelop itself makes use of library view components to display data.

For applications that use a special file format or have to deal with graphics, you are probably forced to create your own view widget
to allow data manipulation. This is realized in our sample by the class <tt/KScribbleView/, already providing a base for a view area.

The inheritance from <tt/<cdx/QWidget// is necessary to overwrite the virtual methods to process user events, this is probably the most work
besides providing popup menus for easier access of certain functions. Also it is likely that you have to implement a set of slots which
can be accessed by <idx/toolbar/ buttons or menu bar commands to connect to as well as methods to manipulate variables such as e.g. a painter
color.

For completeness, we will repeat the necessary methods:

<bf/a) Keyboard events --TAB and Shift-TAB keys:/

changes the keyboard input focus from the current widget to the next widget in the focus order. The focus can be set to widgets by
calling <tt/setFocusPolicy<ncdx/setFocusPolicy()/()/ and process the following event handlers:

<itemize>
<item><tt/virtual void focusInEvent<ncdx/focusInEvent()/ ( <cdx/QFocusEvent/ * )/
<item><tt/virtual void focusOutEvent<ncdx/focusOutEvent()/ ( <cdx/QFocusEvent/ * )/
</itemize>

<bf/b) all other keyboard input:/
<itemize>
<item><tt/virtual void keyPressEvent<ncdx/keyPressEvent()/ ( <cdx/QKeyEvent/ * )/
<item><tt/virtual void keyReleaseEvent<ncdx/keyReleaseEvent()/ ( <cdx/QKeyEvent/ * )/
</itemize>

<bf/c) mouse movements:/
<itemize>
<item><tt/virtual void mouseMoveEvent<ncdx// ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void enterEvent<ncdx/enterEvent()/ ( <cdx/QEvent/ * )/
<item><tt/virtual void leaveEvent<ncdx/leaveEvent()/ ( <cdx/QEvent/ * )/
</itemize>

<bf/d) mouse button actions:/
<itemize>
<item><tt/virtual void mousePressEvent<ncdx/mousePressEvent()/ ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseReleaseEvent<ncdx/mouseReleaseEvent()/ ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseDoubleClickEvent<ncdx/mouseDoubleClickEvent()/ ( <cdx/QMouseEvent/ * )/
</itemize>

<bf/e) window events containing the widget:/
<itemize>
<item><tt/virtual void moveEvent<ncdx/moveEvent()/ ( <cdx/QMoveEvent/ * )/
<item><tt/virtual void resizeEvent<ncdx/resizeEvent()/ ( <cdx/QResizeEvent/ * )/
<item><tt/virtual void closeEvent<ncdx/closeEvent()/ ( <cdx/QCloseEvent/ * )/
</itemize>

When re-implementing these functions, you should watch certain issues to avoid implementation mistakes that will make it almost
impossible to change the widget's behavior afterwards:

<enum>
<item>declare your virtual methods as <bf/virtual/ as well and keep the access to protected. This allows code-reuse by inheritance and
is consistent.
<item>don't hard-code any event-processing which should be made configurable. This counts most for keyboard events which should be
realized with keyboard accelerator<nidx/accelerator/s if any function is called. This even counts for text processing ! (Imagine that a lot of users are
familiar with their favorite editor's behavior. If this is configurable, they can use the behavior they like and are used to)
<item>forward popup menu highlighting signals to the main widget to enable statusbar help
</enum>

<chapt>Configuring Menubars and Toolbars<label id="Configuring Menubars and Toolbars">
<p>
Menubars and <idx/toolbar/s are one of the most important parts of an application to provide methods to work with a document structure. As a
general rule, you should make all functions available by the menubar. Those methods that should not be available at a current stage of
the application process should be disabled.

Further, an application can only contain one menubar, but several <idx/toolbar/s. Toolbars on the other hand should contain only the most
frequently used commands by pixmap icons or provide quick access methods like combos to select values.

<sect>How does it work ?
<p>
Each entry, may it be a menuentry or a <idx/toolbar/ item, has a resource ID which is an integer value. As these values can't be used twice,
those are set by macros, where the numeric values are replaced by a descriptive ID name that can be used in your sources then.

All resource ID's are collected in the file <tt/resource.h/, where you can keep an overview over the used values. Anyway, the compiler
will inform you if you've used a value twice for constructing entries. Also, the resource file should contain all menu accelerator<nidx/accelerator/s by
IDK macro replacements. An example:

<code>
(resource.h)

#define ID_VIEW_TOOLBAR             12010


(kscribble.cpp)

// menu entry Toolbar in the "view" menubar menu
view_menu->insertItem(i18n("&amp;Toolbar"), ID_VIEW_TOOLBAR);

</code>

This inserts the entry Toolbar to the View popup menu of the menubar in the kscribble application. The resource ID's name is held to
contain the menu name and the action's name visible. The ampersand is set in front of the letter that functions as a keyboard
accelerator<nidx/accelerator/ and the entry itself is embraced by the i18n() internationalization macro.

On activating the menu item, the commandCallback() switch is called with the ID number. There, you have to add an according comparator
value with the method you want to execute on activating the menuentry:

<code>
    case ID_VIEW_TOOLBAR:
    	slotViewToolBar();
    	break;
</code>

<comment>Note: you don't have to use the ID system. If no ID is given, the menu gets numbered automatically. The KDevelop framework
uses this as it allows accessing menu and <idx/toolbar/ ID's to create <tt/switch/ statements that select the slot to call on
<tt/activated()/ for menus, <tt/clicked()/ for <idx/toolbar/ buttons. The connection can also be made directly using the provided methods of
the classes providing menus and <idx/toolbar/s.</comment>

<sect>Adding a new menu
<p>
A new menubar is added to an application by the following:

<enum>
<item>add a pointer to the new menu in the App-class header
<item>call the constructor of <tt/<cdx/QPopupMenu// to the pointer in <tt/initMenuBar()/ at the location where your menubar should appear
later.
<item>insert the according menu-items into the popup menu and set their resource ID's in the resource file
<item>add connects for <tt/commandCallback()/ and <tt/statusCallback()/ to the menu at the end of <tt/initMenuBar()/
<item>add the methods you want to call by the menu-entries in the header and implementation file.
<item>add the switch statements for the entries to the <tt/commandCallback()/ and <tt/statusCallback()/ methods
</enum>


<sect>Integrating Toolbar buttons
<p>
Toolbar buttons can be added like menu-entries with the difference that the used method is <tt/insertButton()/ and takes a button
pixmap and tool-tip text instead of a menu text.

The icons you want to use can be loaded by <tt/KIconLoader/, where <tt/<cdx/KApplication// offers the macros <tt/ICON()/ and <tt/Icon()/ to
access the icon loader and load the icon. These macros take the filename of the pixmap as their parameter to load the icon from the KDE
file system in a certain order (see <tt/KIconLoader/ for the search order).

The <idx/KDE libraries/ also offer a set of <idx/toolbar/ buttons that can be used for standard actions. In cases where they don't meet your needs,
you will have to paint your own pixmaps. KDevelop supports this by selecting "New" from the "File" menu, then select Pixmap as the file
type. Usually you will place your <idx/toolbar/ pixmaps in a project subdirectory "<idx/toolbar/" and install them into your application specific
<idx/toolbar/ directory.

<sect>Configuring Statusbars
<p>
The KDevelop projects already make use of the statusbar by providing statusbar messages for menu-entries and <idx/toolbar/ buttons. When
adding a menuentry, also add your status message in the method <tt/statusCallback()/.

<tt/statusCallback()/ uses the method <tt/slotStatusHelpMsg()/ to display a statusbar message for two seconds. When executing a
command, you should use the method <tt/slotStatusMsg()/ at the beginning with the string describing what your application does; before
a return or method end, you should reset the statusbar message with a "Ready." string calling the same method.


<sect>Keyboard Accelerator Configuration
<p>
A very professional thing you should always add to your application are keyboard accelerator<nidx/accelerator/s. Those are mainly used by experienced
users that want to work fast with their applications and are willing to learn shortcut<nidx/shortcuts/s. For this, the <idx/KDE libraries/ provide the class
<tt/<cdx/KAccel//, which provides the keyboard accelerator<nidx/accelerator/ keys and access to global configured standard keyboard accelerator<nidx/accelerator/s.

By default, frame applications generated by KDevelop only use standard keyboard accelerator<nidx/accelerator/s such as F1 for accessing online-help,
Ctrl+N for New File etc. You should look for the keyboard accelerator<nidx/accelerator/s already set in <tt/<cdx/KAccel// first before adding a new
accelerator<nidx/accelerator/.

If your application contains a lot of accelerator<nidx/accelerator/s, you should make them configurable by an Options-menu; either it could be combined
with other application configuration in a <tt/<cdx/QWidget// or stand alone. The KDE library already provides a <tt/KKeyChooser/ for use
in tab dialogs, whereas <tt/KKeyDialog/ provides a ready-to use key-configuration dialog.

See the following classes for more information:

<tt/<cdx/KAccel//(<cdx/kdecore/), <tt/<cdx/KKeyChooser//, <tt/<cdx/KKeyDialog// (<cdx/kdeui/)

<chapt>The Dialogeditor: Where your Dialogs are Build
<p>
<sect>What the Dialogeditor provides
<p>
The built-In dialogeditor of KDevelop is designed to help you construct widgets and dialogs that fit your application's purpose and
reduces the time rapidly to extend the GUI of your application. The only limitation for now is that the dialogeditor does not support
geometry management that is provided by <idx/Qt/; therefore the dialogs are static in their size and this may lead to certain circumstances
where e.g. the label width is not long enough to support the full length of a translation.

On the other hand, the current state of the editor in conjunction with KDevelop's project management offers the fastest way to create
full-featured applications for the K Desktop Environment.


<sect><idx/Qt/ and KDE Widgets
<p>
Currently provided widgets are:

<bf/QT-Widgets:/
<itemize>
<item><bf/<cdx/QWidget// - a widget that can be specified by yourself and can contain other widgets as well. This allows creating a widget
hierarchy within your dialog.
<item><bf/<idx/QLabel// - a label that represents text information on the widget. Use <idx/QLabel/ e.g. in front of lineedits to signal what the
purpose of the line-edit is or which variable e.g. a combo box allows to set.
<item><bf/QPushButton/ - a button that allows to e.g. call another dialog like QFileDialog for selecting a filename.
<item><bf/QCheckBox/ - a check box for e.g. enabling/disabling options. QCheckBox is widely used for configuration dialogs.
<item><bf/QLCDNumber/ - displays numbers in LCD style. Often used for clocks.
<item><bf/QRadioButton/ - like QCheckBox often used to let the user set any options. QRadioButton specializes the options setting when more
of them depend on each other, e.g. you have three radio-buttons, but you want the user to choose one of three offered options. See
<tt/<cdx/QButtonGroup// for additional information.
<item><bf/<cdx/QComboBox// - a combo box lets the user set a value by selecting it from a
drop-down menu or by inserting the value, if the box is write enabled.
<item><bf/QListBox/ - provides a single-column list of items that can be scrolled.
<item><bf/QListView/ - creates a multi-column list view that can be used to display e.g. file trees etc. in tree and table view.
<item><bf/QMultiLineEdit/ - offers a multi-line editor.
<item><bf/QProgressBar/ - displays the progress of an action that takes a longer time to be finished.
<item><bf/QSpinBox/ - allows choosing numeric values by up- and down buttons or insertion if write enabled.
<item><bf/QSlider/ - sets a value in a program-defined range by a slider.
<item><bf/QScrollBar/ - indicates the range of a value and sets the current value by a slider as well as up- and down buttons; often
used for widgets whose contents is larger than the actually visible view area. By using the scrollbar, the visible area can be changed
to another part of the widgets' contents.
<item><bf/QGroupBox/ - provides a group box frame with title to indicate that child widgets within the box belong together.
</itemize>

<bf/KDE-Widgets:/
<itemize>
<item><bf/KColorButton/ - a pushbutton displaying a selected color. On a button press, the KDE Color dialog is shown where the user can
select another color. Often used for drawing applications or in any case where color values can be set.
<item><bf/KCombo/ - similar to <tt/<cdx/QComboBox//. Lets the user choose a value by a drop-down list box.
<item><bf/KDatePicker/ - a complete widget to get a date value by the user.
<item><bf/KDateTable/ - a calendar table to select a date of a month. Used by <tt/KDatePicker/ to build the date picker dialog.
<item><bf/KKeyButton/ - a button to select a key value. If the button is selected, it gets activated. Pressing a keyboard button will
change the key value for the button which can be used to configure key-bindings.
<item><bf/KLed/ - and LED (Light Emitting Diode) widget to display a certain state.
<item><bf/KLedLamp/ - and LED lamp that also supports click actions
<item><bf/KProgress/ - similar to <tt/QProgressBar/, <tt/KProgress/ supports certain other values.
<item><bf/KRestrictedLine/ - a <tt/QLineEdit/ that only accepts certain user input. This can be used to restrict access to certain data
by password dialogs.
<item><bf/KSeparator/ - a separator widget to be used in all cases where <idx/KDE applications/ require a separator to provide a unique look.
Often used in dialogs to separate logical parts where <tt/QGroupBox/ doesn't fit.
<item><bf/KTreeList/ - a collapsible list view to display trees similar to <tt/QListView/.
</itemize>

<sect>Properties of <idx/Qt/ supported Widgets
<p>

The following chapter gives a complete overview over the currently supported widgets of the <idx/Qt/ toolkit. To achieve a better
understanding of the properties, these are separated to their inheritance. As all of them inherit <tt/<cdx/QWidget//, this class is described
first. All <tt/<cdx/QWidget// properties are available for all other widgets as well, so these are not listed for them again. For widget groups
that inherit an abstract subclass of <tt/<cdx/QWidget// as their base-class, the base-classes' properties are listed first (though this class does
not provide a widget in the dialogeditor itself). Then the widget properties for the available widget of the group contains the
properties that are specific to it. For a better understanding the inheritance tree of the available widgets is listed below:

<itemize>
<item><ref id="QWidget" name="<cdx/QWidget/">
	<itemize>
		<item><ref id="QButton" name="<cdx/QButton/"> (abstract)
			<itemize>
			<item><ref id="QCheckBox" name="QCheckBox">
			<item><ref id="QPushButton" name="QPushButton">
			<item><ref id="QRadioButton" name="QRadioButton">
			</itemize>
		<item><ref id="QComboBox" name="<cdx/QComboBox/">
		<item><ref id="QFrame" name="QFrame"> (abstract for now)
			<itemize>
			<item><ref id="QGroupBox" name="QGroupBox">
			<item><ref id="QLCDNumber" name="QLCDNumber">
			<item><ref id="QLabel" name="<idx/QLabel/">
			<item><ref id="QProgressBar" name="QProgressBar">
			<item><ref id="QScrollView" name="QScrollView"> (abstract for now)
				<itemize>
				<item><ref id="QListView" name="QListView">
				</itemize>
			<item><ref id="QSpinBox" name="QSpinBox">
			<item><ref id="QTableView" name="QTableView"> (abstract)
				<itemize>
				<item><ref id="QListBox" name="QListBox">
				<item><ref id="QMultiLineEdit" name="QMultiLineEdit">
				</itemize>
			</itemize>
		<item><ref id="QLineEdit" name="QLineEdit">
		<item><ref id="QScrollBar" name="QScrollBar">
		<item><ref id="QSlider" name="QSlider">
	</itemize>
</itemize>

<sect1><cdx/QWidget/ Properties <label id="QWidget">
<p>
<tt/<cdx/QWidget// is the base class for almost all widgets in <idx/Qt/ and KDE. Therefore widgets that inherit <tt/<cdx/QWidget// will allow to use the same
settings in most cases.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/BgColor:/ Background color of the widget
  <item><bf/BgMode:/ Background mode of the widget
  <item><bf/BgPalColor:/ Color pallette for the background
  <item><bf/BgPixmap:/ filename for a background pixmap
  <item><bf/Cursor:/ Cursor over the widget
  <item><bf/Font:/ Font for the widget
  <item><bf/MaskBitmap:/ filename for a masking bitmap.
  </itemize>
<item><bf/C++ Code:/
  <itemize>
  <item><bf/AcceptsDrops:/ if set to true, the widget item will accept drops by <idx/drag'n drop/ mechanisms (<idx/Qt/ <idx/drag'n drop/
protocol, not KDE 1.x !)
   <item><bf/Connections:/ connects the item's signals to slots
  <item><bf/FocusProxy:/ the item that gives its focus to this widget.
  <item><bf/HasFocus:/ sets if the item has the focus by default. Mind that only one item per dialog can have this value as true
  <item><bf/ResizeToParent:/ resizes the widget to its parent's size (not visible in editing mode)
  <item><bf/VarName:/ Variable name of the item. Change this to names that describe the item's purpose.
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/IsEnabled:/ sets if the widget will accept user events
  <item><bf/IsHidden:/ sets the item to be visible(false) or hidden(true)
  <item><bf/Name:/ sets the name of the widget. Mind that the name is different from the VarName in C++ Code.
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/Height:/ height of the item
  <item><bf/IsFixedSize:/
  <item><bf/MaxHeight:/ maximum value for Height
  <item><bf/MaxWidth:/ maximum value for Width
  <item><bf/MinHeight:/ minimum value for Height
  <item><bf/MinWidth:/ minimum value for Width
  <item><bf/SizeIncX:/ pixel steps for resize actions to X direction
  <item><bf/SizeIncY:/ pixel steps for resize actions to Y direction
  <item><bf/Width:/ width of the item
  <item><bf/X:/ position horizontal, counted from the left corner
  <item><bf/Y:/ position vertical, counted up to down
  </itemize>
</itemize>


<sect1><cdx/QButton/ inherited widgets <label id="QButton">
<p>
<tt/<cdx/QButton// is an abstract widget class that provides properties common to buttons.

Inherits <ref id="QWidget" name="<cdx/QWidget/">

Inherited by <ref id="QCheckBox" name="QCheckBox">, <ref id="QPushButton" name="QPushButton"> and <ref id="QRadioButton"
name="QRadioButton"> inherit <tt/<cdx/QButton//.


<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/setPixmap:/ sets the pixmap filename to use
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/setText:/ the text on labels, buttons and boxes, also pre-set text for lineedits.
  <item><bf/setAutoRepeat:/ if enabled, the clicked() signal is emitted at regular intervals while the button is down. No effect on
  toggle buttons.
  <item><bf/setAutoResize:/ Enables auto-resizing if TRUE. When auto-resize is enabled, the button will resizes itself
  whenever the contents changes.
  </itemize>
</itemize>
<p>

<sect2>QCheckBox Properties <label id="QCheckBox">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QButton" name="<cdx/QButton/">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ defines is the checkbox is set checked on construction
  </itemize>
</itemize>
<p>

<sect2>QPushButton Properties <label id="QPushButton">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QButton" name="<cdx/QButton/">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isAutoDefault: (setAutoDefault)/ the auto-default button becomes the default push button if it receives the keyboard input focus.
  <item><bf/isDefault: (setDefault)/ there can be only one default button and it is only allowed to use in a dialog (see <tt/QDialog/). The
  default button emits <tt/clicked()/ if the user presses the Enter key.
  <item><bf/isMenuButton: (setIsMenuButton)/ tells the button to draw
  a menu indication triangle if enabled. The menu has to be inserted separately.
  <item><bf/isToggleButton::(setToggleButton)/ makes a push button a toggle button, so the button has a similar state as check
  boxes.
  <item><bf/isToggledOn: (setOn)/ (public slot) switches a toggle button on.
  </itemize>
</itemize>
<p>

<sect2>QRadioButton Properties <label id="QRadioButton">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QButton" name="<cdx/QButton/">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ defines is the radio button is set checked on construction
  </itemize>
</itemize>
<p>

<sect1><cdx/QComboBox/ Properties <label id="QComboBox">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">

( no additional properties for now)
<p>


<sect1>QFrame inherited widgets <label id="QFrame">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">

For now only used as an abstract class.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): sets the margin, which is the distance from the innermost pixel of the frame and the outermost pixel of the
  contents.
  </itemize>
</itemize>
<p>

<sect2>QGroupBox Properties <label id="QGroupBox">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Title: (setTitle)/ sets the group box title that is displayed in the box frame.
  </itemize>
</itemize>
<p>

<sect2>QLCDNumber Properties  <label id="QLCDNumber">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/NumDigits:(setNumDigits)/ sets the number of digits displayed in QLCDNumber
  <item><bf/Value: (display)/ (public slot) sets the initial value for QLCDNumber
  </itemize>
</itemize>
<p>


<sect2><idx/QLabel/ Properties  <label id="QLabel">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): sets the margin, which is for <idx/QLabel/ the distance from the frame to the first letter of the label text,
  depending on the alignment of the label.
  </itemize>
<item><bf/C++ Code: /
  <itemize>
  <item><bf/Buddy: (setBuddy)/ sets the buddy widget of the label.
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Text: (setText)/ sets the label text.
  <item><bf/isAutoResize: (setAutoResize)/ if TRUE, the label will resize itself if the contents changes. The top left corner is not
  moved.
  </itemize>
</itemize>
<p>


<sect2>QProgressBar Properties  <label id="QProgressBar">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/TotalSteps: (setTotalSteps)/ (public slot) sets the total steps of the progress bar. During the iteration of your action to
  display the progress, you have to call setProgress(int) to advance the progress step displayed to (int).
  </itemize>
</itemize>
<p>
			
<sect2>QScrollView <label id="QScrollView">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

Inherited by <ref id="QListBox" name="QListBox">
(abstract for now)

Provides a scrollable widget that manages the display of a child widget by a vertical and horizontal scrollbar.

<sect3>QListView<label id="QListView">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">, <ref id="QFrame" name="QFrame"> and <ref id="QListView" name="QListView">

Provides a list view to display hierarchical data either in a table or a tree. Manages itself by scrollbars through <ref
id="QScrollView" name="QScrollView">.

<itemize>
<item><bf/Appearance:/
	<itemize>
	<item><bf/ListViewFont:/ (setFont()) Sets the font of the ListView items
	<item><bf/ListViewPalette:/ (setPalette()) Sets the palette of the list view items
	<item><bf/TreeStepSize:/ (setTreeStepSize(int)) Offset of pixels of a child item to its parent item
	<item><bf/hScrollBarMode:/ Scrollbar mode provided by <ref id="QScrollView" name="QScrollView"> for the horizontal scrollbar
	<item><bf/isAllColumnsShowFocus:/ (setAllColumnsShowFocus(bool)) displays focus on all columns of an item.
	<item><bf/isMultiSelection:/ enables multi-selection of list items
	<item><bf/isRootDecorated:/ enables the + and - decoration to open and close trees
	<item><bf/vScrollBarMode:/Scrollbar mode provided by <ref id="QScrollView" name="QScrollView"> for the vertical scrollbar
	</itemize>
<item><bf/General:/
	<itemize>
	<item><bf/Entries:/ lets you insert a list of entries that are pre-set as QListViewItems.
	<item><bf/isAutoUpdate:/
	</itemize>
</itemize>

<sect2>QSpinBox Properties <label id="QSpinBox">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/MaxValue:/  the maximum value the user can choose
  <item><bf/MinValue:/  the minimum value the user can choose
  <item><bf/Prefix:/
  <item><bf/Suffix:/
  <item><bf/Value:/     the pre-set value when the widget is shown
  <item><bf/isWrapping:/
  </itemize>
</itemize>
<p>

<sect2>QTableView inherited widgets <label id="QTableView">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

Inherited by <ref id="QListBox" name="QListBox"> and <ref id="QMultiLineEdit" name="QMultiLineEdit">
<p>

<sect3>QListBox Properties <label id="QListBox">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isAutoBottomScrollBar: (setAutoBottomScrollBar)/
  <item><bf/isAutoScroll: (setAutoScroll)/
  <item><bf/isAutoScrollBar: (setAutoScrollBar)/
  <item><bf/isAutoUpdate: (setAutoUpdate)/
  <item><bf/isBottomScrollBar: (setBottomScrollBar)/
  <item><bf/isDragSelect: (setDragSelect)/
  <item><bf/isSmoothScrolling: (setSmoothScrolling)/
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/setFixedVisibleLines:/ sets a fixed height for the widget so that the given number of text lines are displayed using the
  current font.
  </itemize>
</itemize>
<p>

<sect3>QMultiLineEdit Properties <label id="QMultiLineEdit">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">, <ref id="QFrame" name="QFrame"> and <ref id="QTableView" name="QTableView">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Text: (setText) / (public slot) sets the text of the widget.
  <item><bf/isAutoUpdate: (setAutoUpdate)/ used to avoid flicker during large changes; the view is not updated if disabled.
  <item><bf/isOverWriteMode: (setOverwriteMode) /(public slot) sets overwrite enabled or disabled.
  <item><bf/isReadOnly: (setReadOnly)/ (public slot) sets the widget text to read only; disables text input.
  <item><bf/isTextSelected: (selectAll)/(public slot) marks the whole text selected
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/setFixedVisibleLines:/ sets a fixed height for the widget so that the given number of text lines are displayed using the current font.
  </itemize>
</itemize>
<p>


<sect1>QLineEdit Properties <label id="QLineEdit">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/">

<itemize>
<item><bf/General:/
<itemize>
<item><bf/CursorPosition: (setCursorPosition)/ sets the default cursor position.
<item><bf/MaxLength: (setMaxLength) / sets the maximum string length
<item><bf/Text: (setText) / (public slot) sets the contents displayed on construction
<item><bf/hasFrame: (setFrame) / draws the line edit within a two-pixel frame if enabled.
<item><bf/isTextSelected: (selectAll) / (public slot) sets the text to be selected.
</itemize>
</itemize>
<p>

<sect1>QScrollBar Properties <label id="QScrollBar">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <tt/QRangeControl/.

<itemize>
<item><bf/General:/
<itemize>
<item><bf/MaxValue:/ sets the maximum slider value; used in constructor (optional)
<item><bf/MinValue:/ sets the minimum slider value; used in constructor (optional)
<item><bf/Orientation: (setOrientation)/ sets the orientation of the scrollbar to horizontal or vertical.
<item><bf/Value: / sets the initial value of the scrollbar in the constructor (optional)
<item><bf/isTracking: (setTracking)/ if enabled, the scrollbar emits <tt/valueChanged()/ whenever the bar is dragged; otherwise only on
mouse release.
</itemize>
</itemize>
<p>

<sect1>QSlider Properties <label id="QSlider">
<p>
Inherits <ref id="QWidget" name="<cdx/QWidget/"> and <tt/QRangeControl/.

<itemize>
<item><bf/General:/
<itemize>
<item><bf/MaxValue:/ sets the maximum slider value; used in constructor (optional)
<item><bf/MinValue:/ sets the minimum slider value; used in constructor (optional)
<item><bf/Orientation: (setOrientation)/ sets the orientation of the slider to horizontal or vertical.
<item><bf/Value: (setValue)/ (public slot) uses <tt/QRangeControl::setValue()/ to set the value.
<item><bf/isTracking:(setTracking)/ if enabled, the slider emits <tt/valueChanged()/ whenever the slider is dragged; otherwise only on
mouse release.
</itemize>

</itemize>
<p>

<sect>Properties of KDE supported Widgets
<p>

<itemize>
<item><ref id="QWidget" name="<cdx/QWidget/">
	<itemize>
	<item><ref id="QButton" name="<cdx/QButton/"> (abstract)
		<itemize>
		<item><ref id="QPushButton" name="QPushButton">
  		<itemize>
  		<item><ref id="KColorButton" name="KColorButton">
  		<item><ref id="KKeyButton" name="KKeyButton">
  		</itemize>		
		</itemize>
	<item><ref id="QComboBox" name="<cdx/QComboBox/">
		<itemize>
		<item><ref id="KCombo" name="KCombo">
		</itemize>
	<item><ref id="QFrame" name="QFrame"> (abstract for now)
 		<itemize>
 		<item><ref id="KDatePicker" name="KDatePicker">
 		<item><ref id="KLedLamp" name="KLedLamp">
 		<item><ref id="KProgress" name="KProgress">
 		<item><ref id="KSeparator" name="KSeparator">
 		<item><ref id="QTableView" name="QTableView"> (abstract)
 			<itemize>
 			<item><ref id="KDateTable" name="KDateTable">
 			<item><ref id="KTreeList" name="KTreeList">
 			</itemize>
 		</itemize>
 	<item><ref id="QLineEdit" name="QLineEdit">
 		<itemize>
 		<item><ref id="KRestrictedLine" name="KRestrictedLine">
 		</itemize>
	</itemize>
	<item><ref id="KLed" name="KLed">
</itemize>

<sect1>KColorButton<label id="KColorButton">
<p>

Inherits <ref id="QPushButton" name="QPushButton">

<itemize>
<item>General
	<itemize>
	<item><bf/DisplayedColor (setColor())/ the displayed color on the button
	</itemize>
</itemize>

<sect1>KKeyButton<label id="KKeyButton">
<p>

<sect1>KCombo<label id="KCombo">
<p>

Inherits: <ref id="QComboBox" name="<cdx/QComboBox/">

<itemize>
<item>General
	<itemize>
	<item><bf/Entries/ the string list of entries displayed in the combo box
	<item><bf/Text/ the text displayed in the combo box currently
	<item><bf/isAutoResize/ resizes the combo box to the current item
	</itemize>
</itemize>

<sect1>KDatePicker<label id="KDatePicker">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item><bf/FontSize/ the font size for the date picker
	</itemize>
</itemize>
	
<sect1>KLedLamp<label id="KLedLamp">
<p>

<sect1>KProgress<label id="KProgress">
<p>

<sect1>KSeparator<label id="KSeparator">
<p>

<itemize>
<item>General
	<itemize>
	<item><bf/Orientation/ sets the orientation of the separator to horizontal or vertical; default is horizontal
	</itemize>
</itemize>

<sect1>KDateTable<label id="KDateTable">
<p>

<sect1>KTreeList<label id="KTreeList">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item><bf/TreeListBgColor/
	<item><bf/TreeListPalette/
	<item><bf/isBottomScrollbar/
	<item><bf/isScrollBar/
	<item><bf/isShowItemText/
	<item><bf/isSmoothScrolling/
	<item><bf/isTreeDrawing/
	</itemize>
<item>General
	<itemize>
	<item><bf/Entries/
	<item><bf/isAutoUpdate/
	</itemize>
</itemize>



<sect1>KRestrictedLine<label id="KRestrictedLine">
<p>

<sect1>KLed<label id="KLed">
<p>

Inherits <ref id="QWidget" name="<cdx/QWidget/">

<itemize>
<item>Appearance
	<itemize>
	<item><bf/LedColor: (setColor())/ sets the displayed LED color
	</itemize>
</itemize>
	
	
<sect>Constructing a new Dialog
<p>
Constructing a new dialog is very easy if you already have experience with graphical construction applications. KDevelop offers to
create a widget visually and displays the look as it will be shown to the user directly. Further, you can have a preview of your widget
by selecting "Preview" from the "View" menu.

To begin constructing a dialog or any other widget, switch to the Dialogeditor and select "New Dialog" from the "File" menu. Then enter
all needed information to the "New Dialog" dialog. Those are:

<enum>
<item>The Dialog inheritance. This is necessary because any widget is at least derived from <tt/<cdx/QWidget//. Besides the widget types
provided by <idx/Qt/, you can inherit e.g. form an abstract base class you constructed yourself within your project. In this case, select
"custom" and enter the header file path to the line edit below.
<item>The Dialog name. This sets the class name of the generated dialog. Select a classname that is descriptive for what the dialog
does; in cases of inheritance from <tt/QDialog/, you may enter a name that ends with <tt/Dlg/ to remember yourself it's a dialog.
Naming convention should match that of KDE and <idx/Qt/: Use uppercase letters for your classname. For e.g. a grid-size selection dialog, you
would enter <tt/GridSizeDlg/.
<item>The generated filenames. Those are preset when entering the dialog name, but can be changed afterwards. If you want to use other
filenames, the naming convention should also match that of KDE and <idx/Qt/: the filenames are all lowercase and contain the classname to
remember what class is kept where. The data file that has to be set will later contain the generated code that will build up your
dialog. You should not edit this file manually afterwards; use the implementation file for any additions towards dialog construction
code and method implementations.
</enum>

The dialog will then show itself as a widget with a grid. As the dialogeditor uses the grid to snap any child widgets to the geometry,
you can change the grid size with the "Grid Size" entry in the "View" menu, if the preset values don't match your needs.

Then select the "Widgets" tabulator on the left pane and press the button for the widget item you want to add to the main widget. It
directly appears on the main widget's left upper corner and gets selected by a resizable frame. Then move or resize the widget with the
mouse. The cursor will change to indicate which action can be done at the current position.

After having finished the construction, select "Generate Files" from the "Build" menu or hit the according <idx/toolbar/ button. The files
will then be generated at the preset location and included into your project sources. A rebuild or make will compile all generated
files within your project and you can add the according constructor call to the application to invoke the dialog or widget. For KDE
projects, all widget properties that will be visible later, e.g. label texts, are set with the <tt/i18n()/ macro of <tt/<cdx/kapp.h// to
support internationalization. Therefore you should do a "Make Messages and merge" when finished with construction and implementation.

When creating a dialog or widget, you should watch the following guidelines:
<itemize>
<item>Always try to be consistent! This is probably the most important rule when constructing GUI elements. Mind that the user will
only accept an application that is easy to understand no matter how complex it's purpose may be.
<item>Add help wherever you can by tool-tips, What's this..? help or Quick-help. This allows getting direct information about the
purpose of the GUI elements.
<item>watch the <bf/<idx/keyboard focus// !  The generator does not take care of that- this has to be watched when constructing any widget;
otherwise you have to reorder your initialization code by hand which is a very unthankful job. The <idx/keyboard focus/ on any widget means
the oder on which items get the keyboard input focus when the user presses the tab and shift+tab button. It would be very annoying if
the focus changes everywhere but not to the next widget visible below or to the right of the current widget. Therefore start
constructing your widget top down from left to right to ensure the consistency of the focus.
</itemize>

<sect>Setting Widget Properties
<p>
<nidx/widget properties/<nidx/dialogeditor/<nidx/properties window/
Widget properties can be set easily with the properties window entries. When a widget gets selected, the properties window
automatically updates to the properties of the current widget. As all widgets are derived from <tt/<cdx/QWidget//, you can set the
<tt/<cdx/QWidget// properties plus an amount of properties that are specific to the selected widget. Properties can be:

<itemize>
<item>Integer values, such as the geometry of a widget or the font size
<item>Boolean values to enable/disable certain parameters of the widget. Set with combos containing true and false
<item>enumerable values of a widget, e.g. the palette. Set with combos containing all possible values
<item>Color values for e.g. the displayed color. Set with the KDE Color Dialog
<item>Font values for e.g. labels. Be careful to set Font values other than the default because this may prevent KDE from updating the
font. Set with the KDE Font Dialog
<item>File names for e.g. background pixmaps. Do not use gif images here as these may get
unsupported by further <idx/Qt/ versions > 1.42
</itemize>

<sect>Integrating the Dialog
<p>
Whenever you created a widget, you probably want to add it to the project to execute the action it is designed for. As a widget can be
constructed for several purposes, we will watch for two cases: a <tt/<cdx/QWidget// inherited widget and a <tt/QDialog/ one.

<sect1><tt/<cdx/QWidget// inherited
<p>
Let's say you created a widget that will be part of the main view. If it fills the whole view area, you have to add an instance pointer
to the header declaration of your <tt/<cdx/KTMainWindow// instance replacing the currently set view widget. Then change the code in the
<tt/initView/ method to set this widget the main view. Additionally, you could remove the View class of the generated project, but mind
that the document instance and the App instance depends on the view class. In this case, it is technically a much better way to create
a mini-KDE application and construct your <tt/<cdx/KTMainWindow// instance yourself.

More often the widget is intended to be a part of the view area, which means it is combined with other widgets. This can be done by
using one of the following classes that provide a divider to separate two widgets:

<enum>
<item><tt/QSplitter/
<item><tt/KPanner/
<item><tt/KNewPanner/
</enum>

If the main view shall contain more than two widgets, you have to use another instance of the divider as one of the two managed widgets
by the first one. Then add the according widgets to each panner and set the first panner the view area.

<sect1><tt/QDialog/ inherited
<p>
If your widget inherits <tt/QDialog/, it is probably intended to change one or more values; often this is used to set the application
preferences. To invoke the dialog, you have to add a slot to the <tt/App/ class by adding the method declaration and the implementation
body. Then add the constructor call to the method as well as a call to <tt/show()/ or <tt/exec()/ the dialog. Finally, you should take
care for processing the results of the dialog; this can either be done by the dialog who changes values of the parent widget itself or
by retrieving the values from the dialog (which would make your dialog a lot more reusable in other projects). Mind that you should call
<tt/delete/ if you called the dialog instance with <tt/new/ to avoid memory leaks.

Finally, you have to connect a menuentry (with according statusbar help) to the new slot invoking the dialog; optionally a keyboard
accelerator<nidx/accelerator/ and a <idx/toolbar/ icon. For this, add a resource ID to the file <tt/resource.h/ with a define. Then add
an according menuentry to one of the popup menus already present in the menubar or create a new popup to add your menuentry. The
menuentry consists of:

<itemize>
<item>an optional icon pixmap. Call this with the <tt/Icon("iconname.xpm")/ macro of <tt/<cdx/KApplication// to use the provided
<tt/KIconLoader/ instance.
<item>the menuentry name. Add this with the <tt/i18n("&amp;entryname")/ macro of <tt/<cdx/KApplication// to allow
internationalization. The ampersand should be in front of the letter that will be displayed underlined to access the entry directly by
keyboard acceleration.
<item>the member instance to call. Normally this would be the <tt/this/ pointer.
<item>the member slot to call. Use <tt/SLOT(yourmethod()/ to call the slot on the signal <tt/activated()/.
<item>the accelerator<nidx/accelerator/ key. This should be set to zero as this is done by an entry in <tt/initKeyAccel()/ where you
have to introduce an accelerator<nidx/accelerator/ key together with the slot to call. Then call <tt/changeMenuAccel()/ to change the
menu item's accelerator<nidx/accelerator/. This will make it configurable by a key-chooser dialog later. For standard actions, use the
enumerable values given by <tt/<cdx/KAccel//. <item>the menu ID as set in <tt/resource.h/
</itemize>


<chapt>Printing Support
<p>
<ncdx/QPrinter/<ncdx/QPainter/<ncdx/QPrintdialog/<nidx/printing/
Printing is usually provided by your application to let the user create a printed version of the document he created with the
application; therefore only needed for those programs that are used to produce something the user may want to print out, e.g. text or
pictures. In any case, this requires an interface that is provided by the <idx/Qt/ library by two classes: the <tt/QPrintDialog/ class,
offering the printing dialog, and the <tt/QPainter/ class that is also used to draw the widget's contents usually. As the view-class of
an application is responsible for displaying a document, it also is responsible for printing.

<sect>The <idx/Qt/ Print Dialog
<p>
The <idx/Qt/ Printer dialog can be used including <tt/qprintdialog.h/. When using the KDE framework application, this is already used by the
view class, so you only have to complete the implementation of the method <tt/print()/ by using <tt/QPainter/.

<sect>The QPainter Class
<p>
Independent of the printer's capabilities, you can use <tt/QPainter/ to draw your document onto the printer provided by <tt/QPrinter/
like you would when drawing onto a widget. The only difficulty would be where you have to implement the way things have to be printed.

<chapt>Help Functions
<p>
A very important part of the development process is to provide help functionality to the user wherever possible. Most developers tend
to delay this, but you should remember that a normal user isn't necessarily a Unix-expert. He may come from the the dark side of
computer software usage offering all sweets that a user may need to work himself into using an application even without ever touching
the manuals. Therefore, the KDE and <idx/Qt/ library provide all means usually considered making an application professional in the eyes of
the normal user by help functions that are ready to use. Within the application, those are:

<itemize>
<item>Tool-Tips
<item>Quick-Help
<item>Statusbar help
<item>What's this...? buttons
</itemize>

Additionally, the application should provide means to access a HTML-based online manual directly using the standard help key F1.

As KDevelop also offers all types of help as well as the KDE framework generated by the application wizard already contains support for
this, this chapter will help you find out where and how to add your help functionality.

During the development of your application you should try to be consistent whatever you're doing; therefore you should do the necessary
steps directly while extending the code. This will prevent you from diving into the code again and figuring out what your application
does or what you intended by certain parts of the code.

<sect>Tool-Tips
<p>
A very easy mean of providing help are tool-tips. Those are small help messages popping up while the user moves the mouse over a widget
that provides a tool-tip and disappears when the mouse moves away. The most popular usage of tool-tips is made in <idx/toolbar/s where your
tool-tips should be kept as small as possible because <idx/toolbar/s can be configured to display their contents in various ways: either
displaying the button, button with text on the right, button with text below, text only.  This possibility should be made configurable
by the user, but isn't a must-be. The text is shown as a tool-tip anyway and a <idx/toolbar/ usually consists of buttons and other widgets
like lineedits and combo boxes. For a complete reference, see the <tt/<cdx/KToolBar// class reference located in the KDE-UI library.

As an example, we have a look at the the "New File" button in a generic application:

<tscreen><verb>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</verb></tscreen>
<ncdx/toolBar()/<nidx/KToolBar/
There, the part <tt/i18n("New File")/ provides a tool-tip message. It is enclosed by the i18n() macro provided by <tt/<cdx/kapp.h// to
translate the tool-tip towards the currently selected language.

Tool-tips can also be added to any custom widget by using the classes <tt/QToolTip/ and <tt/<cdx/QToolTipGroup// provided by <idx/Qt/.
An example of that would be:

<tscreen><verb>
QToolTip::add( yourwidget, i18n("your Tip") );
</verb></tscreen>
For more information, see the <idx/Qt/-Online Reference, class <tt/<cdx/QToolTip//.

<sect>Adding Quick-help
<p>
Quick-Help windows are another good example of providing help. The user can access the quick-help over a widget that it is connected to
by pressing the right mousebutton and selecting "Quick-Help" in the context menu. Therefore, Quick-Help can be placed somewhere in
between a detailed handbook reference help and tool-tips- the documentation would be too extensive and a tool-tip would not provide
enough information. To see how Quick-Help works, open any dialog within KDevelop and press the right mouse button over a dialog item.
Then select the Quick-Help menuentry and you're offered the help message. Additionally, those messages can be formatted by color, font
and even can be used for containing URL's to refer a certain webpage (and therefore can refer to the documentation handbook as well).

To make use of Quick-Help, add the include file <tt/<cdx/kquickhelp.h// to your sourcefile containing quick-help. As the
<tt/<cdx/KQuickHelp// class is part of the KDE-UI library, it should already be used by your application; if not, set the linker flags
of your project to use kdeui.

An example would be:

<tscreen><verb>
KQuickHelp::add( yourwidget, i18n("your Tip") );
</verb></tscreen>

which is almost the same as with QToolTip. When constructing a dialog with the KDevelop dialogeditor, add your tool-tips and Quickhelp
in the implementation file- NOT within the data sourcefile as this is rebuild by the dialogeditor every time you edit the widget.

The <tt/<cdx/KQuickHelp// class provides also formatting text by using tags. It allows hyperlinks including Internet protocols, colors,
font types and sizes. See the <htmlurl url="kde_libref.html" name="KDE Library Reference Guide"> and the <idx/class documentation/ for
<tt/<cdx/KQuickTip// for more information.

<sect>Extending the Statusbar Help
<p>
As the frame applications provided by KDevelop contain a statusbar as well, it also offers a set of statusbar messages already for all
menu and <idx/toolbar/ items. A statusbar help message is a short message that extends the meaning of a tool-tip or can be seen as a
replacement for a tool-tip over menubar items and is (as the name suggests) displayed in the statusbar when the user enters a menu and
highlights the menu entry; therefore all menu items connect their signal <tt/highlighted(int)/ to the method <tt/statusCallback(int)/
which selects the according message in a switch statement. Whenever you add a menuitem to already existing menus or a <idx/toolbar/
item, add an according entry in this method with a short description of the action the user will cause when activating the button or
menuentry.

Example:

<tscreen><verb>
    case ID_FILE_NEW:
 	  	slotStatusHelpMsg(i18n("Creates a new document"));
 	  	break;
</verb></tscreen>

This will display a statusbar message by calling the method <tt/slotStatusHelpMsg()/ with the according translated help string whenever
the user highlights a menu or <idx/toolbar/ item with the id ID_FILE_NEW that is connected to the <tt/statusCallback()/ method.
Toolbars connect to this method by their signal <tt/pressed(int)/, which allows the user to press the <idx/toolbar/ button and move away the
mouse when he doesn't want to invoke the command. <tt/<cdx/KToolBar// also offers the signal <tt/highlighted(int, bool)/ which can be used to
display the message whenever the user highlights the button instead of the preset signal used.


<sect>The "What's This...?" Button
<p>
The <idx/"What's This...?"/ button provides help windows like Quickhelp<nidx/KQuickHelp/, but with the intention that the user wants to
get help about a certain widget within the working view or a <idx/toolbar/ item. It is placed in the <idx/toolbar/ and gets activated
once the user hits the button. The cursor changes to an arrow cursor with a question mark like the button itself looks like. The the
user can press on a visible widget item and gets a help window. As an exercise, you could try this behavior with the What's this...?
button within KDevelop.
To add the What's This...? button, do the following:

<enum>
<item>include <tt/qwhatsthis.h/ into your sourcecode
<item>add a private member <tt/<cdx/QWhatsThis// whats_this/ or with another member name to your <tt/<cdx/KTMainWindow// derived class
declaration <item>define a resource id for your what's this button into the <tt/resource.h/ file,e.g. <tt/#define ID_HELP_WHATS_THIS
10100/
<item>in your method to create the <idx/toolbar/ (usually <tt/initToolBar()/), add at the location you want to have the button
displayed:
<tscreen><verb>
  whats_this = new QWhatsThis;
  QToolButton *btnwhat = whats_this->whatsThisButton(toolBar());
  QToolTip::add(btnwhat, i18n("What's this...?"));
  toolBar()->insertWidget(ID_HELP_WHATS_THIS, btnwhat->sizeHint().width(), btnwhat);
  btnwhat->setFocusPolicy(QWidget::NoFocus);
</verb></tscreen>
<ncdx/setFocusPolicy()/
<item>finally, add the messages you want to have on a click over a certain widget like this:
<tscreen><verb>
whats_this->add(class_tree, i18n("Class Viewer\n\n"
                                  "The class viewer shows all classes, methods and variables "
                                  "of the current project files and allows switching to declarations "
                                  "and implementations. The right button popup-menu allows more specialized "
                                  "functionality."));
</verb></tscreen>
</enum>
	

<chapt>Extending the Documentation with <idx/SGML/
<p>
Due to the fact that projects often lack a complete set of user documentation, all KDevelop projects contain a pre-build handbook that
can be easily adapted; therefore fulfilling another goal of KDE: providing enough online-help to support users that are not familiar
with an application. This chapter therefore introduces you on how to extend the provided documentation template and what you have to do
to make it available to the user.

<sect>Why SGML ?
<p>
<idx/SGML/ (Standard Generalized Markup Language) itself is a language with which one can write specifications of a markup language,
but not a markup language itself. The specification for that markup language is called a DTD (Document Type Definition) which contains
the structure of a document and the valid tags to use. Then, an SGML system provides a set of replacement files that translate the DTD
tags into the desired output - and this is the way it works. The most used output is probably HTML to provide online help through
web-browsers in a time where Internet standards are available even on single-desktop systems. KDE makes extensive use of HTML
documentation by it's <idx/KDEHelp/ application where all <idx/KDE applications/ are listed and give access to their user manuals as
well as by a helpmenu where the user can access the online-help directly from within the application.

Now, KDE (and therefore KDevelop) use the SGML-Tools 1.x package (see <url url="http://www.sgmltools.org">), which was formerly known
as the LinuxDoc package. It contains a DTD called <tt/LinuxDoc/, and a set of mapping files for various output transformations and the
necessary tools that actually do the replacement of <tt/LinuxDoc/ tags. The LinuxDoc DTD is based on the Qwertz DTD which itself was
written to provide a good mapping (replacement of tags) especially for the &latex; text system, therefore is very usable to produce a
good printed output. The package then got it's name from the usage for writing documentation for the LDP (Linux Documentation Project)
and has only changed it's name due to the fact that it is an sgml-system that does not necessarily have a direct connection with the
Linux project but can be used on any Unix-System; you can as well write your own DTD and mappings if you ever like to.

In the meantime, another DTD as been made up to fit the same purpose: the "DocBook DTD". DocBook has obviously some advantages over the
LinuxDoc DTD mostly in providing better tags and mappings for tables and the inclusion of graphics, but that is possible with LinuxDoc
as well. The SGML-Tools therefore switched to provide support for the DocBook DTD in the 2.x version series, which also includes a
converter to produce a DocBook sgml from a LinuxDoc master.

The current state of KDE development is that we're still using the LinuxDoc DTD for some reasons:
<list>
<item>writing LinuxDoc documentation is easy
<item>installing the SGML-Tools 1.x for using LinuxDoc is even much easier
<item>KDE provides an additional tool called <tt/ksgml2html/ which adds the KDE documentation style to the output produced by the
SGML-Tools' 1.x <tt/sgml2html/ converter to produce HTML output.
</list>

I personally have encountered that while writing the KDevelop handbooks using the LinuxDoc DTD is very easy and lasts for the
requirements I need for writing the documentation. The learning curve is very high, so you will be a sgml-tools/LinuxDoc DTD guru
within days and that will save you a lot of time to work yourself into any formatting system such as &tex; for printed output for your
documentation or a markup language for HTML output.

One major reason for still using the sgml-tools 1.x is that most distributions ship with the package and all additional tools you need
for other output formats. This makes the installation as easy as possible and the writing itself isn't very complicated as you will
see. The output formats you can achieve witht the sgml-tools are:

<itemize>
<item>HTML output, with KDE look'n feel when using <tt/ksgml2html/ additionally
<item>plain text
<item>GNU info,
<item>Lyx format
<item>&tex;, DVI, PostScript and PDF format
<item>Rich Text Format (RTF)
</itemize>


<sect>What the Documentation already contains
<p>
When creating a KDevelop project, the subdirectory <tt>docs/en</tt> already contains the english <tt/index.sgml/ documentation file and
the already produced output HTML files. Those are already included into the project as well as their installation destination is preset
to the KDE HTML directory. The documentation is already adapted to your project name, version number and the programmer's information.
Further, the output covers the index.html file containing the table of contents (which is opened by KDE Help when the user requests
help); an installation introduction and a copyright information with regards to the GPL license.

Therefore, when extending the documentation, you only have to add the information that is specifically to your project. Mind that for
KDE projects you have to run "Make Doc-Handbook" from the "Project" menu again after the project is created. The index.sgml file is
again processed by <tt/<idx/ksgml2html// and the KDE-Style is added to the HTML output. Open the <tt>docs/en</tt> directory in the RFV
and add the <tt/logotp3.gif/ file to the project by the context-menu; then set the file properties correctly to install the logo file
into the same location the HTML files will go - to <tt>$(kde_htmldir)/en/&lt;your_project&gt;/logotp3.gif</tt>.

<sect>Writing SGML Documentation
<p>
This section has been added because SGML (or to be more precise: the LinuxDoc DTD) still seems to be difficult for beginners that want
to write documentation. When looking at some KDE applications, I have seen some that contain an sgml file which is the template - but
the author went over to edit the html output instead of the sgml file. This results in problems that translators have - if they want to
provide documentation for your application in their native language, they will have to edit each file as well in HTML and this makes it
impossible to reuse the documetation for other formats not only in the english version but all internationalized versions as well. You
see that this is very short-thinking and a bad situation; personally I think that this results from the author's knowledge of HTML but
not of SGML. As most will try to avoid learning a new formatting language, they will use the HTML output as the template that they
edit. If you once find out how easy (and useful) SGML with LinuxDoc is, you will know that it's worth to learn a few more tags that
built the SGML formatting.

The following sections will therefore introduce you to the most important parts of an LinuxDoc sgml file and how to extend your
documentation.

<sect1>The DTD Declaration
<p>
An SGML file, whatever DTD it may use, always has to start with the DTD declaration. This tells the SGML parser about which DTD to use.
Therefore, the first tag (a bracketed expression like &lt;yourtag&gt; your contents &lt;/yourtag&gt;) is always the DOCTYPE:

<verb>
&lt;!doctype linuxdoc system&gt;
</verb>

That tells your sgml formatter that it shall use the LinuxDoc DTD.

<sect2>The Document Structure
<p>
Now, when using the LinuxDoc, the next tag is the start tag for the document style type. The LinuxDoc DTD offers a whole set of types
that you can select from, dependent on the purpose of your document or it's legth. Available formats are:

<itemize>
<item><tt/&lt;notes&gt;/ for short explanations
<item><tt/&lt;article&gt;/ for writing articles with abt. 10-20 pages (suggested). This is used by the templates of KDevelop and most KDE
applications.
<item><tt/&lt;report&gt;/ for articles that are longer than an &lt;article&gt; type
<item><tt/&lt;book&gt;/ for writing large books - the KDevelop handbooks have been written using this document type
<item><tt/&lt;slides&gt;/ for slideshows. This is useful for presentations. You will use &latex; as output format in most cases, of
course.
<item><tt/&lt;letter&gt;/ for normal letters
<item><tt/&lt;telefax&gt;/ for a telefax
<item><tt/&lt;manpage&gt;/ for a manpage
</itemize>

Mind that these are only describing how the document structure will look like in general - not the actual output. As mentionend, the
KDevelop default generated template is using the &lt;article&gt; structure. This is used by most applications except KDevelop itself
which uses the &lt;book&gt; format. In the HTML output this doesn't really matter much - but for &latex; e.g. this makes much difference.
The handbooks are really "books" with separate pages for each chapter as the main difference.

What follows is that the end of the sgml file must have an end-tag for the document structure type - for &lt;article&gt; this would be
&etago;article&gt;.

<sect1>Titlepages
<p>
Now, after the document structure follows a section that describes all entries usually found on a titlepage. The predefined template
doesn't use this explicitely but only sets the information for <tt/&lt;title&gt;/, <tt/&lt;author&gt;/ and <tt/&lt;date&gt;/ as this
lasts for most purposes. Especially when using a <tt/&lt;book&gt;/ structure, you probably want to define a complete titlepage. The
following lists the according tags for this, taken from the sgml source of this handbook:

<code>
&lt;!doctype linuxdoc system&gt;
&lt;book&gt;
&lt;titlepag&gt;
&lt;title&gt;The KDevelop Programming Handbook
&lt;subtitle&gt;The User Guide to C++ Application Design for the K Desktop Environment (KDE) with the KDevelop IDE, Version 1.0
&lt;author&gt;
&lt;name&gt;Ralf Nolden &lt;htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de"
                                   name = "&lt;Ralf.Nolden@post.rwth-aachen.de&gt;"&gt;
&lt;inst&gt;The KDevelop Team
&lt;date&gt;Version 2.1 , July 7, 1999
&lt;abstract&gt;
This handbook itself is part of the KDevelop Integrated Development Environment
and is therefore also licensed under the GNU General Public License;
see &lt;ref id="Copyright" name="Copyright"&gt; for more information.
&etago;abstract&gt;
</code>

This covers all a normal titlepage usually contains. The <tt/&lt;author&gt;/ tag can also include a <tt/&lt;thanks&gt;/ tag to insert
some thanks to co-authors, lecturers etc. <tt/&lt;inst&gt;/ represents the institute or company for which the author wrote the
documentation; you could also use your team-name here like I did. <tt/&lt;abstract&gt;/ now covers an short description that is placed
on the titlepage as well. This is somewhat annoying on a printed version where this section would be printed on the back of the title
page where the copyright notice etc. are collected; this can be changed for &latex; output when editing the &tex; file.

<sect1>Indices
<p>
The LinuxDoc DTD defines a set of tags for various indices as they occur in usual documents. Those are:

<itemize>
<item>&lt;toc&gt; for the table of contents
<item>&lt;lof&gt; for the list of figures
<item>&lt;lot&gt; for the list of tables
</itemize>

The according start-tags don't necessarily require an end-tag; they're inserted just after the titlepage before the actual beginning of
the document with the according sections or chapters.

Now, when it comes to indexing keywords for an index that is placed at the end of the document, you are provided four different tags;
two which leave the indexed phrase within the page and two for index entries that are not displayed:

<list>
<item>&lt;idx&gt; for a normal index entry
<item>&lt;cdx&gt; for a true-type index entry
<item>&lt;nidx&gt; for an index entry not appearing in the text document
<item>&lt;ncdx&gt; as before for a tt-index entry
</list>

These tags are ignored by all backends (the tool that does the mapping of the sgml-tags to their document format) except
<tt/sgml2latex/, which generates an index file <tt/index.idx/ that can be turned to a &tex;-index with <tt/makeindex index.idx/. The
index itself can be inserted into the &tex; output file afterwards with <tt/\printindex/. I patched my mapping for the &latex; output to do
this automatically (but still don't know how to include the index into the table of contents...).

<sect1>The Document Contents
<p>
Now, after explaining most details of the general structure, we're coming to the actual document contents. Dependent on the document
structure type, has to start with a <tt/&lt;sect&gt;/ tag, when using <tt/&lt;book&gt;/ you have to start with <tt/&lt;chapt&gt;/
for the chapters.

After the start tag, you can structurize each chapter with <tt/&lt;sect1&gt;/, <tt/&lt;sect2&gt;/ etc. up to the allowed level of
sub-sections (4).

The chapter start tag is followed by the chapter's title. There, you have the additional choice to use <tt/&lt;title&gt;/ and
&etago;title&gt; for the chapter's title (optional). Now, afte the title of the chapter, you have to add a &lt;p&gt; tag to actually
start with the subsection's contents. Within that, you have almost all means to format your document with list, enumerations,
itemizations and description lists. Further, quotations, code snippets and the like can be inserted by tags; see you <tt/sgmltools/
documentation guide for a complete list. What you should look for is the "special characters" section. This contains all valid
replacements for characters that are different from the usual alphabet like brackets, slashes and symbols like trademark etc. With the
given tags you can structurize your text contents as you application documentation requires.

<sect>How to call Help in Dialogs
<p><nidx/help functions/
Calling help in dialogs is often done by adding a Help-button; then you add a slot that is called when the button gets pressed. Within
the slot implementation, call


<tscreen><verb>
kapp->invokeHTMLHelp( QString aFilename, QString aTopic );
</verb></tscreen>

where <tt/aFilename/ is the the filename to be called within your HTML documentation directory of the application; e.g index-3.html.
<tt/aTopic/ then is the topic that is to be called. The hash prefix is automatically added; just enter the chapter you want to have on
this page, actually this would be a subsection's name.


<chapt>Class Documentation with <idx/KDoc/
<p>
Another important part of the documentation is including a descriptive help for your class interfaces. This will allow you and other
programmers to use your classes by reading the HTML <idx/class documentation/ that can be created with <tt/<idx/KDoc//. KDevelop supports the use
of <tt/<idx/KDoc// completely by creating the KDE-library documentation, also your application frameworks are already documented. To work
yourself into the provided code, it would be a good start to read the included documentation online. The following describes what to do
to get the <idx/API/ documentation, where KDevelop helps you add it and what kind of special tags <tt/<idx/KDoc// provides additionally.

<sect>How to use KDevelop's Documentation features
<p>
To create the <idx/API/ documentation after you generated a project, select "Make <idx/API/-Doc" from the "Project" menu. This will process all
header files and create the HTML output. Then you can access the documentation by selecting "<idx/API/-Documentation" from the Help-menu or
the according book symbol in the Documentation tree, folder "Current Project".

The documentation is already cross-referenced to the KDE and <idx/Qt/ online-<idx/class documentation/, so you can follow the inheritance easily
with the inheritance overview. This may help you getting started with the KDE and <idx/Qt/ documentation as well.


<sect>Adding Class and Member Documentation
<p>
As KDevelop provides all means to add code automatically, it also offers direct documentation. Whenever you're using the Class
Generator by choosing "Project"->"New Class", add a descriptive help message to the documentation field. This will add the
documentation to the class header.

When adding class member functions and attributes with the <idx/classtools/, add the member documentation to the according documentation
fields as well.

You may think that documentation is a part of the development process that isn't very necessary. But remember that the more your
project grows and the more people take part on the development process, <idx/class documentation/ is the best help to save time. If
developers have to guess by method names what exactly the method does, it is even more likely that the meaning is misunderstood and the
method apparently doesn't do the job a developer guessed it would do. Therefore keep track of your documentation and rebuild it as
often as possible.

Besides this, the documentation files are NOT included into the project, nor do they have any internationalization support. Therefore
all <idx/API/ documentation should be held in English to allow international development groups to work with your sources.

Whenever you may want to add documentation by hand into the header file, just add the documentation <bf/above/ the method or class in a
C-comment style with the difference that the first line has to begin with a slash and a double asterisk.

Example:

<tscreen><verb>
  /** enables menuentries/toolbar items
  	*/
  void enableCommand(int id_);
</verb></tscreen>


<sect>Special Tags
<p>
<bf/NOTE:/ The following documentation of this chapter is taken from the <idx/KDoc/ documentation provided with <idx/KDoc/ by
Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">), author of <idx/KDoc/; Copyright (c) 1997

The documentation is a mixture of:

<itemize>
<item>Normal text. Paragraphs must be separated by at least one blank line.

<item>text of the form
<code>
&lt;pre&gt;
.....code fragments....
&lt;/pre&gt;
</code>
<item>Various tags of the form:
<tscreen><verb>
@tagname [tag parameters]
</verb></tscreen>
</itemize>


The valid tags for each type of source code entity are:

<itemize>
<item>Classes
<tscreen><verb>
  @short [one sentence of text]
    A short description of the class
  @author [one sentence of text]
    Class author
  @version [once sentence of text]
    Class version (I normally set this to the RCS/CVS tag "Id")
  @see [one or more references to classes or methods] 	
    References to other related documentation.
</verb></tscreen>

<item>Methods

<tscreen><verb>
  @see
    as above
  @return [one sentence]
    A sentence describing the return value
  @param [param name identifier] [param description]
    Describe a parameter. The param description can span multiple
    lines and will be terminated by a blank line, the end of the
    comment, or another param entry. For this reason, param entries
    should normally be the last part of the doc comment.
</verb></tscreen>

<item>Constants, Enums, Properties
<tscreen><verb>
  @see
    as above
</verb></tscreen>
<item>ALSO <tt/@ref/
		As a departure from the javadoc format, the metatag "@ref" has the same format as @see, but can appear anywhere in the documentation
(all other tags must appear on a line by themselves).
</itemize>

<chapt>Internationalization
<p>
<sect>What is i18n ?
<p>
i18n is an internationalization system that is used to offer internationalized versions of an application or project. The difficulty
with writing applications is that they only support the language they originally are composed with; visually this can be seen on
labels, menu entries and the like. Goal of the internationalization is to provide applications and library functions in the language of
the user; therefore enabling users that are not capable of the original language to make use of the provided functionality and feel
more comfortable.

<sect>How KDE supports Internationalization
<p>
KDE, as one of the most modern desktop environments, has set one of its numerous goals to provide applications for users in their
native languages, and simplifies the work for developers to provide their application in any of the supported language.

Technically, this is realized by the <idx/KDE File System/ Standard which contains localization support for languages in terms of
documentation and by providing application internationalization through the use of the KDE-core library class <tt/KLocale/. This class
does all the translation, dependent on the preferred language set in the KDE Control Center.

The developer on the other hand only has to know two things to make his application able to use this feature:

<enum>
<item>include <tt/<cdx/kapp.h// into your sourcecode wherever a visible text appears in your application, e.g. in source files that contain
<idx/QLabel/s.
<item>wherever you set the visual string, embrace it with the <tt/i18n()/ macro provided by <tt/<cdx/kapp.h// to enable translation.
<item>whenever you have to access a locale object, use the <tt/klocale/ macro provided by <tt/<cdx/kapp.h//
</enum>

That is almost all you have to watch for while coding. Mind that you should not internationalize any configuration strings that are
used by <tt/<cdx/KConfig//, because this is not necessary on one hand and doesn't work for reading in values on the other.

<sect>Adding a Language to your Project
<p>
KDevelop also takes part on making life easier for developers to include native language support to their applications. Whenever you
create a new KDE project, a <tt/po/ directory is added to the main project directory. There, your <em/&lt;application&gt;/.pot file
will be placed after the generation is complete. The .pot file already contains all strings that are set up with the i18n() macro,
therefore you only have to write your code using the macro again. From time to time, you should do a "Project"-"Make messages and
merge", which will automatically extract all macros again and rebuilds the potfile.
<nidx/"Project"-menu/<nidx/PO-files/<nidx/translations/<ncdx/KLocale/

To add a language to your application, choose "Project"-"Add translation file", which opens the language selection dialog. Select the
desired language and press OK. Then, the according <em/&lt;lang&gt;/.po file will be build in the <tt/po/ directory. Then start
translating the po file by selecting it from the po directory in the Real File Viewer or from the LFV, folder "Translations". If you
have <idx/KTranslator/ installed, it will be opened in the "Tools" window with <idx/KTranslator/, otherwise as a text file in the header/resource
window.
<idx/KTranslator/ makes it very easy to translate strings by scanning the existing translations of your local KDE installation, so they can
be used already.

For editing by hand, we'll have a look at an example:
<tscreen><verb>
#: kscribble.cpp:619
msgid "Opens an existing document"
msgstr ""
</verb></tscreen>

The above shows a string that was extracted from the file <tt/kscribble.cpp/ at line 619. <tt/<cdx/msgid// and <tt/<cdx/msgstr// are the tags which
give the information for the translation; <tt/<cdx/msgstr// will contain the translated string. There, you have to watch escape sequences
such as \n or \t, which have to be included into the translation string. A German translation would therefore look like this:

<tscreen><verb>
#: kscribble.cpp:619
msgid "Opens an existing document"
msgstr "Öffnet ein existierendes Dokument"
</verb></tscreen>

That would be all to watch for translation; after you're done, save the file. When make is run within the po directory, the message
files will be processed and errors may occur if strings are not translated consistently, e.g. escape sequences are missing. Then edit
the according message string again and make sure that make runs without errors.

Additionally, you should be very careful when translating ampersands within text strings. The letters after ampersands are used as
keyboard accelerator<nidx/accelerator/s in conjunction with the ALT key to access menubar or popup menu items to change the <idx/keyboard focus/ to the
selected item more quickly. Now, if the same accelerator<nidx/accelerator/ letter appears in the same <idx/keyboard focus/ area (which would be the main widget
on one time, and a dialog at another), each widget after the first one cannot be accessed by the supposed keyboard accelerator<nidx/accelerator/. So even
translators have a responsibility for the usage of the application under their language. There is also no guarantee that the original
letter will occur in the translation, so translators have to choose very carefully and should test the application under their language
after they installed the translation to ensure it runs without these malfunctions.

<sect>Translation Team Contacts
<p>
The KDE Team also provides numerous contacts to developers that are contributing to the KDE project as translators. Those are organized
in language teams and coordinate the translation work.
For an actual list and information who to ask for translating your application, see <url url="http://www.kde.org">.

The information below is taken from the KDE web site and contains the current contact addresses as of March 06, 1999. If you want to join
a team please write directly to one of the team coordinators.

The translation of the KDE is organized by Juraj Bednar <htmlurl url="mailto:bednar@rak.isternet.sk"
name="mailto:bednar@rak.isternet.sk"> and Matthias Elter <htmlurl url="mailto:me@kde.org" name="me@kde.org">

You can subscribe KDE internationalization mailing list kde-i18n-doc@kde.org by sending a mail to <htmlurl
url="mailto:kde-i18n-doc-request@kde.org?subject=subscribe" name="kde-i18n-doc-request@kde.org"> with the word "subscribe" in the
subject line.

Before starting any translation work, please contact the according translation team leaders for coordination to avoid double work.

<descrip>


<tag/br Breton translation team:/
team coordinators: Jañ-Mai DRAPIER <htmlurl url="mailto:jdrapier@club-internet.fr" name="jdrapier@club-internet.fr">
website: <htmlurl url="http://perso.club-internet.fr/jdrapier" name="http://perso.club-internet.fr/jdrapier">

<tag/ca Catalan translation team:/
team coordinators: Sebastià Pla <htmlurl url="mailto:sastia@redestb.es" name="sastia@redestb.es">

<tag/cs Czech translation team:/
team coordinators:  Miroslav Flídr <htmlurl url="mailto:flidr@kky.zcu.cz" name="flidr@kky.zcu.cz">

<tag/da Danish translation team:/
team coordinators:  Erik Kjær Pedersen <htmlurl url="mailto:erik@binghamton.edu" name="erik@binghamton.edu">

<tag/de German translation team:/
team coordinators: Thomas Diehl <htmlurl url="mailto:th.diehl@gmx.net" name="th.diehl@gmx.net">
website: <url url="http://www.dtp-service.com/kde/de/">
mailing list:  send a mail with 'subscribe' in the subject line to: <htmlurl url="mailto:kde-i18n-de-request@kde.org?subject=subscribe"
name="kde-i18n-de-request@kde.org"> Webforum for discussions and user feedback: <url url="http://www.dtp-service.com/discus_d">

<tag/el Greek translation team:/
team coordinators:  Theodore J. Soldatos <htmlurl url="mailto:theodore@eexi.gr" name="theodore@eexi.gr">

<tag/eo Esperanto translation team:/
team coordinators:  Wolfram Diestel <htmlurl url="mailto:diestel@rzaix340.rz-uni-leipzig.de" name="diestel@rzaix340.rz-uni-leipzig.de">

<tag/es Spanish translation team:/
team coordinators:  Boris Wesslowski, Alonso Lara <htmlurl url="mailto:Boris@Wesslowski.com" name="Boris@Wesslowski.com">
website: <url url="http://members.xoom.com/keko5/">
mailing list: send a mail with 'subscribe' in the subject line to <htmlurl url="mailto:kde-es@kde.org?subject=subscribe"
name="kde-es@kde.org">

<tag/et Estonian translation team:/
team coordinators:  Hasso C. Tepper <htmlurl url="mailto:hasso@ewsound.estnet.ee" name="hasso@ewsound.estnet.ee">

<tag/fi Finnish translation team:/
team coordinators: Kim Enkovaara <htmlurl url="mailto:kim.enkovaara@iki.fi" name="kim.enkovaara@iki.fi">

<tag/fr French translation team:/
team coordinators:  Francois-Xavier Duranceau <htmlurl url="mailto:Francois-Xavier.Duranceau@loria.fr" name="Francois-Xavier.Duranceau@loria.fr">
website: <url url="http://www.loria.fr/~durancea/kde/wip-apps.html">
mailing list: send an empty mail to:  <htmlurl url="mailto:kde-traduc-fr-subscribe@egroups.com" name="kde-traduc-fr-subscribe@egroups.com">

<tag/he Hebrew translation team:/
team coordinators:  Erez Nir <htmlurl url="mailto:erez-n@actcom.co.il" name="erez-n@actcom.co.il">

<tag/hr Croatian translation team:/
team coordinators:  Vladimir Vuksan <htmlurl url="mailto:vuksan@veus.hr" name="vuksan@veus.hr">

<tag/hu Hungarian translation team:/
team coordinators:  Marcell Lengyel <htmlurl url="mailto:miketkf@yahoo.com" name="miketkf@yahoo.com">
website:<url url="http://sophia.jpte.hu/~kde">

<tag/is Icelandic translation team:/
team coordinators:
Logi Ragnarsson, <htmlurl url="mailto:logir@imf.au.dk" name="logir@imf.au.dk">
Thorarinn R. Einarsson, <htmlurl url="mailto:thori@mindspring.com" name="thori@mindspring.com">
Bjarni R. Einarsson, <htmlurl url="mailto:bre@netverjar.is" name="bre@netverjar.is">
Hrafnkell Eiriksson, <htmlurl url="mailto:hkelle@rhi.hi.is" name="hkelle@rhi.hi.is">
Gudmundur Erlingsson, <htmlurl url="mailto:gudmuner@lexis.hi.is" name="gudmuner@lexis.hi.is">
Richard Allen <htmlurl url="mailto:ra@hp.is" name="ra@hp.is">

<tag/it Italian translation team:/
team coordinators:  Andrea Rizzi <htmlurl url="mailto:rizzi@kde.org" name="rizzi@kde.org">

<tag/ko Korean translation team:/
team coordinators:  LinuxKorea Co. <htmlurl url="mailto:kde@linuxkorea.co.kr" name="kde@linuxkorea.co.kr">

<tag/mk Macedonian translation team:/
team coordinators:  Sasha Konecni <htmlurl url="mailto:sasha@msi-uk.com" name="sasha@msi-uk.com">

<tag/nl Dutch translation team:/
team coordinators:  flidr@CyberGate.zcu.cz <htmlurl url="mailto:flidr@CyberGate.zcu.cz" name="flidr@CyberGate.zcu.cz">

<tag/no Norwegian translation team:/
team coordinators:  Hans Petter Bieker <htmlurl url="mailto:zerium@webindex.no" name="zerium@webindex.no">

<tag/pl Polish translation team:/
team coordinators:  Piotr Roszatycki <htmlurl url="mailto:dexter@fnet.pl" name="dexter@fnet.pl">

<tag/pt Portuguese translation team:/
team coordinators:  Pedro Morais <htmlurl url="mailto:pmmm@camoes.rnl.ist.utl.pt" name="pmmm@camoes.rnl.ist.utl.pt">

<tag/pt_BR Brazil Portuguese translation team:/
team coordinators:  Elvis Pfützenreuter <htmlurl url="mailto:epx@netville.com.br" name="epx@netville.com.br">

<tag/ro Romanian translation team:/
team coordinators:  Paul Ionescu <htmlurl url="mailto:ipaul@romsys.ro" name="ipaul@romsys.ro">

<tag/ru Russian translation team:/
team coordinators:  Denis Y. Pershin <htmlurl url="mailto:dyp@inetlab.com" name="dyp@inetlab.com">

<tag/sk Slovak translation team:/
team coordinators:  Juraj Bednar <htmlurl url="mailto:bednar@isternet.sk" name="bednar@isternet.sk">
mailling list:  send a mail with 'subscribe' in the subject line to: <htmlurl url="mailto:sk-i18n@rak.isternet.sk?subject=subscribe"
name="sk-i18n@rak.isternet.sk">

<tag/sl Slovenian translation team:/
team coordinators:  blazzupancic@hotmail.com <htmlurl url="mailto:blazzupancic@hotmail.com" name="blazzupancic@hotmail.com">

<tag/sv Swedish translation team:/
 team coordinators:  Anders Widell <htmlurl url="mailto:d95-awi@nada.kth.se" name="d95-awi@nada.kth.se">

<tag/tr Turkish translation team:/
team coordinators:  Gorkem Cetin <htmlurl url="mailto:gorkem@linux.org.tr" name="gorkem@linux.org.tr">

<tag/zh_GB2312 Simplified Chinese translation team:/
team coordinators:  Wang Jian <htmlurl url="mailto:larkw@263.net" name="larkw@263.net">

<tag/zh_TW_Big5 Chinese BIG5 translation team:/
team coordinators:  Chou Yeh-Jyi <htmlurl url="mailto:ycchou@ccca.nctu.edu.tw" name="ycchou@ccca.nctu.edu.tw">
</descrip>



<chapt>Finding Errors
<p><nidx/debugging macros/
<sect>Debugging Macros provided by <idx/Qt/
<p>
The Debugging Macros provided by the <idx/Qt/ library can be read on the debug.html page of your <idx/Qt/ Online Reference
Documentation, acessable on the link "Debugging Techniques" at the <idx/Qt/ Documentation index page.

The most recently used macros are

<itemize>
<item>ASSERT(b)
<item>CHECK_PTR(p)
</itemize>

Thereby, b is a boolean expression. Gives out a debugging warning if b is false; p is a pointer which is checked and gives out a
warning, if p is null.

Details can be found in the <idx/Qt/ Online Reference.

<sect>KDE Macros
<p>
<bf/NOTE:/ This chapter is a copy of Kalle Dalheimer's <htmlurl url="mailto:kalle@kde.org" name="kalle@kde.org"> explanation document
about the <idx/KDEBUG/ macros included with the KDE libs package as kdebug.html

Last modified: Sat Sep 13 11:56:01 CEST 1997


<bf/What is KDebug/

KDebug is a system of macros and functions that makes using diagnostic messages in your code more efficient. You can give a message
one out of four severity level and an area. You can choose at runtime where diagnostic messages should go and which of them should be
printed at all. How to use KDebug in your code

<bf/The macro <idx/KDEBUG//

Using KDebug is very simple. All you have to do is to #include &lt;kdebug.h&gt; at the beginning of every source file in which you want
to use diagnostic messages and output the messages by calling the macro <idx/KDEBUG/. This macro expects three parameters. The first is the
severity level. Use one of the following constants:

<itemize>
<item><idx/KDEBUG_INFO/
<item><idx/KDEBUG_WARN/
<item><idx/KDEBUG_ERROR/
<item><idx/KDEBUG_FATAL/
</itemize>

The second parameter is the area. An area is a part of KDE that you define yourself. You can then at runtime choose from which areas
diagnostic messages should be printed. Please see the file kdelibs/kdecore/kdebugareas.txt for a list of already allocated area ranges.
Choose an area within the range allocated for your application. If your application is not yet in here and you have CVS access, you can
allocate a range for your application here, otherwise just mail me. It is probably a good idea to define symbolic constants for the
areas you want to use, but this is completely up to you. The third parameter, finally, is the text you want to output. KDebug
automatically prepends the logical application name if you output to a file, to stderr or to syslog. A newline is always appended, you
need not (and should not) use one yourself. If you need parameters, you can use one of the macros KDEBUG1, ..., KDEBUG9. These allow
for one to nine additional arguments. The syntax is exactly the same as with printf, i.e. you have to include format specifiers in your
message which get replaced by the additional parameters. An example:

<tscreen><code>
KDEBUG3( <idx/KDEBUG_INFO/, kmail_composer, "Message no. %d to %s has %d bytes",
          message_no, aMessage.to(), aMessage.length() );
</code></tscreen>


<bf/<idx/KASSERT//

There are also the macros KASSERT, KASSERT1, ..., KASSERT9 which work just like their <idx/KDEBUG/-counterparts, except that they have an
additional bool as their first parameter. Only if this evaluates to false will the message be output. Note: You should not use neither
<idx/KDEBUG/ nor <idx/KASSERT/ before the <cdx/KApplication/ object is constructed. Note 2: KDebug provides no means for internationalization because it
is meant strictly for developers only. If you want to inform the user about an erroneous condition (like "this file is not writable"),
use KMsgBox.

<bf/Compiler switches/

You do not need any special compiler switches in order to use KDebug. But when you ship your
product (this mainly applies to people who create distributions like .rpm or .deb packages), you should compile with the switch
-DNDEBUG. This will simply remove all the debugging code from your application and make it smaller and faster (e.g. it uses 256K less
non-shareable memory).


<bf/How to manage diagnostic messages at runtime/

You can press Ctrl-Shift-F12 in every <cdx/KApplication/ at any time, and the "Debug Settings"-Dialog will appear. Here you can define
separately for every severity level what should be done with the diagnostic messages of that level. The following settings are
available:

<itemize>
<item>Output: In this Combobox, you can choose where the messages should be output. The choices are: "File", "Message Box", "Shell"
(meaning stderr) and "syslog". Please do not direct fatal messages to syslog unless you are the system administrator yourself. The
default is "Message Box".
<item>File: This is only meaningful when you have chosen "File" as the output and provides the name of that file (which is interpreted
relatively to the current directory). The default is kdebug.dbg.

<item>Area: The areas which should only be output. Every message that is not mentioned here will simply not be output (unless this
field remains empty which is the default and means that all messages should be output). Your can enter several areas separated by
commas here, and you can also use area ranges with the syntax start-end. Thus a valid entry could be: 117,214-289,356-359,221. Please
do not use whitespace.
</itemize>

Apart from this, you can also tick the checkbox "Abort on fatal errors". In this case, if a diagnostic message with the severity level
"<idx/KDEBUG_FATAL/" is output, the application aborts with a SIGABRT after outputting the message. When you close the dialog with OK, your
entries apply immediately and saved in your application's configuration file. Please note that these settings are specific for one
singular application! When you press cancel, your entries are discarded and the old ones are restored.

<chapt>The KDE File System Standard
<p>
This chapter is a copy of the KDE-File System Standard as published on the KDE website at <url url="http://www.kde.org">, written by
Richard Moore <htmlurl url="rich@kde.org" name="rich@kde.org">

<bf/KDE File System Standard/

This file documents the directory structure that KDE and all KDE compliant applications should use. This is version 0.0.4 of the
standard.

<sect>Introduction
<p>
The purpose of the <idx/KDE FSSTD/ is to ensure that all resources (icons, mimetypes etc.) needed for <idx/KDE applications/ are stored in a
consistent directory structure. Following this structure allows applications to make use of tools such as the KIconLoader class and
allows separation of the platform specific data needed by KDE from platform independent data (making installations on multiple
architectures possible). In this document directory names have been suffixed with a `/` character. Where the word 'appname' appears in
angle brackets &lt;like this&gt; it means that there should be an entry corresponding to every installed KDE application. The word
'lang' is used in the same way to indicate that there should be an entry for every supported language named according to the standard
two letter language codes eg. 'fr' for French, 'de' for German etc.

<sect>Directory Layout
<p>
The KDE directory structure is as shown below, the top of the KDE installation tree is usually '/opt/kde' and can be found at run time
by using the kdedir() method of <cdx/KApplication/ (this replaces the KDEDIR environment variable the use of which is now deprecated). This
document will refer to this directory as kdedir().
<nidx/KDE File System/<nidx/.kdelnk files/

<itemize>
<item>kdedir()/
  <itemize>
  <item>bin/
  	<itemize>
  	<item>Application binaries
  	</itemize>
  <item>lib/
  	<itemize>
  	<item>standard kde libraries (libkdecore etc.)
  	<item><em/&lt;appname&gt;//
  		<itemize>
  		<item>Application specific data that is platform dependent
  		</itemize>
  	</itemize>
  <item>include/
  	<itemize>
  	<item>standard kde header files
  	</itemize>
  <item>parts/
  <item>cgi-bin/
  	<itemize>
  	<item>CGI programs for kdehelp
  	</itemize>
  <item>share/
  	<itemize>
  	<item>doc/
  		<itemize>
  		<item>HTML/
  			<itemize>
  			<item>default --> Link to kdedir()/share/doc/HTML/en
  			<item><em/&lt;lang&gt;//
  				<itemize>
  				<item><em/&lt;appname&gt;//
  					<itemize>
  					<item>index.html
  					<item>other application help files
  					</itemize>
  				</itemize>
  			</itemize>
  		</itemize>
  	<item>config/
  	<item>applnk/
  		<itemize>
  		<item>System/
  		<item>Utilities/
  		<item>Applications/
  		<item>Games/
  		<item>kfind<idx/.kdelnk/
  		<item>khelp<idx/.kdelnk/
  		<item>khome<idx/.kdelnk/
  		<item>krefresh<idx/.kdelnk/
  		</itemize>
  	<item>mimelnk/
  		<itemize>
  		<item>magic
  		<item>text/
  		<item>audio/
  		</itemize>
  	<item>partlnk/
  		<itemize>
  		<item><em/&lt;partname&gt;/<idx/.kdelnk/
  		</itemize>
  	<item>icons/
  		<itemize>
  		<item>Icons used in kdelnk files
  		<item><em/&lt;appname&gt;/.xpm
  		<item>mini/
  			<itemize>
  			<item>Mini Icons for kpanel
  			</itemize>
  		</itemize>
  	<item><idx/toolbar//
  		<itemize>
  		<item>Standard <idx/toolbar/ pixmaps (eg. fileopen.xpm)
  		</itemize>
  	<item>wallpapers/
  		<itemize>
  		<item>Wallpapers used by kdisplay
  		</itemize>
  	<item>apps/
  		<itemize>
  		<item><em/&lt;appname&gt;//
  			<itemize>
  			<item><idx/toolbar//
  				<itemize>
  				<item>Toolbar pixmaps
  				</itemize>
  			<item>pics/
  				<itemize>
  				<item>Other application pixmaps
  				</itemize>
  			<item>application specific data (must be platform independent)
  			</itemize>				
  		<item><em/&lt;libname&gt;//
  			<itemize>
  			<item>pics/
  			</itemize>
  		</itemize>
  	<item>locale/
  		<itemize>
  		<item><em/&lt;lang&gt;//
  			<itemize>
  			<item>LC_MESSAGES/
  				<itemize>
  				<item><em/&lt;appname&gt;/.mo
  				</itemize>
  			</itemize>
  		</itemize>
  	</itemize>
  </itemize>
</itemize>
					
<sect>What does this mean to application developers?
<p>
A standard KDE application will install files into several places in the above structure. The only required items are the application
binary, the application kdelnk file, the application icon and the application help files - all others are optional. The most common
things that are installed are:

<tscreen><verb>
Type of file                                      Location

Application binary (required)                     kdedir()/bin/
Application kdelnk file (required)                kdedir()/share/applnk/
Application icon (required)                       kdedir()/share/icons/&lt;appname&gt;.xpm
Application help files (required)                 kdedir()/share/doc/default/HTML/&lt;appname&gt;/&lt;index&gt;.html
Application toolbar pixmaps                       kdedir()/share/apps/&lt;appname&gt;/toolbar/
Application platform independent data             kdedir()/share/apps/&lt;appname&gt;/
Application platform specific data                kdedir()/lib/&lt;appname&gt;/
</verb></tscreen>
<nidx/KDE File System/

<sect>Application Documentation
<p>
I've suggested making putting at least a single page in

kdedir()/doc/default/HTML/&lt;appname&gt;/&lt;appname&gt;.html

a requirement for KDE compliance. The application is free to use the directory to store any help data it requires.


Applications that support more than one language would place the other languages inkdedir()/doc/&lt;lang&gt;/HTML/&lt;appname&gt;/&lt;appname&gt;.html
with there being one 'lang' directory for each language code as usual. Arranging the files like this would allow links between the help
files of two different applications that both support a given language.

I am not 100% happy with the solution I've suggested as it does not allow any way to fall back to the default language if a required
translation is not available.

<sect>What does this mean to library developers?
<p>

<itemize>
<item>kdedir()/share/apps/&lt;libname&gt;/<idx/toolbar/
</itemize>
Toolbar icons for library widgets.

<itemize>
<item>kdedir()/share/apps/&lt;libname&gt;/pics
</itemize>
Any other bitmaps for library widgets.

<chapt>File System Usage for KDevelop Projects
<p>
As the last chapter covered the KDE File System Standard, this chapter deals with what you have to do to use the file system. A KDE
project uses the file system at least for installation routines; therefore we will discuss setting installation properties for your
project files. Your application may make use of files that are installed afterwards, where it is important to know how to get the
relative pathname by the standard. This enables your application to work wherever the KDE file system may be and prevents hard-coding
any file information.

<sect>Accessing Files during Runtime
<p>
After the installation of your project by end-users, your application may require file information during runtime. During the
development process, you will experience at least one error which is caused when running your application within the KDevelop IDE and
requiring the application manual by "Help"-"Contents" or pressing the F1 key. This will result in a message box, saying that the
index.html file could not be found- if you haven't installed your application on your local KDE file system. Your application asks
<idx/KDEHelp/ to open your index page with detecting the installation directory first through <tt/<cdx/KApplication//'s methods to access the file
system, therefore, we will have a look at what <tt/<cdx/KApplication// offers and make some example usage. Also other classes of
<tt/KDE-Core/ make use of the KDE File System like <tt/KIconLoader/ and <tt/KLocale/, which will be reviewed afterwards.

<sect><cdx/KApplication/ Methods
<p>

The <cdx/KApplication/ class offers the following methods to access the KDE File System:
<tscreen><verb>
void invokeHTMLHelp ( QString aFilename, QString aTopic ) const
static const QString& kde_htmldir ()
static const QString& kde_appsdir ()
static const QString& kde_icondir ()
static const QString& kde_datadir ()
static const QString& kde_localedir ()
static const QString& kde_cgidir ()
static const QString& kde_sounddir ()
static const QString& kde_toolbardir ()
static const QString& kde_wallpaperdir ()
static const QString& kde_bindir ()
static const QString& kde_configdir ()
static const QString& kde_mimedir ()
static QString localkdedir ()
static QString localconfigdir ()
static QString findFile ( const char *file )
</verb></tscreen>
<nidx/KDE File System/
The methods are generally used with the <tt/<cdx/KApplication// object of your application, where <tt/<cdx/KApplication// offers the macro
<tt/kapp/ to receive the pointer:

#define kapp <cdx/KApplication/::getKApplication()

Therefore, the methods are generally used like this:
<tscreen><verb>
QString sounddir=kapp->kde_sounddir();
</verb></tscreen>
This example stores the path of the KDE sounddirectory under a <tt/QString/, where you would append e.g. the sound filename. Then you
can process this information and play a sound file that is located there. You should always test for the existence of a file by using
<tt/QFileInfo/'s <tt/exists()/ method.

Within these methods,

<tscreen><verb>
void invokeHTMLHelp( QString aFilename, QString aTopic ) const [public]
</verb></tscreen>

takes a special position to invoke the KDE help. Generally, you should use it everywhere a user needs to access information, e.g. when
he is presented a modal dialog. The F1 key will not work to invoke the help contents, also the user should be presented the according
help page. To make a good use of it, add a "Help" button to your dialog and create a slot that is used to connect on signal
<tt/pressed()/. In this method, use <tt/<cdx/invokeHTMLHelp()// with the according page and subject; in case your application's documentation
isn't written completely yet, leave this open to complete it after the documentation is in sync with the application.

The documentation of <tt/<cdx/KApplication// says:

Invoke the kdehelp HTML help viewer.

Parameters: aTopic
This allows context-sensitive help. Its value will be appended to the filename, prefixed with a "#" (hash) character.

aFilename: The filename that is to be loaded. Its location is computed automatically according to the KFSSTND. If aFilename is empty,
the logical appname with .html appended to it is used.


The methods of  <tt/<cdx/KApplication// will retrieve the following path's.

<tscreen><verb>
kde_htmldir()         kdedir()/share/doc/HTML         Returns the directory where KDE stores
                                                      its HTML documentation

kde_appsdir()         kdedir()/share/applnk           Returns the directory where KDE applications
                                                      store their .kdelnk file

kde_icondir()         kdedir()/share/icons            Returns the directory where KDE icons are stored

kde_datadir()         kdedir()/share/apps             Returns the directory where KDE applications
                                                      store their specific data

kde_localedir()       kdedir()/share/locale           Returns the directory where locale-specific
                                                      information (like translated on-screen messages) are stored

kde_cgidir()          kdedir()/cgi-bin                Returns the directory where cgi scripts are stored

kde_sounddir()        kdedir()/share/sounds           Returns the directory where sound data are stored.
                                                      This directory is for KDE specific sounds.
                                                      Sound data of Applications should go
                                                      into kde_datadir()

kde_toolbardir()      kdedir()/share/toolbar          Returns the directory where toolbar icons are stored

kde_wallpaperdir()    kdedir()/share/wallpapers       Returns the directory where KDE wallpaper files are stored

kde_bindir()          kdedir()/bin                    Returns the directory where KDE application binaries are stored

kde_configdir()       kdedir()/share/config           Returns the directory where config files are stored

kde_mimedir()         kdedir()/share/mimelnk          Returns the directory where mimetypes are stored

localkdedir()         $HOME/.kde                      Get the local KDE base dir

localconfigdir()      $HOME/.kde/share/config         Get the local KDE config dir
</verb></tscreen>

To search for a specific file, use <tt/findFile(const char *file)/ which will search several path's of the KDE File System:

<enum>
<item>$KDEDIR,
<item>$KDEPATH,
<item>"&lsqb;KDE Setup&rsqb;:Path=" entry in a config file.
</enum>

If the file is not found, the QString method isEmpty() will  return True

<sect>KIconLoader Methods
<p>

QPixmap loadIcon ( const QString &amp;name, int w = 0, int h = 0 )

QPixmap reloadIcon ( const QString &amp;name, int w = 0, int h = 0)

QPixmap loadMiniIcon ( const QString &amp;name , int w = 0, int h = 0 )

QPixmap loadApplicationIcon ( const QString &amp;name, int w = 0, int h = 0 )

QPixmap loadApplicationMiniIcon ( const QString &amp;name, int w = 0, int h = 0 )

bool insertDirectory ( int index, const QString &amp;dir_name )


<sect>Setting File Installation Properties
<p>
As the above explained where <idx/KDE applications/ should place their files and how to access them at runtime, the following will explain
how to set the file properties correctly to ensure the files get installed at the right place. The Makefiles support a set of macros to
install your files into the KDE File System and which have to be used for setting the file installation properties.

To set the properties, open your project and select "Project"-"File Properties" which opens the File Properties dialog.
The file properties are displayed if you select a filename currently included in the project. First of all, a file has a type property,
which can be one of the following:

<itemize>
<item><bf/HEADER:/  specifies a file as a header file
<item><bf/SOURCE:/ specifies a file as a source file
<item><bf/SCRIPT:/ specifies a file as a script file
<item><bf/DATA:/ specifies a file as a data file that usually gets installed like pixmaps or HTML documentation files
<item><bf/PO:/ specifies a file as a translation file
<item><bf/KDEV_DIALOG:/ specifies a file as a dialog file to be interpreted by the dialog library
</itemize>

Further, a file is included in the project, if "Include in Distribution" is checked. This ensures that the file is included in the
distribution tarball or package.

If a file has to be installed, you have to enable "Install". This will allow setting the Installation path for the selected file, where
the filename is already inserted.

Now, as said above, the Makefile already is capable of a set of macros for the KDE File System Standard. These are used to set the
installation path and ensure that the files actually will land in the KDE file system and not somewhere else. Macros that can be used,
have to be embraced in round brackets and are marked with the dollar sign in front of the macro. When configure builds the Makefiles on
the end-user's system, it will determine values for these macros that match the real directory name and will expand the Makefile.am
macro towards the actual destination.

When looking a standard KDE application project, you will see on the file property of your <tt/index.html/ file that it already uses a
macro to determine where it should go:

$(kde_htmldir)/en/kscribble/index.html

This says, that make should install the file index.html in the kde-html directory, subdirectory en for English, the application
subdirectory and the filename. You could as well use another filename if you like to rename the file on the installation destination.

For the destination of your binary you currently have to edit the project's Makefile.am if your destination should be different form
the "Applications" section of kpanel:

APPSDIR = $(kde_appsdir)/Applications

Possible values are (as the KDE-File System Standard says):

<itemize>
<item>Applications
<item>Games
<item>Graphics
<item>Internet
<item>Multimedia
<item>Settings
<item>System
<item>Utilities
</itemize>

Setting no directory will end your applnk directly in kpanel's root.

The following list contains the macros that can be used in the installation setup for files:

<tscreen><verb>
kde_htmldir       Where your docs should go to. (contains lang subdirs)
kde_appsdir       Where your application file (.kdelnk) should go to.
kde_icondir       Where your icon should go to.
kde_minidir       Where your mini icon should go to.
kde_datadir       Where you install application data. (Use a subdir)
kde_locale        Where translation files should go to.(contains lang subdirs)
kde_cgidir        Where cgi-bin executables should go to.
kde_confdir       Where config files should go to.
kde_mimedir       Where mimetypes should go to.
kde_toolbardir    Where general toolbar icons should go to.
kde_wallpaperdir  Where general wallpapers should go to.
</verb></tscreen>

Use these macros in conjunction with the according necessary subdirectories and the filename for setting the installation properties.
By default, the currently created HTML documentation files, the kdelnk file, Icon, Miniicon and the translation files (also newly
create ones) are already set up for their destination; therefore you don't have to make any changes for your default installation
routine that has been set up by the application wizard of KDevelop.

<sect>Organizing Project Data
<p>
Another issue in creating projects often appears to the programmer if he has or wants to include additional data that have to be
installed with the project. You already know where to install it, but what about organizing it in the source tree ?

A good advice here may be to collect all data in directories that more or less match the KDE File System Standard, e.g. your
application needs additional <idx/toolbar/ icons. Creating these icons in the main project directory is potentially not a good idea as they
will be difficult to locate in the real file viewer and a removal will result in much work for each icon. Therefore, create your icon
with "File"- "New" and choose a subdirectory <tt/<idx/toolbar//; if it doesn't exist, it can be easily created with the "select directory"
dialog. Existing icons can be copied and included into the project with "Project"-"Add existing file(s)", where you have to choose the
files and the destination. When selecting the destination directory, you can create the <tt/<idx/toolbar// subdirectory first within the
selection dialog. After being finished, press OK and the files will be copied as well as included in the project.

As an example, a <idx/toolbar/ icon should go to the following:

$(kde_datadir)/<em/&lt;appname&gt;//<idx/toolbar//<em/&lt;youricon&gt;/.xpm

Pictures or additional icons that are not used as <idx/toolbar/ icons should go to a subdirectory <em/pics/ instead of <em/<idx/toolbar//.

<sect>The <tt/kdelnk/ File
<p>
The <em/&lt;appname&gt;/<idx/.kdelnk/ file currently included in your project will install itself in KDE's kpanel structure. You should think
it is already created and complete, therefore shouldn't require any further notification. Despite of KDevelop's advanced qualities to
help you with creating, programming and designing applications, it cannot determine the exact purpose of your application- and that is
the information you have to add to the kdelnk file. As this is a text file, select it from the RFV or the LFV; it will be opened in the
Header/Resource window.

The sample kdelnk file would look like this:
<tscreen><verb>
# KDE Config File
&lsqb;KDE Desktop Entry&rsqb;
Type=Application
Exec=kscribble
Icon=kscribble.xpm
DocPath=kscribble/index.html
Comment=
Comment&lsqb;de&rsqb;=
Terminal=0
Name=kscribble
Name&lsqb;de&rsqb;=kscribble
</verb></tscreen>

This already contains the basic configuration for the application specific data such as the icon, binary name, application name etc.
You see that the section Comment is still empty. There you have to insert the Quick-Tip that will be displayed when the mouse cursor
moves over the kdelnk file icon on the desktop or in kpanel. If scribble would be a small drawing program, you would enter e.g.

<tscreen><verb>
Comment=A simple drawing program
</verb></tscreen>

Each comment line afterwards will contain the same description translated in the language the brackets symbolize. Ask translators to
insert a good translation in their native language or include the kdelnk file when asking for translating the application's po file;
the same applies to the name of the application set in the Name lines.<footnote>for more information about the purpose of the <idx/.kdelnk/ file, especially its use for commandline processing, see
<htmlurl url="kde_libref.html" name="The KDE Library Reference Guide"></footnote>

<chapt>Programming Guidelines
<p>

Close to the end of this handbook, I want to summarize several issues that programmers should watch out while coding. These are mostly
C++ programming tips that relate to KDE and Qt programming especially and are taken from the KDE Developer's Center which can be found
on the Internet at <url url="http://www.kde.org">.

<descrip>
<tag/Filenames/ First of all, when creating sourcefiles, you should always use lowercase filenames. KDevelop supports
this guideline already if you stick to its filename aut-suggestion. This makes it easier for other developers to remember what source
files to look for when they have to debug your application.

<tag/Classnames/
The classnaming for KDE projects is recommended to be:
<itemize>
<item>class names should begin with a prefixed <bf/K/ followed by the name of the class by purpose (your choice). This would be e.g.
<tt/KMyWidget/ for an application specific widget.
<item>the class members should always begin with lowercase letters, followed by uppercase beginnings for the next word, e.g.
<tt/myWidgetPointer()/
<item>methods that return a private members value shouldn't use the <tt/get/-prefix. You should prefer using a descriptive name for
those types of classmembers. Example: <tt/b_myboolean/ is a private member. The method returning the current value would be e.g.
<tt/myBoolean()/.
</itemize>

<tag/File access within code/
Hardcoding any path should be avoided by using the KDE File System Standard. You only have to watch the installation path for your
files by the according macros of the <tt/Makefile.am/ as described in this handbook. Within the code, you should use the methods of
<tt/KApplication/ to retrieve the actual path.

<tag/Class documentation/
Another thing already mentionend is class documentation. You should stick to use <tt/KDoc/ formatting rules as they are used by all KDE
developers to document their classes. You should at least add a single line to all of your classmembers for yourself to remember the
prurpose and for others to reuse code. The code-reuse by the GPL makes much more sense if you know where to find an already existing
solution if classes are documented. The Qt library referece is a good example of well-documented interfaces, though it doesn't use
<tt/KDoc/.

<tag/Use <tt/new/ to create widgets/
Within your implementation, you should always prefer to create widgets on the heap with <tt/new/. The Qt library has a nice habbit to
automatically delete all child widgets you created with <tt/new/, so you don't ever have to use <tt/delete/ again in those cases. This
is one of the most important practical features of the Qt library and you should make wide use of this.

<tag/Debugging/
When it comes to debugging, you should make use of the macros <tt/KDebug/ provides. Those are similar to the Qt macros, but can be
retrieved by the keycode STRG+ALT+F12. See the <htmlurl url="kde_libref-4.html#ss4.4" name="KDE Library Reference Guide"> for more
information about the event filtering of these Macros. You could as well use <tt/assert()/, but should try to be consistent with your
debugging code.

<tag/<tt/const/-declarations/
Further, you should use <tt/const/ declarations for member functions that should or do not change any private member. This would be the
case for all methods that only return the current value of a private member. This avoids changing the value accidently and will catch
those logical errors at compile time. Now, towards initializing const members you should stick to do that together with using
<tt/static/ in the declaration and initialize the value outside the constructor like this:
<tscreen><verb>
class foo {
	static const int value;
};

const foo::value = 10;
</verb></tscreen>
ANSI C++ allows to initialize the member inside the constructor but you should avoid this as a few compilers are not capable of this
feature.

<tag/Virtual methods/
As explained in section <ref id="User Interaction" name="User Interaction">, you should stick to the access rights and the declaration
by <tt/virtual/ when overwriting virtual methods. At least you shouldn't reduce the access of a virtual method from protected to
private.

<tag/Forward declarations/
Class-headers should be included where you dereference any object or instance of a class in your sourcecode. That means if your class
uses a member of another class, replace the #include directive with a forward declaration of the class, e.g  instead of:

<tscreen><verb>
#include <qpushbutton.h>

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</verb></tscreen>

you should prefer to only declaring the class <tt/QPushButton/ in the header file:

<tscreen><verb>
class QPushButton;

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</verb></tscreen>

and place the include directive into the according sourcefile where e.g. the instance <tt/ok_button/ is dereferenced with any method of
the class <tt/QPushButton/. This saves compile time at any rate, especially if you're using instances of classes that your're working
on. The compiler will recompile all souces that include the header file if you made any changes on the interface of the class,
therefore a simple addition of a method that only returns an internal value will lead to a recompilation of all sources tha include
the header file of the class.

<tag/Unused Parmeter Warnings and default arguments/
Also you should leave out formal parameters of methods that don't necessarily require the actual parameter to work. This avoids the
<tt/unused parameter/ warnings of your compiler when he sees a method that retrieves a formal parameter but doesn't use it in its
implementation. Usually, you will set some default arguments for several methods. Those should always be placed in the declaration of
the class member instead of setting them in the member implementation.

<tag/Using <tt/config.h//
KDevelop projects as well as any other project that is using <tt/autoconf/ to create a <tt/configure/-script produce a file
<tt/config.h/ after executing the <tt/configure/-script on the target machine. The values found by <tt/configure/ are listed there and
can be used within the sourcecode. The directive to include the <tt/config.h/ file is:

<tscreen><verb>
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
</verb></tscreen>

One of the most recently used entries of <tt/config.h/ is probably the type-definition of <tt/bool/ for compilers that don't comply
with the newest ANSI C++ draft.

<tag/Use <tt/0/ instead of <tt/NULL//
You should stickt to using <tt/0/ directly instead of <tt/NULL/ for preset values like the Qt and KDE libraries already do. This
increases portablility of your applications towards different compilers that have problems with <tt/NULL/.

<tag/Temporaries/
You should declare temporary instances always before using them. This is generally considered better than direct use. Example:
<tscreen><verb>
// Don't:
for( int i=0; i<n; i++){
  //do something
  };

// Do:
int i;

for(i=0; i<n; i++){
  //do something
  };
</verb></tscreen>

This also counts on using temporaries in function calls:
<tscreen><verb>
// Don't:
setColor( &amp;(QColor(black)) );

// Do:
QColor color(black);
setColor( &amp;color );
</verb></tscreen>


</descrip>


<chapt>References
<p>

The KDevelop Programming Handbook contains information that are taken from various sources on the Internet and by mails to various
mailing lists, as:

<bf/<idx/KDoc/ documentation:/ Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">

<bf/KDE Developer's Center/ maintained by Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">

<bf/KDE Internationalization:/ Matthias Elter <htmlurl url="mailto:me@kde.org" name="me@kde.org">

<bf/KDebug documentation:/ Kalle Dalheimer <htmlurl url="mailto:kalle@kde.org" name="kalle@kde.org">

<bf/The KDE File System Standard:/ Richard Moore <htmlurl url="mailto:rich@kde.org" name="rich@kde.org">

<bf/KDE-Developer's mini-HOWTO:/ David Sweet <htmlurl url="mailto:dsweet@chaos.umd.edu" name="<dsweet@chaos.umd.edu>">

The contents of the according chapters are copyright of the original authors.


<chapt>Copyright<label id="Copyright">
<p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

<appendix>Additional Information
<p>
<sect>Example Makefile.am for a Shared Library
<p>
<tscreen><verb>
# Example Makefile.am for a shared library.  It makes a library
#  called "example" as libexample.so.2.1.2
# This Makefile.am was taken from the kdelibs distribution and modified
#  to serve as an example.
#
# David Sweet
#

INCLUDES=  $(all_includes)

lib_LTLIBRARIES  = libexample.la

# Note:  If you specify a:b:c as the version in the next line,
#  the library that is made has version (a-c).c.b.  In this
#  example, the version is 2.1.2.
libexample_la_LDFLAGS = -version-info 3:2:1 $(all_libraries)

include_HEADERS = header1.h header2.h\
                  header3.h

# Which headers shouldn't be installed when a   make install  is done?
noinst_HEADERS = version.h

libexample_la_SOURCES = code1.cpp code2.cpp
                        code3.cpp

#  USE_AUTOMOC is great.  This takes care of all of your  moc'ing
#   dependencies.
#  (You still need to include, for example, header1.moc in code1.cpp.)
libexample_la_METASOURCES = USE_AUTOMOC
</verb></tscreen>


</book>





















