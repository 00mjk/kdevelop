<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDE Anwendungs Tutorials: Anwendungs Konzepte</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-7.html">Weiter</A>
 <A HREF="index-5.html">Zurück</A>
 <A HREF="index.html#toc6">Inhaltsverzeichnis</A>
</P>
<H3><A NAME="s6">6. Anwendungs Konzepte</A></H3>

<P>Dieses Kapitel stellt Ihnen die Ideen der bereits erwähnten Applikationsmodelle vor: das MDI (Multiple Document Interface) und das 
Document View Modell. Eine Basiseinführung in das Doc-View Modell und die Generierung eines Projektes mit KDevelop ist schon in 
<A HREF="../programming/index.html">The KDevelop Programming Handbook</A> enthalten, aber auf Basis des Single Document 
Interface (SDI). In jedem Falle, sollten Sie mit den Grundlagen der KDE und Qt Klassen vertraut sein, die in 
<A HREF="../kde_libref/index.html">The KDE Library Reference Guide</A> erklärt sind, die Basisklassen der darunterliegenden 
Bibliotheken und ihre Verwendung werden dort im Detail beschrieben, außerdem finden Sie zusätzlich eine Beschreibung des Qt 
Signal-Slot Verfahrens und der Ereignisverarbeitung.
<P>Als Anhaltspunkt sollten Sie bereits wissen:
<UL>
<LI>Das jede KDE Applikation eine Instanz von <CODE>KApplication</CODE> (bei Qt eine Instanze von <CODE>QApplication</CODE>) benötigt</LI>
<LI>Generell ein Main Fenster von <CODE>KTMainWindow</CODE> bei KDE (for Qt von <CODE>QMainWindow</CODE>) abgeleitet ist</LI>
<LI>Das Ereignisse (z.B. Tastendrücke oder Mausbewegungen) von darunterliegenden Window System an die Anwendung gesendet 
werden</LI>
<LI>Das <CODE>QWidget</CODE> als Basisklasse für alle Graphical User Interface (GUI) Komponenten spezialisierte Event Handler durch 
virtuelle Functionen bereitstellt, die die entsprechenden Events durch Reimplementation von <CODE>QObject::event()</CODE> ausfiltern </LI>
<LI>Das das Qt Signal-Slot Verfahren bedeutet, das eine Komponente Signale aussendet und ein Empfänger sich mit diesen Signalen 
verbinden kann, um bestimmte Aktionen auszuführen.</LI>
<LI>Das dieser Mechanismus es unnötig macht, Klassen für GUI Komponenten zu beerben, weil die Signale Sie über z.B. 
Mausereignisse informieren, wo es passend für ein Widget ist.</LI>
</UL>
<P>
<H3><A NAME="ss6.1">6.1 Das Document-View Modell</A>
</H3>

<P>Das Document-View Modell ist eines der grundlegendsten Konzepte für Anwendungsdesign, das auf GUI basiert. Daher ist ein gewisses 
Verständnis für das Warum nötig, um zu sehen, daß es Sinn macht es zu benutzen, obwohl der Programmiere andere Möglichkeiten hat. 
Lassen Sie uns aber zuerst einen Blick auf das normale Design einer typischen KDE / Qt Applikation werfen:
<P>Die Instanz Ihrer Anwendung stellt die erste Verbindung zu Ihrer Applikation zu Verfügung und ist der Startpunkt der 
Ereignisbehandlung eines Programms. Das Programm selber präsentiert sich dem Benutzer über eine graphische Benutzerschnittstelle, 
die meisten Hauptfenster genannt wird. Das Hauptfenster stellt dann dem Benutzer die erforderlichen Funktionen zur Verfügung, wie 
Tastenkürzel, eine Menüleiste, eine Werkzeugleiste und eine Statuszeile. Im Zentrum befindet sich ein sogenannter 
"Ansichtsbereich", was bedeutet, daß dieser Bereich die Instanz einer anderen Klasse ist, normalerweise "Ansicht" genannt. Diese 
Instanz wird erzeugt, wenn das Hauptfenster beim Programmstart konstruiert wird und muß mit Hilfe einer Methode des Hauptfensters 
zum Ansichtsbereich gemacht werden: <CODE>setView(your_view)</CODE> bei KDE Applikationen die <CODE>KTMainWindow</CODE> verwenden,
<CODE>setCentralWidget(your_view)</CODE> bei Qt Applikationen die <CODE>QMainWindow</CODE> verwenden. Nun, offensichtlich is die Ansicht 
der Bereich, der verantwortlich für die Interaktion mit dem Benutzer ist, wenn die Daten, die er represäntiert manipuliert werden 
sollen. Zum Beispiel könnten Sie <CODE>QMultiLineEdit</CODE> als Ansicht verwenden, und Sie hätten einen Editor. Dann können Sie die 
gegebenen Slots der Ansicht zur Kommunikation mit der Menüleiste oder der Werkzeugleiste folgendermaßen verwenden:
<P>Während Sie die Menüleiste erstellen, möchten Sie eine Methode für das Kommando "Cut" im "Edit" Menü bereitstellen:
<BLOCKQUOTE><CODE>
<PRE>
  pEditMenu->insertItem(BarIcon("editcut"), i18n("Cu&amp;t"),view, SLOT(cut()),KAccel::Cut, ID_EDIT_CUT);
</PRE>
</CODE></BLOCKQUOTE>
<P>Dies erzeugt einen Menüeintrag im "Edit" Menü, der, wenn aktiviert, direkt den Slot <CODE>cut()</CODE> der Instanz 
<CODE>view</CODE> aufruft, wobei wir davon ausgehen, daß Sie diese Instanz als <CODE>QMultiLineEdit</CODE> erzeugt und sie zum 
Ansichtsbereich gemacht haben. 
The multilineedit's slot gets called and cuts out the selected text as a reaction, the functionality is already provided by the class
itself and so there is no need to inherit from <CODE>QMultiLineEdit</CODE> to create a view area that is capable of such actions. They are
ready to use and make application development very fast- you just need the application instance and the main window including the
connections to your view area and you're done ! That means, a simple editor can be written by creating one single class that defines
the main window behavoir and how to save and read files into the editor - just some basic slots your main view has to implement itself.
<P>But here is the reason why we're now introducing this mysterious Document-View model: You have to provide methods by your own to read
and write the actual files you want to edit with the <CODE>QMultiLineEdit</CODE> view-area <B>within</B> the main window's interface.
Yes, this is obviously the easiest thing to do in this case, and the most logic. Now, if we have a look at the files and their contents
as a so-called "Document", which we can subscribe with the attribute of an "Object" in C++ terminology, the next step is just a little
one: If I have a document, a view and a main window- why don't I separate these three objects from each other ? We could easily create
a small class that is responsible for reading in a file into a text stream and then call the view to draw the text visible to the user.
The same applies to saving the file again- the document class should then provide a saving method that retrieves the text from the view
again and saves it as a file. In the example these two methods would be the only actions that are needed to be done by a document
class, because the edit-view already provides all methods basically needed for and editor by slots and you can manipulate the content
of the view by them directly.
<P>Now, the main idea behind the need for this separation into three objects (document, view, main window) instead of the minimum of two,
the view and the main window, is the question: what if I want to give the user the possibility to work with a file by <B>two</B> or
even more views ? Such things can even be done within one main window by splitters or deviders containing two view instances which
shall both display <B>one</B> file. There it is: the solution can only be that if the user manipulates the file contents in one view,
the other view has to be notified about that and to actualize its contents. Otherwise a bad scenario will occur: if the user closes one
view where he added something at the end of the file which he cutted out at the beginning of the file <B>in</B> the other view, the
file will be saved later by still containing the cutted section, because if the second and last view did not recognize this, it still
contains the text without modification from the beginning plus the inserted one. This means that both views have to be synchronized by
their contents they are displaying and that can be done if all views get notified about each action that the user does, which view he
actually uses should be equal. That means that finally a document class is needed to be the one and only holder of the true contents of
the document and is providing the views the possibility to manipulate the contents.
<P>I hope this has given some insight into this model, although in most cases it seems that the programmer can live without it - equally
to just using a provided class as the view area or writing a widget on his own to handle user interaction, as long as you represent
<B>one</B> document or file by <B>one</B> view area, the view can be responsible for the data as well and only provide methods to
retrieve or set the document contents for actions like reading a file or saving it. The next model to describe, the Multiple Document
Interface, will make a difference at this point- there you will see the actual need and the functionality the Document-View model
provides.
<P>
<H3><A NAME="ss6.2">6.2 The Multiple Document Interface (MDI)</A>
</H3>

<P>As the last section described the Document-View model, you will probably guess what MDI means. Users that come from other Operating
Systems than Unix/Linux are used to it as well as programmers developing for those platforms. While X-Window applications traditionally
are more targeting towards functionality and stability, Unix users are used to single windows that provide functionality, therefore
even the Document-View model is often not needed to create applications. With Qt as a multi-platform toolkit, developers are having
even more choice - developing for MS Windows(tm) as well as for Unix systems. While on Windows the lack of creating applications that
are capable of handling so-called child windows has been getting to some kind of standard, this is adressed by the Qt 2.1 library, but
on the other hand Unix users can profit from this architecture as well.
<P>What is now the meaning of MDI ? An MDI application generally has the same concept of a usual application that has, as described above,
one application instance and a main window. The view area now make the difference: you don't directly use a view that represents data
and provides interaction to manipulate that data but a view that handles other windows looking like top-level windows. These windows
are now representing the former view area and the main difference is that the interaction chain changes from
<P>
<BLOCKQUOTE><CODE>
<PRE>
application instance -> main window -> view

to

appliation instance -> main window -> view -> active child window
</PRE>
</CODE></BLOCKQUOTE>
<P>The view now is capable of several actions:
<UL>
<LI>creating as much child windows as the user requests</LI>
<LI>providing methods to retrieve the currently active child window</LI>
<LI>maintaining a list of open views</LI>
<LI>managing the child window behavoir for maximize, minimize such as a window manager does for top-level windows</LI>
</UL>
<P>Now, you can use "complete" widgets like the <CODE>QMultiLineEdit</CODE> as child windows like for an application that only provides one
window and each child window is responsible for it's own data. That could be described as "Multiple Document Interface", whereby each
child window is equal to a single document. The application then manages the usual actions such as providing methods for the child
window interaction such as cut or copy. Extending this concept with the document-view model enhances the possibilities by far: imagine
that you can open as much windows as you like within the main window and that a new child window can be a new view of a document that
is already shown by another child window. The management for this requires a separation into the already described three objects model,
but doesn't limit the actual number of instances of the documents as well as the views.
<P>Fortunately, Qt 2.1 contains the possibility to create such applications and KDevelop provides you with the according application
frameworks for both, Qt-only programs as well as KDE 2 applications with the same interface methods- so it is adequate wether you want
to develop for one of these. Using KDE 2 interfaces will offer you still more possibilites by library functions as well as
inter-process communication, but those are special aspects that are to cover by separate introductions to these techniques.
<P>Now you are prepared for following the development for KDE 2 - just follow the next chapter to get a first look at the functionality
already provided by KDevelop when creating applications. There, we will generate the framework for our tutorial application
<EM>KScribble</EM> and describe the practical aspects of programming MDI applications.
<P>
<P ALIGN="RIGHT">

<A HREF="index-7.html">Weiter</A>
 <A HREF="index-5.html">Zurück</A>
 <A HREF="index.html#toc6">Inhaltsverzeichnis</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
