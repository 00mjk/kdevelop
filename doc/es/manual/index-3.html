<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>El manual de usuario de KDevelop: Programas</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="Manual de usuario de KDevelop">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-4.html">Página siguiente</A>
 <A HREF="index-2.html">Página anterior</A>
 <A HREF="index.html#toc3">Índice general</A>
</P>
<H3><A NAME="Programas"></A> <A NAME="s3">3. Programas</A></H3>

<P>Ahora que ya ha instalado KDevelop satisfactoriamente, y que las opciones más utilizadas están configuradas, se estará preguntándose si este programa ofrece lo que promete. En este capítulo se le dará una guía sobre como crear programas con las herramientas GNU y sobre la parte que KDevelop juega en el proceso.
<P>
<H3><A NAME="El compilador"></A> <A NAME="ss3.1">3.1 El compilador</A>
</H3>

<P>El compilador es el programa que, como mínimo, debe estar instalado en su sistema para poder crear programas ejecutables; este programa es el que compila el código fuente, transformándolo en ficheros objeto con los que crea el programa.
<P>Normalmente, lo ejecutaría de esta forma:
Abra el editor que suela utilizar - no use un procesador de textos. Escriba algo como lo siguiente para crear el código fuente de su primer programa:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;iostream.h>

int main(){

cout &lt;&lt; "Hola Mundo" &lt;&lt; endl;

}
</PRE>
</CODE></BLOCKQUOTE>

Bueno, todo lo que el programa hará será imprimir la cadena "Hola Mundo" en la salida estandar. En cualquier caso, este es el código del programa a generar, no el programa propiamente dicho. Necesitamos un compilador, en este caso un compilador de C++ como g++. Guarde el código fuente como, por ejemplo, miprograma.c e invoque el compilador con el nombre del fichero (en la consola):
<P>
<BLOCKQUOTE><CODE>
<PRE>
g++ -o miprograma miprograma.cpp
</PRE>
</CODE></BLOCKQUOTE>

Ahora ya se puede ejecutar el programa. Escriba <CODE>miprograma</CODE> en la consola. El programa mostrará la cadena; después finalizará.
<P>
<H3><A NAME="Make"></A> <A NAME="ss3.2">3.2 Make y ficheros Makefile</A>
</H3>

<P>Vale, ya tiene todo lo que necesita: un editor y un compilador. Además puede ejecutar sus propios programas C++... Pero no es todo tan fácil, ¿qué pasa si tiene más de un fichero fuente? Además, ¿Tiene que compilar todos los ficheros cada vez que modifique uno? A medida que los programas se hacen más grandes, se vuelven más costosos y complejos de compilar, ya que tiene que ejecutar todos los comandos y opciones directamente. La solución pasa por crear un fichero con el nombre Makefile (en realidad puede tomar cualquier nombre menos el del programa) en el que insertar todos los comandos necesarios para compilar el programa, por supuesto con unas normas de sintaxis. Si las herramientas make o gmake están instaladas, lo único que tiene que hacer es escribir el nombre de la herramienta en el directorio en el que el fichero Makefile se encuentra (si el fichero tiene otro nombre es necesario pasar el parametro `-f nombrefichero'). En ese momento la aplicación make toma el control y se encarga de la compilación del programa. La aplicación make tiene otras muchas ventajas y puede ser utilizada para muchos propositos. Para obtener una visión más clara de la herramienta, abra la consola y escriba:
<P><CODE>man make</CODE>
<P>o busque "GNU Make" en la ayuda del KDE, en "System GNU Info contents".
<P>Ahora ya se habrá dado cuenta de las razones por las que un desarrollador necesita la herramienta make, para facilitar la compilación de sus aplicaciones.
Sin embargo, el problema que existía hasta ahora era que escribir los ficheros Makefile era un trabajo costoso y que requería que el programador se aprendiera las opciones y la sintaxis de make. Afortunadamente, con el KDevelop esto se hace innecesario. Tan sólo tiene que elegir las opciones que desea para el make en el diálogo 
<A HREF="index-13.html#Configuración general">Configuración del KDevelop</A>. KDevelop se encarga de crear el fichero Makefile y de generar la aplicación con él, todo sin necesidad de teclear nada. Sencillamente utilice los botones de la barra de herramientas, a partir del segundo separador, o elija la función deseada en el menú "Construir".
<P>La barra de herramientas y el menú "Construir" le ofrecen las funciones más habituales a la hora de utilizar el make:
<P>
<UL>
<LI> Compilar fichero: sólo está activado si está trabajando con un fichero fuente. Llama al comando make, indicándole que compile únicamente el fichero abierto. </LI>
<LI> Make: llama al make y crea el objetivo.</LI>
<LI> Reconstruir todo: reconstruye el proyecto entero.</LI>
<LI> Limpiar/Reconstruir todo: primero limpia el directorio del proyecto y después ejecuta el programa make.</LI>
<LI> Parar la construcción: cancela el proceso en ejecución. Normalmente se utiliza cuando se está viendo como make hace su trabajo, a la vez que observa el código, y de repente -ooooh- se da cuenta de que hay un error en el código sin corregir. En ese caso sólo tiene que pulsar Parar, corregir el error, y volver a ejecutar make.  </LI>
</UL>
<P>Compilar los ficheros no es lo único que KDevelop realiza con la ayuda de make. Otras cosas más propias de las aplicaciones KDE, como la creación de los ficheros con los mensajes del programa para su traducción, también son controladas por KDevelop y make, por lo que no debe preocuparse por ellas.  
<P>Ahora ya debería tener unos conocimientos básicos sobre los fuentes, el compilador, y porque el programa make es necesario. En la próxima sección, se hablará sobre como los proyectos creados con KDevelop pueden ser compilados en la mayoría de sistemas Unix gracias al fichero de comandos <CODE>configure</CODE>.
<P>
<P>
<H3><A NAME="Configure"></A> <A NAME="ss3.3">3.3 Configure</A>
</H3>

<P>El título de esta sección puede que le lleve a preguntarse ¿configure? ¿Qué he de configurar?
Bueno, supongamos que ha escrito un programa que incluye un fichero Makefile. Le gustaría distribuirlo, pero el programa compilado sólo funciona en su sistema y en aquellos que sean compatibles con él. Para que funcione en otras plataformas distintas a la suya, tales como otros sistemas Unix o máquinas Alpha o RISC, hay que recompilar el programa. La manera más fácil sería copiar los ficheros fuente y ejecutar make en la otra máquina. Pero, ¿que pasa si la otra máquina utiliza otro compilador? (o tiene algún otro problema al compilar el programa). Eso sin pensar en que los directorios de instalación del programa y su documentación pueden ser distintos. Ejemplo: los programas KDE puede que en su máquina se instalen en <CODE></CODE>opt/kde/, pero en otra máquina puede que estén instalados en <CODE></CODE>usr/local/kde/ o en otro sitio. En este caso, tendría que modificar el fichero Makefile cada vez, para asegurar la correcta compilación e instalación de su producto.
<P>Afortunadamente, las herramientas GNU no sólo le proporcionan el mítico <CODE>make</CODE>, también incluyen otros dos paquetes: automake y autoconf. El prefijo "auto" de las utilidades puede inducirle a pensar que, por fin, algo relacionado con el diseño de la aplicación puede hacerse rápida y fácilmente. Pues ha acertado.
<P>La tarea de Automake es, generalmente, crear un fichero <CODE>Makefile.in</CODE> desde un fichero llamado <CODE>Makefile.am</CODE>, que usted debe crear para su proyecto. Este fichero Makefile.am está compuesto por varias macros, que intentan reducir la complejidad de make y hacer que este fichero sea escrito más rápido y de forma más segura que el Makefile..  
<P>Habiendo dicho esto, ¿quién se encarga de crear finalmente el fichero Makefile? Aquí es donde aparece autoconf. Autoconf necesita varios ficheros de macros para funcionar: el fichero Makefile.in (creado por automake), y el fichero <CODE>configure.in</CODE>. Por un lado, el fichero Makefile.am (y por tanto el .in) contiene los macros que especifican que ficheros deben compilarse, que ficheros pertenecen al paquete, y cual será el nombre del fichero o biblioteca que se cree. Por el otro lado, el fichero configure.in contiene macros que configure utilizará para saber lo que tiene que buscar en el sistema. Por ejemplo el nombre del compilador, las bibliotecas necesarias para crear el binario, etc.
<P>Por ejemplo, supongamos que desea crear una aplicación KDE. Tras escribir el código, querrá distribuir el programa entre la comunidad de usuarios, y cada usuario tendrá que compilar el binario. Lo que haría sería escribir un fichero configure.in que contenga las macros necesarias para crear una aplicación KDE. Estas macros se encargarían de comprobar que la biblioteca Qt está instalada, de buscar las cabeceras de Qt, de encontrar las bibliotecas y cabeceras de KDE, etc.
<P><B>Resumen:</B>  Para crear una aplicación según el estándar GNU, que se pueda transportar a distintas máquinas y sistemas Unix, necesita hacer lo siguiente:
<P>
<OL>
<LI> escribir el código de su proyecto</LI>
<LI> escribir un fichero Makefile.am para cada subsirectorio, incluyendo el directorio principal del proyecto</LI>
<LI> crear un fichero configure.in en el directorio principal del proyecto que contenga los requerimientos del sistema</LI>
<LI> ejecutar automake</LI>
<LI> ejecutar autoconf</LI>
</OL>
<P>Y el trabajo principal está hecho. Automake crea el fichero Makefile.in, autoconf procesa el fichero configure.in y crea un fichero de comandos (script) llamado <CODE>configure</CODE>. Cuando se ejecute ./<CODE>configure</CODE>, se realizarán todas las comprobaciones que fueran necesarias, creandose un(os) fichero(s) Makefile que permitirán la ejecución del make para la creación del binario.
<P>Puede que todo esto parezca un montón de trabajo para crear una aplicación pequeña, además de que hay que aprender como escribir las macros correctas. Pero el hecho de que está permitiendo la compilación del programa, en prácticamente todos los sistemas Unix, valdrá la pena tarde o temprano. Además, sólo tiene que hacer esto una vez por cada proyecto, y si el número de ficheros del mismo se incrementa, tan sólo debe añadir los nuevos ficheros a las macros.
<P>Ahora, ¿hasta que punto el KDevelop te ayuda con los anteriores aspectos de la programación? Pues hasta el punto de que no será necesario que sepa nada sobre macros y ficheros de comandos. Todos los detalles al respecto se ocultan tras la interfaz gráfica, que es la que se encarga de este trabajo. Las aplicaciones se crean por tanto de una forma muy agradable (con las herramientas GNU):
<P>Crea la aplicación con el asistente de aplicaciones, únicamente tiene que elegir el tipo de aplicación que desea crear, ya sea una aplicación de terminal o un programa que utilice las bibliotecas Qt o KDE. Todo el trabajo se realiza automáticamente, y su fichero ya contendrá los ficheros Makefile creados con la ayuda de las herramientas GNU.
<P>Y no hay nada más. Ya está preparado para extender el código de su proyecto, tal vez con nuevas clases, diálogos, traducciones o documentación, todo esto también automatizado. Tan sólo tiene que concentrarse en el verdadero trabajo del desarrollador, que es hacer que aplicación que desea crear sea util. En la mayoría de los casos, lo más probable es que no llegue a tocar los ficheros Makefile mientras trabaje con KDevelop.
<P>
<H3><A NAME="Depuración"></A> <A NAME="ss3.4">3.4 Depuración</A>
</H3>

<P>La siguiente sección trata sobre un término usado comúnmente por los desarrolladores: el depurado. La depuración de un programa consiste en asegurarse de que el programa no fallará ni se colgará durante la ejecución, debido a algún fallo en el código. Como nota curiosa, mencionaremos que a este tipo de fallos también se les suele llamar con el anglicismo bug (bicho). Esto es debido a que en los primeros ordenadores, los primeros errores que se produjeron fueron debidos a que había bichos dentro de ellos, que estropeaban los circuitos. Obviamente, hoy en día esto es sólo una anécdota y los fallos se encuentran, como ya hemos dicho, en el código. En las herramientas GNU, encontramos el depurador de GNU, el <CODE>gdb</CODE>. Este programa permite inspeccionar los valores internos de una aplicación en ejecución, además de permitir que esta se ejecute paso a paso, mediante la introducción de puntos de interrupción en el código. Gdb para la ejecución del programa cada vez que este llega a un punto de interrupción. Como en el resto de herramientas, el depurador puede ser manejado desde otro programa que sirva de interfaz de usuario, facilitando la inspección de variables y la distribución de puntos de interrupción. 
<P>Para este propósito, la aplicación de su proyecto se crea, por defecto, con la opción de depurado del compilador, que hace que se guarden datos adicionales junto al ejecutable, para poder localizar valores y líneas dentro del código. KDevelop utiliza el programa KDbg, que es una interfaz de usuario para el gdb. Para depurar su programa, tan sólo tiene que seleccionar "Depurar" en el menú "Construir", o pulsar el botón correspondiente en la barra de herramientas, que es el que tiene dibujados un engranaje con gafas, representando que desea observar la ejecución de la aplicación.
<P>KDevelop abre entonces la ventana de herramientas y lanza su aplicación con KDbg. La interfaz de KDbg aparecerá dentro de la ventana, permitiendo el uso del programa como si hubiera sido ejecutado desde el exterior.
<P>En general, los pasos descritos arriba intentan mostrar, claramente, lo que un desarrollador tiene que hacer al comenzar a escribir su propia aplicación, tratando temas que son comunes a todo los proyectos. Además, se ha explicado la parte de estos que KDevelop realiza y como intenta proveer una forma fácil de programar en Unix. Si desea obtener más información sobre el papel y la razón de ser de las herramientas GNU, debería leer la documentación que se entrega con ellas, normalmente accesible desde la sección "System GNU Info contents" en la ayuda de KDE.
<P>
<P ALIGN="RIGHT">

<A HREF="index-4.html">Página siguiente</A>
 <A HREF="index-2.html">Página anterior</A>
 <A HREF="index.html#toc3">Índice general</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
