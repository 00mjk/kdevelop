<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDevelop. Руководство программиста: Создание новых приложений </TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-4.html">Next</A>
 <A HREF="index-2.html">Previous</A>
 <A HREF="index.html#toc3">Table of Contents</A>
</P>
<H3><A NAME="Creating new Applications"></A> <A NAME="s3">3. Создание новых приложений </A></H3>

<P>KAppWizard, также называемый KDE Application Wizard, предназначен для того, чтобы помочь вам начать работу над новым проектом в KDevelop.
Таким образом, для начала любого вашего проекта вы должны использовать KAppWizard. Потом вы сможете модифицировать и дополнять автоматически сгенерированный скелет кода.
KAppWizard позволяет выбрать один из нескольких типовых проектов, в зависимости от предназначения вашего приложения:
<P>
<UL>
<LI>Обычное приложение KDE: включает исходный код, реализующий стандартную структуру фреймов приложения KDE с поддержкой
модели Докумет-Просмотр (Document-View-Controller), панели меню, панели инструментов и строки статуса, а также набор базовых шаблонов документации в SGML-формате, 
ссылки на KDE-ресурсы и иконки приложения. Этот тип приложений обычно используется для создания новых KDE-проектов.</LI>
<LI>Простое KDE приложение (Mini KDE Application): имеет ту же структуру, что и обычное KDE приложение, но с тем отличием, что
есть только один видимый элемент - окно.</LI>
<LI>Обычное Qt приложение: содержит то же, что и KDE приложение, но код использует только Qt
библиотеки и не содержит поддержки KDE. Это может быть полезно для приложений, которые планируется переносить на WINDOWS платформу, или для тех,
которые не планируют использование конечным пользователем KDE библиотек.</LI>
<LI>C приложение: консольное приложение для C компилятора.</LI>
<LI>C++ приложение: использует C++ компилятор и запускается в консоли, следовательно, не требует  X-Window.</LI>
<LI>Пользовательский проект: создает пустой проект без какого-либо кода. Это может быть полезно для перевода уже существующих программ
под KDevelop или для старта "с самого начала". Имейте в виду, что вы должны уделить внимание созданию makefile'ов и конфигурационных скриптов.</LI>
</UL>
<P>В этой главе мы увидим, как можно использовать KAppWizard и что должно быть сделано для создания проекта KDE приложения.
Это будет первый шаг нашего пути, где мы создадим исходную версию примера проекта. Для всех остальных типов проектов
шаги почти такие же, только вам предоставляется меньше опций для выбора.
<P>
<H3><A NAME="ss3.1">3.1 Использование KAppWizard и генерация проекта</A>
</H3>

<P>
<H4>Запуск KAppWizard и первая страница</H4>

<P>Чтобы начать создание вашего первого KDE приложения, откройте KDevelop. Затем выберите пункт "New..." из меню "Project". Запустится KAppWizard, и вы
увидите дерево на первой странице, содержащее типы проектов. При выборе типа в правой части окна можно увидеть, как будет выглядеть приложение после
работы KAppWizard. Выберите ветвь KDE, тип Normal (Обычное приложение KDE). После этого нажмите кнопку "Next" внизу первой страницы KAppWizard.
Это приведет к переходу на следующую страницу, где вы сможете установить основные опции проекта.
<P>
<H4>Установки страницы Generate</H4>

<P>Для нашего примера мы выберем имя проекта <CODE>KScribble</CODE>; введите это в поле "Projectname". Затем выберите
каталог, в котором вы хотите разместить свой проект; по умолчанию это ваш домашний каталог. Вы можете ввести путь вручную или 
нажать кнопку справа от поля для выбора каталога через диалоговое окно.
<P>Теперь вы должны ввести номер версии. Для первой версии установите номер <CODE>0.1</CODE>. Это обычный номер для нового приложения, которое находится в стадии разработки.
Для таких приложений присваиваются номера, меньшие 1, а стартовая версия вашего приложения будет иметь только исходный набор фреймов, поэтому назовите ее 
0.1.
<P>Наконец, введите свое имя в поле "Author" и ваш email адрес. Остальные опции можете оставить с их значениями по умолчанию.
<P>Для получения дополнительной информации обо всех других опциях, вы можете нажать правую кнопку мыши над соответствующим полем и выбрать пункт меню quick-help.
Откроется окно помощи с кратким описанием назначения опции. Это:
<P>
<UL>
<LI><B>generate sources and headers:</B>  генерировать исходный код и файлы заголовков.</LI>
<LI><B>GNU-Standard-Files:</B>  добавить копию GNU - General Public License в проект и некоторые стандартные файлы с информацией для пользователя
при распространении пакета.</LI>
<LI><B>User-Documentation:</B> руководство пользователя в SGML, шаблон которого уже подготовлен для вашего проекта.</LI>
<LI><B>API-Documentation:</B> создает стартовый набор HTML документации для <B>A</B>pplication <B>P</B>rogramming <B>I</B>nterface.</LI>
<LI><B>lsm-File:</B> Linux Software Map, используется при распространении программы на предлагающих ее сайтах и представляет собой файл с кратким описанием назначения
проекта и его требований.</LI>
<LI><B>.kdelnk-File: </B> файл ссылки, который будет записан в ветку "Applications" дерева меню панели KDE-Panel при инсталляции приложения.</LI>
<LI><B>Program-Icon: </B> иконка, которая представляет проект и может быть использована для создания ссылки на рабочем столе.</LI>
<LI><B>Mini-Icon: </B> мини-иконка, которая отображается возле названия приложения в KDE-Panel,
в верхнем левом углу диалоговых окон приложения и его главного окна.</LI>
</UL>
<P>Теперь переключаемся на следующую страницу нажатием кнопки "Next" для создания шаблона файла заголовка вашего проекта.
<P>
<H4>Шаблоны заголовков и исходников</H4>

<P>Страница шаблонов заголовков позволяет вам автоматически включать предисловие в ваш файл шаблона, содержащее имя файла, дату, год,
copyright, ваше имя и email адрес. Вы не должны изменять текст, набранный заглавными буквами, самостоятельно,
KAppWizard сделает это автоматически и добавит шаблон в ваш проект, вы сможете его использовать в дальнейшем для создания новых файлов.
<P>Вторая часть шаблона файла заголовка, предоставляемого по умолчанию, содержит информацию о лицензировании. Предполагается, что ваш проект попадает под действие 
GNU General Public License, которая также включается в дистрибутив. Эта лицензия используется, чтобы защитить ваш исходный код от любого, кто
захочет его скопировать для своих собственных целей. General Public License предлагает вам эту лицензию и таким образом защищает ваши авторские права,
это общепринято при распространении свободного программного обеспечения. Для получения дополнительной информации о лицензии вы можете прочитать COPYING
файл в корневом каталоге вашего проекта (он будет туда занесен после завершения работы KAppWizard), который является копией GPL и уже входит в состав вашего приложения.
<P>Вы можете выбрать другую лицензию или другой шаблон для использования с проектом. 
Также вы можете отредактировать предоставляемый по умолчанию шаблон. Для того, чтобы сделать это, вы должны вызвать шаблон в окно редактирования. Для очистки страницы по умолчанию
выберите "New", для использования другого шаблона выберите "Load...", что откроет диалоговое окно выбора файла.
<P>Когда вы закончите с этим, переходите к следующей странице, нажав "Next". Эта страница для создания шаблона вашего исходника. В общем она
такая же, как и страница создания шаблона файла заголовка. Единственное отличие в том, что шаблоны используются 
для создания файлов реализации объявленных в заголовках функций.
<P>
<H4>Создание проекта</H4>

<P>
<P>Теперь, когда вы заполнили все опции для <EM>KScribble</EM>, выберите "Next" и нажмите кнопку "Generate" внизу окна KAppWizard.
Если кнопка недоступна, значит, вы установили неправильное значение какой-либо опции. Для исправления ошибки вернитесь назад с помощью кнопки "Back".
<P>После нажатия кнопки "Generate" вы должны увидеть, что KAppWizard начал работу - он копирует все шаблоны в каталог вашего проекта. Потом, когда KAppWizard
завершит работу, кнопка "Cancel" заменится на "Exit". Ее нажатие приведет к выходу из генератора.
<P>После этого шага вы завершаете процесс создания нового проекта. KDevelop загрузит его и предоставит возможность исследовать структуру,
представив проект в виде дерева файлов или классов.
<P>В следующем разделе мы опишем, как откомпилировать и запустить вашу первую версию <EM>KScribble</EM>, и обсудим, как организован исходный код.
<P>
<H3><A NAME="ss3.2">3.2 Первый запуск</A>
</H3>

<P>После того, как наш проект сгенерирован, первое, что необходимо сделать, - просмотреть структуру кода, чтобы получить общее понимание того, как работает приложение.
Это не только поможет нам начать разработку, а и в дальнейшем мы будем ориентироваться, где необходимо вносить изменения.
<P>Когда мы откроем страничку LFV (Logical File Viewer) в левой части окна KDevelop, мы увидим несколько папок, в которых уже размещены файлы проекта в соответствии с их назначением.  
Первые две папки - "Headers" и "Sources". Папка заголовков логически содержит все файлы заголовков проекта,
папка "Sources" - все исходники. Остальные папки сейчас для нас не интересны, их назначение мы рассмотрим позднее.
<P>Две папки содержат следующие файлы:
<P><B>Headers:</B>
<UL>
<LI><B>kscribble.h :</B> содержит объявление класса <B>KScribbleApp</B>.</LI>
<LI><B>kscribbledoc.h :</B> содержит объявление класса <B>KScribbleDoc</B>.</LI>
<LI><B>kscribbleview.h :</B> содержит объявление класса <B>KScribbleView</B>.</LI>
<LI><B>resource.h :</B> содержит коллекцию макросов идентификаторов пунктов меню.</LI>
</UL>
<P><B>Sources:</B>
<UL>
<LI><B>kscribble.cpp :</B> содержит реализацию класса <B>KScribbleApp</B>.</LI>
<LI><B>kscribbledoc.cpp :</B> содержит реализацию класса <B>KScribbleDoc</B>.</LI>
<LI><B>kscribbleview.cpp :</B> содержит реализацию класса <B>KScribbleView</B>.</LI>
<LI><B>main.cpp :</B> содержит реализацию функции <B>main()</B>.</LI>
</UL>
<P>Перед тем, как углубиться в исходный код, позволим KDevelop откомпилировать и запустить наше новое приложение. Чтобы сделать это, выберем "Make" из меню "Build".
или нажмем соответствующую кнопку на панели инструментов. В нижней части KDevelop откроется окно вывода,
и мы увидим сообщения, выдаваемые <CODE>make</CODE> при работе. Они могут несколько отличаться от приводимых ниже,
в зависимости от используемых настроек.
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
1   Making all in docs
2   make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
3   Making all in en
4   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
5   make[2]: Nothing to be done for `all'.
6   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
7   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
8   make[2]: Nothing to be done for `all-am'.
9   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
10  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
11  make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble'
12  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.cpp
13  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.cpp
14  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c                 
    kscribble.cpp
15  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    main.cpp
16  /usr/bin/moc ./kscribble.h -o kscribble.moc.cpp
17  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribble.moc.cpp           
18  /usr/bin/moc ./kscribbledoc.h -o kscribbledoc.moc.cpp
19  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.moc.cpp
20  /usr/bin/moc ./kscribbleview.h -o kscribbleview.moc.cpp
21  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.moc.cpp

22  /bin/sh ../libtool --silent --mode=link g++  -O0 -g -Wall   -o kscribble -L/opt/kde/lib  -L/usr/X11R6/lib -rpath /opt/kde/lib
    -rpath /usr/X11R6/lib kscribbleview.o kscribbledoc.o kscribble.o main.o kscribble.moc.o kscribbledoc.moc.o kscribbleview.moc.o
    -lkfile -lkfm -lkdeui -lkdecore -lqt -lXext -lX11

23  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble'
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Мы проставили номера строк напротив каждой строки, которых нет в выводе KDevelop. Это сделано для облегчения дальнейшего обсуждения того,
что происходит при компиляции. Во-первых, <CODE>make</CODE> работает рекурсивно. Это значит, что она начинает с каталога, откуда была вызвана, и
затем в первую очередь заходит в подкаталог, возвращается и заходит в следующий подкаталог. Наконец, обрабатывается стартовый каталог
и <CODE>make</CODE> завершается. <CODE>make</CODE> вызывается из главного каталога проекта, содержащего исходники. В строках 1 и 2 
мы видим, как <CODE>make</CODE> входит в каталог <CODE>docs</CODE>, затем в подкаталог <CODE>en</CODE>. Так как там нечего делать, она
выходит из этих каталогов, пока не вернется в каталог исходников <CODE>kscribble</CODE> в строке 11. Теперь начинается настоящая работа: <CODE>make</CODE>
вызывает компилятор, <CODE>g++</CODE>, для компиляции файла-исходника <CODE>kscribbleview.cpp</CODE>. Макрос <CODE>-DHAVE_CONFIG_H</CODE> говорит о том, что должен быть использован файл
<CODE>config.h</CODE>. Этот файл содержит макросы для определения платформы и приложения, и расположен в корневом каталоге проекта.
Следующие <CODE>-I</CODE> команды добавляют пути для поиска файлов, указанных в команде <CODE>"#include"</CODE>. Это
текущий каталог, корневой каталог проекта (<CODE>-I..</CODE>), и пути к файлам KDE, Qt и заголовкам библиотек X11.
Эти пути определяются при выполнении скрипта <CODE>configure</CODE> и устанавливаются в файлах Makefile; таким образом, компилятор
знает, где файлы расположены. Наконец, <CODE>-O0</CODE> устанавливает оптимизацию в ноль (без оптимизации), <CODE>-g</CODE> разрешает отладку, <CODE>-Wall</CODE>
устанавливает предупреждения компилятора в значение <CODE>all</CODE>, и <CODE>-c</CODE> говорит компилятору, что необходимо генерировать только файлы obj, то есть надо только откомпилировать файлы.
<P>Это делается и для других файлов-исходников нашего проекта в строках 13-15. Очевидно, наш исходный код откомпилирован, но вместо того,
чтобы линковать объектные файлы исходников в конечный бинарный файл, мы видим несколько иные команды. В строке 16 программа "moc"
вызывается для обработки файла-заголовка <CODE>kscribble.h</CODE>, выводя результат в <CODE>kscribble.moc.cpp</CODE>. Затем, в строке 17, этот исходный файл
компилируется. Аналогичные операции проделываются с другими файлами заголовков проекта до строки 21. Это необходимо, поскольку Qt поддерживает механизм сигнал/слот,
но базируется на C++ реализации, и мы используем определенные ключевые слова, не поддерживаемые языком C++, такие как  
<CODE>signals:</CODE> и <CODE>slots:</CODE>, в наших классах. Это дает нам возможность легко организовать межобъектное взаимодействие для всех 
экземпляров классов, порожденных от <CODE>QObject</CODE>, и избежать использования традиционного механизма callback указателей на функции. 
Таким образом, приложению необходим исходный код, который обеспечивает данную функциональность, и вот для чего вызывается
<CODE>moc</CODE>. <CODE>Moc</CODE> - Meta Object Compiler набора инструментов Qt. Он реализует механизм сигнал/слот, обрабатывая файл заголовка и генерируя код, который
должен быть откомпилирован для получения бинарного файла. Поскольку проекты KDevelop используют <CODE>automoc</CODE> для определения того, какие файлы заголовков должны быть обработаны, мы
не должны следить за вызовами <CODE>moc</CODE> и C++ компилятора для обработки сгенерированных <CODE>moc</CODE> файлов. Только запомните правило, что для использования
механизма сигнал/слот класс должен быть порожден от <CODE>QObject</CODE>, или от любого другого класса, порожденного от <CODE>QObject</CODE>; кроме того,
этот класс должен содержать макрос <CODE>Q_OBJECT</CODE> (без ";"!) в начале своего объявления, и объявления сигналов и слотов.
<P>Наконец, генерируется бинарный файл. Выходной бинарный файл называется <CODE>kscribble</CODE>, линкер использует пути к библиотекам KDE и 
X11, и линкует исходники с библиотеками <CODE>kfile, kfm, kdeui, kdecore, qt, Xext</CODE> и <CODE>X11</CODE>. На этом 
make завершает свою работу.
<P>
<H3><A NAME="ss3.3">3.3 Структура скелета исходного кода</A>
</H3>

<P>
<P>Чтобы понять и использовать концепцию того, как работает приложение KDE, в первую очередь мы должны очень внимательно изучить структуру скелета исходного кода, сгенерированную KAppWizarg.
Как мы уже видели, у нас есть набор файлов заголовков и кода, которые реализуют исходный код приложения,
и делают его готовым к выполнению. Таким образом, простейший путь объяснить код - пройти строка за строкой код так,
как он обрабатывается в процессе выполнения программы до входа в главный цикл событий и перехода в режим ожидания ввода пользователя. Затем мы рассмотрим, как реализуются функции взаимодействия с пользователем
и как некоторые вещи работают. Это, наверное, лучший путь объяснить, как работают элементы окна (framework),
и, поскольку это стандартно для большинства приложений KDE, такое объяснение позволит нам читать исходный код других проектов; кроме того,
мы узнаем, где что необходимо изменить, чтобы заставить свое приложение работать так, как от него требуется.
<P>
<H4><A NAME="The main() Function"></A> Функция <CODE>main()</CODE></H4>

<P>Поскольку приложение начинает свое выполнение входом в функцию <CODE>main()</CODE>, она и будет стартовой точкой нашего исследования.
Функция <CODE>main()</CODE> <EM>KScribble</EM> реализована в файле <CODE>main.cpp</CODE>, а также может быть найдена с помощью
просмотрщика классов (Class Browser) в папке "Globals", подпапке "Functions":
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
1  #include "kscribble.h"
2
3  int main(int argc, char* argv[]) {
4    KApplication app(argc,argv,"KScribble");
5
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
10   else
11   {
12      KScribbleApp* kscribble = new KScribbleApp;
13      kscribble->show();
14      if(argc > 1){
15        kscribble->openFile(argv[1]);
16      }
17    }
18    return app.exec();
19  }
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Итак, что же происходит в первую очередь при создании объекта <CODE>KApplication</CODE>, который получает третьим аргументом имя приложения <EM>KScribble</EM>?
Когда создается новый <CODE>KApplication</CODE>, порождается новый экземпляр объекта <CODE>KConfig</CODE>, который устанавливает связь с конфигурационным файлом,
$HOME/.kde/share/config/appname+rc, содержащим информацию, которую мы хотим использовать при открытии окна приложения. Имя,
которое мы передали конструктору <CODE>app</CODE>, будет использовано позднее в заголовке окна.
<P>По сравнению с примером кода, приведенным при преобразовании первого приложения Qt в приложение KDE, нынешний код имеет отличия. 
После создания экземпляра <CODE>KApplication</CODE> мы проверяем, как приложение вызвано: <CODE>kwm</CODE> менеджером сессий или пользователем.
Это можно узнать, вызывая метод <CODE>isRestored()</CODE> объекта <CODE>app</CODE>, который возвращает <CODE>true</CODE> для случая менеджера сессий
и <CODE>false</CODE> при нормальном запуске.
<P>Менеджмент сессий (session management) - одна из основных возможность приложений KDE, и она широко используется приложениями, но ее несколько долго объяснять.
Поэтому мы вначале последуем по ветке <CODE>else{}</CODE>; затем мы вернемся и поясним функционирование менеджмента сессий.
<P>
<H4>Запуск приложения пользователем</H4>

<P>В ветке <CODE>else{}</CODE> создается экземпляр класса <CODE>KScribbleApp</CODE> (строка 12). Этот объект вызывается, чтобы прорисовать себя, в строке
13, как обычно; строка 14 определяет, есть ли аргументы в командной строке. Если есть, то обычно это имя файла, поэтому
объект <CODE>kscribble</CODE> открывает этот файл с помощью метода <CODE>openFile()</CODE>.
<P>Обратите внимание, что мы не вызывали метод <CODE>setTopWidget(kscribble)</CODE> для нашего приложения - это уже сделано предками класса <CODE>KScribbleApp</CODE>.
Теперь посмотрим на наш объект <CODE>KScribbleApp</CODE> - что это такое и что он предлагает? Единственная вещь, которую мы знаем
на текущий момент, это то, что он должен быть видимым элементом (Widget) для представления пользовательского интерфейса в окне приложения. Обратимся к реализации класса
<CODE>KScribbleApp</CODE>, которая находится в файле <CODE>kscribble.cpp</CODE>, или нажмем мышкой на иконке класса в просмотрщике классов.
Экземпляр класса был создан с помощью конструктора. Во-первых, мы видим, что он порожден от класса <CODE>KTMainWindow</CODE>, который является частью <CODE>kdeui</CODE>. Этот класс, в свою очередь,
унаследован от <CODE>QWidget</CODE>, таким образом, мы имеем нормальный видимый элемент в качестве верхнего окна (top-level window).
<CODE>KTMainWindow</CODE> содержит массу функций, которые использует класс <CODE>KScribbleApp</CODE>. Он предоставляет панель меню, панели инструментов, строку статуса и поддержку менеджмента сессий. Единственная вещь,
которую мы должны сделать, когда наследуем новый класс от <CODE>KTMainWindow</CODE>, - создать все объекты, которые нам нужны, и создать другой элемент, который управляется нашим 
экземпляром <CODE>KTMainWindow</CODE> и заполняет рабочую область окна; обычно этот объект выглядит как область редактирования текста. 
<P>
<H4>Конструктор</H4>

<P>Давайте взглянем на код конструктора и рассмотрим, как создается экземпляр объекта:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
1   KScribbleApp::KScribbleApp()
2   {
3     config=kapp->getConfig();
4       
5
6     ///////////////////////////////////////////////////////////////////
7     // вызываем методы init для активации всех остальных частей конструктора
8     initMenuBar();
9     initToolBar();
10    initStatusBar();
11    initKeyAccel();
12    initDocument();
13    initView();
14
15    readOptions();
16
17    ///////////////////////////////////////////////////////////////////
18    // запрещаем меню и панели инструментов при старте
19    disableCommand(ID_FILE_SAVE);
20    disableCommand(ID_FILE_SAVE_AS);
21    disableCommand(ID_FILE_PRINT);
22
23    disableCommand(ID_EDIT_CUT);
24    disableCommand(ID_EDIT_COPY);
25    disableCommand(ID_EDIT_PASTE);
26  }
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Мы видим, что наш экземпляр <CODE>KConfig</CODE>, отвечающий за конфигурацию, сейчас указывает на конфигурацию приложения, поэтому мы сможем работать
с установками конфигурационного файла в дальнейшем.
<P>Затем, все части приложения, которые необходимы, созданы вызовом соответствующих функций-членов, которые специфичны для нашего приложения.
<P>
<UL>
<LI><B>initMenuBar():</B>  создает панель меню,</LI>
<LI><B>initToolBar():</B>  создает  панель инструментов,</LI>
<LI><B>initStatusBar():</B> создает строку статуса,</LI>
<LI><B>initKeyAccel():</B>  устанавливает все клавиши быстрого доступа(accelerators)
<!--
accelerator
-->
 для нашего приложения согласно глобальной конфигурации, определенной приложением,</LI>
<LI><B>initDocument():</B> создает объект документа для окна приложения,</LI>
<LI><B>initView():</B> создает главный элемент, заполняющий наше окно,</LI>
<LI><B>readOptions():</B>  считывает все специфичные для приложения установки из конфигурационного файла и инициализирует 
оставшиеся части приложения, такие как список последних файлов, положение панелей и размеры окна.</LI>
</UL>
<P>Наконец, мы запрещаем несколько команд, которые пользователь может выдать, поскольку они не должны быть доступны в нынешнем состоянии приложения.
Сейчас мы рассмотрели в общем как создается окно приложения, теперь мы углубимся в детали того, как создаются пользовательские элементы
в упомянутых выше методах.
<P>
<H4>Панель меню</H4>

<P>Как показано выше, панель меню <EM>KScribble</EM> создается методом <CODE>initMenuBar()</CODE>. В нем мы создаем набор
<CODE>QPopupMenu</CODE>, которые выпадают, когда пользователь выбирает пункт меню. Затем мы вставляем их в панель меню и подсоединяем к их входам функции, выполняемые при выборе.
<P>В первую очередь, мы создаем наше <CODE>recent_file_menu</CODE>, которое содержит названия последних 5 открытых файлов. Мы делаем это первым делом, потому что
это меню вставляется в <CODE>file_menu</CODE>. Затем мы добавляем непосредственно связь  - мы только что получили сигнал, который испущен
входом меню с определенным номером входа и вызываем <CODE>slotFileOpenRecent( int )</CODE>, который затем вызывает нужный файл из списка последних открытых файлов.
<P>Теперь мы создаем наше "File"-меню. Это будет меню, выпадающее из панели меню. Стандартные действия вставляются одно за другим в
выпадающее меню - вначале команда создания нового файла, открытия файла, закрытия файла и т.д., наконец "E&amp;xit" для закрытия
приложения. Все входы меню должны быть созданы в том порядке, в каком они будут появляться в дальнейшем, поэтому мы должны следить за тем, 
что в каком месте необходимо расположить. Рассмотрим, например, следующие входы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
file_menu->insertItem(Icon("fileopen.xpm"), i18n("&amp;Open..."), ID_FILE_OPEN );
file_menu->insertItem(i18n("Open &amp;recent"), recent_files_menu, ID_FILE_OPEN_RECENT );
</PRE>
</CODE></BLOCKQUOTE>
<P>Первая команда вставляет вход "Open...". Поскольку мы хотим иметь его с иконкой, мы используем <CODE>insertItem()</CODE> с именем иконки.
Чтобы понять процесс загрузки иконок, мы должны знать, где определен <CODE>Icon()</CODE>. На самом деле это не метод, это макрос, предоставляемый
классом <CODE>KApplication</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#define Icon(x) kapp->getIconLoader()->loadIcon(x)
</PRE>
</CODE></BLOCKQUOTE>
<P>Кроме того, он использует внутри следующий макрос для получения доступа к объекту приложения:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#define kapp KApplication::getKApplication()
</PRE>
</CODE></BLOCKQUOTE>
<P>Это означает, что объект <CODE>KApplication</CODE> уже содержит экземпляр загрузчика иконок - мы должны только получить к нему доступ; после этого он
загрузит соответствующую иконку. Поскольку все наши иконки входят в состав библиотек KDE, мы не должны заботиться ни о чем больше - они устанавливаются 
в системе автоматически, следовательно, мы также не должны включать их в состав дистрибутива нашего приложения.
<P>После параметра иконки (который не обязателен), мы вставляем вход меню с именем <CODE>i18n("&amp;Open...")</CODE>. Таким образом, мы должны разобраться с двумя вещами.
Во-первых, вход вставлен с использованием метода <CODE>i18n()</CODE>. Как и <CODE>Icon()</CODE>, это макрос, определенный в <CODE>kapp.h</CODE>,
который вызывает <CODE>KLocale</CODE> объект класса <CODE>KApplication</CODE> для перевода входа на используемый язык:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#define i18n(X) KApplication::getKApplication()->getLocale()->translate(X)
</PRE>
</CODE></BLOCKQUOTE>
<P>Однако, кто-то может сказать "Я не хочу использовать макросы!" - вы можете делать это в большинстве случаев. Но в данной ситуации
вы должны использовать <CODE>i18n()</CODE>, потому что процедура интернационализации приложения предполагает генерацию файлов,
содержащих то, что надо интернационализировать. А ход этого процесса зависит от строки <CODE>i18n()</CODE>. Поэтому вы должны использовать макрос.
<P>Как вы уже, наверное, догадались, амперсант внутри входа меню интерпретируется как подчеркивание следующей буквы в
тексте входа меню. Это позволяет осуществлять быстрый доступ к командам меню с клавиатуры, когда пользователь нажимает клавишу <CODE>Alt</CODE> и одновременно 
подчеркнутую букву.
<P>Наконец, мы назначаем входу меню идентификатор, который является числом типа integer, по которому мы сможем найти вход меню в дальнейшем.
Чтобы иметь контроль над значениями используемых идентификаторов, они определяются как макросы. Все они собраны в файле <CODE>resource.h</CODE> нашего проекта.
Для обеспечения однообразия, эти макросы все набраны заглавными буквами и начинаются с ID_, затем следует имя меню, а за ним имя входа. Это делает очень простым
определение смысла каждого входа, где бы он ни встретился в коде, и вы не должны возвращаться к коду панели меню для поиска входов.
<P>Следующий пример входа показывает другой вариант метода <CODE>insertItem()</CODE>. Здесь мы добавляем выпадающее меню recent_files_menu как
элемент меню. Это значит, что вход отобразится в виде переданной ему надписи "Open recent", а затем будет стоять стрелка вправо. При выборе входа
появится выпадающее меню со списком последних открытых файлов, и пользователь сможет из него выбрать необходимый файл.
<P>Наконец, существует еще множество способов добавления нового входа меню - в данном случае все реализовано максимально просто. Более подробную
информацию можно найти в документации Qt, в описании класса <CODE>QMenuData</CODE>.
<P>Теперь, после создания выпадающих меню <CODE>file_menu, edit_menu</CODE> и <CODE>view_menu</CODE>, мы должны включить "Help"-меню. Мы можем
сделать это аналогично, но класс <CODE>KApplication</CODE> предоставляет красивый и быстрый метод для этого:
<P>
<BLOCKQUOTE><CODE>
<PRE>
help_menu = kapp->getHelpMenu(true, i18n("KScribble\n" VERSION ));
</PRE>
</CODE></BLOCKQUOTE>
<P>Это все, что мы должны сделать, чтобы получить меню помощи, которое содержит вход для вызова системы помощи с горячей клавишей
<!--
shortcuts
-->
, окно "about" ("о программе...")
для приложения и аналогичное окно для KDE (которое может быть запрещено вызовом <CODE>getHelpMenu(false,...);</CODE>). Содержимое наших окон
"about" определяется с использованием макроса <CODE>i18n()</CODE>. VERSION использует макрос, определенный для номера версии проекта
в файле <CODE>config.h</CODE>, поэтому мы не должны изменять это каждый раз вручную при выпуске нового релиза. Вы можете спокойно добавить в окне "about" любую
информацию о себе - ваше имя, email-адрес, copyright и др.
<P>Теперь мы должны только вставить выпадающие меню в панель меню. Поскольку <CODE>KTMainWindow</CODE> уже создал панель меню для нас, мы только
вставляем их, вызывая <CODE>menuBar()->insertItem();</CODE>.
<P>Все, что осталось сделать - соединить входы меню с методами, которые должны выполняться по их выбору. Следовательно, мы соединяем каждое выпадающее меню по
сигналу <CODE>activated( int )</CODE> с методом <CODE>commandCallback( int )</CODE>, который содержит конструкцию <CODE>switch</CODE>, вызывающую соответствующие
методы для входов меню. Дополнительно, мы соединяем выпадающие меню по их сигналу <CODE>highlighted( int )</CODE> для вывода помощи в строке статуса
по каждому входу. Когда бы пользователь ни перевел указатель мыши или фокус ввода клавиатуры на вход меню, строка статуса выведет соответствующую подсказку.
<P>После того, как мы завершили с панелью меню, мы начнем разбираться с панелью инструментов. Это мы сделаем в следующей секции. Заметьте, что экземпляр
<CODE>KTMainWindow</CODE> может иметь только одну видимую панель меню; таким образом, если вы хотите создать несколько панелей меню, 
вы должны это делать раздельно с использованием экземпляров <CODE>KMenuBar</CODE>, и установить одну из них в соответствующем методе <CODE>KTMainWindow</CODE> как текущую
панель меню. См. документацию по классу <CODE>KMenuBar</CODE> для получения более детальной информации; о том, как расширить возможности, также см.
<A HREF="index-5.html#Configuring Menubars and Toolbars">Конфигурирование панелей меню и панелей инструментов</A>.
<P>
<H4>Панель инструментов</H4>

<P>Создание панелей инструментов даже проще, чем панелей меню. <CODE>KTMainWindow</CODE> предоставляет готовую панель инструментов, которая создается автоматически при вызове конструктора,
а вы можете легко создать еще несколько. На панель инструментов нужно только добавить кнопки для выполнения тех функций, которые вы желаете реализовать:
<P>
<BLOCKQUOTE><CODE>
<PRE>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</PRE>
</CODE></BLOCKQUOTE>
<P>Это добавляет прижатую к левому краю кнопку с иконкой "filenew.xpm" и соответствующим идентификатором на панель инструментов. Третий параметр определяет,
разрешена или запрещена кнопка; по умолчанию мы устанавливаем его равным <CODE>true</CODE>, потому что наш метод <CODE>disableCommand()</CODE> в конце
конструктора сделает необходимые нам установки автоматически для входов меню и панелей инструментов. Наконец, последний параметр используется для
так называемых "всплывающих подсказок" ("Quick-Tip") - когда пользователь располагает указатель мыши над кнопкой так, что она подсвечивается,
появляется окошко с сообщением, содержание которого можно определить этим параметром.
<P>Наконец, все кнопки панели инструментов соединяются с нашим методом <CODE>commandCallback()</CODE> по сигналу <CODE>clicked()</CODE>. По сигналу
<CODE>pressed()</CODE>, мы предоставляем пользователю возможность получить соответствующую подсказку в строке статуса.
<P><B>Дополнительная информация:</B>
<P>Поскольку панели инструментов создаются на основе класса <CODE>KToolBar</CODE>, вы можете посмотреть соответствующую документацию.
С помощью <CODE>KToolBar</CODE> можно реализовать множество вещей, необходимых для панели инструментов, например задержка перед выпадением меню, если по вашей кнопке вызывается выпадающее меню;
кнопки типа "выпадающий список". По умолчанию панель инструментов заполняет всю ширину
окна, что весьма удобно и красиво, если используется только одна панель. Когда их больше, вы должны продумать
их размеры, так как другие панели могут быть показаны в той же строке, что и первая, под панелью меню. Мы обсудим некоторые
вопросы разработки и расширения возможностей панелей инструментов в разделе 
<A HREF="index-5.html#Configuring Menubars and Toolbars">Конфигурирование панелей меню и панелей инструментов</A>.
<P>
<H4>Строка статуса</H4>

<P>Строка статуса, как и панели, предоставляется экземпляром <CODE>KTMainWindow</CODE>, поэтому мы должны только вставить в нее свои составляющие.
По умолчанию, сгенерированное приложение содержит только один элемент для отображения подсказки в строке статуса. Для многих приложений
этого может быть не достаточно. Поэтому вы должны добавить необходимые элементы, например, координаты и т.п.
<P>Кроме того, приложение может иметь только одну активную строку статуса, как и панель меню. Если вы хотите создать их несколько, вы должны
создать их по отдельности и установить текущую строку вызовом соответствующего метода <CODE>KTMainWindow</CODE>. В строку статуса также можно
вставлять видимые элементы, которые могут быть использованы для красивого отображения индикаторов прогресса, как это делает KDevelop. За дальнейшей информацией обращайтесь к описанию класса
<CODE>KStatusBar</CODE> в документации по классам.
<P>
<H4>Горячие клавиши (keyboard accelerator)</H4>

<P>Добравшись до метода <CODE>initKeyAccel()</CODE>, мы уже создали стандартные объекты главного окна приложения - панель меню, 
панели инструментов и строку статуса. Неужели мы не создали ни одной горячей клавиши, с помощью которых опытный пользователь, который желает
работать с клавиатурой, будет иметь быстрый доступ к определенным командам, использующимся наиболее часто в процессе работы с нашей программой. Чтобы сделать это, мы
можем использовать встроенные горячие клавиши, созданные при разработке, например, меню, но KDE предоставляет хорошее 
решение для создания и поддержания пользовательских горячих клавиш. Множество пользователей хотят, чтобы они были конфигурируемыми, с одной стороны,
а с другой стороны, стандартные горячие клавиши должны быть одинаковыми для различных приложений. Центр управления KDE
предоставляет конфигурирование стандартных горячих клавиш
<!--
accelerator
-->
 глобально, используя класс <CODE>KAccel</CODE>. Кроме того,
библиотеки KDE содержат элемент, который позволяет пользователю легко конфигурировать специфические для приложения горячие клавиши
<!--
shortcuts
-->
 локально.
Поскольку наше приложение использует только меню, выполняющие стандартные действия, такие как "New" или "Exit", они устанавливаются с помощью метода
<CODE>initKeyAccel()</CODE>. Стандартные действия должны быть только связаны с соответствующей комбинацией клавиш. Мы должны добавить их, 
вначале указав наименование стандартного действия, а затем выполняемой функции. Поскольку все наши горячие клавиши
определены в меню, мы должны изменить их для входов выпадающих меню. Затем мы вызываем
<CODE>readSettings()</CODE>, который считывает текущие установки корневого окна KDE, содержащего конфигурацию стандартных
горячих клавиш, потом установки для них, определенные в конфигурационном файле приложения.
Когда мы продвинемся дальше в разработке нашего примера, мы поговорим также о том, как конфигурировать специфические
для приложения горячие клавиши через диалоговое окно, 
см. 
<A HREF="index-5.html#Configuring Menubars and Toolbars">Конфигурирование панелей меню и панелей инструментов</A> об этой части процесса разработки.
<P>
<H4>Модель Документ-Просмотр (Document-View Model)</H4>

<P>Следующие два вызова функций-членов, <CODE>initDocument()</CODE> и <CODE>initView()</CODE>, завершают построение той части окна приложения, которую
предполагается представить пользователю: интерфейс для работы с данными, которые должно обрабатывать приложение; это еще одна причина,
по которой наше приложение состоит из трех классов, <CODE>*App</CODE>, <CODE>*View</CODE> и <CODE>*Doc</CODE>. 
Чтобы понять пользу такой структуры, немного отвлечемся от кода и ознакомимся с теорией, а затем снова
вернемся к программе, чтобы увидеть, как KDevelop поддерживает теоретическую модель.
<P>Вообще говоря, все, что было сказано о нашем приложении, это что нам необходим экземпляр приложения, содержащий главное окно. Это окно имеет возможность предоставить 
пользователю базисный интерфейс - оно содержит меню, панель инструментов и строку статуса, а также механизм обработки ввода пользователя. 
Кроме того, оно содержит область, описанную как "просмотр" ("view"). В общем, назначение этой области - показывать данные, которыми сможет манипулировать пользователь,
например, часть большого текстового файла. Хотя текстовый файл, вероятно, больше, чем наша область может показать на экране, она 
предоставляет возможность пользователю перейти к той части документа, которую он хочет видеть (это и есть "просмотр"). Здесь же пользователь может редактировать файл.
Чтобы дать программисту возможность наилучшим образом разделить части приложения при реализации кода, была разработана модель Документ-Просмотр. Хотя она и не является стандартом, она 
предлагает способ, как приложение должно работать:
<P>
<UL>
<LI> Приложение содержит управляющий объект (controller object),</LI>
<LI> объект Просмотр, отображающий данные, с которыми работает пользователь,</LI>
<LI> и объект Документ, который в действительности содержит обрабатываемые данные.</LI>
</UL>
<P>Возвращаясь к нашему примеру обработки текстового файла - наша модель должна работать так: Документ считывает содержимое файла и
предоставляет методы для изменения данных и для сохранения файла. Объект Просмотр обрабатывает события, которые генерирует пользователь
с помощью клавиатуры и мыши, и использует методы объекта Документ для обработки данных.
<P>Наконец, управляющий объект отвечает за взаимодействие с пользователем, предоставляя ему доступ к объектам Документ и Просмотр,
а также интерфейс для выдачи команд на открытие и закрытие документа. Кроме того, некоторые методы объекта Просмотр могут активироваться
командами, поступающими от горячих клавиш, меню и панелей инструментов.
<P>Эта модель Документ-Просмотр имеет некоторые преимущества - она разделяет программный код более объектно-ориентированно, и, таким образом, предоставляет большую гибкость,
например, один и тот же объект Документ может отображаться в нескольких объектах Просмотр одновременно; это может происходить как в различных окнах,
так и в рамках одного окна, разделяя его рабочую область на несколько элементов Просмотр.
<P>Если вы работали в MS-Windows, у вас может быть некоторый опыт такой работы - MFC предоставляет модель документа,
готовую к использованию. Для KDE и Qt приложений дело обстоит несколько по иному. Qt - мощный инструмент, который предоставляет
наиболее необходимые классы и видимые элементы. Но он не заботится о реализации модели Документ-Просмотр, и поскольку KDE унаследована от Qt,
нет никаких оснований вводить в ней такую модель. Есть какой-то смысл в том, что традиционное X-приложение не работает 
с многодокументным интерфейсом (MDI, Multiple Document Interface). Каждое главное окно отвечает за содержащиеся в нем данные и, таким образом,
уменьшает потребность в модели Документ-Просмотр, поскольку все методы работы с документом реализованы в видимом элементе. Единственное исключение на текущий момент -
проект <EM>KOffice</EM>, который предоставляет полный набор офисных приложений, таких как текстовый процессор, электронные таблицы и т.д.
Технически это реализовано внесением двух изменений в традиционный способ использования Qt и KDE:
<P>
<UL>
<LI>KOffice использует KOM и бесплатную (free) реализацию MICO из CORBA для межобъектного взаимодействия,</LI>
<LI>приложения KOffice используют модель Документ-Просмотр, чтобы позволить всем приложениям работать с объектами данных KOffice.</LI>
</UL>
<P>Но, поскольку сейчас KDevelop ориентирован на использование текущих библиотек KDE 1.1.x и Qt 1.4x, мы не можем использовать данную модель по определению - 
она появится в более поздних версиях KDE 2, которая, как предполагается, будет содержать два основных изменения по отношению к текущей - 
<P>
<OL>
<LI>MDI-интерфейс для KTMainWindow</LI>
<LI>KOM библиотеки, которые реализуют модель Документ-Просмотр.</LI>
</OL>
<P>Таким образом, в настоящее время разработчик приложений может либо реализовать все необходимые методы объекта Документ в объекте Просмотр,
или попытаться воспроизвести модель Документ-Просмотр самостоятельно. KDevelop поддерживает такую реализацию, предоставляя все необходимые классы и
основные методы, которые обычно используются в модели Документ-Просмотр в шаблонах приложений для Qt и KDE.
<P>Возвращаясь к коду, сейчас вы понимаете цели использования двух методов, которые мы упоминали в начале данного раздела:
функции <CODE>initDocument()</CODE> и <CODE>initView()</CODE>. <CODE>initDocument()</CODE> создает объект документа, который представляет
данные окна приложения и инициализирует базисные атрибуты, такие как бит модификации, отображающий наличие изменений в текущих данных.
Затем метод <CODE>initView()</CODE> создает видимый элемент <CODE>*View</CODE>, связанный с документом, и
вызывает метод <CODE>setView()</CODE> <CODE>KTMainWindow</CODE>, чтобы сообщить окну <CODE>*App</CODE>, что необходимо использовать элемент <CODE>*View</CODE> как Просмотр.
<P>Для разработчика необходимо знать, что в процессе разработки он должен:
<P>
<UL>
<LI>переопределить виртуальные методы для обработки событий мыши и клавиатуры, предоставляемые <CODE>QWidget</CODE>, в объекте <CODE>*View</CODE>, чтобы реализовать 
способы управления данными.</LI>
<LI>переопределить <CODE>paintEvent()</CODE> класса <CODE>QWidget</CODE> в объекте <CODE>*View</CODE> для перерисовки (repaint()) области просмотра после изменения,</LI>
<LI>доработать реализацию печати документа в методе печати объекта <CODE>*View</CODE>,</LI>
<LI>научить объект <CODE>*Doc</CODE> считыванию и записи файлов,</LI>
<LI>добавить реализацию структуры данных документа к объекту <CODE>*Doc</CODE>, который логически представляет данные документа
в памяти.</LI>
<LI>добавить все методы, которые должны быть доступны пользователю через горячие клавиши, меню и панели инструментов.</LI>
</UL>
<P>
<P>
<H4>Конфигурирование приложения</H4>

<P>Теперь, после того, как мы создали все элементы, инициируемые экземпляром <CODE>KTMainWindow</CODE> нашего приложения, мы должны
установить определенные атрибуты, значения которых влияют на внешний вид нашего приложения. Для этого мы вызываем <CODE>readOptions()</CODE>, которые
считывает все значения и вызывает методы, устанавливающие соответствующие атрибуты. Библиотека KDE-Core содержит класс <CODE>KConfig</CODE>, который предоставляет удобный
способ записи значений в конфигурационный файл, а также считывания их из файла снова. Поскольку каждый экземпляр <CODE>KApplication</CODE> 
создает по умолчанию свой ресурсный файл, мы должны только получить доступ к этому файлу и создать наши значения.  
<CODE>KConfig</CODE> предоставляет нам объект файла.
А мы используем класс <CODE>KConfigBase</CODE> для чтения и записи всех входов. Тогда как запись выполнить очень просто с помощью
метода <CODE>writeEntry()</CODE>, чтение зависит от типа атрибута, который мы хотим инициализировать. Вообще говоря, все входы в конфигурационном файле
состоят из имени значения и значения. Значения, взаимосвязанные по смыслу, могут быть объединены в группы. 
Поэтому мы должны задать имя группы до того, как обратимся к значению. Группа должна быть определена только однажды для чтения набора атрибутов,
входящих в нее. Давайте посмотрим, что мы хотим читать:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
1   void KScribbleApp::readOptions()
2   {
3
4      config->setGroup("General Options");
5
6      // bar status settings
7      bool bViewToolbar = config->readBoolEntry("Show Toolbar", true);
8      view_menu->setItemChecked(ID_VIEW_TOOLBAR, bViewToolbar);
9      if(!bViewToolbar)
10       enableToolBar(KToolBar::Hide);
11
12     bool bViewStatusbar = config->readBoolEntry("Show Statusbar", true);
13     view_menu->setItemChecked(ID_VIEW_STATUSBAR, bViewStatusbar);
14     if(!bViewStatusbar)
15       enableStatusBar(KStatusBar::Hide);
16
17     // bar position settings
18     KMenuBar::menuPosition menu_bar_pos;
19     menu_bar_pos=(KMenuBar::menuPosition)config->readNumEntry("MenuBar Position", KMenuBar::Top);
20
21     KToolBar::BarPosition tool_bar_pos;
22     tool_bar_pos=(KToolBar::BarPosition)config->readNumEntry("ToolBar Position", KToolBar::Top);
23
24     menuBar()->setMenuBarPos(menu_bar_pos);
25     toolBar()->setBarPos(tool_bar_pos);
26
27     // initialize the recent file list
28     recent_files.setAutoDelete(TRUE);
29     config->readListEntry("Recent Files",recent_files);
30
31     uint i;
32     for ( i =0 ; i &lt; recent_files.count(); i++){
33       recent_files_menu->insertItem(recent_files.at(i));
34     }
35
36     QSize size=config->readSizeEntry("Geometry");
37     if(!size.isEmpty())
38       resize(size);
39   }
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Как мы уже видели в одном из предыдущих примеров первое действие, которое делает наш конструктор:
<P>
<BLOCKQUOTE><CODE>
<PRE>
config=kapp->getConfig();
</PRE>
</CODE></BLOCKQUOTE>
<P>что устанавливает указатель <CODE>config</CODE> типа <CODE>KConfig</CODE> на конфигурацию приложения. Поэтому мы не должны заботиться о расположении
конфигурационного файла. Этот файл, согласно стандарту файловой системы KDE (KDE File System Standard, KDE FSS), располагается в
<CODE>$HOME/.kde/share/config/</CODE>; подробнее файловую систему KDE мы рассмотрим позднее, когда будем обсуждать расположение файлов в дистрибутиве приложения.
Поскольку конфигурационный файл располагается в домашнем каталоге пользователя, каждый пользователь имеет свои настройки внешнего вида приложения. 
Это не касается значений, определенных в общесистемном конфигурационном файле, который при необходимости может быть создан и инсталлирован
программистом в каталоге KDE. 
<P>Хотя это бывает полезно в некоторых случаях, мы должны избегать зависимости нашего приложения от существования
значения параметра в конфигурационном файле. Поэтому все методы чтения значений параметров, предоставляемые <CODE>KConfigBase</CODE>, позволяют добавить значение по умолчанию, которое будет использовано,
если не будет найдено в файле. Другой момент, важный для программиста, это то, что конфигурационный файл представляет собой обычный текстовый файл,
поэтому необходимо обратить внимание:
<P>
<UL>
<LI>пользователь может редактировать конфигурационный файл в текстовом редакторе,</LI>
<LI>если пользователь хочет изменить значения вручную, названия должны быть понятными,</LI>
<LI>для значений, которые необходимо сохранить, но которые критичны с точки зрения безопасности (пароли), необходимо предусмотреть соответствующее решение, обеспечивающее безопасность.</LI>
</UL>
<P>Теперь, когда мы знаем теорию, начнем анализировать код. Как уже говорилось, мы должны использовать только наш указатель на конфигурацию для доступа к значениям.
В строке 4 мы делаем текущей группу "General Options".  Это означает, что входящие в нее значения устанавливают какие-то общие атрибуты
приложения. Затем мы считываем значения для панели инструментов и строки статуса - они должны быть сохранены приложением при закрытии,
чтобы восстановить их при перезапуске программы. Поскольку панели могут быть либо включены, либо выключены, мы используем значения типа boolean и
вызываем метод <CODE>readBoolEntry()</CODE>. Процесс идентичен для обеих панелей, поэтому мы рассмотрим только строки 7-10, чтобы понять,
что происходит с панелью инструментов. Во-первых, мы читаем значение во временную переменную <CODE>bViewToolbar</CODE> в строке 7. Имя атрибута
в конфигурационном файле "Show Toolbar", и, если такое значение отсутствует (например, при первом запуске приложения),
задаем значение по умолчанию <CODE>true</CODE>. Потом мы устанавливаем пометку для пункта меню, отвечающего за разрешение/запрещение показа панели инструментов:
мы вызываем <CODE>setItemChecked()</CODE> для входа меню <CODE>ID_VIEW_TOOLBAR</CODE> с нашим атрибутом. Наконец, мы говорим панели инструментов
установить требуемое значение. По умолчанию панель видима, поэтому мы должны что-то делать только в том случае, если <CODE>bViewToolbar</CODE> равно <CODE>false</CODE>.
Вызывая <CODE>enableToolBar()</CODE> (строка 10), мы скрываем панель, если она запрещена.
<P>Теперь мы должны прочитать положение панели. Поскольку пользователь может изменить положение панели, переместив ее с помощью мыши
в другое место, это должно быть, как и отображение панели, также сохранено. Посмотрев на классы <CODE>KToolBar</CODE> и
<CODE>KMenuBar</CODE>, мы видим, что положение панели может быть:
<P>
<BLOCKQUOTE><CODE>
<PRE>
enum BarPosition {Top, Left, Bottom, Right, Floating, Flat}
</PRE>
</CODE></BLOCKQUOTE>
<P>Поскольку это значение записывается в числовом виде, мы должны считывать его с помощью метода <CODE>readNumEntry()</CODE> и преобразовывать в значение положения.
С помощью <CODE>setMenuBarPos()</CODE> и <CODE>setBarPos()</CODE> говорим панелям, где отображаться.
<P>Сейчас вы, возможно, вспомните, что наше меню "File" содержит подменю со списком последних открытых файлов. Имена файлов занесены в список
строк, который сохраняется при закрытии приложения и сейчас должен быть считан для восстановления меню. Во-первых, мы инициализируем список
с занесенными в него значениями строк, используя <CODE>readListEntry()</CODE>. Затем в цикле <CODE>for-</CODE> мы создаем входы меню для каждого элемента списка.
<P>Наконец, мы должны позаботиться о размерах окна нашего приложения. Мы считываем его расположение в переменную <CODE>QSize</CODE>, содержащую x
и y значения для ширины и высоты окна. Поскольку окно инициализируется <CODE>KTMainWindow</CODE>, мы не должны заботиться
о значениях по умолчанию, и только используем метод <CODE>resize()</CODE>, если значение не пусто.
<P>Нам еще осталось объяснить в создании приложения запрет команд, которые
не должны быть доступны, если не удовлетворяются определенные условия. Это сохранение файла и операции, которые используют буфер обмена. В течение
жизни приложения мы должны об этом позаботиться несколько раз, но это достаточно просто, так как шаблон дает нам только 
два метода для разрешения/запрещения команд меню и кнопок панели инструментов.
<P>
<H4>Выполнение</H4>

<P>В предыдущем разделе мы рассматривали только то, что происходит при вызове конструктора экземпляра нашего <CODE>KScribbleApp</CODE>, готовящего для нас главное окно. 
После возвращения в функцию <CODE>main()</CODE> мы должны вызвать метод <CODE>show()</CODE> для того, чтобы отобразить окно. Чем отличаются
<CODE>KApplication</CODE> и <CODE>QApplication</CODE> здесь, так это тем, что мы используем <CODE>KTMainWindow</CODE> как экземпляр нашего
главного элемента (main widget), но мы не устанавливали его с помощью <CODE>setMainWidget()</CODE>. Это делает <CODE>KTMainWindow</CODE> самостоятельно, 
и мы не должны заботиться об этом.
<P>Единственное, что осталось - это обработать аргументы командной строки. Если <CODE>int argc</CODE> > 1,
то пользователь вызвал приложение в виде <CODE>kscribble имя_файла_для_открытия</CODE>. Поэтому мы просим наше приложение
открыть файл <CODE>имя_файла_для_открытия</CODE>, вызывая метод <CODE>openDocumentFile()</CODE> с аргументом, содержащим имя файла.
<P>Последняя строка в <CODE>main()</CODE> выполняет уже известную нам работу: она запускает на выполнение экземпляр приложения, и программа входит в
главный цикл событий.
<P>Ранее, в разделе 
<A HREF="#The main() Function">Функция main()</A>, мы решили рассмотреть только обычный запуск приложения,
и не анализировали ветку <CODE>if( app.isRestored() )</CODE>. Следующий материал является введением в менеджмент сессий, и объясняет,
как приложения используют этот механизм.
<P>
<H4>Введение в Менеджмент сессий (Session Management)</H4>

<P>Как мы уже говорили, функция <CODE>main()</CODE> проверяет, запущено ли приложение пользователем или менеджером сессий. Менеджер сессий отвечает за
сохранение текущего состояния всех открытых окон приложения на рабочем столе и должен восстановить их, когда пользователь войдет в систему в следующий раз,
что значит, что приложение запускается не пользователем, а автоматически. Часть кода, которая выполняется:
<P>
<BLOCKQUOTE><CODE>
<PRE>
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
</PRE>
</CODE></BLOCKQUOTE>
<P>В разделе 
<A HREF="#The main() Function">Функция main()</A> мы начинали с того, что проверяли метод вызова,
запрашивая <CODE>app.isRestored()</CODE>. Затем выполняется строка 8. Она выглядит как простой оператор, но на самом деле это результат выполнения сложного
процесса, за которым мы проследим в этом разделе.
<P>RESTORE() сам по себе - макрос, предоставляемый <CODE>KTMainWindow</CODE>. Он содержит следующий код:
<P>
<BLOCKQUOTE><CODE>
<PRE>
if (app.isRestored()){
  int n = 1;
  while (KTMainWindow::canBeRestored(n)){
    (new KScribbleApp)->restore(n);
    n++;
  }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>Это должно восстанавливать все окна приложения класса <CODE>KScribbleApp</CODE>, создавая экземпляры и вызывая <CODE>restore()</CODE> для
новых окон. Необходимо учесть, что, если ваше приложение использует несколько различных элементов, унаследованных от <CODE>KTMainWindow</CODE>,
вы должны расширить макрос и определять тип верхнего элемента, используя <CODE>KTMainWindow::classNameOfToplevel(n)</CODE> вместо класса
<CODE>KScribbleApp</CODE>.
<P>Метод <CODE>restore()</CODE> затем считывает часть файла сессии, которая содержит информацию об окне. Так как <CODE>KTMainWindow</CODE>
запоминает все это для нас, мы не должны заботиться ни о чем больше. Только необходимо сделать так, чтобы специфичная для нашего экземпляра приложения информация 
была доступна <CODE>KScribbleApp</CODE>. Обычно это будет временный файл, созданный для занесения в него документа,
или другая инициализация, которая нам необходима. Для предоставления этой информации по восстановлению мы должны только переопределить два виртуальных метода
<CODE>KTMainWindow</CODE>, <CODE>saveProperties()</CODE> и <CODE>readProperties()</CODE>. 
Информация, которую мы хотим сохранить в конце сессии, - был ли модифицирован текущий файл и имя файла.
Если файл был модифицирован, мы должны создать временный файл и сохранить модифицированный документ в него.
В начале следующей сессии эта информация используется для восстановления содержимого документа:
<P>
<BLOCKQUOTE><CODE>
<PRE>
void KScribbleApp::readProperties(KConfig*)
{
  QString filename = config->readEntry("filename","");
  bool modified = config->readBoolEntry("modified",false);
  if( modified ){
    bool b_canRecover;
    QString tempname = kapp->checkRecoverFile(filename,b_canRecover);

    if(b_canRecover){
      doc->openDocument(tempname);
      doc->setModified();
      QFileInfo info(filename);
      doc->pathName(info.absFilePath());
      doc->title(info.fileName());
      QFile::remove(tempname);
    }
  }
  else if(!filename.isEmpty()){
  doc->openDocument(filename);
  }
  setCaption(kapp->appName()+": "+doc->getTitle());
}               
</PRE>
</CODE></BLOCKQUOTE>
<P>Здесь строка <CODE>kapp->checkRecoverFile()</CODE> выглядит несколько странно, так как <CODE>b_canRecover</CODE> не инициализирован. Это делается методом <CODE>checkRecoverFile()</CODE>,
который устанавливает <CODE>true</CODE>, если есть файл для восстановления. Поскольку мы сохраняем документ в файл для восстановления только в том случае, если он был изменен,
мы устанавливаем бит "модифицирован" непосредственно, чтобы показать, что информация не была сохранена в надлежащий файл. Также мы должны позаботиться,
чтобы файл для восстановления имел имя, отличное от имени открытого оригинала. Таким образом, мы должны переустановить имя и путь
для старого файла. Наконец, мы извлекли всю информацию для восстановления, какую хотели, и можем удалить временный файл.
<P><B>Подведение итогов:</B>
<P>В этой главе вы узнали, как запускается приложение при нормальном старте и при восстановлении менеджером сессий. Мы прошли
через весь код, разобравшись, как создаются части видимого интерфейса приложения, как инициализируются
атрибуты по значениям, сохраненным в конфигурационном файле. Сейчас вы можете запустить приложение, чтобы проверить его функции и посмотреть,
как реагирует окно программы на события.
<P>
<H3><A NAME="ss3.4">3.4 Дополнительные составляющие проекта KDevelop</A>
</H3>

<P>Кроме исходного кода, проект KDevelop содержит множество других частей, интересных для разработчика. Это:
<UL>
<LI>иконка программы,</LI>
<LI>мини-иконка программы,</LI>
<LI>файл .kdelnk, </LI>
<LI>пример SGML-файла документации,</LI>
<LI>набор документации по API, сгенерированный из исходного кода.</LI>
</UL>
<P>Кроме API-документации, эти элементы проекта будут инсталлированы вместе с бинарными файлами приложения. 
Чтобы проект был как можно более открытым, вы должны согласовать эти его части с функциями приложения. Во-первых, вы должны отредактировать иконки.
Это даст вашему приложению уникальный идентификатор, с помощью которого пользователь сможет узнать ваше приложение в окне
менеджера меню. Файл .kdelnk - это файл, который добавляет ваше приложение в <CODE>kpanel</CODE> в меню <CODE>Applications</CODE>.
Он должен быть отредактирован - необходимо установить путь для инсталляции, что будет обсуждаться далее в этой книге. Наконец, документация, которую вы
предоставите пользователю, пишется в SGML. Это делает очень простым создание нескольких конечных файлов различных форматов из одного исходника. По умолчанию,
KDevelop предлагает создать HTML файлы из этого исходника, для KDE-проектов это делается автоматически с использованием <CODE>ksgml2html</CODE>,
что добавляет классический KDE-вид документации. В последующих главах мы увидим, как редактировать файл SGML, 
и что мы предоставим конечному пользователю для инсталляции.
<P>Наконец, API-документация (Application Programming Interface) позволит вам и другим разработчикам быстро понять код
и использовать классы, не угадывая, для чего они предназначены. Мы научимся создавать API-документацию позднее.
На текущий момент достаточно знать, что документация генерируется программой <CODE>KDoc</CODE>, которая обрабатывает файлы заголовков и создает
HTML документ, поэтому все подлежащие включению в документацию комментарии должны располагаться в заголовках.
<P>
<P ALIGN="RIGHT">

<A HREF="index-4.html">Next</A>
 <A HREF="index-2.html">Previous</A>
 <A HREF="index.html#toc3">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
