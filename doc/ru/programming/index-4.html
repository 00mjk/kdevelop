<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDevelop. Руководство программиста: Главное окно приложения</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-5.html">Next</A>
 <A HREF="index-3.html">Previous</A>
 <A HREF="index.html#toc4">Table of Contents</A>
</P>
<H3><A NAME="s4">4. Главное окно приложения</A></H3>

<P>При разработке приложения с графическим пользовательским интерфейсом наиболее трудоемкой является реализация так называемого элемента Просмотр ("view") приложения.
Просмотр - это видимый элемент, который отображает данные, содержащиеся в обрабатываемом приложением документе, и предоставляет методы для изменения
этих данных. Пользователь заставляет эти методы работать, порождая события клавиатуры и мыши; сложные операции часто
выполняются с помощью команд, генерируемых при выборе пунктов меню или кнопок панели управления, которые взаимодействуют с Просмотром. Строка статуса предоставляет информацию о
документе, о режиме работы объекта Просмотр и о состоянии приложения. Рассмотрим, например, как устроен текстовый редактор, и где реализованы его части.
<P>Редактор обычно предназначен для просмотра и изменения текстового файла пользователем. Если вы
откроете <EM>KEdit</EM>, вы увидите следующие элементы пользовательского интерфейса:
<P>
<UL>
<LI>Панель меню: предоставляет возможность выполнять сложные операции, такие как открытие и закрытие файлов, выход из приложения и т.п.,</LI>
<LI>Панель инструментов: содержит иконки для быстрого доступа к наиболее часто используемым функциям,</LI>
<LI>Строка статуса: отображает координаты текущего положения курсора,</LI>
<LI>Объект Просмотр в центре окна: отображает документ и предоставляет связь курсора с клавиатурой и мышью для обработки данных.</LI>
</UL>
<P>Теперь легко понять, что Просмотр - наиболее специализированная часть приложения, и от того, как он разработан, зависит полезность
приложения и удобство работы с ним. Это значит, что один из первых шагов при разработке приложения - это определение назначения
приложения и того, какой тип объекта Просмотра наилучшим образом позволит пользователю работать с приложением, с минимумом затрат на освоение пользовательского интерфейса.
<P>Для некоторых стандартных задач, например, текстовой обработки или отображения HTML файлов, Qt и библиотеки KDE предоставляют специальные объекты просмотра; мы обсудим 
некоторые аспекты использования таких объектов высокого уровня в следующем разделе. Но для большинства приложений должны быть разработаны новые элементы.
Это момент, где программист становится также дизайнером, и где требуются его творческие способности. Однако не забывайте, что основное в пользовательском интерфейсе - это его интуитивность.
Помните, что многие пользователи не воспримут приложение, которое:
<P>
<UL>
<LI>некрасиво выглядит,</LI>
<LI>не предлагает широкого набора возможностей,</LI>
<LI>трудно в использовании,</LI>
<LI>тяжело для изучения.</LI>
</UL>
<P>Однако не стоит даже говорить, что основной критерий качества разработки - стабильность. Никто не сможет предотвратить все ошибки,
но с помощью хорошо продуманного процесса разработки можно свести их число к минимуму. 
Четко определите цель и широко используйте методы объектно-ориентированного программирования. C++ сделает программирование удовольствием,
если вы будете знать, как использовать его возможности - наследование, ограничения доступа и повторное использование кода.
<P>При создании KDE или Qt проекта вы всегда наследуете объект Просмотра от <CODE>QWidget</CODE> непосредственно или через использование библиотечного элемента,
унаследованного от <CODE>QWidget</CODE>. KAppWizard уже создал объект Просмотра, который является экземпляром класса &lt;ваше_приложение>View, унаследованного от
<CODE>QWidget</CODE>. Приложение создает его в методе
<CODE>initView()</CODE>, где создается экземпляр объекта, который затем устанавливается как главный с помощью <CODE>KTMainWidget::setView()</CODE>.
<P>Эта глава описывает, как использовать библиотеку элементов для создания главного объекта (объекта Просмотр) для KDE или Qt приложений,
которые разрабатываются с помощью KDevelop. Мы просмотрим библиотеки и узнаем, какие типы элементов они предлагают.
<P>
<H3><A NAME="ss4.1">4.1 Использование библиотечных элементов</A>
</H3>

<P>Когда начинается разработка приложения, вы в первую очередь должны просмотреть уже существующий код, что сделает вашу жизнь гораздо легче.
Например, необходимо изучить уже существующие элементы, которые могут быть использованы в качестве объектов Просмотра или как их часть, как непосредственно, так и путем наследования.
Библиотеки KDE и Qt уже содержат набор элементов, которые могут быть использованы для этих целей. Вы имеете две возможности для их использования:
<P>
<OL>
<LI> удалить объект Просмотра, включенный в шаблон, создать экземпляр библиотечного элемента и установить его как главный элемент;</LI>
<LI> изменить предка предложенного в шаблоне элемента на класс библиотечного элемента.</LI>
</OL>
<P>В любом случае, важно понимать, что если приложение на данный момент не линкуется с библиотекой, которая содержит новый элемент,
линкование завершится с ошибкой. После того, как вы решили использовать определенный элемент, посмотрите, с какой библиотекой необходимо связаться. Потом откройте
"Project"->"Options" из меню KDevelop, переключитесь на страницу "Linker Options" и посмотрите на то,
какие библиотеки используются на текущий момент. Если среди них есть библиотека, в которой содержится ваш элемент, вы можете закрыть окно опций проекта без изменений
и начать вносить необходимые изменения в ваш код. Если нет, и в опциях линкера есть возможность добавить необходимую библиотеку выбором соответствующего пункта,
выберите его и нажмите "OK", чтобы закрыть окно опций проекта. В любом другом случае добавьте библиотеку в строку ввода внизу окна с
опцией <CODE>-l</CODE>. Для библиотек, которые ваше приложение должно искать перед генерацией файлов Makefiles в скрипте <CODE>configure</CODE>
на машине пользователя, добавьте соответствующий макрос для поиска в файл <CODE>configure.in</CODE>, расположенный в корневом каталоге проекта, и
добавьте макрос для изменения строки. Имейте в виду, что вы должны запустить "Build"->"Autoconf" и "Build"->"Configure" для того, чтобы
в файлы Makefile была записана правильная информация о макросе для вашей библиотеки.
<P>Кроме того, если include-файлы добавленной библиотеки не попадают в текущий путь для поиска include-файлов (каталоги, заданные с помощью ключа <CODE>-I</CODE> 
в окне вывода информации о работе "Make"), вы должны добавить путь в диалоговом окне Project Options - страница "Compiler Options", с ключом <CODE>-I</CODE>, 
или соответствующий макрос automake в строке ввода "Additional Options".
<P>
<H4>Элементы Qt </H4>

<P>На первой странице Qt online-документации вы найдете ссылку на картинки элементов "Widget Screenshots", где сможете посмотреть,
как выглядят различные элементы Qt. Все они готовы к использованию и могут быть объединены вместе для создания 
сложных главных окон приложений или диалогов. Далее мы описываем некоторые из этих элементов, которые очень полезны при разработке приложений и элементов Просмотр,
но имейте в виду, что библиотеки KDE иногда содержат другие элементы, выполняющие те же задачи; их мы обсудим в следующем разделе.
<P>Перед вами несколько подсказок, для каких целей какие элементы Qt использовать:
<P>
<OL>
<LI>если ваша область просмотра недостаточно велика, чтобы вместить все данные, необходимо обеспечить пользователю возможность прокрутки (скроллинга)
с помощью полос прокрутки справа и внизу. Для этого Qt предоставляет класс <CODE>QScrollView</CODE>, у которого имеется пользовательская область с обеспечением прокрутки.
Вы можете наследовать свой собственный элемент от <CODE>QScrollView</CODE> или использовать его экземпляр для организации просмотра в вашем приложении.</LI>
<LI>для создания прокручиваемой области самостоятельно наследуйте объект Просмотра от класса <CODE>QWidget</CODE> и добавьте к нему вертикальную и горизонтальную прокрутку <CODE>QScrollBar</CODE>
(это сделано в KDE для элемента KHTMLView);</LI>
<LI>для текстовой обработки используйте <CODE>QMultiLineEdit</CODE>. Этот класс предоставляет полнофункциональный текстовый редактор, умеющий
работать с буфером обмена и полосами прокрутки;</LI>
<LI>используйте <CODE>QTableView</CODE>, чтобы отобразить данные в табличной форме. <CODE>QTableView</CODE> управляется полосами прокрутки,
поэтому он - хорошее решение для приложения типа электронных таблиц.</LI>
<LI>для одновременного отображения двух различных элементов или двух экземпляров элемента используйте <CODE>QSplitter</CODE>. Это позволит разделить
область просмотра горизонтально или вертикально. Окно Netscape's Mail - хороший пример того, как это выглядит. Главное окно разделено
по вертикали, а правая часть снова разделена по горизонтали.</LI>
<LI><CODE>QListView</CODE> отображает информацию в виде дерева. Это полезно для представления дерева каталогов или другой иерархической информации, которую необходимо обрабатывать.</LI>
</OL>
<P>Как видно, Qt предоставляет полный набор элементов, уже готовых к использованию, поэтому вы не должны изобретать новых решений,
если они удовлетворяют вашим требованиям. Еще одно преимущество использования стандартных элементов - пользователь уже знает, как с ними работать, и сможет 
сконцентрироваться не на интерфейсе, а на обрабатываемых данных.
<P>
<H4>Элементы KDE</H4>

<P>Библиотеки KDE созданы для облегчения разработки приложений K Desktop Environment, и поддерживают всю функциональность,
реализованную в Qt. Чтобы определить, что нам доступно, посмотрим на дерево документации в KDevelop. Мы видим, что библиотеки KDE
начинаются с <CODE>kdecore</CODE>, которая является основой для всех приложений KDE. Идущая следом <CODE>kdeui</CODE> предоставляет элементы пользовательского интерфейса.
Здесь мы найдем несколько полезных вещей. Для создания приложений <CODE>kdeui</CODE> предлагает:
<P>
<OL>
<LI><CODE>KTabListBox</CODE>: список с несколькими столбцами, строки которого можно изменять с помощью drag'n drop.</LI>
<LI><CODE>KTreeList</CODE>: унаследованный от <CODE>QTableView</CODE>, реализует дерево с возможностью показа/скрытия веток. Может быть использован вместо
<CODE>QListView</CODE>. В KDE 2.0 этот класс реализован не будет.</LI>
<LI><CODE>KEdit</CODE>: базовый класс для приложения <EM>KEdit</EM>, поставляемого вместе с KDE;
может использоваться вместо <CODE>QMultiLineEdit</CODE>.</LI>
<LI><CODE>KNewPanner</CODE>: Управляет двумя дочерними элементами как <CODE>QSplitter</CODE>. В KDE 2.0 этот класс реализован не будет.</LI>
</OL>
<P>Библиотека <CODE>khtmlw</CODE> предоставляет полнофункциональный интерпретатор HTML документов, готовый к использованию. Он поддерживает прокрутку,
поэтому вы не должны о ней заботиться.  Может быть полезен как интегрированное средство просмотра в HTML-редакторе; используется такими приложениями,
как KFM, KDEHelp и KDevelop для показа HTML файлов.
<P>
<P>
<H3><A NAME="Creating your own Views"></A> <A NAME="ss4.2">4.2 Создание собственного элемента просмотра</A>
</H3>

<P>Теперь, когда вы получили общее представление о предоставляемых возможностях, можно заметить, что для большинства задач уже существуют элементы,
которые могут быть использованы самостоятельно или объединены с другими. KMail и сам KDevelop - хорошие примеры использования библиотечных элементов для отображения данных.
<P>Для приложений, которые используют специфические форматы файлов или имеют дело с графикой, вы, вероятно, будете вынуждены создать свой собственный элемент просмотра
для организации обработки данных. Это реализуется в нашем примере с помощью класса <CODE>KScribbleView</CODE>, уже имеющего все необходимое для области просмотра.
<P>При наследовании от <CODE>QWidget</CODE> необходимо переопределить виртуальные методы для обработки пользовательских событий, что, вероятно, будет основной работой;
кроме того, необходимо реализовать всплывающие меню для быстрого доступа к функциям. Вероятно, вам также придется реализовать несколько слотов,
которые будут доступны через кнопки панели инструментов или пункты меню, а также методы управления различными переменными, например, 
цветом кисточки в графическом редакторе.
<P>Повторим для полноты подлежащие переопределению методы:
<P><B>a) События клавиатуры -- клавиши TAB и  Shift-TAB :</B>
<P>изменяет фокус ввода с клавиатуры с текущего элемента на следующий элемент в порядке изменения фокусов. Фокус может быть установлен для элемента
вызовом <CODE>setFocusPolicy
<!--
setFocusPolicy()
-->
()</CODE>. Изменение фокуса обрабатывается следующими обработчиками событий: :
<P>
<UL>
<LI><CODE>virtual void focusInEvent
<!--
focusInEvent()
-->
 ( QFocusEvent * )</CODE></LI>
<LI><CODE>virtual void focusOutEvent
<!--
focusOutEvent()
-->
 ( QFocusEvent * )</CODE></LI>
</UL>
<P><B>b) другой ввод с клавиатуры:</B>
<UL>
<LI><CODE>virtual void keyPressEvent
<!--
keyPressEvent()
-->
 ( QKeyEvent * )</CODE></LI>
<LI><CODE>virtual void keyReleaseEvent
<!--
keyReleaseEvent()
-->
 ( QKeyEvent * )</CODE></LI>
</UL>
<P><B>c) перемещение мыши:</B>
<UL>
<LI><CODE>virtual void mouseMoveEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void enterEvent ( QEvent * )</CODE></LI>
<LI><CODE>virtual void leaveEvent ( QEvent * )</CODE></LI>
</UL>
<P><B>d) нажатие кнопок мыши:</B>
<UL>
<LI><CODE>virtual void mousePressEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void mouseReleaseEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void mouseDoubleClickEvent ( QMouseEvent * )</CODE></LI>
</UL>
<P><B>e) события окна, содержащего элемент:</B>
<UL>
<LI><CODE>virtual void moveEvent ( QMoveEvent * )</CODE></LI>
<LI><CODE>virtual void resizeEvent ( QResizeEvent * )</CODE></LI>
<LI><CODE>virtual void closeEvent ( QCloseEvent * )</CODE></LI>
</UL>
<P>Когда вы переопределяете эти функции, вы должны учесть некоторые моменты, чтобы избежать ошибок, которые 
сделают невозможным изменение поведения элементов в дальнейшем:
<P>
<OL>
<LI>объявляйте ваши виртуальные методы как <B>virtual</B> в секции <B>protected</B>. Это позволит переиспользовать код при наследовании
и обеспечит логическую целостность;</LI>
<LI>не включайте в текст программы, реализующей обработку событий, непосредственно (hard-code) ничего такого, что может конфигурироваться. Это в основном относится к событиям клавиатуры,
которые реализуются через горячие клавиши и состоят в вызове функций. Данное замечание касается даже текстовой обработки! (Вообразите себе, что множество пользователей
привыкли к своему любимому текстовому редактору. Если горячие клавиши конфигурируются, то они смогут использовать привычные для себя настройки);</LI>
<LI>передавайте сигналы, генерируемые при подсветке пунктов меню, главному элементу, чтобы обеспечить подсказки в строке статуса.</LI>
</OL>
<P>
<P ALIGN="RIGHT">

<A HREF="index-5.html">Next</A>
 <A HREF="index-3.html">Previous</A>
 <A HREF="index.html#toc4">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
