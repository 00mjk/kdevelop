<!DOCTYPE LINUXDOC PUBLIC "-//GMD//DTD linuxdoc//RU">
<linuxdoc>
<book>
<titlepag>
<title>KDevelop. Руководство программиста
<subtitle>Руководство по разработке приложений на C++ для K Desktop Environment (KDE) с использованием KDevelop IDE, Version
1.0</subtitle></title>
<author>
<name>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">
<inst>Команда разработчиков KDevelop
<date>Version 2.1 , July 7, 1999
<abstract>
Это руководство - часть интегрированной среды разработки KDevelop, и, следовательно, на него распространяется GNU General
Public License; см. <ref id="Copyright" name="Copyright"> для получения более детальной информации.
</abstract>

<toc>

<chapt>Введение
<p>
По мере того, как Unix системы становятся все более и более популярными даже для начинающих пользователей благодаря своим преимуществам с точки зрения
стабильности и функциональности, многих как-то разочаровывает то, что Unix приложения не имеют надлежащего оформления и каждое
ведет себя по-своему. KDE дает разработчикам почти совершенный путь для создания первоклассных приложений для Unix систем, которые
они смогут предложить широким пользовательским массам. Таким образом, KDE становится все более и более популярной как основа для разработки программ,
и разработчики стремятся извлечь все преимущества из возможностей, предлагаемых этой системой.


<sect>Что вы должны знать
<p>
При написании этой книги мы предполагали, что вы уже владеете языком программирования C++; если это не так, вы
должны его освоить в первую очередь. Информация о C++ доступна из многих источников как в печатной форме в ваших книжных магазинах,
так и в электронном виде через Internet. Знания о разработке графического пользовательского интерфейса не являются необходимыми, так как
это руководство пытается охватить процесс разработки программ для KDE, что включает в себя введение в инструментарий <idx/Qt/, <idx/библиотеки KDE/ и
разработку пользовательского интерфейса. Будет хорошо, если вы чувствуете себя комфортно с KDevelop. Для этого можно прочитать 
"Руководство пользователя KDevelop" ("The User Manual to KDevelop"), 
которое содержит описание функций, предоставляемых IDE.

<sect>Об этой книге
<p>
Эта книга написана для разработчиков как введение в процесс создания приложений для KDE с использованием интегрированной среды разработки KDevelop.

Следующие главы дают представление о том, как создавать проекты, объясняют автоматически сгенерированный исходник и показывают, как
расширить данный код в различных направлениях - <idx/панель инструментов/, панель меню и рабочая область приложения. 

Затем в деталях рассматривается редактор диалоговых окон. Объясняется, как создаются элементы (widget), и подробно рассматриваются
установки свойств для всех предоставляемых элементов.

Наконец, вы узнаете еще о некоторых полезных вещах, что завершит ваше обучение в области разработки проекта и поможет вам освоить
выполнение таких проектных работ, как создание <idx/API/ документации и online-документации.

<bf/В следующей главе/

мы рассмотрим <idx/Qt/ и <idx/библиотеки KDE/, рассмотрим базовые концепции и поймем, почему все так, а не иначе.
Также мы обсудим, как создать учебные приложения, поставляемые с <idx/Qt/ инструментарием, используя KDevelop, после чего начинающие 
смогут увидеть первые результаты после первых шагов, и почувствовать преимущества использования KDevelop.

<bf/В дальнейших главах/ вы разберетесь:
<itemize>
<item>как создавать приложения с помощью KAppWizard,
<item>что предоставляет вам скелет проекта,
<item>что делает автоматически созданный код,
<item>как создавать свои собственные формы (views),
<item>как расширить функциональность ваших приложений с помощью диалоговых окон, панелей меню и <idx/панелей инструментов/,
<item>как сделать ваши приложения более дружественными, реализовав систему помощи,
<item>как писать <idx/SGML/ online документацию.
</itemize>


<sect>Дополнительная информация
<p>
Дополнительная информация о <idx/Qt//KDE программировании доступна из многих источников:

<itemize>
<item><em/Programming with <idx/Qt// by Matthias Kalle Dalheimer, опубликована изд. O'Reilly (см. <url url="http://www.oreilly.com" >), рассматривает
почти все аспекты <idx/Qt/ GUI инструментария и содержит множество примеров.
<item>"Руководство пользователя KDevelop" ("The User Manual to KDevelop"), поставляется вместе с KDevelop IDE,
<item><em/Online-Reference/ по <idx/Qt/-библиотеке, предоставляемая вместе с копией вашего <idx/Qt/ инструментария 
в HTML и доступная в формате PostScript на <url url="http://www.troll.no">
<item>В Internet смотрите
  <itemize>
  <item>Troll Tech web site - <url url="http://www.troll.no">,
  <item>KDE web site - <url url="http://www.kde.org">,
  <item>KDE developer web site - <url url="http://developer.kde.org">
  <item>Домашняя страница KDevelop - <url url="http://www.kdevelop.org">
  </itemize>
</itemize>


Кроме того, вы можете получить помощь, подписавшись на различные mail-листы, адреса которых имеются на упомянутых
сайтах, и в Usenet группах новостей, посвященных KDE, Unix, программированию на C и C++.

Для получения помощи о KDevelop IDE вы можете послать запрос в наш mail-лист
<htmlurl
url="mailto:kdevelop@fara3.cs.uni-potsdam.de" name="kdevelop@fara3.cs.uni-potsdam.de">. 
Имейте в виду, что команда разработчиков KDevelop предоставляет возможность
вам заниматься разработкой приложений и, следовательно, не является командой технической поддержки в случае,
если разработанное вами приложение не работает в связи с ошибками реализации или неверной конфигурацией операционной системы. Учитывая это, мы просим
всех пользователей обращаться к услугам mail-листа в случаях, когда вы сталкиваетесь с проблемами использования собственно IDE, а также
для сообщения нам об ошибках и предложениях по повышению функциональности среды разработки.

<chapt> KDE и <idx/Qt/ Библиотеки
<p>
Норвежская компания Troll Tech (<url url="http://www.troll.no">) предоставляет так называемый 
GUI инструментарий (toolkit), именуемый <idx/Qt/. GUI означает "<bf/Г/рафический <bf/П/ользовательский <bf/И/нтерфейс"
("<bf/G/raphical <bf/U/ser <bf/I/nterface"), поэтому базирующиеся на <idx/Qt/ приложения представляются кнопками, окнами и т.п.
Такие приложения осуществляют взаимодействие с пользователем, представляя в визуальной форме выполняемые функции.
Этот инструментарий необходим для разработки графических приложений, которые используют
X-Window интерфейс в Unix системах, потому что X не содержит предопределенного пользовательского интерфейса.
И хотя другие наборы инструментов также позволяют создавать пользовательский интерфейс, <idx/Qt/ предоставляет некоторые технические возможности, которые делают разработку приложений
очень простой. Кроме того, 
<idx/Qt/ инструментарий также доступен для Microsoft Windows систем, что позволяет разработчикам
выпускать приложения для обеих платформ.

Команда KDE (<url url="http://www.kde.org">) объединилась вместе с целью сделать Unix
системы более дружественными для пользователя, и решила использовать набор инструментов
<idx/Qt/ для разработки оконного менеджера для X-Window, плюс различных приложений,
включенных в дистрибутив KDE.
K Desktop Environment, таким образом, включает оконный менеджер <em/kwm/, 
менеджер файлов <em/kfm/ и панель задач <em/kpanel/ как главные компоненты, а также
массу первоклассных утилит и приложений. После выхода KDE множество
разработчиков обратили свои взоры к новой графической среде и к тому, что она предлагала.
<idx/Библиотеки KDE/ предоставляют все необходимые
методы и классы, которые делают процесс разработки приложений с их помощью однотипным и согласованным, и положение пользователя резко улучшается, так
как он теперь должен разбираться только в специфике использования данного приложения, а не обучаться общим использования очередного варианта пользовательского интерфейса.
Кроме того, KDE программы интегрируются в рабочую среду и предоставляют возможность взаимодействовать
с менеджером файлов, используя <idx/drag'n drop/, предоставляют возможность управления сеансами (session management) и многое другое, 
если разработчик реализовал все возможности, предоставляемые <idx/библиотеками KDE/.

И <idx/Qt/ инструментарий, и <idx/библиотеки KDE/ реализованы с использованием языка программирования C++; 
поэтому большинство приложений, которые используют эти библиотеки, также написаны на C++.
В последующих главах мы бегло ознакомимся с библиотеками, чтобы увидеть, что
за инструмент нам предлагается и как вообще создаются <idx/Qt/ и <idx/KDE / приложения.

<sect> <idx/Qt/ GUI инструментарий
<p>
Как уже говорилось, <idx/Qt/ библиотека - это инструментарий, который предоставляет 
графические элементы, используемые для создания GUI приложений, и который необходим 
при разработке программ для X-Window. Кроме того, <idx/Qt/ предоставляет:

<itemize>
<item> Широкий набор классов и методов, пригодных для использования даже для программ без графического интерфейса,
<item> Хорошее решение для реализации взаимодействия с пользователем посредством виртуальных методов и механизма сигнал/слот,
<item> Набором предопределенных GUI-элементов, называемых "widgets", которые могут быть легко использованы для создания видимых элементов,
<item> Дополнительные полностью предопределенные диалоговые окна, которые часто используются в приложениях, такие как окно прогресса и окно выбора файлов.
</itemize>

Знание <idx/Qt/ классов очень необходимо, даже если вы хотите разрабатывать только KDE-приложения. Чтобы получить первое представление
о том, как GUI-приложения конструируются и компилируются, мы рассмотрим простую, основанную исключительно на использовании <idx/Qt/ программу; 
затем мы расширим ее до KDE-приложения.

<sect1> Первое <idx/Qt/ приложение
<p>
Как правило, программа на C++ должна содержать функцию <tt/main()/, которая является стартовой точкой для выполнения приложения. 
Так как мы хотим, чтобы наше приложение отображалось в графическом окне и предоставляло возможность взаимодействия с пользователем, первое, что мы должны знать, - как оно может показать себя
пользователю. Посмотрим, например, на первую программу, включенную в учебник, поставляемый как часть <idx/Qt/ Online Reference Documentation,
и объясним основные шаги выполнения. 
Итак, почему и как появляется окно приложения:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</code></tscreen>

Это приложение просто рисует окно, содержащее кнопку с надписью "Hello world".  Как и для всех основанных на <idx/Qt/ приложений, вы первым делом
создаете экземпляр (instance) класса <tt/<cdx/QApplication//, представленный переменной <tt/a/.

Затем программа создает экземпляр класса <tt/QPushButton/, называемый <tt/hello/, это будет кнопка. 
Конструктор <tt/hello/ получает строку в качестве параметра, которая представляет собой содержимое элемента, отображаемое как текст на кнопке.

Потом вызывается метод <tt/resize()/ кнопки <tt/hello/. Это изменяет размер элемента по умолчанию (в данном случае
QPushButton), который при создании имел длину 100 пикселей и высоту 30 пикселей. Наконец, метод <tt/setMainWidget()/
вызывается для объекта <tt/a/ и метод <tt/show()/ -  для объекта <tt/hello/. <tt/<cdx/QApplication// выполняет вызов <tt/a.exec()/,
входя в главный цикл событий (main event loop) и ожидая, когда он должен будет вернуть значение integer операционной системе, сигнализируя,
что приложение завершилось.

<sect1> Справочная документация для <idx/Qt/
<p>
А сейчас мы кратко рассмотрим справочную документацию по <idx/Qt/ библиотеке. 
Для того, чтобы сделать это, запустите KDevelop и выберите "<idx/Qt/-library" из
"Help"-меню на панели меню. Средство просмотра документации откроет и покажет вам стартовую страницу справочного руководства <idx/Qt/. 
Это первое место, где необходимо искать информацию о <idx/Qt/, его классах и доступных функциях. Кроме того, приведенная выше программа входит первой
в секцию "tutorials". Чтобы добраться к тем классам, которые мы хотим посмотреть,
<tt/<cdx/QApplication// и <tt/QPushButton/, выберите 
"Alphabetical Class List" и найдите соответствующие имена. Следуйте по любому из линков, чтобы посмотреть документацию
по соответствующему классу.

Для <tt/<cdx/QApplication// вы увидите конструктор и все другие методы, которые есть в данном классе.
Если вы нажмете на линк какого-либо метода, вы получите более детальную информацию об использовании этого метода,
которая бывает очень полезна, если вы не можете определить, как правильно использовать метод, или хотите увидеть пример.
Это также относится к документации по библиотекам KDE, которые используют похожую структуру; вот и почти все,
что вы должны знать о просмотре документации по классам с помощью браузера.

<sect1>Интерпретация примера
<p>
Просматривая <tt/<cdx/QApplication//, вы найдете все его методы, используемые в нашем примере:

<itemize>
<item>constructor <tt/<cdx/QApplication/()/,
<item><tt/setMainWidget()/ метод и
<item><tt/exec()/ метод.
</itemize>

Пояснения, почему мы используем эти методы, очень простые:

<enum>
<item>вначале создаем экземпляр класса <tt/<cdx/QApplication// с помощью вызова конструктора, после этого мы можем использовать GUI элементы, предоставляемые <idx/Qt/,
<item>создаем элемент, который будет наполнением окна нашей программы,
<item>устанавливаем этот элемент как главный элемент для <tt/a/,
<item>выполняем экземпляр <tt/a/ класса <tt/<cdx/QApplication//.
</enum>

Второй объект нашей программы - кнопка (pushbutton), экземпляр класса <tt/QPushButton/. Из двух конструкторов, предоставляемых
для создания объекта, мы выбрали второй: он принимает в качестве аргумента текст, который будет отображаться как метка на кнопке; в данном случае это строка
"Hello world!". Затем мы вызвали метод <tt/resize()/ для изменения размеров кнопки в соответствии с размерами ее содержимого - кнопка должна быть больше, чтобы весь текст был видимым.

А как насчет метода <tt/show()/? Сейчас вы видите, что, как и большинство других элементов, <tt/QPushButton/ основывается на одиночном наследовании (single-inheritance).
Документация говорит, что <tt/QPushButton/ <em/унаследована/ от <tt/<cdx/QButton//.
Перейдем по линку на описание класса <tt/<cdx/QButton//. Это откроет множество других методов,
которые унаследованы QPushButton, мы воспользуемся ими позже для объяснения механизма сигнал/слот. В любом случае, метод <tt/show()/
не присутствует в списке, следовательно, это должен быть метод, передаваемый по наследству. Класс, от которого унаследован <tt/<cdx/QButton//,
<tt/<cdx/QWidget//. Перейдя опять по ссылке, вы увидите целую связку методов, которые реализованы в классе <tt/<cdx/QWidget//, включая
метод <tt/show()/. Теперь мы можем понять, что было сделано в примере с кнопкой:

<enum>
<item>создаем экземпляр <tt/QPushButton/, используя второй конструктор для установки текста на кнопке,
<item>изменяем размер элемента в соответствии с размером его содержимого (текста),
<item>делаем элемент главным элементом экземпляра <tt/<cdx/QApplication// <tt/a/,
<item>говорим элементу показать себя на экране, вызывая его метод <tt/show()/, унаследованный от <tt/<cdx/QWidget//.
</enum>

После вызова метода <tt/exec()/ приложение становится видимым для пользователя, отображая окно с кнопкой "Hello world!".
Таким образом, GUI программа кое в чем отличается от процедурного приложения. Основное здесь в том, что приложение входит
в так называемый "главный цикл событий" ("main event loop"). Это означает, что <idx/Qt/ приложение должно войти в главный цикл событий, чтобы начать обработку событий, потом программа ждет от пользователя действия и затем реагирует на него. 
Следующий раздел коротко описывает,
что это значит для программиста и какие средства представляет <idx/Qt/ для обработки пользовательских событий.

(Для уже опытных пользователей: Кнопка не имеет родителя, он не указан в конструкторе, поэтому она - единственный элемент верхнего уровня и 
работает в локальном цикле событий, и не нуждается во входе в глобальный цикл событий, см. документацию по классу <tt/<cdx/QWidget//  и 
"The KDE Library Reference Guide")

<bf/Подведение итогов:/

Приложения <idx/Qt/ всегда создают экземпляр класса <tt/<cdx/QApplication//. Это обеспечивает нам возможность создавать окна, которые
графически представляют программу пользователю и обеспечивают взаимодействие с ним. Содержимое окна называется Главный элемент ("Main Widget"). Это означает
что все графические элементы базируются на классе <tt/<cdx/QWidget//, и могут быть любыми элементами, удовлетворяющими нужды приложения
в части связи с пользователем. Поэтому все пользовательские элементы, которые необходимо сделать видимыми, должны быть унаследованы от <tt/<cdx/QWidget//.

<sect1>Взаимодействие с пользователем<label id="User Interaction">
<p>
После прочтения последнего раздела вы должны уже знать:
<itemize>
<item>что предоставляет библиотека <idx/Qt/ в терминах GUI приложения,
<item>как создаются программы, использующие <idx/Qt/ и
<item>где и как найти информацию о классах, которые вас интересуют, используя средство просмотра документации.
</itemize>

А сейчас мы вдохнем в приложение "жизнь", научив его обрабатывать пользовательские события. Обычно пользователь имеет два средства для взаимодействия с программой:
мышь и клавиатуру. В обеих случаях, графический пользовательский интерфейс должен иметь методы для регистрации действия и методы,
которые делают что-то, реагируя на это действие.

Оконная система, таким образом, передает все сгенерированные пользователем события соответствующему приложению. <cdx/QApplication/ затем передает их активному окну
как <tt/<cdx/QEvent// и элементы сами решают, что с ними делать. Элемент получает событие и выполняет
<tt/<cdx/QWidget/::event(<cdx/QEvent/*)/, который решает, какое событие произошло и как реагировать; <tt/event()/, следовательно,
является главным обработчиком событий. Затем функция <tt/event()/ проводит событие через так называемый фильтр событий, который определяет, что случилось и что делать
с событием. Если ни один фильтр не распознал событие, вызывается специальный обработчик событий.
Таким образом, мы должны различать:

<bf/a) События клавиатуры -- клавиши TAB и  Shift-TAB :/

изменяет фокус ввода с клавиатуры с текущего элемента на следующий элемент в порядке изменения фокусов. Фокус может быть установлен для элемента
вызовом <tt/setFocusPolicy<ncdx/setFocusPolicy()/()/. Изменение фокуса обрабатывается следующими обработчиками событий: :

<itemize>
<item><tt/virtual void focusInEvent<ncdx/focusInEvent()/ ( <cdx/QFocusEvent/ * )/
<item><tt/virtual void focusOutEvent<ncdx/focusOutEvent()/ ( <cdx/QFocusEvent/ * )/
</itemize>

<bf/b) другой ввод с клавиатуры:/
<itemize>
<item><tt/virtual void keyPressEvent<ncdx/keyPressEvent()/ ( <cdx/QKeyEvent/ * )/
<item><tt/virtual void keyReleaseEvent<ncdx/keyReleaseEvent()/ ( <cdx/QKeyEvent/ * )/
</itemize>

<bf/c) перемещение мыши:/
<itemize>
<item><tt/virtual void mouseMoveEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void enterEvent ( <cdx/QEvent/ * )/
<item><tt/virtual void leaveEvent ( <cdx/QEvent/ * )/
</itemize>

<bf/d) нажатие кнопок мыши:/
<itemize>
<item><tt/virtual void mousePressEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseReleaseEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseDoubleClickEvent ( <cdx/QMouseEvent/ * )/
</itemize>

<bf/e) события окна, содержащего элемент:/
<itemize>
<item><tt/virtual void moveEvent ( <cdx/QMoveEvent/ * )/
<item><tt/virtual void resizeEvent ( <cdx/QResizeEvent/ * )/
<item><tt/virtual void closeEvent ( <cdx/QCloseEvent/ * )/
</itemize>

Заметьте, что все функции событий virtual и protected; таким образом, вы можете переопределить события, которые вам нужны в ваших элементах,
и указать, как ваш элемент должен на них реагировать. <tt/<cdx/QWidget// также содержит несколько других виртуальных методов, которые могут быть полезны в ваших программах; 
это, в общем-то, все, что вам сейчас необходимо знать о <tt/<cdx/QWidget//.

<sect1>Взаимодействие объектов с помощью сигналов и слотов
<p>
Сейчас мы подошли к наиболее яркому преимуществу <idx/Qt/ инструментария: механизм сигнал/слот. Этот механизм предлагает очень удобное и полезное 
решение для реализации взаимодействия объектов, которое обычно выполняется с помощью <tt/callback/ функций для различных X-Window наборов элементов.
Реализация с помощью <tt/callback/ функций требует очень строгого программирования и иногда превращает задачу построения пользовательского интерфейса в очень сложную
(как об этом говорится в документации <idx/Qt/ и как это объяснено в книге K.Dalheimer <em/Programming with <idx/Qt//).
Troll Tech изобрела новую систему, в которой объекты могут испускать (emit) сигналы,
которые могут быть соединены (connected) с методами, объявленными как слоты (slot).
Для программиста на C++ необходимо знать несколько простых вещей об этом механизме:

<enum>
<item>объявление класса, который использует сигналы/слоты, должно содержать макрос <tt/Q_OBJECT/ в начале (без ";");
и этот класс должен быть унаследован от <tt/QObject/.
<item>сигнал может испускаться по ключевому слову <tt/emit/, например, <tt/emit signal(parameters);/ из любой функции-члена класса, который поддерживает механизм сигнал/слот,
<item>все сигналы, используемые классом и не унаследованные от предков, должны быть добавлены в объявление класса в секцию <tt/signals:/,
<item>все методы, которые могут быть соединены с сигналами, должны быть объявлены в секциях с дополнительным ключевым словом <tt/slot/, например,
<tt/<bf/public/ slots:/ внутри объявления класса,
<item>meta-object компилятор <tt/moc/ должен быть запущен для обработки файла заголовка для подстановки макросов и выдачи файла с реализацией
(в которой не требуется разбираться). Выходной файл <tt/moc/ компилируется обычным компилятором C++.
</enum>
Другой способ использовать сигналы без наследования от <tt/QObject/ - использовать класс <tt/QSignal/ - см. справочное руководство
для получения дополнительной информации и примеров использования. В дальнейшем материале мы предполагаем, что используется наследование от <tt/QObject/.

Используя этот механизм, ваш класс может посылать сигналы и предоставлять слоты для присоединения к ним сигналов. Используя сигналы, вы не должны
заботиться о том, кто их получает - вы должны испустить сигнал и любой слот, который вы соединили с этим сигналом, сможет прореагировать
на появление сигнала. Кроме того, слоты могут использоваться как обычные методы при реализации программы.

Теперь, для того, чтобы соединить сигнал и слот, вы должны использовать метод <tt/connect()/, который предоставляет <tt/QObject/, или, где это возможно, 
специальные методы, которые предоставляют объекты для установки соединения с определенными сигналами.

<sect2>Пример использования
<p>
Чтобы объяснить, как организовать межобъектное взаимодействие, вернемся к нашему первому примеру и добавим в него простое соединение:

<tscreen><code>
#include <qapplication.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</code></tscreen>

Как видно, единственное изменение, оживляющее кнопку, - использование метода <tt/connect()/:
<tt/connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));/. Вот и все, что мы добавили. 
Что это значит? В классе <tt/QObject/ метод <tt/connect()/ объявляется так:

<tt/bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )/

Это значит, что вы должны предоставить экземпляру QObject указатель на источник сигнала, имея в виду, что он должен уметь испускать этот сигнал, 
первым параметром; затем вы должны указать сигнал, для которого устанавливается соединение. Следующие два параметра - объект-получатель, 
который предоставляет слот, и фукнкция-член, которая <em/и есть/ слот, выполняемый при получении сигнала. 

Используя сигналы и слоты, объекты вашей программы могут взаимодействовать между собой проще, без точного определения типа объекта-получателя сигнала. 
Вы изучите подробнее использование этого механизма позднее в этой книге. Более подробная информация о
механизме Сигнал/Слот также может быть найдена в "The KDE Library Reference Guide" 
и в <idx/Qt/ online-документации.

<sect>Что предлагает KDE
<p>
<sect1>Библиотеки KDE 1.1.x 
<p>
На момент написания книги KDevelop использует KDE 1.1, поэтому мы здесь рассмотрим 
<idx/библиотеки KDE / этого релиза. Основные <idx/библиотеки KDE/, которые вы будете использовать при разработке <idx/приложений KDE/, следующие: 

<itemize>
<item>библиотека KDE-Core содержит все классы, не являющиеся видимыми элементами, и обеспечивает реализацию тех возможностей, которые ваше приложение может использовать;
<item>библиотека KDE-UI содержит элементы пользовательского интерфейса, такие как панель меню, <idx/панели инструментов/ и т.п.;
<item>библиотека KFile содержит диалоговое окно выбора файлов.
</itemize>

Кроме того, для специальных целей KDE предоставляет следующие библиотеки:

<itemize>
<item>библиотека KHTMLW содержит элемент, который полностью интерпретирует HTML-файлы и используется в таких программах, как <idx/KDEHelp/, KFM, KDevelop;
<item>библиотека KFM позволяет использовать KDE менеджер файлов из вашего приложения;
<item>библиотека KAb, KAddressBook. Реализует доступ к адресной книге, например, для приложений, работающих с email;
<item>библиотека KSpell предоставляет элементы для интеграции Ispell, программы проверки правописания, в приложения типа
редакторов; используется в KEdit.
</itemize>

Теперь давайте посмотрим, что необходимо сделать, чтобы превратить наше <idx/Qt/ приложение в KDE приложение.

<sect1>Пример приложения KDE 
<p>
Сейчас вы увидите, что создание KDE приложения не на много сложнее, чем приложения для <idx/Qt/. Для использования возможностей KDE
вы просто должны включить в программу другие классы, и все будет сделано. Например, рассмотрим измененную версию примера программы <idx/Qt/,
приведенного выше:

<tscreen><code>
#include <kapp.h>
#include <qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</code></tscreen>

Как видно, в первую очередь мы изменили <tt/<cdx/QApplication// на <tt/<cdx/KApplication//. Далее, мы использовали вместо метода
<tt/setMainWidget()/ метод <tt/setTopWidget/, который вызывает <tt/<cdx/KApplication// для установки главного элемента (main widget). Вот и все! Ваше первое KDE
приложение готово - вы только должны сообщить компилятору путь к файлам KDE, упомянутым в командах "#include", и линкеру - линковать с ключом -lkdecore.

Теперь, когда вы знаете, что в общем делает функция main(), как приложения становятся видимыми и как организовать взаимодействие пользователя и объектов программы,
мы переходим к следующей главе, где мы сделаем наше первое приложение с помощью KDevelop - там вы сможете также протестировать все вышеупомянутое и посмотреть результат.

Сейчас вам будет полезно посмотреть дополнительно справочное руководство по <idx/Qt/, особенно в части <tt/<cdx/QApplication//,
<tt/<cdx/QWidget// и <tt/QObject/, документацию по библиотеке KDE-Core для класса <tt/<cdx/KApplication//.
Справочник "KDE Library Reference" содержит полное описание вызова
конструкторов <tt/<cdx/QApplication// и <tt/<cdx/KApplication//, включая обработку аргументов командной строки.

<chapt>Создание новых приложений <label id="Creating new Applications">
<p>
KAppWizard, также называемый KDE Application Wizard, предназначен для того, чтобы помочь вам начать работу над новым проектом в KDevelop.
Таким образом, для начала любого вашего проекта вы должны использовать KAppWizard. Потом вы сможете модифицировать и дополнять автоматически сгенерированный скелет кода.
KAppWizard позволяет выбрать один из нескольких типовых проектов, в зависимости от предназначения вашего приложения:

<itemize>
<item>Обычное приложение KDE: включает исходный код, реализующий стандартную структуру фреймов приложения KDE с поддержкой
модели Докумет-Просмотр (Document-View-Controller), панели меню, <idx/панели инструментов/ и строки статуса, а также набор базовых шаблонов документации в <idx/SGML/-формате, 
ссылки на KDE-ресурсы и иконки приложения. Этот тип приложений обычно используется для создания новых KDE-проектов.
<item>Простое KDE приложение (Mini KDE Application): имеет ту же структуру, что и обычное KDE приложение, но с тем отличием, что
есть только один видимый элемент - окно.
<item>Обычное <idx/Qt/ приложение: содержит то же, что и KDE приложение, но код использует только <idx/Qt/
библиотеки и не содержит поддержки KDE. Это может быть полезно для приложений, которые планируется переносить на WINDOWS платформу, или для тех,
которые не планируют использование конечным пользователем KDE библиотек.
<item>C приложение: консольное приложение для C компилятора.
<item>C++ приложение: использует C++ компилятор и запускается в консоли, следовательно, не требует  X-Window.
<item>Пользовательский проект: создает пустой проект без какого-либо кода. Это может быть полезно для перевода уже существующих программ
под KDevelop или для старта "с самого начала". Имейте в виду, что вы должны уделить внимание созданию makefile'ов и конфигурационных скриптов.
</itemize>

В этой главе мы увидим, как можно использовать KAppWizard и что должно быть сделано для создания проекта KDE приложения.
Это будет первый шаг нашего пути, где мы создадим исходную версию примера проекта. Для всех остальных типов проектов
шаги почти такие же, только вам предоставляется меньше опций для выбора.

<sect>Использование KAppWizard и генерация проекта
<p>
<sect1>Запуск KAppWizard и первая страница
<p>
Чтобы начать создание вашего первого KDE приложения, откройте KDevelop. Затем выберите пункт "New..." из меню "Project". Запустится KAppWizard, и вы
увидите дерево на первой странице, содержащее типы проектов. При выборе типа в правой части окна можно увидеть, как будет выглядеть приложение после
работы KAppWizard. Выберите ветвь KDE, тип Normal (Обычное приложение KDE). После этого нажмите кнопку "Next" внизу первой страницы KAppWizard.
Это приведет к переходу на следующую страницу, где вы сможете установить основные опции проекта.

<sect1>Установки страницы Generate
<p>
Для нашего примера мы выберем имя проекта <tt/KScribble/; введите это в поле "Projectname". Затем выберите
каталог, в котором вы хотите разместить свой проект; по умолчанию это ваш домашний каталог. Вы можете ввести путь вручную или 
нажать кнопку справа от поля для выбора каталога через диалоговое окно.

Теперь вы должны ввести номер версии. Для первой версии установите номер <tt/0.1/. Это обычный номер для нового приложения, которое находится в стадии разработки.
Для таких приложений присваиваются номера, меньшие 1, а стартовая версия вашего приложения будет иметь только исходный набор фреймов, поэтому назовите ее 
0.1.

Наконец, введите свое имя в поле "Author" и ваш email адрес. Остальные опции можете оставить с их значениями по умолчанию.

Для получения дополнительной информации обо всех других опциях, вы можете нажать правую кнопку мыши над соответствующим полем и выбрать пункт меню quick-help.
Откроется окно помощи с кратким описанием назначения опции. Это:

<itemize>
<item><bf/generate sources and headers:/  генерировать исходный код и файлы заголовков.
<item><bf/GNU-Standard-Files:/  добавить копию GNU - General Public License в проект и некоторые стандартные файлы с информацией для пользователя
при распространении пакета.
<item><bf/User-Documentation:/ руководство пользователя в <idx/SGML/, шаблон которого уже подготовлен для вашего проекта.
<item><bf/<idx/API/-Documentation:/ создает стартовый набор HTML документации для <bf/A/pplication <bf/P/rogramming <bf/I/nterface.
<item><bf/lsm-File:/ Linux Software Map, используется при распространении программы на предлагающих ее сайтах и представляет собой файл с кратким описанием назначения
проекта и его требований.
<item><bf/<idx/.kdelnk/-File: / файл ссылки, который будет записан в ветку "Applications" дерева меню панели KDE-Panel при инсталляции приложения.
<item><bf/Program-Icon: / иконка, которая представляет проект и может быть использована для создания ссылки на рабочем столе.
<item><bf/Mini-Icon: / мини-иконка, которая отображается возле названия приложения в KDE-Panel,
в верхнем левом углу диалоговых окон приложения и его главного окна.
</itemize>

Теперь переключаемся на следующую страницу нажатием кнопки "Next" для создания шаблона файла заголовка вашего проекта.

<sect1>Шаблоны заголовков и исходников
<p>
Страница шаблонов заголовков позволяет вам автоматически включать предисловие в ваш файл шаблона, содержащее имя файла, дату, год,
copyright, ваше имя и email адрес. Вы не должны изменять текст, набранный заглавными буквами, самостоятельно,
KAppWizard сделает это автоматически и добавит шаблон в ваш проект, вы сможете его использовать в дальнейшем для создания новых файлов.

Вторая часть шаблона файла заголовка, предоставляемого по умолчанию, содержит информацию о лицензировании. Предполагается, что ваш проект попадает под действие 
GNU General Public License, которая также включается в дистрибутив. Эта лицензия используется, чтобы защитить ваш исходный код от любого, кто
захочет его скопировать для своих собственных целей. General Public License предлагает вам эту лицензию и таким образом защищает ваши авторские права,
это общепринято при распространении свободного программного обеспечения. Для получения дополнительной информации о лицензии вы можете прочитать COPYING
файл в корневом каталоге вашего проекта (он будет туда занесен после завершения работы KAppWizard), который является копией GPL и уже входит в состав вашего приложения.

Вы можете выбрать другую лицензию или другой шаблон для использования с проектом. 
Также вы можете отредактировать предоставляемый по умолчанию шаблон. Для того, чтобы сделать это, вы должны вызвать шаблон в окно редактирования. Для очистки страницы по умолчанию
выберите "New", для использования другого шаблона выберите "Load...", что откроет диалоговое окно выбора файла.

Когда вы закончите с этим, переходите к следующей странице, нажав "Next". Эта страница для создания шаблона вашего исходника. В общем она
такая же, как и страница создания шаблона файла заголовка. Единственное отличие в том, что шаблоны используются 
для создания файлов реализации объявленных в заголовках функций.

<sect1>Создание проекта
<p>

Теперь, когда вы заполнили все опции для <em/KScribble/, выберите "Next" и нажмите кнопку "Generate" внизу окна KAppWizard.
Если кнопка недоступна, значит, вы установили неправильное значение какой-либо опции. Для исправления ошибки вернитесь назад с помощью кнопки "Back".

После нажатия кнопки "Generate" вы должны увидеть, что KAppWizard начал работу - он копирует все шаблоны в каталог вашего проекта. Потом, когда KAppWizard
завершит работу, кнопка "Cancel" заменится на "Exit". Ее нажатие приведет к выходу из генератора.

После этого шага вы завершаете процесс создания нового проекта. KDevelop загрузит его и предоставит возможность исследовать структуру,
представив проект в виде дерева файлов или классов.

В следующем разделе мы опишем, как откомпилировать и запустить вашу первую версию <em/KScribble/, и обсудим, как организован исходный код.

<sect>Первый запуск
<p>
После того, как наш проект сгенерирован, первое, что необходимо сделать, - просмотреть структуру кода, чтобы получить общее понимание того, как работает приложение.
Это не только поможет нам начать разработку, а и в дальнейшем мы будем ориентироваться, где необходимо вносить изменения.

Когда мы откроем страничку LFV (Logical File Viewer) в левой части окна KDevelop, мы увидим несколько папок, в которых уже размещены файлы проекта в соответствии с их назначением.  
Первые две папки - "Headers" и "Sources". Папка заголовков логически содержит все файлы заголовков проекта,
папка "Sources" - все исходники. Остальные папки сейчас для нас не интересны, их назначение мы рассмотрим позднее.

Две папки содержат следующие файлы:

<bf/Headers:/
<itemize>
<item><bf/kscribble.h :/ содержит объявление класса <bf/KScribbleApp/.
<item><bf/kscribbledoc.h :/ содержит объявление класса <bf/KScribbleDoc/.
<item><bf/kscribbleview.h :/ содержит объявление класса <bf/KScribbleView/.
<item><bf/resource.h :/ содержит коллекцию макросов идентификаторов пунктов меню.
</itemize>

<bf/Sources:/
<itemize>
<item><bf/kscribble.cpp :/ содержит реализацию класса <bf/KScribbleApp/.
<item><bf/kscribbledoc.cpp :/ содержит реализацию класса <bf/KScribbleDoc/.
<item><bf/kscribbleview.cpp :/ содержит реализацию класса <bf/KScribbleView/.
<item><bf/main.cpp :/ содержит реализацию функции <bf/main()/.
</itemize>

Перед тем, как углубиться в исходный код, позволим KDevelop откомпилировать и запустить наше новое приложение. Чтобы сделать это, выберем "Make" из меню "Build".
или нажмем соответствующую кнопку на панели инструментов. В нижней части KDevelop откроется окно вывода,
и мы увидим сообщения, выдаваемые <tt/make/ при работе. Они могут несколько отличаться от приводимых ниже,
в зависимости от используемых настроек.

<tscreen><code>
1   Making all in docs
2   make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
3   Making all in en
4   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
5   make[2]: Nothing to be done for `all'.
6   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs/en'
7   make[2]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
8   make[2]: Nothing to be done for `all-am'.
9   make[2]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
10  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble/docs'
11  make[1]: Entering directory `/home/rnolden/Tutorial/kscribble1/kscribble'
12  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.cpp
13  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.cpp
14  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c 		
    kscribble.cpp
15  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    main.cpp
16  /usr/bin/moc ./kscribble.h -o kscribble.moc.cpp
17  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribble.moc.cpp 		
18  /usr/bin/moc ./kscribbledoc.h -o kscribbledoc.moc.cpp
19  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbledoc.moc.cpp
20  /usr/bin/moc ./kscribbleview.h -o kscribbleview.moc.cpp
21  g++ -DHAVE_CONFIG_H -I. -I. -I.. -I/opt/kde/include -I/usr/lib/qt/include  -I/usr/X11R6/include    -O0 -g -Wall  -c
    kscribbleview.moc.cpp

22  /bin/sh ../libtool --silent --mode=link g++  -O0 -g -Wall   -o kscribble -L/opt/kde/lib  -L/usr/X11R6/lib -rpath /opt/kde/lib
    -rpath /usr/X11R6/lib kscribbleview.o kscribbledoc.o kscribble.o main.o kscribble.moc.o kscribbledoc.moc.o kscribbleview.moc.o
    -lkfile -lkfm -lkdeui -lkdecore -lqt -lXext -lX11

23  make[1]: Leaving directory `/home/rnolden/Tutorial/kscribble1/kscribble'
</code></tscreen>
<p>
Мы проставили номера строк напротив каждой строки, которых нет в выводе KDevelop. Это сделано для облегчения дальнейшего обсуждения того,
что происходит при компиляции. Во-первых, <tt/make/ работает рекурсивно. Это значит, что она начинает с каталога, откуда была вызвана, и
затем в первую очередь заходит в подкаталог, возвращается и заходит в следующий подкаталог. Наконец, обрабатывается стартовый каталог
и <tt/make/ завершается. <tt/make/ вызывается из главного каталога проекта, содержащего исходники. В строках 1 и 2 
мы видим, как <tt/make/ входит в каталог <tt/docs/, затем в подкаталог <tt/en/. Так как там нечего делать, она
выходит из этих каталогов, пока не вернется в каталог исходников <tt/kscribble/ в строке 11. Теперь начинается настоящая работа: <tt/make/
вызывает компилятор, <tt/g++/, для компиляции файла-исходника <tt/kscribbleview.cpp/. Макрос <tt/-DHAVE_CONFIG_H/ говорит о том, что должен быть использован файл
<tt/config.h/. Этот файл содержит макросы для определения платформы и приложения, и расположен в корневом каталоге проекта.
Следующие <tt/-I/ команды добавляют пути для поиска файлов, указанных в команде <tt/"#include"/. Это
текущий каталог, корневой каталог проекта (<tt/-I../), и пути к файлам KDE, <idx/Qt/ и заголовкам библиотек X11.
Эти пути определяются при выполнении скрипта <tt/configure/ и устанавливаются в файлах Makefile; таким образом, компилятор
знает, где файлы расположены. Наконец, <tt/-O0/ устанавливает оптимизацию в ноль (без оптимизации), <tt/-g/ разрешает отладку, <tt/-Wall/
устанавливает предупреждения компилятора в значение <tt/all/, и <tt/-c/ говорит компилятору, что необходимо генерировать только файлы obj, то есть надо только откомпилировать файлы.

Это делается и для других файлов-исходников нашего проекта в строках 13-15. Очевидно, наш исходный код откомпилирован, но вместо того,
чтобы линковать объектные файлы исходников в конечный бинарный файл, мы видим несколько иные команды. В строке 16 программа "moc"
вызывается для обработки файла-заголовка <tt/kscribble.h/, выводя результат в <tt/kscribble.moc.cpp/. Затем, в строке 17, этот исходный файл
компилируется. Аналогичные операции проделываются с другими файлами заголовков проекта до строки 21. Это необходимо, поскольку <idx/Qt/ поддерживает механизм сигнал/слот,
но базируется на C++ реализации, и мы используем определенные ключевые слова, не поддерживаемые языком C++, такие как  
<tt/signals:/ и <tt/slots:/, в наших классах. Это дает нам возможность легко организовать межобъектное взаимодействие для всех 
экземпляров классов, порожденных от <tt/QObject/, и избежать использования традиционного механизма callback указателей на функции. 
Таким образом, приложению необходим исходный код, который обеспечивает данную функциональность, и вот для чего вызывается
<tt/moc/. <tt/Moc/ - Meta Object Compiler набора инструментов <idx/Qt/. Он реализует механизм сигнал/слот, обрабатывая файл заголовка и генерируя код, который
должен быть откомпилирован для получения бинарного файла. Поскольку проекты KDevelop используют <tt/automoc/ для определения того, какие файлы заголовков должны быть обработаны, мы
не должны следить за вызовами <tt/moc/ и C++ компилятора для обработки сгенерированных <tt/moc/ файлов. Только запомните правило, что для использования
механизма сигнал/слот класс должен быть порожден от <tt/QObject/, или от любого другого класса, порожденного от <tt/QObject/; кроме того,
этот класс должен содержать макрос <tt/Q_OBJECT/ (без ";"!) в начале своего объявления, и объявления сигналов и слотов.

Наконец, генерируется бинарный файл. Выходной бинарный файл называется <tt/kscribble/, линкер использует пути к библиотекам KDE и 
X11, и линкует исходники с библиотеками <tt/kfile, kfm, kdeui, kdecore, qt, Xext/ и <tt/X11/. На этом 
make завершает свою работу.

<sect>Структура скелета исходного кода
<p>

Чтобы понять и использовать концепцию того, как работает приложение KDE, в первую очередь мы должны очень внимательно изучить структуру скелета исходного кода, сгенерированную KAppWizarg.
Как мы уже видели, у нас есть набор файлов заголовков и кода, которые реализуют исходный код приложения,
и делают его готовым к выполнению. Таким образом, простейший путь объяснить код - пройти строка за строкой код так,
как он обрабатывается в процессе выполнения программы до входа в главный цикл событий и перехода в режим ожидания ввода пользователя. Затем мы рассмотрим, как реализуются функции взаимодействия с пользователем
и как некоторые вещи работают. Это, наверное, лучший путь объяснить, как работают элементы окна (framework),
и, поскольку это стандартно для большинства приложений KDE, такое объяснение позволит нам читать исходный код других проектов; кроме того,
мы узнаем, где что необходимо изменить, чтобы заставить свое приложение работать так, как от него требуется.

<sect1>Функция <tt/main()/<label id="The main() Function">
<p>
Поскольку приложение начинает свое выполнение входом в функцию <tt/main()/, она и будет стартовой точкой нашего исследования.
Функция <tt/main()/ <em/KScribble/ реализована в файле <tt/main.cpp/, а также может быть найдена с помощью
просмотрщика классов (Class Browser) в папке "Globals", подпапке "Functions":

<tscreen><code>
1  #include "kscribble.h"
2
3  int main(int argc, char* argv[]) {
4    KApplication app(argc,argv,"KScribble");
5
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
10   else
11   {
12      KScribbleApp* kscribble = new KScribbleApp;
13      kscribble->show();
14      if(argc > 1){
15        kscribble->openFile(argv[1]);
16      }
17    }
18    return app.exec();
19  }
</code></tscreen>

Итак, что же происходит в первую очередь при создании объекта <tt/<cdx/KApplication//, который получает третьим аргументом имя приложения <em/KScribble/?
Когда создается новый <tt/<cdx/KApplication//, порождается новый экземпляр объекта <tt/<cdx/KConfig//, который устанавливает связь с конфигурационным файлом,
$HOME/.kde/share/config/appname+rc, содержащим информацию, которую мы хотим использовать при открытии окна приложения. Имя,
которое мы передали конструктору <tt/app/, будет использовано позднее в заголовке окна.

По сравнению с примером кода, приведенным при преобразовании первого приложения <idx/Qt/ в приложение KDE, нынешний код имеет отличия. 
После создания экземпляра <tt/<cdx/KApplication// мы проверяем, как приложение вызвано: <tt/kwm/ менеджером сессий или пользователем.
Это можно узнать, вызывая метод <tt/isRestored()/ объекта <tt/app/, который возвращает <tt/true/ для случая менеджера сессий
и <tt/false/ при нормальном запуске.

Менеджмент сессий (session management) - одна из основных возможность приложений KDE, и она широко используется приложениями, но ее несколько долго объяснять.
Поэтому мы вначале последуем по ветке <tt/else{}/; затем мы вернемся и поясним функционирование менеджмента сессий.

<sect1>Запуск приложения пользователем
<p>
В ветке <tt/else{}/ создается экземпляр класса <tt/KScribbleApp/ (строка 12). Этот объект вызывается, чтобы прорисовать себя, в строке
13, как обычно; строка 14 определяет, есть ли аргументы в командной строке. Если есть, то обычно это имя файла, поэтому
объект <tt/kscribble/ открывает этот файл с помощью метода <tt/openFile()/.

Обратите внимание, что мы не вызывали метод <tt/setTopWidget(kscribble)/ для нашего приложения - это уже сделано предками класса <tt/KScribbleApp/.
Теперь посмотрим на наш объект <tt/KScribbleApp/ - что это такое и что он предлагает? Единственная вещь, которую мы знаем
на текущий момент, это то, что он должен быть видимым элементом (Widget) для представления пользовательского интерфейса в окне приложения. Обратимся к реализации класса
<tt/KScribbleApp/, которая находится в файле <tt/kscribble.cpp/, или нажмем мышкой на иконке класса в просмотрщике классов.
Экземпляр класса был создан с помощью конструктора. Во-первых, мы видим, что он порожден от класса <tt/<cdx/KTMainWindow//, который является частью <tt/kdeui/. Этот класс, в свою очередь,
унаследован от <tt/<cdx/QWidget//, таким образом, мы имеем нормальный видимый элемент в качестве верхнего окна (top-level window).
<tt/<cdx/KTMainWindow// содержит массу функций, которые использует класс <tt/KScribbleApp/. Он предоставляет панель меню, <idx/панели инструментов/, строку статуса и поддержку менеджмента сессий. Единственная вещь,
которую мы должны сделать, когда наследуем новый класс от <tt/<cdx/KTMainWindow//, - создать все объекты, которые нам нужны, и создать другой элемент, который управляется нашим 
экземпляром <tt/<cdx/KTMainWindow// и заполняет рабочую область окна; обычно этот объект выглядит как область редактирования текста. 

<sect2>Конструктор
<p>
Давайте взглянем на код конструктора и рассмотрим, как создается экземпляр объекта:

<tscreen><code>
1   KScribbleApp::KScribbleApp()
2   {
3     config=kapp->getConfig();
4	
5
6     ///////////////////////////////////////////////////////////////////
7     // вызываем методы init для активации всех остальных частей конструктора
8     initMenuBar();
9     initToolBar();
10    initStatusBar();
11    initKeyAccel();
12    initDocument();
13    initView();
14
15    readOptions();
16
17    ///////////////////////////////////////////////////////////////////
18    // запрещаем меню и панели инструментов при старте
19    disableCommand(ID_FILE_SAVE);
20    disableCommand(ID_FILE_SAVE_AS);
21    disableCommand(ID_FILE_PRINT);
22
23    disableCommand(ID_EDIT_CUT);
24    disableCommand(ID_EDIT_COPY);
25    disableCommand(ID_EDIT_PASTE);
26  }
</code></tscreen>

Мы видим, что наш экземпляр <tt/<cdx/KConfig//, отвечающий за конфигурацию, сейчас указывает на конфигурацию приложения, поэтому мы сможем работать
с установками конфигурационного файла в дальнейшем.

Затем, все части приложения, которые необходимы, созданы вызовом соответствующих функций-членов, которые специфичны для нашего приложения.

<itemize>
<item><bf/initMenuBar():/  создает панель меню,
<item><bf/initToolBar():/  создает  <idx/панель инструментов/,
<item><bf/initStatusBar():/ создает строку статуса,
<item><bf/initKeyAccel():/  устанавливает все клавиши быстрого доступа(accelerators)<nidx/accelerator/ для нашего приложения согласно глобальной конфигурации, определенной приложением,
<item><bf/initDocument():/ создает объект документа для окна приложения,
<item><bf/initView():/ создает главный элемент, заполняющий наше окно,
<item><bf/readOptions():/  считывает все специфичные для приложения установки из конфигурационного файла и инициализирует 
оставшиеся части приложения, такие как список последних файлов, положение панелей и размеры окна.
</itemize>

Наконец, мы запрещаем несколько команд, которые пользователь может выдать, поскольку они не должны быть доступны в нынешнем состоянии приложения.
Сейчас мы рассмотрели в общем как создается окно приложения, теперь мы углубимся в детали того, как создаются пользовательские элементы
в упомянутых выше методах.

<sect2>Панель меню
<p>Как показано выше, панель меню <em/KScribble/ создается методом <tt/initMenuBar()/. В нем мы создаем набор
<tt/<cdx/QPopupMenu//, которые выпадают, когда пользователь выбирает пункт меню. Затем мы вставляем их в панель меню и подсоединяем к их входам функции, выполняемые при выборе.

В первую очередь, мы создаем наше <tt/recent_file_menu/, которое содержит названия последних 5 открытых файлов. Мы делаем это первым делом, потому что
это меню вставляется в <tt/file_menu/. Затем мы добавляем непосредственно связь  - мы только что получили сигнал, который испущен
входом меню с определенным номером входа и вызываем <tt/slotFileOpenRecent( int )/, который затем вызывает нужный файл из списка последних открытых файлов.

Теперь мы создаем наше "File"-меню. Это будет меню, выпадающее из панели меню. Стандартные действия вставляются одно за другим в
выпадающее меню - вначале команда создания нового файла, открытия файла, закрытия файла и т.д., наконец "E&amp;xit" для закрытия
приложения. Все входы меню должны быть созданы в том порядке, в каком они будут появляться в дальнейшем, поэтому мы должны следить за тем, 
что в каком месте необходимо расположить. Рассмотрим, например, следующие входы:

<tscreen><verb>
file_menu->insertItem(Icon("fileopen.xpm"), i18n("&amp;Open..."), ID_FILE_OPEN );
file_menu->insertItem(i18n("Open &amp;recent"), recent_files_menu, ID_FILE_OPEN_RECENT );
</verb></tscreen>

Первая команда вставляет вход "Open...". Поскольку мы хотим иметь его с иконкой, мы используем <tt/insertItem()/ с именем иконки.
Чтобы понять процесс загрузки иконок, мы должны знать, где определен <tt/Icon()/. На самом деле это не метод, это макрос, предоставляемый
классом <tt/<cdx/KApplication//:

<tscreen><verb>
#define Icon(x) kapp->getIconLoader()->loadIcon(x)
</verb></tscreen>

Кроме того, он использует внутри следующий макрос для получения доступа к объекту приложения:

<tscreen><verb>
#define kapp KApplication::getKApplication()
</verb></tscreen>

Это означает, что объект <tt/<cdx/KApplication// уже содержит экземпляр загрузчика иконок - мы должны только получить к нему доступ; после этого он
загрузит соответствующую иконку. Поскольку все наши иконки входят в состав <idx/библиотек KDE/, мы не должны заботиться ни о чем больше - они устанавливаются 
в системе автоматически, следовательно, мы также не должны включать их в состав дистрибутива нашего приложения.

После параметра иконки (который не обязателен), мы вставляем вход меню с именем <tt/i18n("&amp;Open...")/. Таким образом, мы должны разобраться с двумя вещами.
Во-первых, вход вставлен с использованием метода <tt/i18n()/. Как и <tt/Icon()/, это макрос, определенный в <tt/<cdx/kapp.h//,
который вызывает <tt/KLocale/ объект класса <tt/<cdx/KApplication// для перевода входа на используемый язык:

<tscreen><verb>
#define i18n(X) KApplication::getKApplication()->getLocale()->translate(X)
</verb></tscreen>

Однако, кто-то может сказать "Я не хочу использовать макросы!" - вы можете делать это в большинстве случаев. Но в данной ситуации
вы должны использовать <tt/i18n()/, потому что процедура интернационализации приложения предполагает генерацию файлов,
содержащих то, что надо интернационализировать. А ход этого процесса зависит от строки <tt/i18n()/. Поэтому вы должны использовать макрос.

Как вы уже, наверное, догадались, амперсант внутри входа меню интерпретируется как подчеркивание следующей буквы в
тексте входа меню. Это позволяет осуществлять быстрый доступ к командам меню с клавиатуры, когда пользователь нажимает клавишу <tt/Alt/ и одновременно 
подчеркнутую букву.

Наконец, мы назначаем входу меню идентификатор, который является числом типа integer, по которому мы сможем найти вход меню в дальнейшем.
Чтобы иметь контроль над значениями используемых идентификаторов, они определяются как макросы. Все они собраны в файле <tt/resource.h/ нашего проекта.
Для обеспечения однообразия, эти макросы все набраны заглавными буквами и начинаются с ID_, затем следует имя меню, а за ним имя входа. Это делает очень простым
определение смысла каждого входа, где бы он ни встретился в коде, и вы не должны возвращаться к коду панели меню для поиска входов.

Следующий пример входа показывает другой вариант метода <tt/insertItem()/. Здесь мы добавляем выпадающее меню recent_files_menu как
элемент меню. Это значит, что вход отобразится в виде переданной ему надписи "Open recent", а затем будет стоять стрелка вправо. При выборе входа
появится выпадающее меню со списком последних открытых файлов, и пользователь сможет из него выбрать необходимый файл.

Наконец, существует еще множество способов добавления нового входа меню - в данном случае все реализовано максимально просто. Более подробную
информацию можно найти в документации <idx/Qt/, в описании класса <tt/<cdx/QMenuData//.

Теперь, после создания выпадающих меню <tt/file_menu, edit_menu/ и <tt/view_menu/, мы должны включить "Help"-меню. Мы можем
сделать это аналогично, но класс <tt/<cdx/KApplication// предоставляет красивый и быстрый метод для этого:

<tscreen><verb>
help_menu = kapp->getHelpMenu(true, i18n("KScribble\n" VERSION ));
</verb></tscreen>

Это все, что мы должны сделать, чтобы получить меню помощи, которое содержит вход для вызова системы помощи с горячей клавишей<nidx/shortcuts/, окно "about" ("о программе...")
для приложения и аналогичное окно для KDE (которое может быть запрещено вызовом <tt/getHelpMenu(false,...);/). Содержимое наших окон
"about" определяется с использованием макроса <tt/i18n()/. VERSION использует макрос, определенный для номера версии проекта
в файле <tt/config.h/, поэтому мы не должны изменять это каждый раз вручную при выпуске нового релиза. Вы можете спокойно добавить в окне "about" любую
информацию о себе - ваше имя, email-адрес, copyright и др.

Теперь мы должны только вставить выпадающие меню в панель меню. Поскольку <tt/<cdx/KTMainWindow// уже создал панель меню для нас, мы только
вставляем их, вызывая <tt/menuBar()->insertItem();/.

Все, что осталось сделать - соединить входы меню с методами, которые должны выполняться по их выбору. Следовательно, мы соединяем каждое выпадающее меню по
сигналу <tt/activated( int )/ с методом <tt/commandCallback( int )/, который содержит конструкцию <tt/switch/, вызывающую соответствующие
методы для входов меню. Дополнительно, мы соединяем выпадающие меню по их сигналу <tt/highlighted( int )/ для вывода помощи в строке статуса
по каждому входу. Когда бы пользователь ни перевел указатель мыши или фокус ввода клавиатуры на вход меню, строка статуса выведет соответствующую подсказку.

После того, как мы завершили с панелью меню, мы начнем разбираться с панелью инструментов. Это мы сделаем в следующей секции. Заметьте, что экземпляр
<tt/<cdx/KTMainWindow// может иметь только одну видимую панель меню; таким образом, если вы хотите создать несколько панелей меню, 
вы должны это делать раздельно с использованием экземпляров <tt/<cdx/KMenuBar//, и установить одну из них в соответствующем методе <tt/<cdx/KTMainWindow// как текущую
панель меню. См. документацию по классу <tt/<cdx/KMenuBar// для получения более детальной информации; о том, как расширить возможности, также см.
<ref id="Configuring Menubars and Toolbars" name="Конфигурирование панелей меню и панелей инструментов">.

<sect2>Панель инструментов
<p>
Создание <idx/панелей инструментов/ даже проще, чем панелей меню. <tt/<cdx/KTMainWindow// предоставляет готовую панель инструментов, которая создается автоматически при вызове конструктора,
а вы можете легко создать еще несколько. На панель инструментов нужно только добавить кнопки для выполнения тех функций, которые вы желаете реализовать:

<tscreen><verb>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</verb></tscreen>

Это добавляет прижатую к левому краю кнопку с иконкой "filenew.xpm" и соответствующим идентификатором на панель инструментов. Третий параметр определяет,
разрешена или запрещена кнопка; по умолчанию мы устанавливаем его равным <tt/true/, потому что наш метод <tt/disableCommand()/ в конце
конструктора сделает необходимые нам установки автоматически для входов меню и панелей инструментов. Наконец, последний параметр используется для
так называемых "всплывающих подсказок" ("Quick-Tip") - когда пользователь располагает указатель мыши над кнопкой так, что она подсвечивается,
появляется окошко с сообщением, содержание которого можно определить этим параметром.

Наконец, все кнопки панели инструментов соединяются с нашим методом <tt/commandCallback()/ по сигналу <tt/clicked()/. По сигналу
<tt/pressed()/, мы предоставляем пользователю возможность получить соответствующую подсказку в строке статуса.

<bf/Дополнительная информация:/

Поскольку <idx/панели инструментов/ создаются на основе класса <tt/<cdx/KToolBar//, вы можете посмотреть соответствующую документацию.
С помощью <tt/<cdx/KToolBar// можно реализовать множество вещей, необходимых для панели инструментов, например задержка перед выпадением меню, если по вашей кнопке вызывается выпадающее меню;
кнопки типа "выпадающий список". По умолчанию панель инструментов заполняет всю ширину
окна, что весьма удобно и красиво, если используется только одна панель. Когда их больше, вы должны продумать
их размеры, так как другие панели могут быть показаны в той же строке, что и первая, под панелью меню. Мы обсудим некоторые
вопросы разработки и расширения возможностей панелей инструментов в разделе <ref id="Configuring Menubars and Toolbars" name="Конфигурирование панелей меню и панелей инструментов">.

<sect2>Строка статуса
<p>
Строка статуса, как и панели, предоставляется экземпляром <tt/<cdx/KTMainWindow//, поэтому мы должны только вставить в нее свои составляющие.
По умолчанию, сгенерированное приложение содержит только один элемент для отображения подсказки в строке статуса. Для многих приложений
этого может быть не достаточно. Поэтому вы должны добавить необходимые элементы, например, координаты и т.п.

Кроме того, приложение может иметь только одну активную строку статуса, как и панель меню. Если вы хотите создать их несколько, вы должны
создать их по отдельности и установить текущую строку вызовом соответствующего метода <tt/<cdx/KTMainWindow//. В строку статуса также можно
вставлять видимые элементы, которые могут быть использованы для красивого отображения индикаторов прогресса, как это делает KDevelop. За дальнейшей информацией обращайтесь к описанию класса
<tt/KStatusBar/ в документации по классам.

<sect2>Горячие клавиши (keyboard accelerator)
<p>
Добравшись до метода <tt/initKeyAccel()/, мы уже создали стандартные объекты главного окна приложения - панель меню, 
<idx/панели инструментов/ и строку статуса. Неужели мы не создали ни одной горячей клавиши, с помощью которых опытный пользователь, который желает
работать с клавиатурой, будет иметь быстрый доступ к определенным командам, использующимся наиболее часто в процессе работы с нашей программой. Чтобы сделать это, мы
можем использовать встроенные горячие клавиши, созданные при разработке, например, меню, но KDE предоставляет хорошее 
решение для создания и поддержания пользовательских горячих клавиш. Множество пользователей хотят, чтобы они были конфигурируемыми, с одной стороны,
а с другой стороны, стандартные горячие клавиши должны быть одинаковыми для различных приложений. Центр управления KDE
предоставляет конфигурирование стандартных горячих клавиш<nidx/accelerator/ глобально, используя класс <tt/<cdx/KAccel//. Кроме того,
<idx/библиотеки KDE/ содержат элемент, который позволяет пользователю легко конфигурировать специфические для приложения горячие клавиши<nidx/shortcuts/ локально.
Поскольку наше приложение использует только меню, выполняющие стандартные действия, такие как "New" или "Exit", они устанавливаются с помощью метода
<tt/initKeyAccel()/. Стандартные действия должны быть только связаны с соответствующей комбинацией клавиш. Мы должны добавить их, 
вначале указав наименование стандартного действия, а затем выполняемой функции. Поскольку все наши горячие клавиши
определены в меню, мы должны изменить их для входов выпадающих меню. Затем мы вызываем
<tt/readSettings()/, который считывает текущие установки корневого окна KDE, содержащего конфигурацию стандартных
горячих клавиш, потом установки для них, определенные в конфигурационном файле приложения.
Когда мы продвинемся дальше в разработке нашего примера, мы поговорим также о том, как конфигурировать специфические
для приложения горячие клавиши через диалоговое окно, 
см. <ref id="Configuring Menubars and Toolbars" name="Конфигурирование панелей меню и панелей инструментов"> об этой части процесса разработки.

<sect2>Модель Документ-Просмотр (Document-View Model)
<p>
Следующие два вызова функций-членов, <tt/initDocument()/ и <tt/initView()/, завершают построение той части окна приложения, которую
предполагается представить пользователю: интерфейс для работы с данными, которые должно обрабатывать приложение; это еще одна причина,
по которой наше приложение состоит из трех классов, <tt/*App/, <tt/*View/ и <tt/*Doc/. 
Чтобы понять пользу такой структуры, немного отвлечемся от кода и ознакомимся с теорией, а затем снова
вернемся к программе, чтобы увидеть, как KDevelop поддерживает теоретическую модель.

Вообще говоря, все, что было сказано о нашем приложении, это что нам необходим экземпляр приложения, содержащий главное окно. Это окно имеет возможность предоставить 
пользователю базисный интерфейс - оно содержит меню, панель инструментов и строку статуса, а также механизм обработки ввода пользователя. 
Кроме того, оно содержит область, описанную как "просмотр" ("view"). В общем, назначение этой области - показывать данные, которыми сможет манипулировать пользователь,
например, часть большого текстового файла. Хотя текстовый файл, вероятно, больше, чем наша область может показать на экране, она 
предоставляет возможность пользователю перейти к той части документа, которую он хочет видеть (это и есть "просмотр"). Здесь же пользователь может редактировать файл.
Чтобы дать программисту возможность наилучшим образом разделить части приложения при реализации кода, была разработана модель Документ-Просмотр. Хотя она и не является стандартом, она 
предлагает способ, как приложение должно работать:

<itemize>
<item> Приложение содержит управляющий объект (controller object),
<item> объект Просмотр, отображающий данные, с которыми работает пользователь,
<item> и объект Документ, который в действительности содержит обрабатываемые данные.
</itemize>

Возвращаясь к нашему примеру обработки текстового файла - наша модель должна работать так: Документ считывает содержимое файла и
предоставляет методы для изменения данных и для сохранения файла. Объект Просмотр обрабатывает события, которые генерирует пользователь
с помощью клавиатуры и мыши, и использует методы объекта Документ для обработки данных.

Наконец, управляющий объект отвечает за взаимодействие с пользователем, предоставляя ему доступ к объектам Документ и Просмотр,
а также интерфейс для выдачи команд на открытие и закрытие документа. Кроме того, некоторые методы объекта Просмотр могут активироваться
командами, поступающими от горячих клавиш, меню и панелей инструментов.

Эта модель Документ-Просмотр имеет некоторые преимущества - она разделяет программный код более объектно-ориентированно, и, таким образом, предоставляет большую гибкость,
например, один и тот же объект Документ может отображаться в нескольких объектах Просмотр одновременно; это может происходить как в различных окнах,
так и в рамках одного окна, разделяя его рабочую область на несколько элементов Просмотр.

Если вы работали в MS-Windows, у вас может быть некоторый опыт такой работы - MFC предоставляет модель документа,
готовую к использованию. Для KDE и <idx/Qt/ приложений дело обстоит несколько по иному. <idx/Qt/ - мощный инструмент, который предоставляет
наиболее необходимые классы и видимые элементы. Но он не заботится о реализации модели Документ-Просмотр, и поскольку KDE унаследована от <idx/Qt/,
нет никаких оснований вводить в ней такую модель. Есть какой-то смысл в том, что традиционное X-приложение не работает 
с многодокументным интерфейсом (MDI, Multiple Document Interface). Каждое главное окно отвечает за содержащиеся в нем данные и, таким образом,
уменьшает потребность в модели Документ-Просмотр, поскольку все методы работы с документом реализованы в видимом элементе. Единственное исключение на текущий момент -
проект <em/KOffice/, который предоставляет полный набор офисных приложений, таких как текстовый процессор, электронные таблицы и т.д.
Технически это реализовано внесением двух изменений в традиционный способ использования <idx/Qt/ и KDE:

<itemize>
<item>KOffice использует KOM и бесплатную (free) реализацию MICO из CORBA для межобъектного взаимодействия,
<item>приложения KOffice используют модель Документ-Просмотр, чтобы позволить всем приложениям работать с объектами данных KOffice.
</itemize>

Но, поскольку сейчас KDevelop ориентирован на использование текущих библиотек KDE 1.1.x и <idx/Qt/ 1.4x, мы не можем использовать данную модель по определению - 
она появится в более поздних версиях KDE 2, которая, как предполагается, будет содержать два основных изменения по отношению к текущей - 

<enum>
<item>MDI-интерфейс для <cdx/KTMainWindow/
<item>KOM библиотеки, которые реализуют модель Документ-Просмотр.
</enum>

Таким образом, в настоящее время разработчик приложений может либо реализовать все необходимые методы объекта Документ в объекте Просмотр,
или попытаться воспроизвести модель Документ-Просмотр самостоятельно. KDevelop поддерживает такую реализацию, предоставляя все необходимые классы и
основные методы, которые обычно используются в модели Документ-Просмотр в шаблонах приложений для <idx/Qt/ и KDE.

Возвращаясь к коду, сейчас вы понимаете цели использования двух методов, которые мы упоминали в начале данного раздела:
функции <tt/initDocument()/ и <tt/initView()/. <tt/initDocument()/ создает объект документа, который представляет
данные окна приложения и инициализирует базисные атрибуты, такие как бит модификации, отображающий наличие изменений в текущих данных.
Затем метод <tt/initView()/ создает видимый элемент <tt/*View/, связанный с документом, и
вызывает метод <tt/setView()/ <tt/<cdx/KTMainWindow//, чтобы сообщить окну <tt/*App/, что необходимо использовать элемент <tt/*View/ как Просмотр.

Для разработчика необходимо знать, что в процессе разработки он должен:

<itemize>
<item>переопределить виртуальные методы для обработки событий мыши и клавиатуры, предоставляемые <tt/<cdx/QWidget//, в объекте <tt/*View/, чтобы реализовать 
способы управления данными.
<item>переопределить <tt/paintEvent()/ класса <tt/<cdx/QWidget// в объекте <tt/*View/ для перерисовки (repaint()) области просмотра после изменения,
<item>доработать реализацию печати документа в методе печати объекта <tt/*View/,
<item>научить объект <tt/*Doc/ считыванию и записи файлов,
<item>добавить реализацию структуры данных документа к объекту <tt/*Doc/, который логически представляет данные документа
в памяти.
<item>добавить все методы, которые должны быть доступны пользователю через горячие клавиши, меню и панели инструментов.
</itemize>


<sect2>Конфигурирование приложения
<p>
Теперь, после того, как мы создали все элементы, инициируемые экземпляром <tt/<cdx/KTMainWindow// нашего приложения, мы должны
установить определенные атрибуты, значения которых влияют на внешний вид нашего приложения. Для этого мы вызываем <tt/readOptions()/, которые
считывает все значения и вызывает методы, устанавливающие соответствующие атрибуты. Библиотека KDE-Core содержит класс <tt/<cdx/KConfig//, который предоставляет удобный
способ записи значений в конфигурационный файл, а также считывания их из файла снова. Поскольку каждый экземпляр <tt/<cdx/KApplication// 
создает по умолчанию свой ресурсный файл, мы должны только получить доступ к этому файлу и создать наши значения.  
<tt/<cdx/KConfig// предоставляет нам объект файла.
А мы используем класс <tt/<cdx/KConfigBase// для чтения и записи всех входов. Тогда как запись выполнить очень просто с помощью
метода <tt/writeEntry()/, чтение зависит от типа атрибута, который мы хотим инициализировать. Вообще говоря, все входы в конфигурационном файле
состоят из имени значения и значения. Значения, взаимосвязанные по смыслу, могут быть объединены в группы. 
Поэтому мы должны задать имя группы до того, как обратимся к значению. Группа должна быть определена только однажды для чтения набора атрибутов,
входящих в нее. Давайте посмотрим, что мы хотим читать:

<tscreen><code>
1   void KScribbleApp::readOptions()
2   {
3
4      config->setGroup("General Options");
5
6      // bar status settings
7      bool bViewToolbar = config->readBoolEntry("Show Toolbar", true);
8      view_menu->setItemChecked(ID_VIEW_TOOLBAR, bViewToolbar);
9      if(!bViewToolbar)
10       enableToolBar(KToolBar::Hide);
11
12     bool bViewStatusbar = config->readBoolEntry("Show Statusbar", true);
13     view_menu->setItemChecked(ID_VIEW_STATUSBAR, bViewStatusbar);
14     if(!bViewStatusbar)
15       enableStatusBar(KStatusBar::Hide);
16
17     // bar position settings
18     KMenuBar::menuPosition menu_bar_pos;
19     menu_bar_pos=(KMenuBar::menuPosition)config->readNumEntry("MenuBar Position", KMenuBar::Top);
20
21     KToolBar::BarPosition tool_bar_pos;
22     tool_bar_pos=(KToolBar::BarPosition)config->readNumEntry("ToolBar Position", KToolBar::Top);
23
24     menuBar()->setMenuBarPos(menu_bar_pos);
25     toolBar()->setBarPos(tool_bar_pos);
26
27     // initialize the recent file list
28     recent_files.setAutoDelete(TRUE);
29     config->readListEntry("Recent Files",recent_files);
30
31     uint i;
32     for ( i =0 ; i < recent_files.count(); i++){
33       recent_files_menu->insertItem(recent_files.at(i));
34     }
35
36     QSize size=config->readSizeEntry("Geometry");
37     if(!size.isEmpty())
38       resize(size);
39   }
</code></tscreen>

Как мы уже видели в одном из предыдущих примеров первое действие, которое делает наш конструктор:

<tscreen><verb>
config=kapp->getConfig();
</verb></tscreen>

что устанавливает указатель <tt/config/ типа <tt/<cdx/KConfig// на конфигурацию приложения. Поэтому мы не должны заботиться о расположении
конфигурационного файла. Этот файл, согласно стандарту файловой системы KDE (KDE File System Standard, KDE FSS), располагается в
<tt>&dollar;HOME/.kde/share/config/</tt>; подробнее файловую систему KDE мы рассмотрим позднее, когда будем обсуждать расположение файлов в дистрибутиве приложения.
Поскольку конфигурационный файл располагается в домашнем каталоге пользователя, каждый пользователь имеет свои настройки внешнего вида приложения. 
Это не касается значений, определенных в общесистемном конфигурационном файле, который при необходимости может быть создан и инсталлирован
программистом в каталоге KDE. 

Хотя это бывает полезно в некоторых случаях, мы должны избегать зависимости нашего приложения от существования
значения параметра в конфигурационном файле. Поэтому все методы чтения значений параметров, предоставляемые <tt/<cdx/KConfigBase//, позволяют добавить значение по умолчанию, которое будет использовано,
если не будет найдено в файле. Другой момент, важный для программиста, это то, что конфигурационный файл представляет собой обычный текстовый файл,
поэтому необходимо обратить внимание:

<itemize>
<item>пользователь может редактировать конфигурационный файл в текстовом редакторе,
<item>если пользователь хочет изменить значения вручную, названия должны быть понятными,
<item>для значений, которые необходимо сохранить, но которые критичны с точки зрения безопасности (пароли), необходимо предусмотреть соответствующее решение, обеспечивающее безопасность.
</itemize>

Теперь, когда мы знаем теорию, начнем анализировать код. Как уже говорилось, мы должны использовать только наш указатель на конфигурацию для доступа к значениям.
В строке 4 мы делаем текущей группу "General Options".  Это означает, что входящие в нее значения устанавливают какие-то общие атрибуты
приложения. Затем мы считываем значения для панели инструментов и строки статуса - они должны быть сохранены приложением при закрытии,
чтобы восстановить их при перезапуске программы. Поскольку панели могут быть либо включены, либо выключены, мы используем значения типа boolean и
вызываем метод <tt/readBoolEntry()/. Процесс идентичен для обеих панелей, поэтому мы рассмотрим только строки 7-10, чтобы понять,
что происходит с панелью инструментов. Во-первых, мы читаем значение во временную переменную <tt/bViewToolbar/ в строке 7. Имя атрибута
в конфигурационном файле "Show Toolbar", и, если такое значение отсутствует (например, при первом запуске приложения),
задаем значение по умолчанию <tt/true/. Потом мы устанавливаем пометку для пункта меню, отвечающего за разрешение/запрещение показа панели инструментов:
мы вызываем <tt/setItemChecked()/ для входа меню <tt/ID_VIEW_TOOLBAR/ с нашим атрибутом. Наконец, мы говорим панели инструментов
установить требуемое значение. По умолчанию панель видима, поэтому мы должны что-то делать только в том случае, если <tt/bViewToolbar/ равно <tt/false/.
Вызывая <tt/enableToolBar()/ (строка 10), мы скрываем панель, если она запрещена.

Теперь мы должны прочитать положение панели. Поскольку пользователь может изменить положение панели, переместив ее с помощью мыши
в другое место, это должно быть, как и отображение панели, также сохранено. Посмотрев на классы <tt/<cdx/KToolBar// и
<tt/<cdx/KMenuBar//, мы видим, что положение панели может быть:

<tscreen><verb>
enum BarPosition {Top, Left, Bottom, Right, Floating, Flat}
</verb></tscreen>

Поскольку это значение записывается в числовом виде, мы должны считывать его с помощью метода <tt/readNumEntry()/ и преобразовывать в значение положения.
С помощью <tt/setMenuBarPos()/ и <tt/setBarPos()/ говорим панелям, где отображаться.

Сейчас вы, возможно, вспомните, что наше меню "File" содержит подменю со списком последних открытых файлов. Имена файлов занесены в список
строк, который сохраняется при закрытии приложения и сейчас должен быть считан для восстановления меню. Во-первых, мы инициализируем список
с занесенными в него значениями строк, используя <tt/readListEntry()/. Затем в цикле <tt/for-/ мы создаем входы меню для каждого элемента списка.

Наконец, мы должны позаботиться о размерах окна нашего приложения. Мы считываем его расположение в переменную <tt/QSize/, содержащую x
и y значения для ширины и высоты окна. Поскольку окно инициализируется <tt/<cdx/KTMainWindow//, мы не должны заботиться
о значениях по умолчанию, и только используем метод <tt/resize()/, если значение не пусто.

Нам еще осталось объяснить в создании приложения запрет команд, которые
не должны быть доступны, если не удовлетворяются определенные условия. Это сохранение файла и операции, которые используют буфер обмена. В течение
жизни приложения мы должны об этом позаботиться несколько раз, но это достаточно просто, так как шаблон дает нам только 
два метода для разрешения/запрещения команд меню и кнопок панели инструментов.

<sect2>Выполнение
<p>
В предыдущем разделе мы рассматривали только то, что происходит при вызове конструктора экземпляра нашего <tt/KScribbleApp/, готовящего для нас главное окно. 
После возвращения в функцию <tt/main()/ мы должны вызвать метод <tt/show()/ для того, чтобы отобразить окно. Чем отличаются
<tt/<cdx/KApplication// и <tt/<cdx/QApplication// здесь, так это тем, что мы используем <tt/<cdx/KTMainWindow// как экземпляр нашего
главного элемента (main widget), но мы не устанавливали его с помощью <tt/setMainWidget()/. Это делает <tt/<cdx/KTMainWindow// самостоятельно, 
и мы не должны заботиться об этом.

Единственное, что осталось - это обработать аргументы командной строки. Если <tt/int argc/ > 1,
то пользователь вызвал приложение в виде <tt/kscribble имя_файла_для_открытия/. Поэтому мы просим наше приложение
открыть файл <tt/имя_файла_для_открытия/, вызывая метод <tt/openDocumentFile()/ с аргументом, содержащим имя файла.

Последняя строка в <tt/main()/ выполняет уже известную нам работу: она запускает на выполнение экземпляр приложения, и программа входит в
главный цикл событий.

Ранее, в разделе <ref id="The main() Function" name="Функция main()">, мы решили рассмотреть только обычный запуск приложения,
и не анализировали ветку <tt/if( app.isRestored() )/. Следующий материал является введением в менеджмент сессий, и объясняет,
как приложения используют этот механизм.

<sect1>Введение в Менеджмент сессий (Session Management)
<p>
Как мы уже говорили, функция <tt/main()/ проверяет, запущено ли приложение пользователем или менеджером сессий. Менеджер сессий отвечает за
сохранение текущего состояния всех открытых окон приложения на рабочем столе и должен восстановить их, когда пользователь войдет в систему в следующий раз,
что значит, что приложение запускается не пользователем, а автоматически. Часть кода, которая выполняется:

<tscreen><verb>
6    if (app.isRestored())
7    {
8       RESTORE(KScribbleApp);
9    }
</verb></tscreen>

В разделе <ref id="The main() Function" name="Функция main()"> мы начинали с того, что проверяли метод вызова,
запрашивая <tt/app.isRestored()/. Затем выполняется строка 8. Она выглядит как простой оператор, но на самом деле это результат выполнения сложного
процесса, за которым мы проследим в этом разделе.

RESTORE() сам по себе - макрос, предоставляемый <tt/<cdx/KTMainWindow//. Он содержит следующий код:

<tscreen><verb>
if (app.isRestored()){
  int n = 1;
  while (KTMainWindow::canBeRestored(n)){
    (new KScribbleApp)->restore(n);
    n++;
  }
}
</verb></tscreen>

Это должно восстанавливать все окна приложения класса <tt/KScribbleApp/, создавая экземпляры и вызывая <tt/restore()/ для
новых окон. Необходимо учесть, что, если ваше приложение использует несколько различных элементов, унаследованных от <tt/<cdx/KTMainWindow//,
вы должны расширить макрос и определять тип верхнего элемента, используя <tt/<cdx/KTMainWindow/::classNameOfToplevel(n)/ вместо класса
<tt/KScribbleApp/.

Метод <tt/restore()/ затем считывает часть файла сессии, которая содержит информацию об окне. Так как <tt/<cdx/KTMainWindow//
запоминает все это для нас, мы не должны заботиться ни о чем больше. Только необходимо сделать так, чтобы специфичная для нашего экземпляра приложения информация 
была доступна <tt/KScribbleApp/. Обычно это будет временный файл, созданный для занесения в него документа,
или другая инициализация, которая нам необходима. Для предоставления этой информации по восстановлению мы должны только переопределить два виртуальных метода
<tt/<cdx/KTMainWindow//, <tt/saveProperties()/ и <tt/readProperties()/. 
Информация, которую мы хотим сохранить в конце сессии, - был ли модифицирован текущий файл и имя файла.
Если файл был модифицирован, мы должны создать временный файл и сохранить модифицированный документ в него.
В начале следующей сессии эта информация используется для восстановления содержимого документа:

<tscreen><verb>
void KScribbleApp::readProperties(KConfig*)
{
  QString filename = config->readEntry("filename","");
  bool modified = config->readBoolEntry("modified",false);
  if( modified ){
    bool b_canRecover;
    QString tempname = kapp->checkRecoverFile(filename,b_canRecover);

    if(b_canRecover){
      doc->openDocument(tempname);
      doc->setModified();
      QFileInfo info(filename);
      doc->pathName(info.absFilePath());
      doc->title(info.fileName());
      QFile::remove(tempname);
    }
  }
  else if(!filename.isEmpty()){
  doc->openDocument(filename);
  }
  setCaption(kapp->appName()+": "+doc->getTitle());
}		
</verb></tscreen>

Здесь строка <tt/kapp->checkRecoverFile()/ выглядит несколько странно, так как <tt/b_canRecover/ не инициализирован. Это делается методом <tt/checkRecoverFile()/,
который устанавливает <tt/true/, если есть файл для восстановления. Поскольку мы сохраняем документ в файл для восстановления только в том случае, если он был изменен,
мы устанавливаем бит "модифицирован" непосредственно, чтобы показать, что информация не была сохранена в надлежащий файл. Также мы должны позаботиться,
чтобы файл для восстановления имел имя, отличное от имени открытого оригинала. Таким образом, мы должны переустановить имя и путь
для старого файла. Наконец, мы извлекли всю информацию для восстановления, какую хотели, и можем удалить временный файл.

<bf/Подведение итогов:/

В этой главе вы узнали, как запускается приложение при нормальном старте и при восстановлении менеджером сессий. Мы прошли
через весь код, разобравшись, как создаются части видимого интерфейса приложения, как инициализируются
атрибуты по значениям, сохраненным в конфигурационном файле. Сейчас вы можете запустить приложение, чтобы проверить его функции и посмотреть,
как реагирует окно программы на события.

<sect>Дополнительные составляющие проекта KDevelop
<p>
Кроме исходного кода, проект KDevelop содержит множество других частей, интересных для разработчика. Это:
<itemize>
<item>иконка программы,
<item>мини-иконка программы,
<item>файл <idx/.kdelnk/, 
<item>пример <idx/SGML/-файла документации,
<item>набор документации по <idx/API/, сгенерированный из исходного кода.
</itemize>

Кроме <idx/API/-документации, эти элементы проекта будут инсталлированы вместе с бинарными файлами приложения. 
Чтобы проект был как можно более открытым, вы должны согласовать эти его части с функциями приложения. Во-первых, вы должны отредактировать иконки.
Это даст вашему приложению уникальный идентификатор, с помощью которого пользователь сможет узнать ваше приложение в окне
менеджера меню. Файл <idx/.kdelnk/ - это файл, который добавляет ваше приложение в <tt/kpanel/ в меню <tt/Applications/.
Он должен быть отредактирован - необходимо установить путь для инсталляции, что будет обсуждаться далее в этой книге. Наконец, документация, которую вы
предоставите пользователю, пишется в <idx/SGML/. Это делает очень простым создание нескольких конечных файлов различных форматов из одного исходника. По умолчанию,
KDevelop предлагает создать HTML файлы из этого исходника, для KDE-проектов это делается автоматически с использованием <tt/<idx/ksgml2html//,
что добавляет классический KDE-вид документации. В последующих главах мы увидим, как редактировать файл <idx/SGML/, 
и что мы предоставим конечному пользователю для инсталляции.

Наконец, <idx/API/-документация (Application Programming Interface) позволит вам и другим разработчикам быстро понять код
и использовать классы, не угадывая, для чего они предназначены. Мы научимся создавать <idx/API/-документацию позднее.
На текущий момент достаточно знать, что документация генерируется программой <tt/<idx/KDoc//, которая обрабатывает файлы заголовков и создает
HTML документ, поэтому все подлежащие включению в документацию комментарии должны располагаться в заголовках.

<chapt>Главное окно приложения
<p>
При разработке приложения с графическим пользовательским интерфейсом наиболее трудоемкой является реализация так называемого элемента Просмотр ("view") приложения.
Просмотр - это видимый элемент, который отображает данные, содержащиеся в обрабатываемом приложением документе, и предоставляет методы для изменения
этих данных. Пользователь заставляет эти методы работать, порождая события клавиатуры и мыши; сложные операции часто
выполняются с помощью команд, генерируемых при выборе пунктов меню или кнопок панели управления, которые взаимодействуют с Просмотром. Строка статуса предоставляет информацию о
документе, о режиме работы объекта Просмотр и о состоянии приложения. Рассмотрим, например, как устроен текстовый редактор, и где реализованы его части.

Редактор обычно предназначен для просмотра и изменения текстового файла пользователем. Если вы
откроете <em/KEdit/, вы увидите следующие элементы пользовательского интерфейса:

<itemize>
<item>Панель меню: предоставляет возможность выполнять сложные операции, такие как открытие и закрытие файлов, выход из приложения и т.п.,
<item>Панель инструментов: содержит иконки для быстрого доступа к наиболее часто используемым функциям,
<item>Строка статуса: отображает координаты текущего положения курсора,
<item>Объект Просмотр в центре окна: отображает документ и предоставляет связь курсора с клавиатурой и мышью для обработки данных.
</itemize>

Теперь легко понять, что Просмотр - наиболее специализированная часть приложения, и от того, как он разработан, зависит полезность
приложения и удобство работы с ним. Это значит, что один из первых шагов при разработке приложения - это определение назначения
приложения и того, какой тип объекта Просмотра наилучшим образом позволит пользователю работать с приложением, с минимумом затрат на освоение пользовательского интерфейса.

Для некоторых стандартных задач, например, текстовой обработки или отображения HTML файлов, <idx/Qt/ и <idx/библиотеки KDE/ предоставляют специальные объекты просмотра; мы обсудим 
некоторые аспекты использования таких объектов высокого уровня в следующем разделе. Но для большинства приложений должны быть разработаны новые элементы.
Это момент, где программист становится также дизайнером, и где требуются его творческие способности. Однако не забывайте, что основное в пользовательском интерфейсе - это его интуитивность.
Помните, что многие пользователи не воспримут приложение, которое:

<itemize>
<item>некрасиво выглядит,
<item>не предлагает широкого набора возможностей,
<item>трудно в использовании,
<item>тяжело для изучения.
</itemize>

Однако не стоит даже говорить, что основной критерий качества разработки - стабильность. Никто не сможет предотвратить все ошибки,
но с помощью хорошо продуманного процесса разработки можно свести их число к минимуму. 
Четко определите цель и широко используйте методы объектно-ориентированного программирования. C++ сделает программирование удовольствием,
если вы будете знать, как использовать его возможности - наследование, ограничения доступа и повторное использование кода.

При создании KDE или <idx/Qt/ проекта вы всегда наследуете объект Просмотра от <tt/<cdx/QWidget// непосредственно или через использование библиотечного элемента,
унаследованного от <tt/<cdx/QWidget//. KAppWizard уже создал объект Просмотра, который является экземпляром класса <ваше_приложение>View, унаследованного от
<tt/<cdx/QWidget//. Приложение создает его в методе
<tt/initView()/, где создается экземпляр объекта, который затем устанавливается как главный с помощью <tt/KTMainWidget::setView()/.

Эта глава описывает, как использовать библиотеку элементов для создания главного объекта (объекта Просмотр) для KDE или <idx/Qt/ приложений,
которые разрабатываются с помощью KDevelop. Мы просмотрим библиотеки и узнаем, какие типы элементов они предлагают.

<sect>Использование библиотечных элементов
<p>
Когда начинается разработка приложения, вы в первую очередь должны просмотреть уже существующий код, что сделает вашу жизнь гораздо легче.
Например, необходимо изучить уже существующие элементы, которые могут быть использованы в качестве объектов Просмотра или как их часть, как непосредственно, так и путем наследования.
Библиотеки KDE и <idx/Qt/ уже содержат набор элементов, которые могут быть использованы для этих целей. Вы имеете две возможности для их использования:

<enum>
<item> удалить объект Просмотра, включенный в шаблон, создать экземпляр библиотечного элемента и установить его как главный элемент;
<item> изменить предка предложенного в шаблоне элемента на класс библиотечного элемента.
</enum>

В любом случае, важно понимать, что если приложение на данный момент не линкуется с библиотекой, которая содержит новый элемент,
линкование завершится с ошибкой. После того, как вы решили использовать определенный элемент, посмотрите, с какой библиотекой необходимо связаться. Потом откройте
"Project"->"Options" из меню KDevelop, переключитесь на страницу "Linker Options" и посмотрите на то,
какие библиотеки используются на текущий момент. Если среди них есть библиотека, в которой содержится ваш элемент, вы можете закрыть окно опций проекта без изменений
и начать вносить необходимые изменения в ваш код. Если нет, и в опциях линкера есть возможность добавить необходимую библиотеку выбором соответствующего пункта,
выберите его и нажмите "OK", чтобы закрыть окно опций проекта. В любом другом случае добавьте библиотеку в строку ввода внизу окна с
опцией <tt/-l/. Для библиотек, которые ваше приложение должно искать перед генерацией файлов Makefiles в скрипте <tt/configure/
на машине пользователя, добавьте соответствующий макрос для поиска в файл <tt/configure.in/, расположенный в корневом каталоге проекта, и
добавьте макрос для изменения строки. Имейте в виду, что вы должны запустить "Build"->"Autoconf" и "Build"->"Configure" для того, чтобы
в файлы Makefile была записана правильная информация о макросе для вашей библиотеки.

Кроме того, если include-файлы добавленной библиотеки не попадают в текущий путь для поиска include-файлов (каталоги, заданные с помощью ключа <tt/-I/ 
в окне вывода информации о работе "Make"), вы должны добавить путь в диалоговом окне Project Options - страница "Compiler Options", с ключом <tt/-I/, 
или соответствующий макрос automake в строке ввода "Additional Options".

<sect1>Элементы <idx/Qt/ 
<p>
На первой странице <idx/Qt/ online-документации вы найдете ссылку на картинки элементов "Widget Screenshots", где сможете посмотреть,
как выглядят различные элементы <idx/Qt/. Все они готовы к использованию и могут быть объединены вместе для создания 
сложных главных окон приложений или диалогов. Далее мы описываем некоторые из этих элементов, которые очень полезны при разработке приложений и элементов Просмотр,
но имейте в виду, что <idx/библиотеки KDE/ иногда содержат другие элементы, выполняющие те же задачи; их мы обсудим в следующем разделе.

Перед вами несколько подсказок, для каких целей какие элементы <idx/Qt/ использовать:

<enum>
<item>если ваша область просмотра недостаточно велика, чтобы вместить все данные, необходимо обеспечить пользователю возможность прокрутки (скроллинга)
с помощью полос прокрутки справа и внизу. Для этого <idx/Qt/ предоставляет класс <tt/QScrollView/, у которого имеется пользовательская область с обеспечением прокрутки.
Вы можете наследовать свой собственный элемент от <tt/QScrollView/ или использовать его экземпляр для организации просмотра в вашем приложении.
<item>для создания прокручиваемой области самостоятельно наследуйте объект Просмотра от класса <tt/<cdx/QWidget// и добавьте к нему вертикальную и горизонтальную прокрутку <tt/QScrollBar/
(это сделано в KDE для элемента KHTMLView);
<item>для текстовой обработки используйте <tt/QMultiLineEdit/. Этот класс предоставляет полнофункциональный текстовый редактор, умеющий
работать с буфером обмена и полосами прокрутки;
<item>используйте <tt/QTableView/, чтобы отобразить данные в табличной форме. <tt/QTableView/ управляется полосами прокрутки,
поэтому он - хорошее решение для приложения типа электронных таблиц.
<item>для одновременного отображения двух различных элементов или двух экземпляров элемента используйте <tt/QSplitter/. Это позволит разделить
область просмотра горизонтально или вертикально. Окно Netscape's Mail - хороший пример того, как это выглядит. Главное окно разделено
по вертикали, а правая часть снова разделена по горизонтали.
<item><tt/QListView/ отображает информацию в виде дерева. Это полезно для представления дерева каталогов или другой иерархической информации, которую необходимо обрабатывать.
</enum>

Как видно, <idx/Qt/ предоставляет полный набор элементов, уже готовых к использованию, поэтому вы не должны изобретать новых решений,
если они удовлетворяют вашим требованиям. Еще одно преимущество использования стандартных элементов - пользователь уже знает, как с ними работать, и сможет 
сконцентрироваться не на интерфейсе, а на обрабатываемых данных.

<sect1>Элементы KDE
<p>
Библиотеки KDE созданы для облегчения разработки приложений K Desktop Environment, и поддерживают всю функциональность,
реализованную в <idx/Qt/. Чтобы определить, что нам доступно, посмотрим на дерево документации в KDevelop. Мы видим, что библиотеки KDE
начинаются с <tt/kdecore/, которая является основой для всех приложений KDE. Идущая следом <tt/kdeui/ предоставляет элементы пользовательского интерфейса.
Здесь мы найдем несколько полезных вещей. Для создания приложений <tt/kdeui/ предлагает:

<enum>
<item><tt/<cdx/KTabListBox//: список с несколькими столбцами, строки которого можно изменять с помощью <idx/drag'n drop/.
<item><tt/<cdx/KTreeList//: унаследованный от <tt/<cdx/QTableView//, реализует дерево с возможностью показа/скрытия веток. Может быть использован вместо
<tt/QListView/. В KDE 2.0 этот класс реализован не будет.
<item><tt/<cdx/KEdit//: базовый класс для приложения <em/KEdit/, поставляемого вместе с KDE;
может использоваться вместо <tt/<cdx/QMultiLineEdit//.
<item><tt/<cdx/KNewPanner//: Управляет двумя дочерними элементами как <tt/<cdx/QSplitter//. В KDE 2.0 этот класс реализован не будет.
</enum>

Библиотека <tt/khtmlw/ предоставляет полнофункциональный интерпретатор HTML документов, готовый к использованию. Он поддерживает прокрутку,
поэтому вы не должны о ней заботиться.  Может быть полезен как интегрированное средство просмотра в HTML-редакторе; используется такими приложениями,
как KFM, <idx/KDEHelp/ и KDevelop для показа HTML файлов.


<sect>Создание собственного элемента просмотра<label id="Creating your own Views">
<p>
Теперь, когда вы получили общее представление о предоставляемых возможностях, можно заметить, что для большинства задач уже существуют элементы,
которые могут быть использованы самостоятельно или объединены с другими. KMail и сам KDevelop - хорошие примеры использования библиотечных элементов для отображения данных.

Для приложений, которые используют специфические форматы файлов или имеют дело с графикой, вы, вероятно, будете вынуждены создать свой собственный элемент просмотра
для организации обработки данных. Это реализуется в нашем примере с помощью класса <tt/KScribbleView/, уже имеющего все необходимое для области просмотра.

При наследовании от <tt/<cdx/QWidget// необходимо переопределить виртуальные методы для обработки пользовательских событий, что, вероятно, будет основной работой;
кроме того, необходимо реализовать всплывающие меню для быстрого доступа к функциям. Вероятно, вам также придется реализовать несколько слотов,
которые будут доступны через кнопки панели инструментов или пункты меню, а также методы управления различными переменными, например, 
цветом кисточки в графическом редакторе.

Повторим для полноты подлежащие переопределению методы:

<bf/a) События клавиатуры -- клавиши TAB и  Shift-TAB :/

изменяет фокус ввода с клавиатуры с текущего элемента на следующий элемент в порядке изменения фокусов. Фокус может быть установлен для элемента
вызовом <tt/setFocusPolicy<ncdx/setFocusPolicy()/()/. Изменение фокуса обрабатывается следующими обработчиками событий: :

<itemize>
<item><tt/virtual void focusInEvent<ncdx/focusInEvent()/ ( <cdx/QFocusEvent/ * )/
<item><tt/virtual void focusOutEvent<ncdx/focusOutEvent()/ ( <cdx/QFocusEvent/ * )/
</itemize>

<bf/b) другой ввод с клавиатуры:/
<itemize>
<item><tt/virtual void keyPressEvent<ncdx/keyPressEvent()/ ( <cdx/QKeyEvent/ * )/
<item><tt/virtual void keyReleaseEvent<ncdx/keyReleaseEvent()/ ( <cdx/QKeyEvent/ * )/
</itemize>

<bf/c) перемещение мыши:/
<itemize>
<item><tt/virtual void mouseMoveEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void enterEvent ( <cdx/QEvent/ * )/
<item><tt/virtual void leaveEvent ( <cdx/QEvent/ * )/
</itemize>

<bf/d) нажатие кнопок мыши:/
<itemize>
<item><tt/virtual void mousePressEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseReleaseEvent ( <cdx/QMouseEvent/ * )/
<item><tt/virtual void mouseDoubleClickEvent ( <cdx/QMouseEvent/ * )/
</itemize>

<bf/e) события окна, содержащего элемент:/
<itemize>
<item><tt/virtual void moveEvent ( <cdx/QMoveEvent/ * )/
<item><tt/virtual void resizeEvent ( <cdx/QResizeEvent/ * )/
<item><tt/virtual void closeEvent ( <cdx/QCloseEvent/ * )/
</itemize>

Когда вы переопределяете эти функции, вы должны учесть некоторые моменты, чтобы избежать ошибок, которые 
сделают невозможным изменение поведения элементов в дальнейшем:

<enum>
<item>объявляйте ваши виртуальные методы как <bf/virtual/ в секции <bf/protected/. Это позволит переиспользовать код при наследовании
и обеспечит логическую целостность;
<item>не включайте в текст программы, реализующей обработку событий, непосредственно (hard-code) ничего такого, что может конфигурироваться. Это в основном относится к событиям клавиатуры,
которые реализуются через горячие клавиши и состоят в вызове функций. Данное замечание касается даже текстовой обработки! (Вообразите себе, что множество пользователей
привыкли к своему любимому текстовому редактору. Если горячие клавиши конфигурируются, то они смогут использовать привычные для себя настройки);
<item>передавайте сигналы, генерируемые при подсветке пунктов меню, главному элементу, чтобы обеспечить подсказки в строке статуса.
</enum>

<chapt>Конфигурирование меню и панелей инструментов<label id="Configuring Menubars and Toolbars">
<p>
Меню и панели инструментов - одна из наиболее важных частей приложения для обеспечения работы с документом.
Как правило, вы должны сделать доступными все функции через меню. Те пункты меню, которые вызывают функции, недоступные в текущем состоянии приложения,
должны быть запрещены.

Далее, приложение может содержать только одну панель меню, но несколько панелей инструментов. 

Панель инструментов должна содержать только наиболее часто используемые функции,
которые должны вызываться нажатием кнопок с иконками; также в состав панелей инструментов могут входить выпадающие списки для выбора значений.

<sect>Как они работают ?
<p>
Каждый вход меню или кнопка панели инструментов имеет ресурсный идентификатор (ID), представляющий собой число типа integer. Поскольку данные значения не могут использоваться дважды,
они представляются макросами. В макросах числовое значение заменяется осмысленным названием, используемым в коде программы.

Все ресурсные ID собраны в файле <tt/resource.h/, где можно посмотреть, какие числа уже задействованы. В любом случае, компилятор
проинформирует вас, если вы дважды используете одно и то же число для различных входов. Кроме того, ресурсный файл должен содержать все клавиши быстрого доступа к меню,
заменяемые в IDK-макросе(?). Например:

<code>
(resource.h)

#define ID_VIEW_TOOLBAR             12010


(kscribble.cpp)

// menu entry Toolbar in the "view" menubar menu
view_menu->insertItem(i18n("&amp;Toolbar"), ID_VIEW_TOOLBAR);

</code>

Этот код добавляет вход Toolbar в меню View панели меню приложения kscribble. Имя ресурсного ID
состоит из имени меню и имени входа, как видно. Амперсант, стоящий перед буквой, заставляет ее работать как горячую клавишу,
а само имя входа передается с использованием макроса интернационализации i18n().

При активации входа меню вызывается конструкция switch функции commandCallback() с ID меню. Поэтому вы должны добавить соответствующее сравнение
в конструкцию switch и функцию, которую необходимо выполнить при выборе данного входа меню:

<code>
    case ID_VIEW_TOOLBAR:
    	slotViewToolBar();
    	break;
</code>

Заметьте, что вы не обязаны использовать систему ID. Если не задан никакой ID, меню нумеруется автоматически. 
KDevelop использует систему ID для того, чтобы иметь возможность создать конструкции switch для выбора выполняемого слота при
поступлении сигнала <tt/activated()/ для меню и <tt/clicked()/ для кнопок панели инструментов. 
Однако эта связь может быть реализована непосредственно, используя соответствующие методы классов меню и панели инструментов.


<sect>Добавление нового меню
<p>
Новое меню добавляется в приложение так:

<enum>
<item>добавьте указатель на новое меню в заголовке класса приложения (App-class);
<item>вызовите конструктор <tt/<cdx/QPopupMenu// для указателя в <tt/initMenuBar()/ там, где должна появиться ваша панель меню в дальнейшем;
<item>добавьте соответствующие пункты меню в выпадающие меню и установите их ресурсные ID в файле ресурсов;
<item>добавьте связи меню с <tt/commandCallback()/ и <tt/statusCallback()/ в конце <tt/initMenuBar()/;
<item>добавьте методы, которые будут вызываться при выборе входов меню, в заголовки и файлы реализации;
<item>добавьте конструкции switch для входов в <tt/commandCallback()/ и <tt/statusCallback()/;
</enum>


<sect>Использование кнопок панелей инструментов
<p>
Кнопки панелей инструментов могут быть добавлены аналогично входам меню, но с тем отличием, что используемый метод - <tt/insertButton()/. 
Этот метод принимает в качестве аргументов иконку и всплывающую подсказку вместо текста меню.

Иконки, которые вы хотите использовать, загружаются с помощью <tt/KIconLoader/. <tt/<cdx/KApplication// предоставляет макросы <tt/ICON()/ и <tt/Icon()/ 
для доступа к <tt/KIconLoader/ и загрузки иконок. Эти макросы получают в качестве параметра имя файла иконки для ее загрузки из
файловой системы KDE, производя в ней поиск в определенном порядке (см. <tt/KIconLoader/ для уточнения этого порядка).


<idx/Библиотеки KDE/ также предоставляют набор кнопок для панелей инструментов, которые используются для выполнения стандартных действий. В случае, когда они не удовлетворяют ваших потребностей,
вы должны самостоятельно нарисовать иконки. KDevelop поможет вам это сделать - выберите "New" из меню "File", затем выберите тип файла Pixmap.
Обычно иконки для панели инструментов располагаются в поддиректории проекта "<idx/toolbar/" и инсталлируются оттуда в специфичный для вашего приложения
KDE каталог "<idx/toolbar/".

<sect>Конфигурация строки статуса
<p>Шаблон проекта KDevelop уже использует строку статуса, отображая в ней справку о назначении входов меню и кнопок панели инструментов.
При добавлении входа меню также добавляйте справочное сообщение в метод <tt/statusCallback()/.

<tt/statusCallback()/ использует метод <tt/slotStatusHelpMsg()/ для показа сообщения в строке статуса в течение 2 секунд.
Когда выполняется команда, вы должны использовать метод <tt/slotStatusMsg()/ в начале выполнения со строкой, поясняющей, что приложение делает;
перед окончанием операции вы должны установить сообщение в строке статуса "Ready.", вызывая тот же метод.


<sect>Конфигурация горячих клавиш
<p>
Очень профессиональная вещь, которую вы всегда должны добавлять в ваше приложение, - это горячие клавиши. Они обычно используются опытными пользователями,
которые хотят работать с приложением быстро и готовы изучить горячие клавиши. Для них библиотека KDE предоставляет класс
<tt/<cdx/KAccel//, который реализует горячие клавиши и обеспечивает доступ к стандартной глобальной конфигурации горячих клавиш.

По умолчанию, приложение, сгенерированное KDevelop, использует только стандартные горячие клавиши, такие как F1 для получения помощи,
Ctrl+N для создания нового файла. Перед добавлением новой комбинации клавиш вы должны посмотреть, а не определена ли она уже.

Если ваше приложение содержит множество горячих клавиш, вы должны сделать их конфигурируемыми через меню Options; они могут совпадать с конфигурацией других приложений
или использоваться только в вашем. Библиотека KDE предоставляет класс <tt/KKeyChooser/ для использования в многостраничном диалоге,
тогда как <tt/KKeyDialog/ дает готовое диалоговое окно для конфигурации горячих клавиш.

Для более детальной информации см. следующие классы:
<tt/<cdx/KAccel//(<cdx/kdecore/), <tt/<cdx/KKeyChooser//, <tt/<cdx/KKeyDialog// (<cdx/kdeui/).

<chapt>Редактор диалоговых окон  Dialogeditor: Где строятся диалоги
<p>
<sect>Что предлагает Dialogeditor
<p>
Встроенный в KDevelop редактор диалогов разработан для того, чтобы помочь создавать диалоги, которые требуются для вашего приложения,
и тем самым резко уменьшить время, расходуемое на построение графического пользовательского интерфейса. Единственное ограничение на сегодняшний день состоит в том, что Dialogeditor не поддерживает
управление геометрическими размерами элементов, которое предоставляется <idx/Qt/; поэтому диалоговые окна получаются статическими в своих размерах, что при определенных условиях может привести
к нарушениям во внешнем виде приложения, например, текст метки после перевода приложения на другой язык окажется слишком длинным и не поместится в отведенном для него пространстве.

Но текущее состояние редактора в сочетании с возможностями по управлению проектом KDevelop обеспечивает скорейший путь для создания
полнофункциональных приложений для K Desktop Environment.


<sect>Элементы <idx/Qt/ и KDE
<p>
На текущий момент доступны следующие элементы:

<bf/QT-элементы:/
<itemize>
<item><bf/<cdx/QWidget// - элемент, который может использоваться сам по себе, и может содержать другие элементы. Это позволяет создать иерархию элементов внутри вашего диалога.
<item><bf/<idx/QLabel// - метка, представляющая текстовую информацию на элементе. Используется <idx/QLabel/, например, напротив строк ввода
для пояснения их предназначения или возле выпадающего списка для указания названия устанавливаемого параметра.
<item><bf/QPushButton/ - кнопка, позволяющая, например, вызвать другое диалоговое окно типа QFileDialog для выбора имени файла.
<item><bf/QCheckBox/ - элемент, показывающий, разрешена или запрещена опция. QCheckBox широко используется в диалоговых окнах конфигурации.
<item><bf/QLCDNumber/ - отображает номер как на жидкокристаллическом (LCD) экране. Часто используется как часы.
<item><bf/QRadioButton/ - как и QCheckBox, позволяет пользователю выбрать опцию. QRadioButton используется для установки опций, когда
они являются взаимозависимыми, например, вы имеете 3 кнопки, но выбрана может быть только одна из них. См.
<tt/<cdx/QButtonGroup// для более детальной информации.
<item><bf/<cdx/QComboBox// - позволяет пользователю установить значение, выбирая его из
выпадающего меню, или ввести значение, если элемент сконфигурирован доступным для этого.
<item><bf/QListBox/ - предоставляет список элементов, состоящий из одной колонки, с возможностью прокрутки.
<item><bf/QListView/ - создает многоколонный список, который может быть использован для отображения, например, иерархии каталогов в виде таблицы или дерева.
<item><bf/QMultiLineEdit/ - предоставляет многострочный текстовый редактор.
<item><bf/QProgressBar/ - показывает степень выполнения действия, если оно занимает много времени.
<item><bf/QSpinBox/ - позволяет выбрать числовое значение с помощью стрелок вверх/вниз, или ввести его непосредственно в поле ввода, если позволяет конфигурация.
<item><bf/QSlider/ - устанавливает значение в заданном программой диапазоне.
<item><bf/QScrollBar/ - показывает диапазон изменения значения и устанавливает текущее значение с помощью ползунка и кнопок вверх/вниз; часто
используется для элементов, чье содержимое больше видимой области. С его использованием организуется прокрутка и видимая область элемента может меняться.
<item><bf/QGroupBox/ - предоставляет фрейм с заголовком, чтобы показать, что элементы внутри сгруппированы.
</itemize>

<bf/KDE-элементы:/
<itemize>
<item><bf/KColorButton/ - кнопка, отображающая выбранный цвет. При нажатии вызывается KDE-окно выбора цвета, в котором пользователь
может выбрать другой цвет. Часто используется для приложений типа графического редактора и в других случаях, когда может быть выбран цвет.
<item><bf/KCombo/ - аналогичен <tt/<cdx/QComboBox//. Позволяет пользователю выбирать значение из выпадающего списка.
<item><bf/KDatePicker/ - мощный элемент для ввода даты пользователем.
<item><bf/KDateTable/ - табличка календаря для выбора дня месяца. Используется <tt/KDatePicker/ для построения диалога ввода даты.
<item><bf/KKeyButton/ - кнопка для выбора значения клавиши. Если кнопка выбрана, то она активируется, и нажатие клавиши на клавиатуре
изменяет установленный для кнопки код. Может быть использована для конфигурирования обработки клавиатурных команд.
<item><bf/KLed/ - LED (Light Emitting Diode), светящийся диод. Предназначен для отображения текущего состояния.
<item><bf/KLedLamp/ - аналогичен <bf/KLed/, но поддерживает нажатие мышью.
<item><bf/KProgress/ - аналогичен <tt/QProgressBar/, но поддерживает другие диапазоны значений.
<item><bf/KRestrictedLine/ - <tt/QLineEdit/ с возможностями фильтрации ввода. Может быть использован для создания окна ввода пароля.
<item><bf/KSeparator/ - разделитель, который используется во всех случаях, где необходимо что-то отделить от чего-то.
Часто используется в диалогах для выделения логических частей там, где не может быть использован <tt/QGroupBox/.
<item><bf/KTreeList/ - сворачивающийся список для отображения деревьев, похожий на <tt/QListView/.
</itemize>

<sect>Свойства элементов <idx/Qt/
<p>

Эта глава дает полный обзор поддерживаемых в настоящее время элементов <idx/Qt/. Чтобы достичь лучшего понимания
назначения свойств, они разделены в соответствии с иерархией наследования. Так как все элементы имеют предком <tt/<cdx/QWidget//, этот класс описан
первым. Все свойства <tt/<cdx/QWidget// доступны для всех остальных элементов, поэтому повторно не приводятся. Для групп элементов,
которые унаследованы от абстрактных подклассов (<tt/<cdx/QWidget// - базовый класс), свойства базового класса приведены вначале 
(хотя этот класс и не предоставляет видимых элементов в редакторе диалогов).
Затем приводятся свойства для доступных элементов группы, содержащих специфичные опции.
Для лучшего понимания иерархии наследования дерево, представляющее ее, приводится ниже:

<itemize>
<item><ref id="QWidget" name="QWidget">
	<itemize>
		<item><ref id="QButton" name="QButton"> (abstract)
			<itemize>
			<item><ref id="QCheckBox" name="QCheckBox">
			<item><ref id="QPushButton" name="QPushButton">
			<item><ref id="QRadioButton" name="QRadioButton">
			</itemize>
		<item><ref id="QComboBox" name="QComboBox">
		<item><ref id="QFrame" name="QFrame"> (abstract for now)
			<itemize>
			<item><ref id="QGroupBox" name="QGroupBox">
			<item><ref id="QLCDNumber" name="QLCDNumber">
			<item><ref id="QLabel" name="QLabel">
			<item><ref id="QProgressBar" name="QProgressBar">
			<item><ref id="QScrollView" name="QScrollView"> (abstract for now)
				<itemize>
				<item><ref id="QListView" name="QListView">
				</itemize>
			<item><ref id="QSpinBox" name="QSpinBox">
			<item><ref id="QTableView" name="QTableView"> (abstract)
				<itemize>
				<item><ref id="QListBox" name="QListBox">
				<item><ref id="QMultiLineEdit" name="QMultiLineEdit">
				</itemize>
			</itemize>
		<item><ref id="QLineEdit" name="QLineEdit">
		<item><ref id="QScrollBar" name="QScrollBar">
		<item><ref id="QSlider" name="QSlider">
	</itemize>
</itemize>

<sect1>Свойства <cdx/QWidget/ <label id="QWidget">
<p>
<tt/<cdx/QWidget// - базовый класс почти для всех элементов <idx/Qt/ и KDE. Поэтому элементы, унаследованные от <tt/<cdx/QWidget//, позволяют использовать те же
установки в большинстве случаев.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/BgColor:/ Цвет заднего плана (background) элемента
  <item><bf/BgMode:/ Режим заднего плана элемента
  <item><bf/BgPalColor:/ Цветовая палитра заднего плана элемента
  <item><bf/BgPixmap:/ Имя файла картинки заднего плана элемента
  <item><bf/Cursor:/ Курсор над элементом
  <item><bf/Font:/ Шрифт элемента
  <item><bf/MaskBitmap:/ Имя файла для накладываемого точечного рисунка (masking bitmap)
  </itemize>
<item><bf/C++ Code:/
  <itemize>
  <item><bf/AcceptsDrops:/ если установлено в true, экземпляр элемента воспринимает механизм <idx/drag'n drop/ <idx/Qt/-протокола, не KDE 1.x !
  <item><bf/Connections:/ соединение сигналов и слотов элемента
  <item><bf/FocusProxy:/ элемент, предоставляющий фокус данному элементу
  <item><bf/HasFocus:/ устанавливается, если элемент имеет фокус по умолчанию. Помните, что только один объект в диалоге может иметь данное свойство равным true
  <item><bf/ResizeToParent:/ изменяет размер элемента до размера родителя (не виден в режиме редактирования)
  <item><bf/VarName:/ имя переменной объекта. Измените это на имя, описывающее предназначение элемента.
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/IsEnabled:/ устанавливается, если элемент должен принимать пользовательские события
  <item><bf/IsHidden:/ делает элемент невидимым (true) или видимым (false)
  <item><bf/Name:/ устанавливает имя элемента. Помните, что имя отличается от VarName в коде C++.
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/Height:/ высота элемента
  <item><bf/IsFixedSize:/ true - имеет фиксированный размер
  <item><bf/MaxHeight:/ максимальное значение для высоты  Height
  <item><bf/MaxWidth:/  максимальное значение для ширины Width
  <item><bf/MinHeight:/ минимальное значение для высоты Height
  <item><bf/MinWidth:/ минимальное значение для ширины Width
  <item><bf/SizeIncX:/ количество пикселей в одном шаге при изменении размеров по X
  <item><bf/SizeIncY:/ количество пикселей в одном шаге при изменении размеров по Y
  <item><bf/Width:/ ширина элемента
  <item><bf/X:/ положение по горизонтали, считаемое от левого угла
  <item><bf/Y:/ положение по вертикали, считаемое сверху вниз
  </itemize>
</itemize>


<sect1>Наследуемые элементы <cdx/QButton/<label id="QButton">
<p>
<tt/<cdx/QButton// - абстрактный класс, предоставляющий свойства для всех кнопок.

Порожден от <ref id="QWidget" name="QWidget">

Наследуется <ref id="QCheckBox" name="QCheckBox">, <ref id="QPushButton" name="QPushButton"> и <ref id="QRadioButton"
name="QRadioButton">.


<itemize>
<item><bf/Appearance:/
  <itemize>
  <item><bf/setPixmap:/ имя файла используемой картинки
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/setText:/ текст на метках, кнопках и ящиках (boxes), также предустановленный текст для строк ввода
  <item><bf/setAutoRepeat:/ если разрешено, сигнал clicked() испускается через равные интервалы времени, пока кнопка находится в нажатом состоянии. Не действует на переключаемые (toggle) кнопки.
  <item><bf/setAutoResize:/ Если true, то разрешается автоматическое изменение размера. Если оно разрешено, то кнопка изменяет свой размер
при изменении содержимого.
  </itemize>
</itemize>
<p>

<sect2>Свойства QCheckBox <label id="QCheckBox">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ определяет, выбрана ли кнопка при создании
  </itemize>
</itemize>
<p>

<sect2>Свойства QPushButton <label id="QPushButton">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isAutoDefault: (setAutoDefault)/ если установлено авто-умолчание, то кнопка становится кнопкой по умолчанию, когда она получает фокус ввода с клавиатуры
  <item><bf/isDefault: (setDefault)/ может быть только одна кнопка по умолчанию и это может быть использовано только в диалоге. 
Кнопка по умолчанию испускает сигнал <tt/clicked()/ при нажатии пользователем клавиши Enter.
  <item><bf/isMenuButton: (setIsMenuButton)/ сообщает кнопке о необходимости нарисовать стрелку меню. Меню должно быть вставлено отдельно.
  <item><bf/isToggleButton::(setToggleButton)/ делает кнопку переключаемой, то есть заставляет ее вести себя аналогично QCheckBox.
  <item><bf/isToggledOn: (setOn)/ (public slot) включает переключаемую кнопку.
  </itemize>
</itemize>
<p>

<sect2>Свойства QRadioButton <label id="QRadioButton">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QButton" name="QButton">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isChecked: (setChecked)/ определяет, выбрана ли кнопка при создании
  </itemize>
</itemize>
<p>

<sect1>Свойства <cdx/QComboBox/ <label id="QComboBox">
<p>
Порожден от <ref id="QWidget" name="QWidget">

(нет дополнительных свойств)
<p>


<sect1>Элементы, унаследованные от QFrame <label id="QFrame">
<p>
Порожден от <ref id="QWidget" name="QWidget">

Сейчас используется только как абстрактный класс.

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): устанавливает отступ, равный расстоянию от самого внутреннего пикселя рамки и до 
самого внешнего пикселя содержимого
  </itemize>
</itemize>
<p>

<sect2>Свойства QGroupBox <label id="QGroupBox">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Title: (setTitle)/ устанавливает заголовок группы, который отображается на групповой рамке
  </itemize>
</itemize>
<p>

<sect2>Свойства QLCDNumber <label id="QLCDNumber">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/NumDigits:(setNumDigits)/ устанавливает количество цифр, отображаемых в QLCDNumber
  <item><bf/Value: (display)/ (public slot) отображает исходное значение QLCDNumber
  </itemize>
</itemize>
<p>


<sect2>Свойства <idx/QLabel/ <label id="QLabel">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/Appearance:/
  <itemize>
  <item>Margin (setMargin): устанавливает отступ, который для <idx/QLabel/ равен расстоянию от рамки до первого символа текста метки,
в зависимости от выравнивания метки
  </itemize>
<item><bf/C++ Code: /
  <itemize>
  <item><bf/Buddy: (setBuddy)/ определяет объект, которому передается фокус при выборе метки
  </itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Text: (setText)/ устанавливает текст метки
  <item><bf/isAutoResize: (setAutoResize)/ если true, то метка изменяет свой размер при изменении содержимого. Левый верхний угол
не передвигается
  </itemize>
</itemize>
<p>


<sect2>Свойства QProgressBar<label id="QProgressBar">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/TotalSteps: (setTotalSteps)/ (public slot) устанавливает общее количество шагов для индикатора прогресса. В процессе выполнения вашего задания
для отображения прогресса вы должны вызывать метод setProgress(int) для отображения количества пройденных шагов (int).
  </itemize>
</itemize>
<p>
			
<sect2>QScrollView <label id="QScrollView">
<p>
Порожден от <ref id="QWidget" name="QWidget"> and <ref id="QFrame" name="QFrame">

Наследуется <ref id="QListBox" name="QListBox">
(сейчас абстрактный)

Предоставляет элемент с возможностью прокрутки, который управляет отображением дочерних элементов с помощью вертикальной и горизонтальной прокрутки

<sect3>QListView<label id="QListView">
<p>
Порожден от <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> и <ref id="QListView" name="QListView">

Предоставляет список для отображения иерархических данных как в виде таблицы, так и в виде дерева. Имеет прокрутку, организованную с помощью
<ref id="QScrollView" name="QScrollView">.

<itemize>
<item><bf/Appearance:/
	<itemize>
	<item><bf/ListViewFont:/ (setFont()) устанавливает шрифт для строк списка
	<item><bf/ListViewPalette:/ (setPalette()) устанавливает палитру для строк списка
	<item><bf/TreeStepSize:/ (setTreeStepSize(int)) смещение в пикселях дочернего элемента от родительского
	<item><bf/hScrollBarMode:/ Режим прокрутки предоставляется <ref id="QScrollView" name="QScrollView"> для горизонтальной прокрутки
	<item><bf/isAllColumnsShowFocus:/ (setAllColumnsShowFocus(bool)) показывает фокус для всех колонок списка
	<item><bf/isMultiSelection:/ разрешает множественный выбор строк списка
	<item><bf/isRootDecorated:/ разрешает показ "+" и "-" для развернутых и свернутых веток
	<item><bf/vScrollBarMode:/ Режим прокрутки предоставляется <ref id="QScrollView" name="QScrollView"> для вертикальной прокрутки
	</itemize>
<item><bf/General:/
	<itemize>
	<item><bf/Entries:/ позволяет вам вставить список строк, который устанавливается как QListViewItems
	<item><bf/isAutoUpdate:/
	</itemize>
</itemize>

<sect2>Свойства QSpinBox <label id="QSpinBox">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <ref id="QFrame" name="QFrame">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/MaxValue:/  максимальное значение, которое пользователь может выбрать
  <item><bf/MinValue:/  минимальное значение, которое пользователь может выбрать
  <item><bf/Prefix:/
  <item><bf/Suffix:/
  <item><bf/Value:/     предустановленное значение при отображении элемента
  <item><bf/isWrapping:/
  </itemize>
</itemize>
<p>

<sect2>Элементы, унаследованные от QTableView <label id="QTableView">
<p>
Порожден от <ref id="QWidget" name="<QWidget">, <ref id="QFrame" name="QFrame"> и <ref id="QTableView" name="QTableView">

Наследуется <ref id="QListBox" name="QListBox"> and <ref id="QMultiLineEdit" name="QMultiLineEdit">
<p>

<sect3>Свойства QListBox <label id="QListBox">
<p>
Порожден от <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> и <ref id="QTableView" name="QTableView">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/isAutoBottomScrollBar: (setAutoBottomScrollBar)/
  <item><bf/isAutoScroll: (setAutoScroll)/
  <item><bf/isAutoScrollBar: (setAutoScrollBar)/
  <item><bf/isAutoUpdate: (setAutoUpdate)/
  <item><bf/isBottomScrollBar: (setBottomScrollBar)/
  <item><bf/isDragSelect: (setDragSelect)/
  <item><bf/isSmoothScrolling: (setSmoothScrolling)/
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/setFixedVisibleLines:/ устанавливает фиксированную высоту элемента, указывая количество текстовых строк, которые отображаются с использованием текущего шрифта
  </itemize>
</itemize>
<p>

<sect3>Свойства QMultiLineEdit<label id="QMultiLineEdit">
<p>
Порожден от <ref id="QWidget" name="QWidget">, <ref id="QFrame" name="QFrame"> и <ref id="QTableView" name="QTableView">

<itemize>
<item><bf/General:/
  <itemize>
  <item><bf/Text: (setText) / (public slot) устанавливает текст элемента
  <item><bf/isAutoUpdate: (setAutoUpdate)/ используется для того, чтобы избежать мигания при больших изменениях; элемент не обновляется, если запрещено
  <item><bf/isOverWriteMode: (setOverwriteMode) /(public slot) включает режим замены при вводе
  <item><bf/isReadOnly: (setReadOnly)/ (public slot) если установлен в true, то текст не может редактироваться
  <item><bf/isTextSelected: (selectAll)/(public slot) делает выбранным весь текст
  </itemize>
<item><bf/Geometry:/
  <itemize>
  <item><bf/setFixedVisibleLines:/ устанавливает фиксированную высоту для элементов, при этом отображается заданное количество текстовых строк текущим шрифтом
  </itemize>
</itemize>
<p>


<sect1>Свойства QLineEdit <label id="QLineEdit">
<p>
Порожден от <ref id="QWidget" name="QWidget">

<itemize>
<item><bf/General:/
<itemize>
<item><bf/CursorPosition: (setCursorPosition)/ устанавливает позицию курсора по умолчанию
<item><bf/MaxLength: (setMaxLength) / устанавливает максимальную длину строки
<item><bf/Text: (setText) / (public slot) устанавливает текст, отображаемый при создании
<item><bf/hasFrame: (setFrame) / если разрешено, то рисует элемент внутри рамки шириной 2 пикселя
<item><bf/isTextSelected: (selectAll) / (public slot) делает текст выбранным
</itemize>
</itemize>
<p>

<sect1>Свойства QScrollBar<label id="QScrollBar">
<p>
Порожден от <ref id="QWidget" name="QWidget"> и <tt/QRangeControl/.

<itemize>
<item><bf/General:/
<itemize>
<item><bf/MaxValue:/ устанавливает максимальное значение ползунка; используется в конструкторе (не обязательно)
<item><bf/MinValue:/ устанавливает минимальное значение ползунка; используется в конструкторе (не обязательно)
<item><bf/Orientation: (setOrientation)/ устанавливает горизонтальное или вертикальное положение
<item><bf/Value: / устанавливает начальное положение (не обязательно)
<item><bf/isTracking: (setTracking)/ если разрешено, то элемент испускает сигнал <tt/valueChanged()/, пока он перемещает ползунок при нажатой кнопке мыши; иначе 
сигнал испускается после того, как кнопка мыши будет отпущена
</itemize>
</itemize>
<p>

<sect1>Свойства QSlider <label id="QSlider">
<p>
Порожден от <ref id="QWidget" name="<QWidget"> и <tt/QRangeControl/.

<itemize>
<item><bf/General:/
<itemize>
<item><bf/MaxValue:/ устанавливает максимальное значение ползунка; используется в конструкторе (не обязательно)
<item><bf/MinValue:/ устанавливает минимальное значение ползунка; используется в конструкторе (не обязательно)
<item><bf/Orientation: (setOrientation)/ устанавливает горизонтальное или вертикальное положение
<item><bf/Value: (setValue)/ (public slot) использует <tt/QRangeControl::setValue()/ для присвоения значения
<item><bf/isTracking:(setTracking)/ если разрешено, то элемент испускает сигнал <tt/valueChanged()/, пока он перемещает ползунок при нажатой кнопке мыши; иначе 
сигнал испускается после того, как кнопка мыши будет отпущена
</itemize>
</itemize>
<p>

<sect>Свойства элементов KDE 
<p>

<itemize>
<item><ref id="QWidget" name="QWidget">
	<itemize>
	<item><ref id="QButton" name="QButton"> (abstract)
		<itemize>
		<item><ref id="QPushButton" name="QPushButton">
  		<itemize>
  		<item><ref id="KColorButton" name="KColorButton">
  		<item><ref id="KKeyButton" name="KKeyButton">
  		</itemize>		
		</itemize>
	<item><ref id="QComboBox" name="QComboBox">
		<itemize>
		<item><ref id="KCombo" name="KCombo">
		</itemize>
	<item><ref id="QFrame" name="QFrame"> (abstract for now)
 		<itemize>
 		<item><ref id="KDatePicker" name="KDatePicker">
 		<item><ref id="KLedLamp" name="KLedLamp">
 		<item><ref id="KProgress" name="KProgress">
 		<item><ref id="KSeparator" name="KSeparator">
 		<item><ref id="QTableView" name="QTableView"> (abstract)
 			<itemize>
 			<item><ref id="KDateTable" name="KDateTable">
 			<item><ref id="KTreeList" name="KTreeList">
 			</itemize>
 		</itemize>
 	<item><ref id="QLineEdit" name="QLineEdit">
 		<itemize>
 		<item><ref id="KRestrictedLine" name="KRestrictedLine">
 		</itemize>
	</itemize>
	<item><ref id="KLed" name="KLed">
</itemize>

<sect1>KColorButton<label id="KColorButton">
<p>

Порожден от <ref id="QPushButton" name="QPushButton">

<itemize>
<item>General
	<itemize>
	<item><bf/DisplayedColor (setColor())/ отображаемый цвет кнопки
	</itemize>
</itemize>

<sect1>KKeyButton<label id="KKeyButton">
<p>

<sect1>KCombo<label id="KCombo">
<p>

Порожден от <ref id="QComboBox" name="QComboBox">

<itemize>
<item>General
	<itemize>
	<item><bf/Entries/ список входов, отображаемых в элементе
	<item><bf/Text/ текущий отображаемый текст
	<item><bf/isAutoResize/ изменить размер в соответствии с размером текущего элемента
	</itemize>
</itemize>

<sect1>KDatePicker<label id="KDatePicker">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item><bf/FontSize/ размер шрифта элемента
	</itemize>
</itemize>
	
<sect1>KLedLamp<label id="KLedLamp">
<p>

<sect1>KProgress<label id="KProgress">
<p>

<sect1>KSeparator<label id="KSeparator">
<p>

<itemize>
<item>General
	<itemize>
	<item><bf/Orientation/ устанавливает ориентацию разделителя - горизонтальная или вертикальная; по умолчанию горизонтальная
	</itemize>
</itemize>

<sect1>KDateTable<label id="KDateTable">
<p>

<sect1>KTreeList<label id="KTreeList">
<p>

<itemize>
<item>Appearance
	<itemize>
	<item><bf/TreeListBgColor/
	<item><bf/TreeListPalette/
	<item><bf/isBottomScrollbar/
	<item><bf/isScrollBar/
	<item><bf/isShowItemText/
	<item><bf/isSmoothScrolling/
	<item><bf/isTreeDrawing/
	</itemize>
<item>General
	<itemize>
	<item><bf/Entries/
	<item><bf/isAutoUpdate/
	</itemize>
</itemize>



<sect1>KRestrictedLine<label id="KRestrictedLine">
<p>

<sect1>KLed<label id="KLed">
<p>

Порожден от <ref id="QWidget" name="QWidget">

<itemize>
<item>Appearance
	<itemize>
	<item><bf/LedColor: (setColor())/ устанавливает отображаемый цвет индикатора
	</itemize>
</itemize>
	
	
<sect>Создание нового диалога
<p>
Создание нового диалога очень простой процесс, если у вас уже есть опыт графической разработки приложений. KDevelop предоставляет
возможность создавать элементы визуально и показывает, как они будут выглядеть в приложении. Кроме того, вы можете выбрать команду предварительного просмотра 
"Preview" из меню "View".

Для создания диалога или любого другого элемента переключитесь в режим Dialogeditor'а и выберите "New" из меню "File". Затем введите
всю необходимую информацию в диалог "New Dialog". Это:

<enum>
<item>От какого класса наследуется диалог (The Dialog inheritance). Это необходимо, потому что любой элемент в конце концов порожден от <tt/<cdx/QWidget//. Кроме типов элементов,
предоставляемых <idx/Qt/, вы можете наследовать элемент, например, от абстрактного базового класса, который вы создали сами в проекте. В этом случае
выберите "custom" и введите путь файла заголовка в строку ввода ниже.
<item>Имя диалога (The Dialog name). Это устанавливает имя класса для генерируемого диалога. Выберите осмысленное имя, отражающее назначение диалога; 
в случае наследования от <tt/QDialog/, вы можете ввести имя, заканчивающееся буквами <tt/Dlg/, чтобы помнить, что это диалог.
При присвоении имени следует использовать принятые в KDE и <idx/Qt/ соглашения: используйте заглавные буквы в имени класса. Например, диалог выбора размеров таблицы
вы можете назвать <tt/GridSizeDlg/.
<item>Имена генерируемых файлов (The generated filenames). Они заполняются при вводе имени диалога, но могут быть изменены. Если вы хотите использовать другие
имена файлов, также необходимо придерживаться соглашений KDE и <idx/Qt/: все имена файлов набираются строчными буквами и содержат имя класса
для напоминания, что он содержится в этом файле. Файл данных, который будет задан позднее, содержит сгенерированный код, получаемый при создании диалога. 
Вы не должны редактировать этот файл непосредственно; используйте файл реализации для любых добавлений в диалог и реализации его методов.
</enum>

После этого диалог отобразится как элемент с сеткой. Поскольку сетка используется редактором диалогов для привязки элементов к ее узлам, вы можете
изменять шаг сетки с помощью пункта "Grid Size" в меню "View", если вас не удовлетворяет значение по умолчанию

Выберите переключатель "Widgets" на левой панели и нажмите тот элемент, который вы хотите добавить в главное окно. Он
появится в главном окне в левом верхнем углу и будет выбран рамкой, позволяющей производить изменение размеров. Передвиньте или измените размер элемента
с помощью мыши. Курсор будет при этом изменяться, чтобы показать, какое действие может быть выполнено в данной позиции.

После завершения создания диалога выберите "Generate Files" из меню "Build" или нажмите соответствующую кнопку панели инструментов.
Файлы будут сгенерированы в предопределенном месте и включены в исходники вашего проекта. Команда "Build" или "Make" перекомпилирует все сгенерированные
файлы вашего проекта и вы сможете добавить соответствующий вызов конструктора в ваше приложение для отображения диалога или элемента.
Для проектов KDE все свойства элементов могут быть просмотрены позже, например текст метки, установленный с помощью макроса <tt/i18n()/ из <tt/<cdx/kapp.h//
для поддержки интернационализации. Таким образом, вы должны выполнить "Make Messages and merge" после завершения создания и реализации.

При создании диалога или элемента вы должны следовать следующим советам:
<itemize>
<item>Всегда стремитесь к стандарту! Это, наверное, наиболее важное правило при разработке элементов графического пользовательского интерфейса. Помните, что пользователь
воспримет только те приложения, которые легко понять, независимо от того, насколько сложны решаемые ими задачи.
<item>Добавляйте везде, где это возможно, всплывающие подсказки. Что это..? Помощь, или Быстрая помощь. Это позволяет получить информацию
о целях конкретного объекта пользовательского интерфейса.
<item>Следите за <bf/фокусом ввода клавиатуры/! Генератор не заботится об этом - об этом надо помнить при создании любого элемента;
иначе вы будете вынуждены переупорядочивать ваш инициализационный код вручную, что является очень неблагодарным занятием. Порядок изменения фокуса ввода клавиатуры значит
порядок, в котором составляющие диалог элементы получают фокус, когда пользователь нажимает клавиши Tab и Shift+Tab. Очень надоедливо,
когда фокус изменяется как угодно, но только не на следующий элемент, расположенный ниже или справа от текущего. Поэтому начинайте
создание ваших элементов сверху вниз слева направо для уверенности в правильности перемещения фокуса.
</itemize>

<sect>Установка свойств элемента
<p>

<nidx/widget properties/<nidx/dialogeditor/<nidx/properties window/
Свойства элемента могут быть легко установлены через окно свойств элемента. Когда выбирается элемент, окно свойств
автоматически обновляется и отображает свойства текущего элемента. Поскольку все элементы произошли от <tt/<cdx/QWidget//, вы можете установить 
свойства <tt/<cdx/QWidget// и свойства, специфичные для выбранного элемента. Свойства могут быть:

<itemize>
<item>Значениями типа integer, такие как положение элемента или размер шрифта
<item>Значениями типа boolean для разрешения/запрещения определенных параметров элемента. Установленные выбором из списка содержат true и false
<item>Значения перечислимых типов, например, палитра. При установке выбором из списка содержат все доступные значения
<item>Значение цвета, например, для цвета элемента. Устанавливается с помощью диалога выбора цветов KDE
<item>Шрифт, например, текста метки. Будьте осторожны, задавая значение шрифта, отличное от шрифта по умолчанию, поскольку может случиться, что KDE не обновит шрифт.
<item>Имена файлов для картинок заднего плана. Не используйте файлы формата gif,
поскольку они могут не поддерживаться последующими версиями <idx/Qt/.
</itemize>

<sect>Подключение диалога к проекту
<p>
Когда вы создаете элемент, вы, вероятно, хотите добавить его в проект для выполнения функций, для которых он был разработан. Поскольку элемент
может быть создан для выполнения нескольких функций, мы рассмотрим 2 случая - элемент унаследован от <tt/<cdx/QWidget//, и элемент унаследован от <tt/QDialog/.

<sect1>Наследование от <tt/<cdx/QWidget// 
<p>
Предположим, вы создали элемент, который будет входить в состав главного окна. Если вы заполняете всю видимую область, вы должны добавить 
указатель на экземпляр объекта в файл заголовка с определением вашего экземпляра <tt/<cdx/KTMainWindow//, заменив текущий объект Просмотр. Затем измените код в
методе <tt/initView/ для установки вашего элемента главным. Кроме того, вы можете удалить класс View из сгенерированного проекта, но помните,
что экземпляр документа и экземпляр приложения (App) зависят от класса View. В этой ситуации технически гораздо более удобно создать
мини-KDE приложение и создать свой экземпляр <tt/<cdx/KTMainWindow//.

Гораздо чаще элемент будет частью видимой области, что предполагает его объединение с другими элементами. Это может быть сделано
с использованием одного из следующих классов, которые предлагают разделители для отделения двух элементов:

<enum>
<item><tt/QSplitter/
<item><tt/KPanner/
<item><tt/KNewPanner/
</enum>

Если видимая область будет содержать более двух элементов, вы сможете использовать второй экземпляр разделителя в качестве объекта управления
в одной из первоначальных областей. Добавьте соответствующие элементы на каждую из частей видимой области и установите первый разделитель как видимую область.
(см. Netscape Mail - прим. переводч.)

<sect1>Наследование от <tt/QDialog/ 
<p>
Если ваш элемент унаследован от <tt/QDialog/, то, вероятно, он используется для изменения одного или нескольких значений; часто это необходимо для установки
настроек приложения. Для вызова диалога вы должны добавить слот в класс <tt/App/, вставляя объявление метода и его реализацию.
Затем добавьте вызов конструктора для метода, а также вызов <tt/show()/ или <tt/exec()/ диалога. Наконец, вы должны позаботиться
об обработке результатов работы диалога; это может быть сделано в диалоге изменением значений родителя, или
получением значений из диалога (что сделает ваш диалог гораздо более легко переносимым в другие проекты). Имейте в виду, что вы должны вызвать
<tt/delete/, если вы создаете экземпляр диалога с помощью <tt/new/, чтобы избежать потери памяти.

Наконец, вы должны связать вход меню (обеспечив соответствующее сообщение в строке статуса) с новым методом, вызывающим диалог; можно 
создать горячую клавишу и кнопку на панели инструментов. Для этого добавьте ресурсный ID в файл <tt/resource.h/. Затем
добавьте соответствующий вход меню в одно из выпадающих меню, уже имеющихся в панели меню, или создайте новое.
Вход меню состоит из:

<itemize>
<item>необязательной иконки. Установите ее вызовом макроса <tt/Icon("iconname.xpm")/ из <tt/<cdx/KApplication//, чтобы использовать
уже существующий экземпляр <tt/KIconLoader/.
<item>имени входа меню. Добавьте его с использованием макроса <tt/i18n("&amp;имя_входа")/ из <tt/<cdx/KApplication//, чтобы обеспечить
интернационализацию. Амперсант должен быть перед буквой, которая обеспечивает доступ по горячей клавише.
<item>экземпляр, содержащий вызываемый метод. Обычно это указатель <tt/this/.
<item>вызываемый слот. Используйте <tt/SLOT(ваш_метод())/ для вызова слота по сигналу <tt/activated()/.
<item>горячая клавиша. Должна быть установлена в 0, поскольку это назначение делается в <tt/initKeyAccel()/, где вы
вводите горячие клавиши вместе с слотами для вызова. Затем вызовите <tt/changeMenuAccel()/ для изменения
горячей клавиши. Это позволит сделать ее конфигурируемой через стандартный диалог в дальнейшем. Для стандартных действий используйте 
значения, определенные <tt/<cdx/KAccel//.
<item>меню ID, установленный в <tt/resource.h/
</itemize>


<chapt>Поддержка печати
<p>
<ncdx/QPrinter/<ncdx/QPainter/<ncdx/QPrintdialog/<nidx/printing/
Печать обычно используется, чтобы пользователь мог получить твердую копию созданного им электронного документа.
Поэтому функция необходима только для тех программ, которые делают что-то, что можно напечатать, например, текст
или картинку. В любом случае, это требует интерфейсного решения, предоставляемого библиотекой <idx/Qt/ в двух классах: <tt/QPrintDialog/,
предоставляющий диалог печати, и <tt/QPainter/, который обычно используется для прорисовки содержимого элемента. Поскольку объект Просмотр
приложения способен отобразить документ, он также способен его и напечатать.

<sect><idx/Qt/ диалог печати
<p>
Для использования <idx/Qt/ диалога печати необходимо добавить в секцию "#include" <tt/qprintdialog.h/. При использовании шаблона KDE приложения это 
делается автоматически объектом Просмотра, поэтому вы должны только завершить реализацию метода <tt/print()/, используя <tt/QPainter/.

<sect>Класс QPainter 
<p>
Независимо от возможностей принтера, вы можете использовать <tt/QPainter/ для вывода вашего документа на принтер, предоставляемый <tt/QPrinter/,
как будто вы прорисовываете элемент на экране. Сложности возникнут только с тем, как создать то, что необходимо напечатать.

<chapt>Система помощи
<p>
Очень важная часть процесса разработки - реализация системы помощи там, где это возможно. Многие разработчики
стараются сделать это в последнюю очередь, но вы должны помнить, что обычный пользователь не обязательно эксперт Unix'а. Он может прийти с темной стороны
компьютерных программ, где даются все возможные конфетки и пользоваться приложением можно, даже не заглядывая в руководство.
Библиотеки KDE и <idx/Qt/ предоставляют все, что может потребоваться, чтобы сделать приложение профессионально выглядящим в глазах
обычного пользователя, и все функции помощи могут быть использованы. В приложении это:

<itemize>
<item>Всплывающие подсказки (Tool-Tips)
<item>Быстрая помощь (Quick-Help)
<item>Помощь в строке статуса (Statusbar help)
<item>Кнопка What's this...? 
</itemize>

Кроме того, приложение должно обеспечивать доступ к документации в HTML-формате, используя стандартную кнопку F1.

KDevelop предоставляет возможность реализации всех функций помощи, и стандартный шаблон приложения уже содержит их базовую реализацию.
Поэтому в данной главе мы рассмотрим, что, где и как надо добавлять в вашу систему помощи для ее расширения.

В процессе разработки вашего приложения вы должны следить за согласованностью элементов того, что вы разрабатываете; вы должны добавлять
функции помощи непосредственно при разработке кода. Это позволит вам избежать его последующего анализа и выяснения, за что же отвечает
данная часть приложения.

<sect>Всплывающие подсказки
<p>
Очень простой способ обеспечения помощи - это всплывающие подсказки. Это маленькие сообщения, которые появляются, когда пользователь подводит указатель мыши к элементу.
Сообщение исчезает, когда указатель мыши убирается с элемента. Наиболее популярно использование всплывающих подсказок в панелях инструментов.
Здесь всплывающие подсказки должны быть как можно короче, потому что панель инструментов может конфигурироваться для отображения только кнопок, кнопок и текста справа, кнопок и текста под ними или только текста.
Это может быть реализовано в приложении, а может и не быть реализовано.
Текст всегда отображается как всплывающая подсказка, и панель инструментов обычно состоит из кнопок и других элементов,
например, строк ввода и выпадающих списков. Для получения полной информации см. описание класса <tt/<cdx/KToolBar// в библиотеке KDE-UI.

Например, рассмотрим кнопку "New File" в сгенерированном шаблоне:

<tscreen><verb>
toolBar()->insertButton(Icon("filenew.xpm"), ID_FILE_NEW, true, i18n("New File") );
</verb></tscreen>

<ncdx/toolBar()/<nidx/KToolBar/
Здесь часть <tt/i18n("New File")/ реализует всплывающую подсказку. Она заключена в макрос i18n(), предоставляемый <tt/<cdx/kapp.h//
для перевода подсказки на используемый язык.

Всплывающая подсказка может быть добавлена к любому пользовательскому элементу с помощью <idx/Qt/-классов <tt/QToolTip/ и <tt/<cdx/QToolTipGroup//.
Например,

<tscreen><verb>
QToolTip::add( yourwidget, i18n("Ваша_подсказка") );
</verb></tscreen>

Для получения более подробной информации, см. описание класса <tt/<cdx/QToolTip// в документации <idx/Qt/.

<sect>Добавление быстрой помощи
<p>
Окно быстрой помощи - это другой хороший пример предоставления помощи. Пользователь может получить быструю помощь о назначении элемента, нажав правую кнопку мыши
над ним и выбрав из контекстного меню пункт "Quick-Help". Функция Быстрой помощи располагается где-то посередине между всплывающими подсказками и полным руководством пользователя.
Полное руководство содержит слишком много связанной с другими частями приложения информации, а всплывающие подсказки не дают достаточно информации.
Чтобы увидеть, как работает быстрая помощь, откройте любой диалог в KDevelop и нажмите правую кнопку мыши над его элементом.
Затем выберите пункт меню Quick-Help, и появится окно с сообщением. Эти сообщения могут быть отформатированы с использованием цвета, различных шрифтов,
и даже содержать гиперссылки (что может быть использовано для обращения к страницам документации).

Для реализации быстрой помощи добавьте в секцию "include" файл <tt/<cdx/kquickhelp.h//.
Поскольку класс <tt/<cdx/KQuickHelp// - часть библиотеки KDE-UI, она уже должна использоваться вашим приложением. Если это не так, установите соответствующий флаг линкера
для использования kdeui.

Например,

<tscreen><verb>
KQuickHelp::add( yourwidget, i18n("Ваше_сообщение") );
</verb></tscreen>

что почти аналогично QToolTip. При создании диалогового окна с помощью редактора диалогов KDevelop'а, добавьте ваши всплывающие подсказки и быструю помощь
в файл реализации - НЕ в исходный файл редактора диалогов, поскольку этот файл переписывается при каждом редактировании элемента.

Класс <tt/<cdx/KQuickHelp// предоставляет возможность форматирования текста с использованием тагов. Он позволяет включение цветового выделения, гиперссылок,
типов шрифтов и размеров шрифтов. См. "KDE Library Reference Guide" и 
документацию по классу <tt/<cdx/KQuickTip// для дополнительной информации.

<sect>Реализация помощи в строке статуса
<p>
Шаблон приложения, генерируемый KDevelop, содержит, кроме всего прочего, строку статуса. Кроме того, он содержит сообщения для каждого из
пунктов меню и элементов панели инструментов. Помощь строки статуса - короткое сообщение, которое подробнее объясняет смысл всплывающей подсказки, или
может рассматриваться как замена всплывающих подсказок для пунктов меню, и, как следует из названия, отображается в строке статуса, когда вход меню
подсвечивается; поэтому все входы меню связывают сигнал <tt/highlighted(int)/ с методом <tt/statusCallback(int)/,
который выбирает соответствующее сообщение в конструкции switch. Если вы добавляете новый пункт меню или новую кнопку панели инструментов, 
добавьте соответствующий вход в этот метод с кратким описанием действия, выполняемого при активации кнопки или пункта меню.

Пример:

<tscreen><verb>
    case ID_FILE_NEW:
 	  	slotStatusHelpMsg(i18n("Creates a new document"));
 	  	break;
</verb></tscreen>

Это будет отображать сообщение в строке статуса, вызывая метод <tt/slotStatusHelpMsg()/ с соответствующей переведенной строкой помощи, 
когда пользователь подсвечивает вход меню или кнопку панели инструментов с ID ID_FILE_NEW, который привязан к методу <tt/statusCallback()/.
Панели инструментов связаны с этим методом сигналом <tt/pressed(int)/, что позволяет пользователю нажать кнопку панели и убрать с нее
указатель мыши, не выполняя команды. <tt/<cdx/KToolBar// также предоставляет сигнал <tt/highlighted(int, bool)/, который может быть использован
для отображения сообщения при подсветке кнопки вместо ее нажатия.


<sect>Кнопка "What's This...?"
<p>
Кнопка <idx/"What's This...?"/ предоставляет окно помощи, аналогичное Quickhelp, когда пользователь хочет получить
конкретную помощь по определенному элементу рабочей области или элементу панели инструментов. Она располагается на панели инструментов и активируется
после нажатия пользователем на нее. Курсор изменяется на стрелку с вопросительным знаком, как это изображено на кнопке.
Пользователь может нажать на видимый элемент и получить окно помощи. В качестве упражнения вы можете посмотреть на поведение What's this...?
в KDevelop.
Для добавления кнопки What's This...? проделайте следующее:

<enum>
<item>включите <tt/qwhatsthis.h/ в исходный код
<item>добавьте функцию-член <tt/<cdx/QWhatsThis// whats_this (или с другим именем) в область private вашего класса, унаследованного от <tt/<cdx/KTMainWindow//
<item>определите идентификатор ресурса для этой кнопки в <tt/resource.h/, например, <tt/#define ID_HELP_WHATS_THIS 10100/
<item>в методе, создающем панель инструментов (обычно <tt/initToolBar()/), добавьте, где должна располагаться ваша кнопка:
<tscreen><verb>
  whats_this = new QWhatsThis;
  QToolButton *btnwhat = whats_this->whatsThisButton(toolBar());
  QToolTip::add(btnwhat, i18n("What's this...?"));
  toolBar()->insertWidget(ID_HELP_WHATS_THIS, btnwhat->sizeHint().width(), btnwhat);
  btnwhat->setFocusPolicy(QWidget::NoFocus);
</verb></tscreen>
<ncdx/setFocusPolicy()/
<item>добавьте сообщение, которое будет отображаться для определенного элемента:
<tscreen><verb>
whats_this->add(class_tree, i18n("Class Viewer\n\n"
                                  "The class viewer shows all classes, methods and variables "
                                  "of the current project files and allows switching to declarations "
                                  "and implementations. The right button popup-menu allows more specialized "
                                  "functionality."));
</verb></tscreen>
</enum>
	

<chapt>Создание документации с использованием <idx/SGML/
<p>
Учитывая тот факт, что зачастую проекты не содержат полного набора пользовательской документации, все проекты KDevelop 
включают в себя шаблон документации, который может быть легко приспособлен к проекту; этим достигается одна из целей KDE: предоставить достаточное количество online-помощи для поддержки пользователей, еще не овладевших приложением.
Эта глава посвящена тому, как расширить предлагаемый шаблон документации и что необходимо сделать, чтобы он стал доступен пользователю.

<sect>Почему SGML ?
<p>
<idx/SGML/ (Standard Generalized Markup Language) 
- язык, с помощью которого можно написать спецификацию другого языка разметки (markup language),
но он не является языком разметки сам по себе. Спецификация для языка разметки называется DTD (Document Type Definition, Определение типа документа), и содержит
структуры документа и доступные таги. Кроме того, SGML-система предоставляет набор файлов замены, которые переводят таги DTD
в требуемый формат - вот так это работает. Наиболее часто используемый формат вывода - HTML для создания online-помощи,
просматриваемой через браузер, учитывая, что стандарты Internet доступны даже на отдельно стоящих компьютерах. KDE широко использует HTML
документацию в <idx/KDEHelp/, в котором приведены все <idx/приложения KDE/, и предоставляет доступ к их руководствам пользователя.
Эти руководства доступны также через меню Help непосредственно из приложения.

Сейчас KDE и, следовательно, KDevelop, используют пакет SGML-Tools 1.x (см. <url url="http://www.sgmltools.org">), ранее известный как
пакет LinuxDoc. Он содержит DTD, называемый <tt/LinuxDoc/, набор map-файлов для генерации выходных файлов в различных форматах
и необходимые инструменты, которые в действительности производят замену тагов <tt/LinuxDoc/. LinuxDoc DTD базируется на Qwertz DTD, который, в свою очередь,
был написан для обеспечения хорошего картирования (mapping, то есть замена тагов) в основном для текстовой системы &latex;, поэтому с ним очень легко генерировать
готовые к печати документы. Пакет получил свое название в связи с его использованием для написания документации LDP (Linux Documentation Project, Проект документирования Linux),
и его имя было изменено только из-за того, что это была sgml-система, которая вовсе не должна быть связана с Linux-проектом, а может использоваться
на любой из Unix-систем; вы можете даже написать свой собственный DTD и map-файлы для него.

Тем временем был разработан для определенных целей другой DTD - "DocBook DTD". DocBook имеет почти те же возможности, что и 
LinuxDoc DTD, но предоставляет лучшие таги и map-файлы для таблиц и включаемой графики, но все это возможно и в LinuxDoc.
SGML-инструмент, таким образом, получил необходимость поддержки DocBook DTD в серии версий 2.x, которые также предоставляли конвертер для получения
DocBook sgml из исходников LinuxDoc.

В своем текущем состоянии KDE все еще использует LinuxDoc DTD по нескольким причинам:
<list>
<item>написание LinuxDoc документации проще,
<item>инсталляция SGML-Tools 1.x для использования LinuxDoc еще проще,
<item>KDE предоставляет дополнительный инструмент, называемый <tt/ksgml2html/, который придает стиль KDE выходным файлам HTML, генерируемым
конвертером SGML-Tools 1.x <tt/sgml2html/.
</list>

Я сам обнаружил, пока писал книги о KDevelop, что использовать LinuxDoc DTD очень просто, и он предоставляет все необходимое
для написания документации. Скорость изучения очень высокая, поэтому вы сможете стать гуру в области sgml-tools/LinuxDoc DTD
за несколько дней, и это сохранит вам очень много времени при работе с такими системами форматирования, как &tex; для распечатки
документации или языком разметки для создания HTML.

Основная причина продолжать использовать sgml-tools 1.x - большинство дистрибутивов содержат пакет и дополнительные средства, необходимые вам
для производства других выходных форматов. Это делает инсталляцию максимально простой, да и написание sgml-документа само по себе не сложное, как вы увидите. 
Вы можете получить документы в следующих форматах, генерируя их из sgml: 

<itemize>
<item>HTML, который приобретает вид KDE документа, если дополнительно используется <tt/ksgml2html/,
<item>текст,
<item>GNU info,
<item>Lyx формат,
<item>&tex;, DVI, PostScript и PDF формат,
<item>Rich Text Format (RTF).
</itemize>


<sect>Что уже содержит шаблон документации
<p>
При создании проекта KDevelop подкаталог <tt>docs/en</tt> уже содержит файл <tt/index.sgml/ с документацией на английском языке и
уже сгенерированные файлы HTML формата. Они уже включены в проект, и путь для их инсталляции указывает
на KDE HTML каталог. Документация уже адаптирована к вашему наименованию проекта, номеру версии и содержит информацию о программисте.
Далее, файл index.html включает содержание руководства по использованию программы. Этот файл открывается системой помощи KDE, когда пользователь
запрашивает помощь по работе с вашим приложением; в файл включены инструкция по установке, лицензия GPL и информация о copyright.

При разработке документации вы должны только добавить информацию, специфичную для вашего приложения. Помните, что
проект KDE требует запуска "Make Doc-Handbook" из меню "Project" после окончания разработки проекта. Файл index.sgml
при этом вновь обрабатывается <tt/<idx/ksgml2html// и генерируется выполненная в KDE-стиле HTML документация. Откройте каталог <tt>docs/en</tt> в RFV
и добавьте <tt/logotp3.gif/ в проект через контекстное меню; затем правильно задайте его свойства для инсталляции логотипа
в тот же каталог, где будут расположены HTML файлы - <tt>$(kde_htmldir)/en/&lt;ваш_проект&gt;/logotp3.gif</tt>.

<sect>Написание SGML документации
<p>
Этот раздел добавлен, потому что SGML (или, более точно, LinuxDoc DTD), все еще кажется сложным для начинающих
писать документацию. Когда я посмотрел на некоторые приложения KDE, то увидел, что некоторые из них содержат файл sgml в виде исходного шаблона -
а автор редактировал HTML файлы вместо sgml. Это приводит к проблемам при переводе - если необходимо
перевести документацию на родной язык, приходится редактировать каждый файл в HTML формате, и это делает
невозможным повторное использование документов в других форматах, причем не только в английской версии, а и во всех локализованных версиях проекта.
Как видно, это не продуманное решение, приводящее к весьма тяжким последствиям; я считаю, что это происходит, поскольку автор знает HTML,
но не знает SGML. Поскольку большинство старается избежать изучения нового языка форматирования, они используют HTML файлы как шаблон для редактирования.
Если вы однажды посмотрите на то, как легко и просто использовать SGML с LinuxDoc, вы решите, что лучше выучить несколько лишних тагов
и создавать SGML формат.

Следующие разделы дают начальную информацию о наиболее важных частях файла sgml в LinuxDoc, и объясняют, как расширить
вашу документацию.

<sect1>Объявления DTD
<p>
Для того, чтобы показать, какой вариант DTD используется, каждый sgml файл начинается с объявления DTD.
Первый таг (взятое в скобки выражение, например &lt;ваш_таг&gt; содержимое &lt;/ваш_таг&gt) всегда DOCTYPE:

<verb>
&lt;!doctype linuxdoc system&gt;
</verb>

Это сообщает вашему форматировщику sgml, что он должен использовать LinuxDoc DTD.

<sect2>Структура документа
<p>
При использовании LinuxDoc следующий таг - стартовый таг документа, определяющий его стиль. LinuxDoc DTD предлагает целый набор типов документов,
из который вы можете выбрать нужный в зависимости от назначения документа и его длины. Доступны следующие типы:

<itemize>
<item><tt/&lt;notes&gt;/ для короткого пояснения,
<item><tt/&lt;article&gt;/ для написания статьи длиной 10-20 страниц (примерно). Этот тип используется в качестве шаблона в KDevelop и большинстве KDE
приложений,
<item><tt/&lt;report&gt;/ для статей длиннее &lt;article&gt;,
<item><tt/&lt;book&gt;/ для написания большой книги - руководство по KDevelop использует этот тип,
<item><tt/&lt;slides&gt;/ для слайд-шоу. Это полезно для презентаций. Предполагается использование &latex; в качестве конечного формата в большинстве случаев,
<item><tt/&lt;letter&gt;/ для обычных писем,
<item><tt/&lt;telefax&gt;/ для факсов,
<item><tt/&lt;manpage&gt;/ для статьи man.
</itemize>

Имейте в виду, что эти типы описывают только общую организацию структуры документа, а не конкретный вид выходных документов. Как упоминалось,
KDevelop по умолчанию генерирует шаблон, используя структуру &lt;article&gt;. Это используется большинством приложений, исключая сам KDevelop, который использует тип
&lt;book&gt;. В HTML формате это не имеет серьезного значения - но для &latex;, например, это важно.
Руководство - это настоящая "книга" с отдельными страницами для каждой главы (главное отличие).

Конец sgml файла должен содержать завершающий таг для структуры документа - для &lt;article&gt; это будет 
&etago;article&gt;.

<sect1>Титульная страница
<p>
После тага структуры документа идет секция, описывающая основные пункты, располагаемые на титульной странице. Шаблон
не использует их все, но заполняет информацию для тагов <tt/&lt;title&gt;/, <tt/&lt;author&gt;/ и <tt/&lt;date&gt;/, чего обычно достаточно.
При использовании структуры <tt/&lt;book&gt;/ вы, вероятно, захотите определить все таги титульной страницы.
Следующий пример показывает использование этих тагов, он взят из sgml исходника этой книги:

<code>
&lt;!doctype linuxdoc system&gt;
&lt;book&gt;
&lt;titlepag&gt;
&lt;title&gt;The KDevelop Programming Handbook
&lt;subtitle&gt;The User Guide to C++ Application Design for the K Desktop Environment (KDE) with the KDevelop IDE, Version 1.0
&lt;author&gt;
&lt;name&gt;Ralf Nolden &lt;htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de"
                                   name = "&lt;Ralf.Nolden@post.rwth-aachen.de&gt;"&gt;
&lt;inst&gt;The KDevelop Team
&lt;date&gt;Version 2.1 , July 7, 1999
&lt;abstract&gt;
This handbook itself is part of the KDevelop Integrated Development Environment
and is therefore also licensed under the GNU General Public License;
see &lt;ref id="Copyright" name="Copyright"&gt; for more information.
&etago;abstract&gt;
</code>

Это включает в себя все, что обычно содержит титульная страница. Таг <tt/&lt;author&gt;/ включает таг <tt/&lt;thanks&gt;/, вставляющий
некоторые благодарности соавторам и т.п. <tt/&lt;inst&gt;/ представляет институт или компанию, для которой автор писал
документацию; вы также можете использовать имя вашей команды, как сделал я. <tt/&lt;abstract&gt;/ содержит краткое описание, расположенное
на титульной странице. Это несколько неприятно в печатной версии, поэтому там данная секция будет напечатана на обратной стороне титульной страницы
вместе с copyright; это может быть изменено в &latex; редактированием файла &tex;.

<sect1>Индексы
<p>
LinuxDoc DTD определяет набор тагов для построения различных индексов, как это обычно делается в документах. Это:

<itemize>
<item>&lt;toc&gt; для содержания
<item>&lt;lof&gt; для списка рисунков
<item>&lt;lot&gt; для списка таблиц
</itemize>

Завершающий таг не требуется в конце; индексы вставляются непосредственно после титульной страницы перед началом
документа с соответствующими разделами или главами.

Для индексации ключевых слов, список которых располагается в конце документа, вам предоставляются 4 различных тага;
два из них оставляют индексированную фразу видимой на странице, а два других не отображают индексные входы:

<list>
<item>&lt;idx&gt; для элемента обычного индекса,
<item>&lt;cdx&gt; для true-type элемента индекса,
<item>&lt;nidx&gt; для индексного входа, не отображаемого на странице,
<item>&lt;ncdx&gt; аналогично для tt-индекса
</list>

Эти таги игнорируются всеми конечными форматами, кроме
<tt/sgml2latex/, который генерирует индексный файл <tt/index.idx/, который преобразуется в &tex;-индекс командой <tt/makeindex index.idx/.
Сам индекс может быть вставлен в &tex; файл с помощью <tt/\printindex/.
Я написал скрипт, автоматизирующий вставку
индекса в &latex; (но до сих пор не знаю, как включить индекс в содержание...).

<sect1>Содержание документа
<p>
Сейчас, после объяснения большинства деталей основной структуры, мы переходим к рассмотрению текста документа. В зависимости от 
типа структуры документа, он начинается либо с тага <tt/&lt;sect&gt;/, либо, при использовании <tt/&lt;book&gt;/, с тага <tt/&lt;chapt&gt;/
для глав.

После стартового тага, вы можете структурировать каждую главу с помощью <tt/&lt;sect1&gt;/, <tt/&lt;sect2&gt;/ и т.п. до максимального
уровня вложенности (4).

После стартового тага главы следует ее заголовок. Здесь вы можете использовать <tt/&lt;title&gt;/ 
и <tt/&etago;title&gt;/ для заголовков глав (при необходимости). После заголовка главы вы должны добавить таг &lt;p&gt;,
чтобы обозначить начало текста главы. В тексте вы имеете возможность использовать списки, перечисления,
списки определений (description lists) и т.п. Далее, цитаты и фрагменты кода также могут быть вставлены с помощью тагов, см. 
документацию по <tt/sgmltools/ для получения полного перечня тагов. Также в ней посмотрите раздел о добавлении специальных символов.
В нем перечислены все доступные неалфавитные символ, например, знак торговой марки.
С помощью этих тагов вы сможете структурировать документацию так, как это требуется для вашего приложения.

<sect>Как вызывать помощь в диалоговых окнах
<p><nidx/help functions/
Вызов помощи в диалогах часто реализуется с помощью кнопки Помощь (Help); после этого вы добавляете слот, выполняемый по нажатию этой кнопки.
В коде этого слота вы должны вызвать:

<tscreen><verb>
kapp->invokeHTMLHelp( QString aFilename, QString aTopic );
</verb></tscreen>

где <tt/aFilename/ - имя файла в каталоге с HTML-документацией вашего приложения; например, index-3.html.
<tt/aTopic/ - заголовок, который должен быть вызван. Хеш-префикс "#" добавляется автоматически; введите главу,
к которой вы хотите обратиться, хотя это может быть и заголовок более низкого уровня.

<chapt>Документирование классов с помощью <idx/KDoc/
<p>
Другая важная часть документации - краткое описание интерфейса классов. Это позволит вам и другим
программистам использовать ваши классы, читая HTML файлы документации классов, которая создается с помощью <tt/<idx/KDoc//. KDevelop поддерживает использование
<tt/<idx/KDoc// для создания документации к KDE-библиотекам, и ваш шаблон уже документирован. Для работы
с предлагаемым в нем кодом полезно прочитать online-документацию. Данная глава описывает, что необходимо сделать
для документирования <idx/API/, и как KDevelop поможет вам в этом, также рассматриваются дополнительные таги, поддерживаемые <tt/<idx/KDoc//.

<sect>Как использовать возможности KDevelop по документированию
<p>
Для создания документации <idx/API/ после разработки проекта выберите "Make <idx/API/-Doc" из меню "Project". 
Это приведет к просмотру всех файлов заголовков и созданию на их основе HTML файлов документации. После этого
вы сможете получить доступ к документации, выбирая "<idx/API/-Documentation" из меню помощи
или соответствующую книгу в дереве документации, папка "Current Project".

Документация уже содержит ссылки на KDE и <idx/Qt/ online-документацию классов, поэтому вы сможете проследить наследование
и легко обозреть иерархию. Это может вам также помочь в начале работы с документацией KDE и <idx/Qt/.

<sect>Добавление документации классов и их членов
<p>
KDevelop предоставляет как способы автоматического добавления кода, так и способы автоматического документирования. 
Когда вы используете генератор классов, выбирая "Project"->"New Class", добавьте краткое описание класса в поле документирования. Это вставит
его в заголовок класса.

При добавлении в класс функции-члена и атрибутов с помощью <idx/classtools/, добавьте краткое описание члена в поле документирования.

Вы можете подумать, что документация - это часть процесса разработки, которая не очень важна. Но помните, что большинство
проектов растут, и все больше и больше людей начинают принимать участие в их разработке. Поэтому документирование классов - хороший путь сэкономить время.
Даже если вы присвоили методам имена, точно описывающие их назначение, очень вероятно, что их не поймут или со временем изменятся функции метода.
Поэтому поддерживайте в порядке вашу документацию и обновляйте ее как можно чаще.

Несмотря на вышесказанное, файлы документации НЕ включаются в проект, и не интернационализируются. Поэтому
вся документация <idx/API/ должна быть написана на английском, чтобы позволить работать с ней международной команде.

Если вы хотите добавить документирование вручную в файл заголовка, добавьте его <bf/над/  методом или классом
в виде C-комментария с одним отличием - первая строка должна начинаться со слеша и двух звездочек.

Например:

<tscreen><verb>
  /** enables menuentries/toolbar items
  	*/
  void enableCommand(int id_);
</verb></tscreen>


<sect>Специальные таги
<p>
<bf/Внимание:/ последующий текст этой главы взят из документации <idx/KDoc/, поставляемой вместе с <idx/KDoc/ и написанной
Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">), автором <idx/KDoc/; Copyright (c) 1997

Документация состоит из:

<itemize>
<item>Обычного текста. Параграфы должны быть разделены минимум одной пустой строкой.

<item>Текста в форме
<code>
&lt;pre&gt;
.....фрагмент кода....
&lt;/pre&gt;
</code>
<item>Различных тагов в форме:
<tscreen><verb>
@имя_тага [параметры тага]
</verb></tscreen>
</itemize>


Доступные таги для каждого объекта кода следующие:

<itemize>
<item>Классы
<tscreen><verb>
  @short [одна фраза текста]
    Краткое описание класса
  @author [одна фраза текста]
    Автор класса
  @version [одна фраза текста]
    Версия класса (Я обычно устанавливаю это равным RCS/CVS "Id" тага)
  @see [одна или несколько ссылок на классы и методы] 	
    Ссылки на связанную документацию.
</verb></tscreen>

<item>Методы

<tscreen><verb>
  @see
    см. выше
  @return [одна фраза текста]
    Фраза, описывающая возвращаемое значение
  @param [идентификатор имени параметра] [описание параметра]
    Описывает параметр. Может содержать несколько строк и прерывается
    пустой строкой, окончанием комментария или другим тагом параметра.
    Поэтому обычно располагается в конце комментариев.
</verb></tscreen>

<item>Константы, множества, свойства
<tscreen><verb>
  @see
    см. выше
</verb></tscreen>
<item>ALSO <tt/@ref/
	Взято из формата документирования java. Метасимвол @ref имеет тот же формат, что и @see, но может встречаться в любом месте документации
(остальные описания должны располагаться на той же строке, что и таг).
</itemize>

<chapt>Интернационализация
<p>
<sect>Что такое i18n ?
<p>
i18n - это система интернационализации, которая используется для разработки интернациональных версий программы или проекта. Сложность
написания приложений состоит в том, что они поддерживают только один язык, заложенный в них при разработке; это проявляется в
надписях меток, входов меню и т.п. Цель интернационализации - предоставить приложения и библиотечные функции на языке
пользователя; это сделает их доступными пользователям, не владеющим языком оригинала, сделает их работу более комфортной.

<sect>Как KDE поддерживает интернационализацию
<p>
KDE, как современная рабочая среда, среди множества других целей ставит перед собой цель обеспечения пользователей приложениями
на их родном языке, и облегчения работы программистов в части реализации поддержки множества языков.

Технически это реализуется с помощью стандарта файловой системы KDE, который поддерживает локализацию документации
и предоставляет возможность интернационализации приложений, используя класс  <tt/KLocale/ библиотеки KDE-core.
Он реализует перевод в зависимости от того, какой язык установлен по умолчанию в Центре управления KDE (KDE Control Center).

Разработчик, с другой стороны, должен соблюдать только три правила, чтобы сделать свое приложение обладающим возможностью интернационализации:

<enum>
<item>включить <tt/<cdx/kapp.h// в исходный код везде, где есть видимый текст, т.е. в исходники, содержащие
объекты <idx/QLabel/,
<item>везде, где встречаются видимые строки, вставить их в макрос <tt/i18n()/, предоставляемый <tt/<cdx/kapp.h// для интернационализации,
<item>везде, где вы используете локализованный объект, использовать макрос <tt/klocale/, предоставляемый <tt/<cdx/kapp.h//.
</enum>

Это почти все, за чем вы должны следить при разработке кода. Имейте в виду, что вы не должны интернационализировать конфигурационные строки,
используемые <tt/<cdx/KConfig//, потому что это, с одной стороны, ненужно, а с другой стороны, не будет работать.

<sect>Добавление языка в проект
<p>
KDevelop также принимает участие в облегчении вашей жизни при добавлении поддержки нового языка в ваше приложение. 
Всегда при создании нового проекта KDE каталог <tt/po/ добавляется в корневой каталог проекта. В него будет помещен ваш файл <em/&lt;приложение&gt;/.pot 
после окончания генерации. pot файл содержит все строки, заключенные в макрос i18n().
Вы должны только написать свой код, используя этот макрос. Время от времени вы должны запускать "Project"-"Make messages and
merge", что автоматически извлечет все макросы из кода и сгенерирует pot файл.
<nidx/"Project"-menu/<nidx/PO-files/<nidx/translations/<ncdx/KLocale/

Для добавления языка в ваше приложение, выберите "Project"-"Add translation file", после чего откроется каталог выбора языка. Выберите
требуемый язык и нажмите OK. После этого соответствующий <em/&lt;lang&gt;/.po файл появится в каталоге <tt/po/. Запустите
перевод po файла, выбрав его в каталоге po, в Real File Viewer или из LFV, папка "Translations". Если вы
установили <idx/KTranslator/, он откроется в окне "Tools" с <idx/KTranslator/, иначе как текстовый файл в панели header/resource.
<idx/KTranslator/ облегчает перевод строк, сканируя уже существующие переводы вашей локальной инсталляции KDE, поэтому
уже существующий перевод может использоваться повторно.

Рассмотрим пример ручного редактирования:
<tscreen><verb>
#: kscribble.cpp:619
msgid "Opens an existing document"
msgstr ""
</verb></tscreen>

Это строка, взятая из файла <tt/kscribble.cpp/, строка кода номер 619. <tt/<cdx/msgid// и <tt/<cdx/msgstr// - это таги, которые
дают информацию для перевода; <tt/<cdx/msgstr// должен содержать переведенный текст. Вы можете увидеть эскейп-последовательности
типа \n или \t, которые должны быть включены в переведенную строку. Русский перевод будет выглядеть так:

<tscreen><verb>
#: kscribble.cpp:619
msgid "Opens an existing document"
msgstr "Открыть существующий документ"
</verb></tscreen>

Это все, что необходимо для перевода; когда это сделано, сохраните файл. Когда make будет просматривать каталог po, будет обработан файл сообщений
и могут возникнуть ошибки, если строки переведены неправильно, например, без учета эскейп-последовательностей. 
Если это произошло, отредактируйте строку сообщения снова и убедитесь, что make выполняется без ошибок.

Кроме того, вы должны быть очень аккуратны при переводе амперсантов в текстовых строках. Буква после амперсанта используется как
горячая клавиша в сочетании с клавишей ALT для переключения фокуса ввода клавиатуры на требуемый элемент. 
Если одинаковые буквы используются в одной области фокуса клавиатуры (например, главное окно или диалоговое окно),
все элементы, кроме первого, не будут доступны по горячей клавише. Поэтому переводчик также отвечает за возможность использования приложения.
Кроме того, нет никаких гарантий, что исходная буква встретится в переводе, поэтому переводчик должен быть очень осторожен и должен протестировать приложение на своем языке
после установки перевода, чтобы убедиться в отсутствии подобных неприятностей.

<sect>Связь с командой перевода
<p>
Команда KDE предоставляет многочисленные возможности контакта для разработчиков, выполняющих функции переводчиков.
Они организованы в группы по языку перевода, на уровне которых и координируется работа. Для получения списка групп и адресов, где можно узнать 
о переводе ваших приложений, см. <url url="http://www.kde.org">.

Информация, приводимая ниже, взята с web-сайта KDE и отражает состояние на 6 марта 1999 года. Если вы хотите присоединиться к команде перевода,
пишите непосредственно своему координатору.

Перевод KDE организован Juraj Bednar <htmlurl url="mailto:bednar@rak.isternet.sk"
name="mailto:bednar@rak.isternet.sk"> и Matthias Elter <htmlurl url="mailto:me@kde.org" name="me@kde.org">.

Вы можете подписаться на лист рассылки kde-i18n-doc@kde.org, послав письмо на <htmlurl
url="mailto:kde-i18n-doc-request@kde.org?subject=subscribe" name="kde-i18n-doc-request@kde.org"> 
со словом "subscribe" в теме письма.

Перед началом любой работы по переводу, пожалуйста, свяжитесь с координатором вашей группы, чтобы избежать двойной работы.

<descrip>


<tag/br Breton translation team:/
team coordinators: JaЯ-Mai DRAPIER <htmlurl url="mailto:jdrapier@club-internet.fr" name="jdrapier@club-internet.fr">
website: <htmlurl url="http://perso.club-internet.fr/jdrapier" name="http://perso.club-internet.fr/jdrapier">

<tag/ca Catalan translation team:/
team coordinators: SebastiЮ Pla <htmlurl url="mailto:sastia@redestb.es" name="sastia@redestb.es">

<tag/cs Czech translation team:/
team coordinators:  Miroslav FlМdr <htmlurl url="mailto:flidr@kky.zcu.cz" name="flidr@kky.zcu.cz">

<tag/da Danish translation team:/
team coordinators:  Erik KjФr Pedersen <htmlurl url="mailto:erik@binghamton.edu" name="erik@binghamton.edu">

<tag/de German translation team:/
team coordinators: Thomas Diehl <htmlurl url="mailto:th.diehl@gmx.net" name="th.diehl@gmx.net">
website: <url url="http://www.dtp-service.com/kde/de/">
mailing list:  send a mail with 'subscribe' in the subject line to: <htmlurl url="mailto:kde-i18n-de-request@kde.org?subject=subscribe"
name="kde-i18n-de-request@kde.org"> Webforum for discussions and user feedback: <url url="http://www.dtp-service.com/discus_d">

<tag/el Greek translation team:/
team coordinators:  Theodore J. Soldatos <htmlurl url="mailto:theodore@eexi.gr" name="theodore@eexi.gr">

<tag/eo Esperanto translation team:/
team coordinators:  Wolfram Diestel <htmlurl url="mailto:diestel@rzaix340.rz-uni-leipzig.de" name="diestel@rzaix340.rz-uni-leipzig.de">

<tag/es Spanish translation team:/
team coordinators:  Boris Wesslowski, Alonso Lara <htmlurl url="mailto:Boris@Wesslowski.com" name="Boris@Wesslowski.com">
website: <url url="http://members.xoom.com/keko5/">
mailing list: send a mail with 'subscribe' in the subject line to <htmlurl url="mailto:kde-es@kde.org?subject=subscribe"
name="kde-es@kde.org">

<tag/et Estonian translation team:/
team coordinators:  Hasso C. Tepper <htmlurl url="mailto:hasso@ewsound.estnet.ee" name="hasso@ewsound.estnet.ee">

<tag/fi Finnish translation team:/
team coordinators: Kim Enkovaara <htmlurl url="mailto:kim.enkovaara@iki.fi" name="kim.enkovaara@iki.fi">

<tag/fr French translation team:/
team coordinators:  Francois-Xavier Duranceau <htmlurl url="mailto:Francois-Xavier.Duranceau@loria.fr" name="Francois-Xavier.Duranceau@loria.fr">
website: <url url="http://www.loria.fr/~durancea/kde/wip-apps.html">
mailing list: send an empty mail to:  <htmlurl url="mailto:kde-traduc-fr-subscribe@egroups.com" name="kde-traduc-fr-subscribe@egroups.com">

<tag/he Hebrew translation team:/
team coordinators:  Erez Nir <htmlurl url="mailto:erez-n@actcom.co.il" name="erez-n@actcom.co.il">

<tag/hr Croatian translation team:/
team coordinators:  Vladimir Vuksan <htmlurl url="mailto:vuksan@veus.hr" name="vuksan@veus.hr">

<tag/hu Hungarian translation team:/
team coordinators:  Marcell Lengyel <htmlurl url="mailto:miketkf@yahoo.com" name="miketkf@yahoo.com">
website:<url url="http://sophia.jpte.hu/~kde">

<tag/is Icelandic translation team:/
team coordinators:
Logi Ragnarsson, <htmlurl url="mailto:logir@imf.au.dk" name="logir@imf.au.dk">
Thorarinn R. Einarsson, <htmlurl url="mailto:thori@mindspring.com" name="thori@mindspring.com">
Bjarni R. Einarsson, <htmlurl url="mailto:bre@netverjar.is" name="bre@netverjar.is">
Hrafnkell Eiriksson, <htmlurl url="mailto:hkelle@rhi.hi.is" name="hkelle@rhi.hi.is">
Gudmundur Erlingsson, <htmlurl url="mailto:gudmuner@lexis.hi.is" name="gudmuner@lexis.hi.is">
Richard Allen <htmlurl url="mailto:ra@hp.is" name="ra@hp.is">

<tag/it Italian translation team:/
team coordinators:  Andrea Rizzi <htmlurl url="mailto:rizzi@kde.org" name="rizzi@kde.org">

<tag/ko Korean translation team:/
team coordinators:  LinuxKorea Co. <htmlurl url="mailto:kde@linuxkorea.co.kr" name="kde@linuxkorea.co.kr">

<tag/mk Macedonian translation team:/
team coordinators:  Sasha Konecni <htmlurl url="mailto:sasha@msi-uk.com" name="sasha@msi-uk.com">

<tag/nl Dutch translation team:/
team coordinators:  flidr@CyberGate.zcu.cz <htmlurl url="mailto:flidr@CyberGate.zcu.cz" name="flidr@CyberGate.zcu.cz">

<tag/no Norwegian translation team:/
team coordinators:  Hans Petter Bieker <htmlurl url="mailto:zerium@webindex.no" name="zerium@webindex.no">

<tag/pl Polish translation team:/
team coordinators:  Piotr Roszatycki <htmlurl url="mailto:dexter@fnet.pl" name="dexter@fnet.pl">

<tag/pt Portuguese translation team:/
team coordinators:  Pedro Morais <htmlurl url="mailto:pmmm@camoes.rnl.ist.utl.pt" name="pmmm@camoes.rnl.ist.utl.pt">

<tag/pt_BR Brazil Portuguese translation team:/
team coordinators:  Elvis PfЭtzenreuter <htmlurl url="mailto:epx@netville.com.br" name="epx@netville.com.br">

<tag/ro Romanian translation team:/
team coordinators:  Paul Ionescu <htmlurl url="mailto:ipaul@romsys.ro" name="ipaul@romsys.ro">

<tag/ru Russian translation team:/
team coordinators:  Denis Y. Pershin <htmlurl url="mailto:dyp@inetlab.com" name="dyp@inetlab.com">

<tag/sk Slovak translation team:/
team coordinators:  Juraj Bednar <htmlurl url="mailto:bednar@isternet.sk" name="bednar@isternet.sk">
mailling list:  send a mail with 'subscribe' in the subject line to: <htmlurl url="mailto:sk-i18n@rak.isternet.sk?subject=subscribe"
name="sk-i18n@rak.isternet.sk">

<tag/sl Slovenian translation team:/
team coordinators:  blazzupancic@hotmail.com <htmlurl url="mailto:blazzupancic@hotmail.com" name="blazzupancic@hotmail.com">

<tag/sv Swedish translation team:/
 team coordinators:  Anders Widell <htmlurl url="mailto:d95-awi@nada.kth.se" name="d95-awi@nada.kth.se">

<tag/tr Turkish translation team:/
team coordinators:  Gorkem Cetin <htmlurl url="mailto:gorkem@linux.org.tr" name="gorkem@linux.org.tr">

<tag/zh_GB2312 Simplified Chinese translation team:/
team coordinators:  Wang Jian <htmlurl url="mailto:larkw@263.net" name="larkw@263.net">

<tag/zh_TW_Big5 Chinese BIG5 translation team:/
team coordinators:  Chou Yeh-Jyi <htmlurl url="mailto:ycchou@ccca.nctu.edu.tw" name="ycchou@ccca.nctu.edu.tw">
</descrip>



<chapt>Поиск ошибок
<p><nidx/debugging macros/
<sect>Отладочные макросы, предоставляемые <idx/Qt/
<p>
Отладочные макросы, предоставляемые  библиотекой <idx/Qt/, описаны на странице debug.html online-документации <idx/Qt/, 
доступной по линку "Debugging Techniques" на странице с индексом <idx/Qt/-документации.

Наиболее часто используемые макросы:

<itemize>
<item>ASSERT(b)
<item>CHECK_PTR(p)
</itemize>

b - выражение типа boolean. Генерирует предупреждающее сообщение дебаггера, если равно false; p - указатель, который проверяется, если
он равен нулю, то генерируется предупреждающее сообщение.

Подробности см. в online-документации <idx/Qt/.

<sect>Макросы KDE
<p>
<bf/Внимание:/ Эта глава - копия документа о макросе <idx/KDEBUG/, включенного в набор библиотек KDE и
написанного Kalle Dalheimer's <htmlurl url="mailto:kalle@kde.org" name="kalle@kde.org">. Документ
находится в файле kdebug.html.

Последнее изменение: Sat Sep 13 11:56:01 CEST 1997


<bf/Что такое KDebug/

KDebug - набор макросов и функций, делающий более эффективным использование диагностических сообщений. Вы можете получать сообщения
одного из четырех уровней строгости. Вы можете выбрать в процессе выполнения, куда должны выводиться диагностические сообщения, и какие из них
вообще должны выводиться.

<bf/Макрос <idx/KDEBUG//

Использование KDebug очень простое. Все, что вы должны сделать, это включить #include &lt;kdebug.h&gt; 
в начало каждого исходного файла, в котором вы хотите использовать диагностические сообщения, и выводить эти сообщения, 
вызывая макрос <idx/KDEBUG/. Он ожидает 3 параметра. Первый - уровень безопасности; используйте следующие константы:

<itemize>
<item><idx/KDEBUG_INFO/
<item><idx/KDEBUG_WARN/
<item><idx/KDEBUG_ERROR/
<item><idx/KDEBUG_FATAL/
</itemize>

Второй параметр - это область. Область - часть KDE, которую вы определяете сами. Потом, в процессе выполнения, вы сможете выбрать, от какой
области необходимо печатать диагностические сообщения. См. файл kdelibs/kdecore/kdebugareas.txt для получения списка уже назначенных диапазонов областей.
Выберите область в диапазоне вашего приложения. Если ваше приложение еще не включено в этот список, и вы имеете доступ к CVS, вы можете
назначить там область для своего приложения, иначе напишите мне. Вероятно, будет хорошей идеей определить символическую константу для
области, которую вы хотите использовать, но это решаете вы. 

Третий параметр, наконец, это текст, который вы хотите вывести. KDebug
автоматически добавит логическое имя приложения, если вы производите вывод в файл, в stderr или в syslog. Всегда добавляется символ новой строки, 
вы не должны его использовать сами. Если вам нужны параметры, вы можете использовать один из макросов KDEBUG1, ..., KDEBUG9. Это позволит
иметь от 1 до 9 дополнительных параметров. Синтаксис вывода абсолютно аналогичен printf, например, вы можете включать спецификации формата в ваше
сообщение, которые заменяются дополнительными параметрами. Например:

<tscreen><code>
KDEBUG3( <idx/KDEBUG_INFO/, kmail_composer, "Message no. %d to %s has %d bytes",
          message_no, aMessage.to(), aMessage.length() );
</code></tscreen>


<bf/<idx/KASSERT//

Есть также макросы KASSERT, KASSERT1, ..., KASSERT9, которые работают так же, как их <idx/KDEBUG/-аналоги, однако они имеют
дополнительный первый параметр булевского типа. Только если он обращается в ложь, сообщение будет распечатано. 

Примечание 1: вы не должны использовать ни <idx/KDEBUG/, ни <idx/KASSERT/ до создания объекта <cdx/KApplication/.
 
Примечание 2: KDebug не предоставляет никаких возможностей интернационализации, поскольку он предназначен только для разработчиков.
Если вы хотите информировать пользователя о нештатной ситуации (например, "этот файл защищен от записи"), используйте 
KMsgBox.

<bf/Опции компилятора/

Вы не должны задавать никаких специальных ключей для компилятора при использовании KDebug. 
Но когда вы распространяете свое приложение (в основном это касается людей, которые создают .rpm или .deb пакеты), вы должны компилировать с ключом
-DNDEBUG. Это просто удалит код дебаггера из вашего приложения и сделает его меньше и быстрее (например, оно будет использовать на 256K меньше
памяти).


<bf/Как анализировать диагностические сообщения в процессе выполнения/

Вы можете нажать Ctrl-Shift-F12 в любом приложении KDE в любое время, и появится диалог "Debug Settings". В нем вы сможете определить
раздельно для каждого уровня строгости, что должно быть сделано с диагностическими сообщениями этого уровня. Возможны следующие настройки:

<itemize>
<item>Output: в этом списке вы можете выбрать, куда будут выводиться диагностические сообщения; доступен выбор "File", "Message Box", "Shell" (имеется в виду stderr)
и "syslog". Не направляйте фатальные сообщения в syslog, если вы не системный администратор.
По умолчанию используется "Message Box".
<item>File: это поле используется, если вы решили выводить сообщения в файл; здесь указывается имя файла (интерпретируется относительно текущего каталога).
По умолчанию kdebug.dbg.

<item>Area: определяет области, для которых осуществляется вывод. Все сообщения, не упомянутые в них, не будут выведены
(если только это поле не оставлено пустым, что используется по умолчанию и значит вывод всех сообщений). Вы можете ввести несколько областей,
разделенных ",", и вы можете назначить диапазоны областей с синтаксисом "начало-конец". Например, 117,214-289,356-359,221. Не используйте пробелы.
</itemize>

Кроме того, вы можете выбрать опцию "Прерывать на фатальных ошибках" ("Abort on fatal errors"). В этом случае при возникновении диагностического сообщения с уровнем
"<idx/KDEBUG_FATAL/" приложение завершит работу с кодом SIGABRT после вывода этого сообщения. Когда вы закроете диалог кнопкой OK, ваши
настройки вступят в силу немедленно и сохранятся в конфигурационном файле вашего приложения. Имейте в виду, что эти установки специфичны
для каждого приложения! При нажатии cancel все изменения будут утеряны, и будут возвращены предыдущие установки.

<chapt>Стандарт файловой системы KDE
<p>
Эта глава - копия стандарта файловой системы KDE, опубликованного на web-сайте KDE <url url="http://www.kde.org">. Стандарт написан
Richard Moore <htmlurl url="rich@kde.org" name="rich@kde.org">

<bf/Стандарт файловой системы KDE/

Этот документ определяет структуру каталогов, которую должны использовать все программы KDE. Это версия 0.0.4 стандарта.

<sect>Введение
<p>
Цель <idx/KDE FSSTD/ - создать уверенность, что все ресурсы (иконки, mime-типы и т.п.), необходимые приложению KDE, расположены
в соответствующих директориях. Следование этой структуре позволит приложениям использовать такие инструменты, как класс KIconLoader, и
реализует отделение платформеннозависимых данных, необходимых KDE, от платформеннонезависимых данных (сделав возможной инсталляцию для различных
архитектур). В этом документе имена каталогов оканчиваются '/'. Когда употребляется слово 'appname', взятое в угловые скобки
&lt;вот так&gt;, то это значит, что на его месте могут быть входы, соответствующие любому установленному приложению KDE.
Слово 'lang' используется аналогично, чтобы показать, что здесь должны быть входы для всех поддерживаемых языков, состоящие из двух букв,
например, 'fr' для французского, 'ru' для русского.

<sect>Структура каталогов
<p>
Структура каталогов KDE показана ниже, корневой каталог инсталляции KDE обычно '/opt/kde', и может быть получен в процессе выполнения
вызовом метода kdedir() класса <cdx/KApplication/ (это заменяет переменную окружения KDEDIR, которую постепенно перестают использовать).
В данном документе этот каталог обозначается kdedir().
<nidx/KDE File System/<nidx/.kdelnk files/

<itemize>
<item>kdedir()/
  <itemize>
  <item>bin/
  	<itemize>
  	<item>Бинарные файлы приложений
  	</itemize>
  <item>lib/
  	<itemize>
  	<item>стандартные библиотеки KDE (libkdecore, например)
  	<item><em/&lt;appname&gt;//
  		<itemize>
  		<item>Платформеннозависимые данные приложения
  		</itemize>
  	</itemize>
  <item>include/
  	<itemize>
  	<item>Стандартные файлы заголовков KDE
  	</itemize>
  <item>parts/
  <item>cgi-bin/
  	<itemize>
  	<item>CGI программы для kdehelp
  	</itemize>
  <item>share/
  	<itemize>
  	<item>doc/
  		<itemize>
  		<item>HTML/
  			<itemize>
  			<item>default --> ссылка на kdedir()/share/doc/HTML/en
  			<item><em/&lt;lang&gt;//
  				<itemize>
  				<item><em/&lt;appname&gt;//
  					<itemize>
  					<item>index.html
  					<item>Другие файлы помощи
  					</itemize>
  				</itemize>
  			</itemize>
  		</itemize>
  	<item>config/
  	<item>applnk/
  		<itemize>
  		<item>System/
  		<item>Utilities/
  		<item>Applications/
  		<item>Games/
  		<item>kfind<idx/.kdelnk/
  		<item>khelp<idx/.kdelnk/
  		<item>khome<idx/.kdelnk/
  		<item>krefresh<idx/.kdelnk/
  		</itemize>
  	<item>mimelnk/
  		<itemize>
  		<item>magic
  		<item>text/
  		<item>audio/
  		</itemize>
  	<item>partlnk/
  		<itemize>
  		<item><em/&lt;partname&gt;/<idx/.kdelnk/
  		</itemize>
  	<item>icons/
  		<itemize>
  		<item>Иконки, используемые в kdelnk файлах
  		<item><em/&lt;appname&gt;/.xpm
  		<item>mini/
  			<itemize>
  			<item>Мини-иконки для kpanel
  			</itemize>
  		</itemize>
  	<item><idx/toolbar//
  		<itemize>
  		<item>Стандартные иконки панели инструментов (например, fileopen.xpm)
  		</itemize>
  	<item>wallpapers/
  		<itemize>
  		<item>Обои, используемые kdisplay
  		</itemize>
  	<item>apps/
  		<itemize>
  		<item><em/&lt;appname&gt;//
  			<itemize>
  			<item><idx/toolbar//
  				<itemize>
  				<item>Иконки панели инструментов
  				</itemize>
  			<item>pics/
  				<itemize>
  				<item>Другие рисунки приложения
  				</itemize>
  			<item>Платформеннонезависимые данные приложения
  			</itemize>				
  		<item><em/&lt;libname&gt;//
  			<itemize>
  			<item>pics/
  			</itemize>
  		</itemize>
  	<item>locale/
  		<itemize>
  		<item><em/&lt;lang&gt;//
  			<itemize>
  			<item>LC_MESSAGES/
  				<itemize>
  				<item><em/&lt;appname&gt;/.mo
  				</itemize>
  			</itemize>
  		</itemize>
  	</itemize>
  </itemize>
</itemize>
					
<sect>Что это значит для разработчика?
<p>
Стандартное приложение KDE инсталлирует файлы в различные места вышеприведенной структуры. Безусловно необходимые файлы - исполнимые файлы приложения,
файл kdelnk, иконка приложения и файлы помощи - все остальные не обязательны. Файлы инсталлируются в следующие каталоги:

<tscreen><verb>
Тип файла	                                  Расположение

Бинарные файлы приложения (необходимо             kdedir()/bin/
Файл kdelnk приложения (необходимо)               kdedir()/share/applnk/
Иконка приложения (необходимо)                    kdedir()/share/icons/&lt;appname&gt;.xpm
Файлы помощи приложения (необходимо)              kdedir()/share/doc/default/HTML/&lt;appname&gt;/&lt;index&gt;.html
Иконки панели инструментов приложения             kdedir()/share/apps/&lt;appname&gt;/toolbar/
Платформеннонезависимые данные приложения         kdedir()/share/apps/&lt;appname&gt;/
Платформеннозависимые данные приложения           kdedir()/lib/&lt;appname&gt;/
</verb></tscreen>
<nidx/KDE File System/

<sect>Документация приложения
<p>
Я советую поместить хотя бы одну страницу в

kdedir()/doc/default/HTML/&lt;appname&gt;/&lt;appname&gt;.html

для соответствия стандартам KDE. Приложение может использовать каталог для хранения в нем любых необходимых файлов помощи. 

Приложения, поддерживающие несколько языков, должны поместить файлы на этих языках в 
kdedir()/doc/&lt;lang&gt;/HTML/&lt;appname&gt;/&lt;appname&gt;.html,
создавая один 'lang' каталог для каждого языка, используя его двухбуквенный код, как обычно. Такое расположение файлов позволит создать ссылки
между файлами помощи двух различных приложений, поддерживающих данный язык. 

Я не совсем удовлетворен предлагаемым решением, поскольку оно не позволяет вернуться к языку по умолчанию, если требуемый перевод отсутствует.

<sect>Что это значит для разработчиков библиотек?
<p>

<itemize>
<item>kdedir()/share/apps/&lt;libname&gt;/<idx/toolbar/
</itemize>
Иконки панели инструментов для элементов библиотеки.

<itemize>
<item>kdedir()/share/apps/&lt;libname&gt;/pics
</itemize>
Другие картинки (bitmaps) для элементов библиотеки.

<chapt>Использование файловой системы в проектах KDevelop
<p>
Предыдущая глава описывала стандарт файловой системы KDE, эта глава описывает, как использовать файловую систему. Проект KDE
использует файловую систему по крайней мере при инсталляции; поэтому мы обсудим правила установки инсталляционных свойств 
файлов вашего проекта. Поскольку ваше приложение будет использовать все установленные файлы, ему важно знать, как получить к ним
стандартные относительные пути. Это позволит вашему приложению работать независимо от того, где располагается корневой каталог файловой системы KDE, и, таким образом,
избежать жесткого задания путей файлов.

<sect>Доступ к файлам в процессе выполнения
<p>
После инсталляции вашего проекта конечным пользователем, вашему приложению может потребоваться файл в процессе выполнения. В ходе
разработки вы наверняка натыкались на одну ошибку при запуске приложения из IDE KDevelop - при вызове
помощи через "Help"-"Contents" или нажатием F1. В результате вам выдавалось сообщение, что
файл index.html не найден - если вы не установили перед этим приложение в локальной файловой системе KDE. Ваше приложение запрашивает
<idx/KDEHelp/, чтобы он открыл индексную страницу, предварительно определяя каталог инсталляции методами <tt/<cdx/KApplication//, осуществляющими доступ
к файловой системе; поэтому рассмотрим, что предлагает <tt/<cdx/KApplication//, и приведем несколько примеров использования. Другие классы
<tt/KDE-Core/ также используют файловую систему KDE, например, <tt/KIconLoader/ и <tt/KLocale/, которые будут рассмотрены позже.

<sect>Методы <cdx/KApplication/ 
<p>

Класс <cdx/KApplication/ предоставляет следующие методы доступа к файловой системе KDE:
<tscreen><verb>
void invokeHTMLHelp ( QString aFilename, QString aTopic ) const
static const QString& kde_htmldir ()
static const QString& kde_appsdir ()
static const QString& kde_icondir ()
static const QString& kde_datadir ()
static const QString& kde_localedir ()
static const QString& kde_cgidir ()
static const QString& kde_sounddir ()
static const QString& kde_toolbardir ()
static const QString& kde_wallpaperdir ()
static const QString& kde_bindir ()
static const QString& kde_configdir ()
static const QString& kde_mimedir ()
static QString localkdedir ()
static QString localconfigdir ()
static QString findFile ( const char *file )
</verb></tscreen>
<nidx/KDE File System/

Методы обычно используются с объектом <tt/<cdx/KApplication// вашего приложения, где <tt/<cdx/KApplication// предоставляет макрос 
<tt/kapp/, возвращающий указатель на него:

#define kapp <cdx/KApplication/::getKApplication()

Поэтому обычно методы используются так:
<tscreen><verb>
QString sounddir=kapp->kde_sounddir();
</verb></tscreen>
В этом примере путь к каталогу KDE с звуковыми файлами заносится в <tt/QString/, к которому вы должны добавить, например, имя файла.
Затем вы можете обработать эту информацию и проиграть файл. Всегда проверяйте существование файла, используя
метод <tt/exists()/ объекта <tt/QFileInfo/.

Среди этих методов,
<tscreen><verb>
void invokeHTMLHelp( QString aFilename, QString aTopic ) const [public]
</verb></tscreen>
занимает специальное положение; он запускает помощь KDE. Вы должны использовать его везде, где пользователю требуется доступ к информации, например, когда
открыт модальный диалог. Клавиша F1 не будет работать для вызова помощи в этой ситуации, хотя пользователь должен быть обеспечен соответствующей
страницей помощи. Чтобы обеспечить ее использование, добавьте кнопку "Help" в ваш диалог и создайте слот, к которому подсоедините кнопку по сигналу 
<tt/pressed()/. В этом слоте используйте <tt/<cdx/invokeHTMLHelp()// со ссылкой на соответствующую страницу и раздел; в случае, если
документация еще не написана, оставьте вопрос открытым, чтобы решить его при синхронизации документации с приложением.

В документации по <tt/<cdx/KApplication// говорится:

Вызов просмотрщика HTML файлов помощи KDE.

Параметры: aTopic - 
Это позволяет реализовать контекстно-зависимую помощь. Его значение добавляется к имени файла после хеш-символа "#".

aFilename - Имя файла, который будет загружен. Его расположение определяется автоматически в соответствии с KFSSTND. Если aFilename пусто,
используется логическое имя приложения с добавленным к нему расширением .html.


Методы  <tt/<cdx/KApplication// возвращают следующие пути:

<tscreen><verb>
kde_htmldir()         kdedir()/share/doc/HTML         Возвращает каталог, в котором KDE хранит
                                                      свои файлы HTML документации

kde_appsdir()         kdedir()/share/applnk           Возвращает каталог, в котором приложения 
						      KDE хранят файл .kdelnk

kde_icondir()         kdedir()/share/icons            Возвращает каталог иконок KDE

kde_datadir()         kdedir()/share/apps             Возвращает каталог, в котором приложения
                                                      KDE хранят свои специальные данные

kde_localedir()       kdedir()/share/locale           Возвращает каталог, в котором хранятся файлы с информацией
                                                      о локализации (например, перевод экранных сообщений) 

kde_cgidir()          kdedir()/cgi-bin                Возвращает каталог с cgi-скриптами

kde_sounddir()        kdedir()/share/sounds           Возвращает каталог со звуковыми файлами.
                                                      Это каталог специальных звуков KDE.
                                                      Звуки приложения хранятся в
                                                      kde_datadir()

kde_toolbardir()      kdedir()/share/toolbar          Возвращает каталог с иконками кнопок панели инструментов

kde_wallpaperdir()    kdedir()/share/wallpapers       Возвращает каталог с обоями

kde_bindir()          kdedir()/bin                    Возвращает каталог с бинарными файлами приложений KDE

kde_configdir()       kdedir()/share/config           Возвращает каталог с конфигурационными файлами

kde_mimedir()         kdedir()/share/mimelnk          Возвращает каталог с информацией о mime-типах

localkdedir()         $HOME/.kde                      Возвращает локальный корневой каталог KDE (KDE base dir)

localconfigdir()      $HOME/.kde/share/config         Возвращает локальный каталог KDE с конфигурационными файлами
</verb></tscreen>

Для поиска определенного файла, используйте <tt/findFile(const char *file)/, который просматривает следующие пути файловой системы KDE:

<enum>
<item>$KDEDIR,
<item>$KDEPATH,
<item>"&lsqb;KDE Setup&rsqb;:Path=" вход в конфигурационном файле.
</enum>

Если файл не найден, метод QString isEmpty() возвращает True

<sect>Методы KIconLoader 
<p>

QPixmap loadIcon ( const QString &amp;name, int w = 0, int h = 0 )

QPixmap reloadIcon ( const QString &amp;name, int w = 0, int h = 0)

QPixmap loadMiniIcon ( const QString &amp;name , int w = 0, int h = 0 )

QPixmap loadApplicationIcon ( const QString &amp;name, int w = 0, int h = 0 )

QPixmap loadApplicationMiniIcon ( const QString &amp;name, int w = 0, int h = 0 )

bool insertDirectory ( int index, const QString &amp;dir_name )


<sect>Установка инсталляционных свойств файлов
<p>
Выше было объяснено, где приложение KDE должно располагать свои файлы и как получить к ним доступ при выполнении. Теперь объясним,
как правильно установить свойства файлов, чтобы они записались в нужные места при инсталляции. Файлы Makefiles поддерживают набор макросов
для инсталляции ваших файлов в файловую систему KDE, которые должны быть использованы при установке значений инсталляционных свойств файлов.

Для установки свойств откройте проект и выберите "Project"-"File Properties", что откроет диалог свойств файла.
Свойства файла отображаются, если вы выберите файл, включенный в проект. Во-первых, файл имеет свойство "тип" ("type"),
которое может принимать такие значения:

<itemize>
<item><bf/HEADER:/ файл заголовка
<item><bf/SOURCE:/ файл исходника
<item><bf/SCRIPT:/ файл сценария (script-файл)
<item><bf/DATA:/ файл данных, обычно картинка или файл документации HTML
<item><bf/PO:/ файл перевода
<item><bf/KDEV_DIALOG:/ файл диалога, обрабатываемый библиотекой диалогов
</itemize>

Далее, файл включен в проект, если выбрана опция "Include in Distribution". Ее установка приведет к включению файла в дистрибутив приложения.

Если файл должен быть инсталлирован, вы должны разрешить опцию "Install". Это сделает доступным свойство Installation path (путь инсталляции) для выбранного файла,
куда уже вставлено имя файла.

Как уже говорилось, Makefile содержит набор макросов для путей файловой системы KDE. Они используются для установки
путей инсталляции, и дают гарантию, что файл будет действительно записан в соответствующее место файловой системы, а не куда-нибудь еще. Используемые макросы
должны быть взяты в круглые скобки и отмечены символом доллара перед макросом. Когда configure создает файлы Makefile
на машине конечного пользователя, то определяются значения этих макросов, соответствующие реальному каталогу, и в файлы Makefile.am 
заносится действительная информация о путях.

Если посмотреть на стандартный проект KDE, то можно увидеть, что свойство файла <tt/index.html/ уже использует макрос
для определения пути:

$(kde_htmldir)/en/kscribble/index.html

Это значит, что make запишет файл index.html в kde-html каталог, подкаталог en для английского языка, подкаталог приложения в файл с именем index.html.
Вы можете использовать другое имя файла, если вы хотите переименовать файл при инсталляции.

Для определения положения файлов приложения в структуре kpanel вы должны отредактировать файл проекта Makefile.am, если место назначения отличается от
секции "Приложения" ("Applications") kpanel:

APPSDIR = $(kde_appsdir)/Applications

Возможные значения (как говорит стандарт файловой системы KDE):

<itemize>
<item>Applications
<item>Games
<item>Graphics
<item>Internet
<item>Multimedia
<item>Settings
<item>System
<item>Utilities
</itemize>

Установка пустого пути добавит линк вашего приложения непосредственно в корень kpanel.

Следующий список содержит макросы, которые могут использоваться для указания путей файлов:

<tscreen><verb>
kde_htmldir       - для документации (содержит подкаталоги для языков),
kde_appsdir       - для файла (.kdelnk), 
kde_icondir       - для иконок,
kde_minidir       - для мини-иконок,
kde_datadir       - для данных приложения (используйте подкаталог),
kde_locale        - для файлов перевода (содержит подкаталоги для языков),
kde_cgidir        - для cgi-bin исполнимых файлов,
kde_confdir       - для конфигурационных файлов,
kde_mimedir       - для mime-типов,
kde_toolbardir    - для общих иконок панелей инструментов,
kde_wallpaperdir  - для общих обоев.
</verb></tscreen>

Используйте эти макросы с необходимыми подкаталогами и именами файлов для установки инсталляционных свойств.
По умолчанию, текущая версия HTML документации, файл kdelnk, иконка и мини-иконка, файлы перевода (даже новые)
уже имеют установленными пути инсталляции; поэтому вы не должны вносить никаких изменений в конфигурацию по умолчанию
шаблона, сгенерированного KDevelop.

<sect>Организация данных проекта
<p>
Другая проблема, с которой часто сталкиваются разработчики, это когда они включают в свой проект дополнительные файлы с данными,
которые необходимо инсталлировать вместе с проектом. Вы уже знаете, куда их инсталлировать, но как организовать их в исходном дереве?

Хорошим советом будет собрать данные в каталоги, которые более-менее соответствуют стандарту файловой системы KDE, например,
ваше приложение требует дополнительных иконок панели инструментов. Создание этих иконок в главном каталоге проекта - не очень хорошая идея,
поскольку их будет тяжело найти в просмотрщике файлов, и их удаление превращается в долгую работу с каждой иконкой. Создайте свой каталог для иконок
с помощью "File"- "New" и выберите подкаталог <tt/<idx/toolbar//; если он не существует, то его можно легко создать через диалог "выбор каталога" ("select directory").
Существующие иконки можно скопировать и добавить в проект командой "добавить существующие файлы" ("Project"-"Add existing file(s)"), в которой необходимо выбрать
файлы и каталог назначения. При выборе каталога назначения, вы можете вначале создать каталог <tt/<idx/toolbar// в диалоге.
По окончании нажмите OK, и файлы будут скопированы и включены в проект.

Как пример, иконки панели инструментов должны инсталлироваться в:

$(kde_datadir)/<em/&lt;appname&gt;//<idx/toolbar//<em/&lt;ваша_иконка&gt;/.xpm

Картинки и другие иконки, которые не используются на панелях инструментов, лучше положить в подкаталог <em/pics/ вместо <em/<idx/toolbar//.

<sect>Файл <tt/kdelnk/
<p>
Файл <em/&lt;appname&gt;/<idx/.kdelnk/, включенный в ваш проект, будет проинсталлирован в структуру меню kpanel.
Он полностью заполнен, и в общем случае не требует доработки. Но, несмотря на способности KDevelop помогать вам в разработке проекта,
он не может определить конечных целей вашего приложения, а эту информацию можно включить в 
файл kdelnk. Поскольку это текстовый файл, выберите его из RFV или LFV; он откроется в
окне Header/Resource.

Перед вами пример файла kdelnk:
<tscreen><verb>
# KDE Config File
&lsqb;KDE Desktop Entry&rsqb;
Type=Application
Exec=kscribble
Icon=kscribble.xpm
DocPath=kscribble/index.html
Comment=
Comment&lsqb;de&rsqb;=
Terminal=0
Name=kscribble
Name&lsqb;de&rsqb;=kscribble
</verb></tscreen>

Это уже содержит базовую конфигурацию нашего приложения (иконки, имя исполнимого файла, название приложения и т.п.).
Но секция комментариев Comment остается пустой. Сюда вы можете вставить всплывающую подсказку, которая будет отображаться, когда курсор
мыши будет находиться над иконкой файла на рабочем столе или в меню kpanel. Если scribble будет небольшой графической программой, то введите, например,

<tscreen><verb>
Comment=A simple drawing program
</verb></tscreen>

Каждая последующая строка комментариев содержит перевод этого описания на указанный в квадратных скобках язык. Попросите переводчиков
вставить правильный перевод на их родной язык или включите файл kdelnk, когда будете просить о переводе файла po приложения;
то же самое касается и названия приложения в строке Name файла. 
<footnote>Более подробную информацию о файле <idx/.kdelnk/, особенно о его использовании
при обработке командной строки, см.
<htmlurl url="kde_libref.html" name="The KDE Library Reference Guide"></footnote>

<chapt>Советы по программированию
<p>
В конце этой книги я хочу обратить внимание на некоторые моменты, о которых надо помнить при разработке. Это в основном
советы по программированию на C++, которые относятся к KDE и особенно Qt, и взяты в центре разработчиков KDE, который можно найти
в Internet по адресу <url url="http://www.kde.org">.

<descrip>
<tag/Имена файлов/ Во-первых, при создании исходников вы должны использовать только строчные буквы в именах файлов. KDevelop обеспечивает
это, если вы используете автоприсвоение имен. Это упрощает для других разработчиков запоминание того,
что в каком файле искать при отладке.

<tag/Имена классов/
Имена классов в приложении KDE должны:
<itemize>
<item>начинаться с префикса <bf/K/, затем следует имя, описывающее назначение класса (по вашему выбору). Например,
<tt/KMyWidget/ для специального элемента приложения,
<item>иметь членов, имена которых начинаются только со строчной буквы, а следующие слова в них начинаются с заглавной, например,
<tt/myWidgetPointer()/,
<item>называть методы, которые возвращают значения private-атрибутов, без использования префикса <tt/get/. Используйте содержательное имя
члена класса. Например, <tt/b_myboolean/ - private член. Метод, возвращающий текущее значение, может называться
<tt/myBoolean()/.
</itemize>

<tag/Обращение к файлам в коде/
Следует избегать жесткого задания путей, используя стандарт файловой системы KDE. Вы должны только определить путь к вашему приложению,
это можно сделать с помощью соответствующего макроса в файле <tt/Makefile.am/, как это было описано выше. В коде используйте методы
<tt/KApplication/ для получения действительных путей.

<tag/Документация классов/
Еще один пункт, который уже упоминался, - документация классов. Вы должны придерживаться правил форматирования <tt/KDoc/, поскольку их используют все разработчики KDE
для документирования классов. Добавьте хотя бы одну строку комментариев к каждому члену класса себе для напоминания
его предназначения и другим для повторного использования кода. Повторное использование кода с GPL имеет больше смысла, когда вы знаете, где найти
уже существующее решение по документированному классу. Qt-библиотека - хороший пример хорошо документированного интерфейса, хотя он не использует 
<tt/KDoc/.

<tag/Используйте <tt/new/ для создания элементов/
В реализации приложения предпочитайте создавать элементы в куче вызовом <tt/new/. Библиотеки Qt имеют хорошее свойство
автоматически удалять все дочерние элементы, созданные с помощью <tt/new/, поэтому вы не должны даже использовать <tt/delete/.
Это одно из важнейших технических преимуществ библиотеки Qt, и вы должны его широко использовать.

<tag/Отладка/
Когда дело доходит до отладки, используйте макрос <tt/KDebug/. Есть похожие макросы Qt, но он обеспечивает доступ с свойствам через клавиши
STRG+ALT+F12. См. <htmlurl url="../kde_libref/index-4.html#ss4.4" name="KDE Library Reference Guide"> 
для более подробной информации о фильтрации событий этим макросом. Вы также можете использовать <tt/assert()/, но поддерживайте соответствие
с кодом для отладки.

<tag/Объявления <tt/const//
Используйте объявление <tt/const/ для функций-членов, которые не меняют значений private-членов. Это можно использовать
для всех методов, возвращающих значения этих членов. Это позволяет избежать случайного изменения значения и отловить
логические ошибки на этапе компиляции. Что касается инициализации членов с декларацией const, вы должны это делать одновременно с использованием 
<tt/static/ в определении, и инициализировать значение вне конструктора:
<tscreen><verb>
class foo {
	static const int value;
};

const foo::value = 10;
</verb></tscreen>

ANSI C++ позволяет инициализировать член в конструкторе, но избегайте подобной техники, так как некоторые компиляторы не поддерживают данную возможность.

<tag/Виртуальные методы/
Как объяснялось в разделе <ref id="User Interaction" name="Взаимодействие с пользователем">, 
вы должны учитывать права доступа и декларацию <tt/virtual/ при перекрывании виртуальных методов. По крайней мере, вы не должны уменьшать доступ к виртуальному методу от protected
до private.

<tag/Предварительные объявления/
Заголовки классов должны быть включены там, где вы обращаетесь к объекту или экземпляру класса в вашем коде. Это значит, что если ваш класс
использует член другого класса, замените директиву #include предварительным описанием класса, например, вместо:

<tscreen><verb>
#include <qpushbutton.h>

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</verb></tscreen>

предпочтительнее только объявить класс <tt/QPushButton/ в файле заголовка:

<tscreen><verb>
class QPushButton;

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</verb></tscreen>

и поместить директиву include в соответствующий файл-исходник, где, например, экземпляр <tt/ok_button/ используется любым методом
класса <tt/QPushButton/. Это сохранит время компилятора, особенно если вы используете экземпляры классов, которые вы разрабатываете. 
Компилятор должен перекомпилировать все исходники, включающие заголовок, если вы делаете любое изменение в интерфейсе класса,
поэтому простое добавление метода, возвращающего целое значение внутреннего объекта, может привести к перекомпиляции всех исходников,
включающих файл заголовка данного класса.

<tag/Сообщения о неиспользуемых параметрах и значения по умолчанию/
Также вы должны удалить формальные параметры методов, которые не являются необходимыми. Это позволит избежать
предупреждения <tt/unused parameter/ от вашего компилятора, когда он увидит формальный параметр, который не используется
в реализации. Обычно вы посылаете несколько аргументов по умолчанию в некоторые методы. Их значения необходимо устанавливать в объявлении
члена класса, а не в его реализации.

<tag/Использование <tt/config.h//
Проекты KDevelop, как и любые другие проекты, использующие <tt/autoconf/ для создания скриптов <tt/configure/, создают файл
<tt/config.h/ после выполнения скрипта <tt/configure/ на пользовательской машине. В нем приводятся значения, найденные <tt/configure/,
которые могут быть использованы в исходниках. Директива для включения файла <tt/config.h/ следующая:

<tscreen><verb>
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
</verb></tscreen>

Один из наиболее часто используемых входов <tt/config.h/, вероятно, определение типа <tt/bool/ для компиляторов,
которые не совместимы с проектами последних версий ANSI C++.

<tag/Используйте <tt/0/ вместо <tt/NULL//
Предпочитайте использовать <tt/0/ непосредственно вместо <tt/NULL/ для установки значений, как это делают библиотеки KDE и Qt. 
Это повышает переносимость ваших приложений для компиляторов, которые имеют проблемы с использованием <tt/NULL/.

<tag/Временные данные/
Вы должны определять временные экземпляры всегда перед их использованием. Это лучший путь, чем прямое использование. Пример:
<tscreen><verb>
// Не следует
for( int i=0; i<n; i++){
  //что-то делаем
  };

// Следует
int i;

for(i=0; i<n; i++){
  //что-то делаем
  };
</verb></tscreen>

Это также касается вызовов функций:
<tscreen><verb>
// Не следует
setColor( &amp;(QColor(black)) );

// Следует
QColor color(black);
setColor( &amp;color );
</verb></tscreen>


</descrip>

<chapt>Лицензирование
<p>
В этой секции обсуждаются вопросы, связанные с лицензированием приложений, разработанных с использованием KDevelop IDE. Во-первых, мы
рассмотрим стандартное поведение, рассмотрим преимущества лицензирования вашего приложения в соответствии с GPL и, наконец, 
обсудим вопросы разработки коммерческих приложений.

<sect>Лицензия GPL
<p>
KDevelop IDE лицензирован в соответствии с GNU General Public License. Это значит, что любой пользователь может копировать, изменять и
распространять исходный код пакета KDevelop в соответствии с условиями данной лицензии. Эта лицензия защищает права команды разработчиков 
KDevelop как авторов данного продукта.

Исходя из этого, с целью помочь авторам при разработке свободно распространяемых программ, все сгенерированные KDevelop шаблоны
содержат ссылку на GPL, а также копию самой лицензии. Разработчики, с другой стороны, <em/могут/ использовать данную лицензию
как основу для распространения своей продукции, но ни в коем случае не принуждаются к этому.

Автор, лицензируя свой продукт на основе GPL, получает следующие возможности:

<itemize>
<item>вы можете использовать любой уже существующий код, лицензированный в соответствии с GPL, и включить его в ваш пакет (также не существует ограничений
на повторное использование кода, не входящего в противоречие с его лицензией),
<item>ваш код имеет copyright, что защищает ваши права как автора,
<item>повторное использование кода другими авторами улучшает общий процесс разработки свободных программ.
</itemize>

<sect>Лицензии KDE и Qt
<p>
Лицензирование Qt создавало много проблем разработчикам KDE, пока не вышла версия Qt 2.0, которая распространяется с новой QPL
лицензией. Компания Troll Tech, собственник и создатель Qt, поставляет Unix-версию библиотеки бесплатно, но с
ограничением, что вы не можете изменять поставляемый код и распространять его без их согласия.
По этой причине многие разработчики свободного программного обеспечения осуждают эту лицензию, поскольку она не абсолютно свободна, особенно для внесения изменений.
С другой стороны, библиотеки Qt предоставляют много возможностей, которые делают их очень привлекательными для коммерческих приложений:

<itemize>
<item>Покупая коммерческую лицензию, вы можете писать переносимые приложения для Unix и Windows платформ,
<item>Предлагаемые классы и шаблоны - хорошее решение для быстрой и простой разработки приложений,
<item>Вы можете вести разработку для Unix, не завися от лицензии GPL, если приобретаете коммерческую лицензию.
</itemize>

Проект KDE, в свою очередь, использует библиотеку Qt как базу для разработки оболочки для Unix систем, а также
предоставляет дополнительные возможности к предлагаемым Qt. Разработчики могут реализовать их, используя библиотеки, распространяемые как библиотеки KDE.

Библиотеки KDE распространяются в соответствии с LGPL, GNU Library General Public License. 

Что это значит для разработчиков приложений?

<sect1>Не коммерческая разработка
<p>
Для не коммерческой разработки, библиотеки Qt предоставляются бесплатно. Приложение может их использовать, не изменяя сами библиотеки;
разработчик должен также бесплатно предоставить исходный код приложения.

LGPL библиотек KDE позволяет использовать библиотеки KDE для не коммерческой разработки. Вы можете использовать библиотеки KDE
как вы того хотите, или как это необходимо вашему приложению.

<sect1>Коммерческая разработка
<p>
Для коммерческой разработки, компания Troll Tech предлагает купить коммерческую лицензию. Это позволит использовать библиотеки Qt
для разработки так, как это требуется вашему приложению. Вы можете распространять ваше приложение в любой форме, как в бинарной, 
так и с исходным кодом, независимо от лицензии GPL.

При использовании библиотек KDE, вы должны посмотреть лицензию LGPL, которая ясно разрешает коммерческую разработку с использованием библиотек,
распространяемых в соответствии с LGPL. Вы должны только изучить условия лицензии, чтобы знать ограничения, могущие возникнуть при использовании библиотек KDE
как базы для коммерческой разработки приложений, основанных на KDE.

<sect>Лицензия вашего продукта
<p>
Таким образом, команда KDevelop, как авторы интегрированной среды разработки KDevelop, позволяют вам распространять любое приложение,
созданное с использованием KDevelop IDE, в соответствии с выбранной вами лицензией; только с учетом ограничений лицензий, которые возникают 
при использовании кода библиотек. Это:

<itemize>
<item>Для приложений Qt: Ограничения лицензии Qt, которые влияют на статус вашего дистрибутива, который может быть
не коммерческим (free) продуктом, или коммерческим.
<item>Для приложений KDE: Ограничения лицензии Qt, определяющие статус вашего продукта, <em/плюс/ ограничения
LGPL (GNU Library General Public License), поставляемой с копиями используемых библиотек.
<item>для всех остальных исходных кодов вы можете выбирать лицензию.
</itemize>

Таким образом, вы можете изменить лицензию по умолчанию, включаемую в любое сгенерированное KDevelop приложение, или базовое приложение,
по вашему выбору, только выполняя ограничения лицензий связанных библиотек.

Если у вас есть другие вопросы, связанные с лицензированием, обращайтесь к команде разработчиков KDevelop.


<chapt>Ссылки
<p>
Руководство программиста KDevelop содержит информацию, полученную из различных источников в Internet и mail-листов,
таких как:

<bf/<idx/KDoc/ documentation:/ Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">

<bf/KDE Developer's Center/ maintained by Sirtaj S. Kang <htmlurl url="mailto:taj@.kde.org" name="taj@.kde.org">

<bf/KDE Internationalization:/ Matthias Elter <htmlurl url="mailto:me@kde.org" name="me@kde.org">

<bf/KDebug documentation:/ Kalle Dalheimer <htmlurl url="mailto:kalle@kde.org" name="kalle@kde.org">

<bf/The KDE File System Standard:/ Richard Moore <htmlurl url="mailto:rich@kde.org" name="rich@kde.org">

<bf/KDE-Developer's mini-HOWTO:/ David Sweet <htmlurl url="mailto:dsweet@chaos.umd.edu" name="<dsweet@chaos.umd.edu>">

Содержимое соответствующих глав сохраняет copyright его авторов.


<chapt>Copyright<label id="Copyright">
<p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>
</chapt>
<appendix>Дополнительная информация
<p>
<sect>Пример Makefile.am для динамической библиотеки
<p>
<tscreen><verb>
# Example Makefile.am for a shared library.  It makes a library
#  called "example" as libexample.so.2.1.2
# This Makefile.am was taken from the kdelibs distribution and modified
#  to serve as an example.
#
# David Sweet
#
INCLUDES=  $(all_includes)

lib_LTLIBRARIES  = libexample.la

# Note:  If you specify a:b:c as the version in the next line,
#  the library that is made has version (a-c).c.b.  In this
#  example, the version is 2.1.2.
libexample_la_LDFLAGS = -version-info 3:2:1 $(all_libraries)

include_HEADERS = header1.h header2.h\
                  header3.h

# Which headers shouldn't be installed when a   make install  is done?
noinst_HEADERS = version.h

libexample_la_SOURCES = code1.cpp code2.cpp
                        code3.cpp

#  USE_AUTOMOC is great.  This takes care of all of your  moc'ing
#   dependencies.
#  (You still need to include, for example, header1.moc in code1.cpp.)
libexample_la_METASOURCES = USE_AUTOMOC
</verb></tscreen>
</book>

