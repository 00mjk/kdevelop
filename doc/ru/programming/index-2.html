<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDevelop. Руководство программиста: KDE и Qt Библиотеки</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=koi8-r">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-3.html">Next</A>
 <A HREF="index-1.html">Previous</A>
 <A HREF="index.html#toc2">Table of Contents</A>
</P>
<H3><A NAME="s2">2. KDE и Qt Библиотеки</A></H3>

<P>Норвежская компания Troll Tech (
<A HREF="http://www.troll.no">http://www.troll.no</A>) предоставляет так называемый 
GUI инструментарий (toolkit), именуемый Qt. GUI означает "<B>Г</B>рафический <B>П</B>ользовательский <B>И</B>нтерфейс"
("<B>G</B>raphical <B>U</B>ser <B>I</B>nterface"), поэтому базирующиеся на Qt приложения представляются кнопками, окнами и т.п.
Такие приложения осуществляют взаимодействие с пользователем, представляя в визуальной форме выполняемые функции.
Этот инструментарий необходим для разработки графических приложений, которые используют
X-Window интерфейс в Unix системах, потому что X не содержит предопределенного пользовательского интерфейса.
И хотя другие наборы инструментов также позволяют создавать пользовательский интерфейс, Qt предоставляет некоторые технические возможности, которые делают разработку приложений
очень простой. Кроме того, 
Qt инструментарий также доступен для Microsoft Windows систем, что позволяет разработчикам
выпускать приложения для обеих платформ.
<P>Команда KDE (
<A HREF="http://www.kde.org">http://www.kde.org</A>) объединилась вместе с целью сделать Unix
системы более дружественными для пользователя, и решила использовать набор инструментов
Qt для разработки оконного менеджера для X-Window, плюс различных приложений,
включенных в дистрибутив KDE.
K Desktop Environment, таким образом, включает оконный менеджер <EM>kwm</EM>, 
менеджер файлов <EM>kfm</EM> и панель задач <EM>kpanel</EM> как главные компоненты, а также
массу первоклассных утилит и приложений. После выхода KDE множество
разработчиков обратили свои взоры к новой графической среде и к тому, что она предлагала.
Библиотеки KDE предоставляют все необходимые
методы и классы, которые делают процесс разработки приложений с их помощью однотипным и согласованным, и положение пользователя резко улучшается, так
как он теперь должен разбираться только в специфике использования данного приложения, а не обучаться общим использования очередного варианта пользовательского интерфейса.
Кроме того, KDE программы интегрируются в рабочую среду и предоставляют возможность взаимодействовать
с менеджером файлов, используя drag'n drop, предоставляют возможность управления сеансами (session management) и многое другое, 
если разработчик реализовал все возможности, предоставляемые библиотеками KDE.
<P>И Qt инструментарий, и библиотеки KDE реализованы с использованием языка программирования C++; 
поэтому большинство приложений, которые используют эти библиотеки, также написаны на C++.
В последующих главах мы бегло ознакомимся с библиотеками, чтобы увидеть, что
за инструмент нам предлагается и как вообще создаются Qt и KDE  приложения.
<P>
<H3><A NAME="ss2.1">2.1 Qt GUI инструментарий</A>
</H3>

<P>Как уже говорилось, Qt библиотека - это инструментарий, который предоставляет 
графические элементы, используемые для создания GUI приложений, и который необходим 
при разработке программ для X-Window. Кроме того, Qt предоставляет:
<P>
<UL>
<LI> Широкий набор классов и методов, пригодных для использования даже для программ без графического интерфейса,</LI>
<LI> Хорошее решение для реализации взаимодействия с пользователем посредством виртуальных методов и механизма сигнал/слот,</LI>
<LI> Набором предопределенных GUI-элементов, называемых "widgets", которые могут быть легко использованы для создания видимых элементов,</LI>
<LI> Дополнительные полностью предопределенные диалоговые окна, которые часто используются в приложениях, такие как окно прогресса и окно выбора файлов.</LI>
</UL>
<P>Знание Qt классов очень необходимо, даже если вы хотите разрабатывать только KDE-приложения. Чтобы получить первое представление
о том, как GUI-приложения конструируются и компилируются, мы рассмотрим простую, основанную исключительно на использовании Qt программу; 
затем мы расширим ее до KDE-приложения.
<P>
<H4>Первое Qt приложение</H4>

<P>Как правило, программа на C++ должна содержать функцию <CODE>main()</CODE>, которая является стартовой точкой для выполнения приложения. 
Так как мы хотим, чтобы наше приложение отображалось в графическом окне и предоставляло возможность взаимодействия с пользователем, первое, что мы должны знать, - как оно может показать себя
пользователю. Посмотрим, например, на первую программу, включенную в учебник, поставляемый как часть Qt Online Reference Documentation,
и объясним основные шаги выполнения. 
Итак, почему и как появляется окно приложения:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Это приложение просто рисует окно, содержащее кнопку с надписью "Hello world".  Как и для всех основанных на Qt приложений, вы первым делом
создаете экземпляр (instance) класса <CODE>QApplication</CODE>, представленный переменной <CODE>a</CODE>.
<P>Затем программа создает экземпляр класса <CODE>QPushButton</CODE>, называемый <CODE>hello</CODE>, это будет кнопка. 
Конструктор <CODE>hello</CODE> получает строку в качестве параметра, которая представляет собой содержимое элемента, отображаемое как текст на кнопке.
<P>Потом вызывается метод <CODE>resize()</CODE> кнопки <CODE>hello</CODE>. Это изменяет размер элемента по умолчанию (в данном случае
QPushButton), который при создании имел длину 100 пикселей и высоту 30 пикселей. Наконец, метод <CODE>setMainWidget()</CODE>
вызывается для объекта <CODE>a</CODE> и метод <CODE>show()</CODE> -  для объекта <CODE>hello</CODE>. <CODE>QApplication</CODE> выполняет вызов <CODE>a.exec()</CODE>,
входя в главный цикл событий (main event loop) и ожидая, когда он должен будет вернуть значение integer операционной системе, сигнализируя,
что приложение завершилось.
<P>
<H4>Справочная документация для Qt</H4>

<P>А сейчас мы кратко рассмотрим справочную документацию по Qt библиотеке. 
Для того, чтобы сделать это, запустите KDevelop и выберите "Qt-library" из
"Help"-меню на панели меню. Средство просмотра документации откроет и покажет вам стартовую страницу справочного руководства Qt. 
Это первое место, где необходимо искать информацию о Qt, его классах и доступных функциях. Кроме того, приведенная выше программа входит первой
в секцию "tutorials". Чтобы добраться к тем классам, которые мы хотим посмотреть,
<CODE>QApplication</CODE> и <CODE>QPushButton</CODE>, выберите 
"Alphabetical Class List" и найдите соответствующие имена. Следуйте по любому из линков, чтобы посмотреть документацию
по соответствующему классу.
<P>Для <CODE>QApplication</CODE> вы увидите конструктор и все другие методы, которые есть в данном классе.
Если вы нажмете на линк какого-либо метода, вы получите более детальную информацию об использовании этого метода,
которая бывает очень полезна, если вы не можете определить, как правильно использовать метод, или хотите увидеть пример.
Это также относится к документации по библиотекам KDE, которые используют похожую структуру; вот и почти все,
что вы должны знать о просмотре документации по классам с помощью браузера.
<P>
<H4>Интерпретация примера</H4>

<P>Просматривая <CODE>QApplication</CODE>, вы найдете все его методы, используемые в нашем примере:
<P>
<UL>
<LI>constructor <CODE>QApplication()</CODE>,</LI>
<LI><CODE>setMainWidget()</CODE> метод и</LI>
<LI><CODE>exec()</CODE> метод.</LI>
</UL>
<P>Пояснения, почему мы используем эти методы, очень простые:
<P>
<OL>
<LI>вначале создаем экземпляр класса <CODE>QApplication</CODE> с помощью вызова конструктора, после этого мы можем использовать GUI элементы, предоставляемые Qt,</LI>
<LI>создаем элемент, который будет наполнением окна нашей программы,</LI>
<LI>устанавливаем этот элемент как главный элемент для <CODE>a</CODE>,</LI>
<LI>выполняем экземпляр <CODE>a</CODE> класса <CODE>QApplication</CODE>.</LI>
</OL>
<P>Второй объект нашей программы - кнопка (pushbutton), экземпляр класса <CODE>QPushButton</CODE>. Из двух конструкторов, предоставляемых
для создания объекта, мы выбрали второй: он принимает в качестве аргумента текст, который будет отображаться как метка на кнопке; в данном случае это строка
"Hello world!". Затем мы вызвали метод <CODE>resize()</CODE> для изменения размеров кнопки в соответствии с размерами ее содержимого - кнопка должна быть больше, чтобы весь текст был видимым.
<P>А как насчет метода <CODE>show()</CODE>? Сейчас вы видите, что, как и большинство других элементов, <CODE>QPushButton</CODE> основывается на одиночном наследовании (single-inheritance).
Документация говорит, что <CODE>QPushButton</CODE> <EM>унаследована</EM> от <CODE>QButton</CODE>.
Перейдем по линку на описание класса <CODE>QButton</CODE>. Это откроет множество других методов,
которые унаследованы QPushButton, мы воспользуемся ими позже для объяснения механизма сигнал/слот. В любом случае, метод <CODE>show()</CODE>
не присутствует в списке, следовательно, это должен быть метод, передаваемый по наследству. Класс, от которого унаследован <CODE>QButton</CODE>,
<CODE>QWidget</CODE>. Перейдя опять по ссылке, вы увидите целую связку методов, которые реализованы в классе <CODE>QWidget</CODE>, включая
метод <CODE>show()</CODE>. Теперь мы можем понять, что было сделано в примере с кнопкой:
<P>
<OL>
<LI>создаем экземпляр <CODE>QPushButton</CODE>, используя второй конструктор для установки текста на кнопке,</LI>
<LI>изменяем размер элемента в соответствии с размером его содержимого (текста),</LI>
<LI>делаем элемент главным элементом экземпляра <CODE>QApplication</CODE> <CODE>a</CODE>,</LI>
<LI>говорим элементу показать себя на экране, вызывая его метод <CODE>show()</CODE>, унаследованный от <CODE>QWidget</CODE>.</LI>
</OL>
<P>После вызова метода <CODE>exec()</CODE> приложение становится видимым для пользователя, отображая окно с кнопкой "Hello world!".
Таким образом, GUI программа кое в чем отличается от процедурного приложения. Основное здесь в том, что приложение входит
в так называемый "главный цикл событий" ("main event loop"). Это означает, что Qt приложение должно войти в главный цикл событий, чтобы начать обработку событий, потом программа ждет от пользователя действия и затем реагирует на него. 
Следующий раздел коротко описывает,
что это значит для программиста и какие средства представляет Qt для обработки пользовательских событий.
<P>(Для уже опытных пользователей: Кнопка не имеет родителя, он не указан в конструкторе, поэтому она - единственный элемент верхнего уровня и 
работает в локальном цикле событий, и не нуждается во входе в глобальный цикл событий, см. документацию по классу <CODE>QWidget</CODE>  и 
"The KDE Library Reference Guide")
<P><B>Подведение итогов:</B>
<P>Приложения Qt всегда создают экземпляр класса <CODE>QApplication</CODE>. Это обеспечивает нам возможность создавать окна, которые
графически представляют программу пользователю и обеспечивают взаимодействие с ним. Содержимое окна называется Главный элемент ("Main Widget"). Это означает
что все графические элементы базируются на классе <CODE>QWidget</CODE>, и могут быть любыми элементами, удовлетворяющими нужды приложения
в части связи с пользователем. Поэтому все пользовательские элементы, которые необходимо сделать видимыми, должны быть унаследованы от <CODE>QWidget</CODE>.
<P>
<H4><A NAME="User Interaction"></A> Взаимодействие с пользователем</H4>

<P>После прочтения последнего раздела вы должны уже знать:
<UL>
<LI>что предоставляет библиотека Qt в терминах GUI приложения,</LI>
<LI>как создаются программы, использующие Qt и</LI>
<LI>где и как найти информацию о классах, которые вас интересуют, используя средство просмотра документации.</LI>
</UL>
<P>А сейчас мы вдохнем в приложение "жизнь", научив его обрабатывать пользовательские события. Обычно пользователь имеет два средства для взаимодействия с программой:
мышь и клавиатуру. В обеих случаях, графический пользовательский интерфейс должен иметь методы для регистрации действия и методы,
которые делают что-то, реагируя на это действие.
<P>Оконная система, таким образом, передает все сгенерированные пользователем события соответствующему приложению. QApplication затем передает их активному окну
как <CODE>QEvent</CODE> и элементы сами решают, что с ними делать. Элемент получает событие и выполняет
<CODE>QWidget::event(QEvent*)</CODE>, который решает, какое событие произошло и как реагировать; <CODE>event()</CODE>, следовательно,
является главным обработчиком событий. Затем функция <CODE>event()</CODE> проводит событие через так называемый фильтр событий, который определяет, что случилось и что делать
с событием. Если ни один фильтр не распознал событие, вызывается специальный обработчик событий.
Таким образом, мы должны различать:
<P><B>a) События клавиатуры -- клавиши TAB и  Shift-TAB :</B>
<P>изменяет фокус ввода с клавиатуры с текущего элемента на следующий элемент в порядке изменения фокусов. Фокус может быть установлен для элемента
вызовом <CODE>setFocusPolicy
<!--
setFocusPolicy()
-->
()</CODE>. Изменение фокуса обрабатывается следующими обработчиками событий: :
<P>
<UL>
<LI><CODE>virtual void focusInEvent
<!--
focusInEvent()
-->
 ( QFocusEvent * )</CODE></LI>
<LI><CODE>virtual void focusOutEvent
<!--
focusOutEvent()
-->
 ( QFocusEvent * )</CODE></LI>
</UL>
<P><B>b) другой ввод с клавиатуры:</B>
<UL>
<LI><CODE>virtual void keyPressEvent
<!--
keyPressEvent()
-->
 ( QKeyEvent * )</CODE></LI>
<LI><CODE>virtual void keyReleaseEvent
<!--
keyReleaseEvent()
-->
 ( QKeyEvent * )</CODE></LI>
</UL>
<P><B>c) перемещение мыши:</B>
<UL>
<LI><CODE>virtual void mouseMoveEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void enterEvent ( QEvent * )</CODE></LI>
<LI><CODE>virtual void leaveEvent ( QEvent * )</CODE></LI>
</UL>
<P><B>d) нажатие кнопок мыши:</B>
<UL>
<LI><CODE>virtual void mousePressEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void mouseReleaseEvent ( QMouseEvent * )</CODE></LI>
<LI><CODE>virtual void mouseDoubleClickEvent ( QMouseEvent * )</CODE></LI>
</UL>
<P><B>e) события окна, содержащего элемент:</B>
<UL>
<LI><CODE>virtual void moveEvent ( QMoveEvent * )</CODE></LI>
<LI><CODE>virtual void resizeEvent ( QResizeEvent * )</CODE></LI>
<LI><CODE>virtual void closeEvent ( QCloseEvent * )</CODE></LI>
</UL>
<P>Заметьте, что все функции событий virtual и protected; таким образом, вы можете переопределить события, которые вам нужны в ваших элементах,
и указать, как ваш элемент должен на них реагировать. <CODE>QWidget</CODE> также содержит несколько других виртуальных методов, которые могут быть полезны в ваших программах; 
это, в общем-то, все, что вам сейчас необходимо знать о <CODE>QWidget</CODE>.
<P>
<H4>Взаимодействие объектов с помощью сигналов и слотов</H4>

<P>Сейчас мы подошли к наиболее яркому преимуществу Qt инструментария: механизм сигнал/слот. Этот механизм предлагает очень удобное и полезное 
решение для реализации взаимодействия объектов, которое обычно выполняется с помощью <CODE>callback</CODE> функций для различных X-Window наборов элементов.
Реализация с помощью <CODE>callback</CODE> функций требует очень строгого программирования и иногда превращает задачу построения пользовательского интерфейса в очень сложную
(как об этом говорится в документации Qt и как это объяснено в книге K.Dalheimer <EM>Programming with Qt</EM>).
Troll Tech изобрела новую систему, в которой объекты могут испускать (emit) сигналы,
которые могут быть соединены (connected) с методами, объявленными как слоты (slot).
Для программиста на C++ необходимо знать несколько простых вещей об этом механизме:
<P>
<OL>
<LI>объявление класса, который использует сигналы/слоты, должно содержать макрос <CODE>Q_OBJECT</CODE> в начале (без ";");
и этот класс должен быть унаследован от <CODE>QObject</CODE>.</LI>
<LI>сигнал может испускаться по ключевому слову <CODE>emit</CODE>, например, <CODE>emit signal(parameters);</CODE> из любой функции-члена класса, который поддерживает механизм сигнал/слот,</LI>
<LI>все сигналы, используемые классом и не унаследованные от предков, должны быть добавлены в объявление класса в секцию <CODE>signals:</CODE>,</LI>
<LI>все методы, которые могут быть соединены с сигналами, должны быть объявлены в секциях с дополнительным ключевым словом <CODE>slot</CODE>, например,
<CODE><B>public</B> slots:</CODE> внутри объявления класса,</LI>
<LI>meta-object компилятор <CODE>moc</CODE> должен быть запущен для обработки файла заголовка для подстановки макросов и выдачи файла с реализацией
(в которой не требуется разбираться). Выходной файл <CODE>moc</CODE> компилируется обычным компилятором C++.</LI>
</OL>

Другой способ использовать сигналы без наследования от <CODE>QObject</CODE> - использовать класс <CODE>QSignal</CODE> - см. справочное руководство
для получения дополнительной информации и примеров использования. В дальнейшем материале мы предполагаем, что используется наследование от <CODE>QObject</CODE>.
<P>Используя этот механизм, ваш класс может посылать сигналы и предоставлять слоты для присоединения к ним сигналов. Используя сигналы, вы не должны
заботиться о том, кто их получает - вы должны испустить сигнал и любой слот, который вы соединили с этим сигналом, сможет прореагировать
на появление сигнала. Кроме того, слоты могут использоваться как обычные методы при реализации программы.
<P>Теперь, для того, чтобы соединить сигнал и слот, вы должны использовать метод <CODE>connect()</CODE>, который предоставляет <CODE>QObject</CODE>, или, где это возможно, 
специальные методы, которые предоставляют объекты для установки соединения с определенными сигналами.
<P>
<H4>Пример использования</H4>

<P>Чтобы объяснить, как организовать межобъектное взаимодействие, вернемся к нашему первому примеру и добавим в него простое соединение:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Как видно, единственное изменение, оживляющее кнопку, - использование метода <CODE>connect()</CODE>:
<CODE>connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));</CODE>. Вот и все, что мы добавили. 
Что это значит? В классе <CODE>QObject</CODE> метод <CODE>connect()</CODE> объявляется так:
<P><CODE>bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )</CODE>
<P>Это значит, что вы должны предоставить экземпляру QObject указатель на источник сигнала, имея в виду, что он должен уметь испускать этот сигнал, 
первым параметром; затем вы должны указать сигнал, для которого устанавливается соединение. Следующие два параметра - объект-получатель, 
который предоставляет слот, и фукнкция-член, которая <EM>и есть</EM> слот, выполняемый при получении сигнала. 
<P>Используя сигналы и слоты, объекты вашей программы могут взаимодействовать между собой проще, без точного определения типа объекта-получателя сигнала. 
Вы изучите подробнее использование этого механизма позднее в этой книге. Более подробная информация о
механизме Сигнал/Слот также может быть найдена в "The KDE Library Reference Guide" 
и в Qt online-документации.
<P>
<H3><A NAME="ss2.2">2.2 Что предлагает KDE</A>
</H3>

<P>
<H4>Библиотеки KDE 1.1.x </H4>

<P>На момент написания книги KDevelop использует KDE 1.1, поэтому мы здесь рассмотрим 
библиотеки KDE  этого релиза. Основные библиотеки KDE, которые вы будете использовать при разработке приложений KDE, следующие: 
<P>
<UL>
<LI>библиотека KDE-Core содержит все классы, не являющиеся видимыми элементами, и обеспечивает реализацию тех возможностей, которые ваше приложение может использовать;</LI>
<LI>библиотека KDE-UI содержит элементы пользовательского интерфейса, такие как панель меню, панели инструментов и т.п.;</LI>
<LI>библиотека KFile содержит диалоговое окно выбора файлов.</LI>
</UL>
<P>Кроме того, для специальных целей KDE предоставляет следующие библиотеки:
<P>
<UL>
<LI>библиотека KHTMLW содержит элемент, который полностью интерпретирует HTML-файлы и используется в таких программах, как KDEHelp, KFM, KDevelop;</LI>
<LI>библиотека KFM позволяет использовать KDE менеджер файлов из вашего приложения;</LI>
<LI>библиотека KAb, KAddressBook. Реализует доступ к адресной книге, например, для приложений, работающих с email;</LI>
<LI>библиотека KSpell предоставляет элементы для интеграции Ispell, программы проверки правописания, в приложения типа
редакторов; используется в KEdit.</LI>
</UL>
<P>Теперь давайте посмотрим, что необходимо сделать, чтобы превратить наше Qt приложение в KDE приложение.
<P>
<H4>Пример приложения KDE </H4>

<P>Сейчас вы увидите, что создание KDE приложения не на много сложнее, чем приложения для Qt. Для использования возможностей KDE
вы просто должны включить в программу другие классы, и все будет сделано. Например, рассмотрим измененную версию примера программы Qt,
приведенного выше:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#include &lt;kapp.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!" );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Как видно, в первую очередь мы изменили <CODE>QApplication</CODE> на <CODE>KApplication</CODE>. Далее, мы использовали вместо метода
<CODE>setMainWidget()</CODE> метод <CODE>setTopWidget</CODE>, который вызывает <CODE>KApplication</CODE> для установки главного элемента (main widget). Вот и все! Ваше первое KDE
приложение готово - вы только должны сообщить компилятору путь к файлам KDE, упомянутым в командах "#include", и линкеру - линковать с ключом -lkdecore.
<P>Теперь, когда вы знаете, что в общем делает функция main(), как приложения становятся видимыми и как организовать взаимодействие пользователя и объектов программы,
мы переходим к следующей главе, где мы сделаем наше первое приложение с помощью KDevelop - там вы сможете также протестировать все вышеупомянутое и посмотреть результат.
<P>Сейчас вам будет полезно посмотреть дополнительно справочное руководство по Qt, особенно в части <CODE>QApplication</CODE>,
<CODE>QWidget</CODE> и <CODE>QObject</CODE>, документацию по библиотеке KDE-Core для класса <CODE>KApplication</CODE>.
Справочник "KDE Library Reference" содержит полное описание вызова
конструкторов <CODE>QApplication</CODE> и <CODE>KApplication</CODE>, включая обработку аргументов командной строки.
<P>
<P ALIGN="RIGHT">

<A HREF="index-3.html">Next</A>
 <A HREF="index-1.html">Previous</A>
 <A HREF="index.html#toc2">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
