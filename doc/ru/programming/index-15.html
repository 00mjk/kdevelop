<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDevelop. Руководство программиста: Советы по программированию</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=koi8-r">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-16.html">Next</A>
 <A HREF="index-14.html">Previous</A>
 <A HREF="index.html#toc15">Table of Contents</A>
</P>
<H3><A NAME="s15">15. Советы по программированию</A></H3>

<P>В конце этой книги я хочу обратить внимание на некоторые моменты, о которых надо помнить при разработке. Это в основном
советы по программированию на C++, которые относятся к KDE и особенно Qt, и взяты в центре разработчиков KDE, который можно найти
в Internet по адресу 
<A HREF="http://www.kde.org">http://www.kde.org</A>.
<P>
<DL>
<DT><B>Имена файлов</B><DD><P>Во-первых, при создании исходников вы должны использовать только строчные буквы в именах файлов. KDevelop обеспечивает
это, если вы используете автоприсвоение имен. Это упрощает для других разработчиков запоминание того,
что в каком файле искать при отладке.
<P>
<DT><B>Имена классов</B><DD><P>Имена классов в приложении KDE должны:
<UL>
<LI>начинаться с префикса <B>K</B>, затем следует имя, описывающее назначение класса (по вашему выбору). Например,
<CODE>KMyWidget</CODE> для специального элемента приложения,</LI>
<LI>иметь членов, имена которых начинаются только со строчной буквы, а следующие слова в них начинаются с заглавной, например,
<CODE>myWidgetPointer()</CODE>,</LI>
<LI>называть методы, которые возвращают значения private-атрибутов, без использования префикса <CODE>get</CODE>. Используйте содержательное имя
члена класса. Например, <CODE>b_myboolean</CODE> - private член. Метод, возвращающий текущее значение, может называться
<CODE>myBoolean()</CODE>.</LI>
</UL>
<P>
<DT><B>Обращение к файлам в коде</B><DD><P>Следует избегать жесткого задания путей, используя стандарт файловой системы KDE. Вы должны только определить путь к вашему приложению,
это можно сделать с помощью соответствующего макроса в файле <CODE>Makefile.am</CODE>, как это было описано выше. В коде используйте методы
<CODE>KApplication</CODE> для получения действительных путей.
<P>
<DT><B>Документация классов</B><DD><P>Еще один пункт, который уже упоминался, - документация классов. Вы должны придерживаться правил форматирования <CODE>KDoc</CODE>, поскольку их используют все разработчики KDE
для документирования классов. Добавьте хотя бы одну строку комментариев к каждому члену класса себе для напоминания
его предназначения и другим для повторного использования кода. Повторное использование кода с GPL имеет больше смысла, когда вы знаете, где найти
уже существующее решение по документированному классу. Qt-библиотека - хороший пример хорошо документированного интерфейса, хотя он не использует 
<CODE>KDoc</CODE>.
<P>
<DT><B>Используйте <CODE>new</CODE> для создания элементов</B><DD><P>В реализации приложения предпочитайте создавать элементы в куче вызовом <CODE>new</CODE>. Библиотеки Qt имеют хорошее свойство
автоматически удалять все дочерние элементы, созданные с помощью <CODE>new</CODE>, поэтому вы не должны даже использовать <CODE>delete</CODE>.
Это одно из важнейших технических преимуществ библиотеки Qt, и вы должны его широко использовать.
<P>
<DT><B>Отладка</B><DD><P>Когда дело доходит до отладки, используйте макрос <CODE>KDebug</CODE>. Есть похожие макросы Qt, но он обеспечивает доступ с свойствам через клавиши
STRG+ALT+F12. См. 
<A HREF="../kde_libref/index-4.html#ss4.4">KDE Library Reference Guide</A> 
для более подробной информации о фильтрации событий этим макросом. Вы также можете использовать <CODE>assert()</CODE>, но поддерживайте соответствие
с кодом для отладки.
<P>
<DT><B>Объявления <CODE>const</CODE></B><DD><P>Используйте объявление <CODE>const</CODE> для функций-членов, которые не меняют значений private-членов. Это можно использовать
для всех методов, возвращающих значения этих членов. Это позволяет избежать случайного изменения значения и отловить
логические ошибки на этапе компиляции. Что касается инициализации членов с декларацией const, вы должны это делать одновременно с использованием 
<CODE>static</CODE> в определении, и инициализировать значение вне конструктора:
<BLOCKQUOTE><CODE>
<PRE>
class foo {
        static const int value;
};

const foo::value = 10;
</PRE>
</CODE></BLOCKQUOTE>
<P>ANSI C++ позволяет инициализировать член в конструкторе, но избегайте подобной техники, так как некоторые компиляторы не поддерживают данную возможность.
<P>
<DT><B>Виртуальные методы</B><DD><P>Как объяснялось в разделе 
<A HREF="index-2.html#User Interaction">Взаимодействие с пользователем</A>, 
вы должны учитывать права доступа и декларацию <CODE>virtual</CODE> при перекрывании виртуальных методов. По крайней мере, вы не должны уменьшать доступ к виртуальному методу от protected
до private.
<P>
<DT><B>Предварительные объявления</B><DD><P>Заголовки классов должны быть включены там, где вы обращаетесь к объекту или экземпляру класса в вашем коде. Это значит, что если ваш класс
использует член другого класса, замените директиву #include предварительным описанием класса, например, вместо:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;qpushbutton.h>

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</PRE>
</CODE></BLOCKQUOTE>
<P>предпочтительнее только объявить класс <CODE>QPushButton</CODE> в файле заголовка:
<P>
<BLOCKQUOTE><CODE>
<PRE>
class QPushButton;

class KMyWidget:public QWidget
{

private:
  QPushButton* ok_button;
};
</PRE>
</CODE></BLOCKQUOTE>
<P>и поместить директиву include в соответствующий файл-исходник, где, например, экземпляр <CODE>ok_button</CODE> используется любым методом
класса <CODE>QPushButton</CODE>. Это сохранит время компилятора, особенно если вы используете экземпляры классов, которые вы разрабатываете. 
Компилятор должен перекомпилировать все исходники, включающие заголовок, если вы делаете любое изменение в интерфейсе класса,
поэтому простое добавление метода, возвращающего целое значение внутреннего объекта, может привести к перекомпиляции всех исходников,
включающих файл заголовка данного класса.
<P>
<DT><B>Сообщения о неиспользуемых параметрах и значения по умолчанию</B><DD><P>Также вы должны удалить формальные параметры методов, которые не являются необходимыми. Это позволит избежать
предупреждения <CODE>unused parameter</CODE> от вашего компилятора, когда он увидит формальный параметр, который не используется
в реализации. Обычно вы посылаете несколько аргументов по умолчанию в некоторые методы. Их значения необходимо устанавливать в объявлении
члена класса, а не в его реализации.
<P>
<DT><B>Использование <CODE>config.h</CODE></B><DD><P>Проекты KDevelop, как и любые другие проекты, использующие <CODE>autoconf</CODE> для создания скриптов <CODE>configure</CODE>, создают файл
<CODE>config.h</CODE> после выполнения скрипта <CODE>configure</CODE> на пользовательской машине. В нем приводятся значения, найденные <CODE>configure</CODE>,
которые могут быть использованы в исходниках. Директива для включения файла <CODE>config.h</CODE> следующая:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif
</PRE>
</CODE></BLOCKQUOTE>
<P>Один из наиболее часто используемых входов <CODE>config.h</CODE>, вероятно, определение типа <CODE>bool</CODE> для компиляторов,
которые не совместимы с проектами последних версий ANSI C++.
<P>
<DT><B>Используйте <CODE>0</CODE> вместо <CODE>NULL</CODE></B><DD><P>Предпочитайте использовать <CODE>0</CODE> непосредственно вместо <CODE>NULL</CODE> для установки значений, как это делают библиотеки KDE и Qt. 
Это повышает переносимость ваших приложений для компиляторов, которые имеют проблемы с использованием <CODE>NULL</CODE>.
<P>
<DT><B>Временные данные</B><DD><P>Вы должны определять временные экземпляры всегда перед их использованием. Это лучший путь, чем прямое использование. Пример:
<BLOCKQUOTE><CODE>
<PRE>
// Не следует
for( int i=0; i&lt;n; i++){
  //что-то делаем
  };

// Следует
int i;

for(i=0; i&lt;n; i++){
  //что-то делаем
  };
</PRE>
</CODE></BLOCKQUOTE>
<P>Это также касается вызовов функций:
<BLOCKQUOTE><CODE>
<PRE>
// Не следует
setColor( &amp;(QColor(black)) );

// Следует
QColor color(black);
setColor( &amp;color );
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
</DL>
<P>
<P ALIGN="RIGHT">

<A HREF="index-16.html">Next</A>
 <A HREF="index-14.html">Previous</A>
 <A HREF="index.html#toc15">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
