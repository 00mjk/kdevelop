
<!doctype linuxdoc system>
<book>
<titlepag>
<title>KDE Application Tutorials
<subtitle>The KDE Application Tutorials Handbook for the KDevelop Integrated Development Environment
<author>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">
<inst>The KDevelop Team
<date>Version 0.2 , Thu Jan 27 2000
<abstract>
The KDE Application Tutorials Handbook for the KDevelop Integrated Development Environment, a tutorial collection on how to create KDE
applications by examples. This handbook itself is part of the KDevelop Integrated Development Environment and is therefore also
licensed under the GNU General Public License; see <ref id="Copyright" name="Copyright"> for more information.
</abstract>

<toc>

<chapt>Introduction
<p>
This handbook will try to teach you KDE/Qt application design by creating an example application step-by-step. The major intention is
to gain a certain understanding how two of the most important ideas of graphical user interface programming work: the document-view
model and the multiple document interface (MDI) model.

By this, you will also get a good idea of concepts that are coming up ahead: KDE 2 and the Qt 2.1 library, bringing new enhancements
and technology to the programmer's hands that will improve application design and widen the possibilities that are open to use.
Keywords such as widget themes, Inter-Process Communication and embedded applications are popularly talked about and will allow even
more than one can think about right now.

Therefore, KDevelop 1.1, still based on KDE 1.1.x, provides developers some of the most requested possibilities: developing
applications for KDE 2, while still running a stable desktop environment. This also implies that this tutorial will be based on a KDE 2
application that already makes use of Qt-2.1, offering a solution for the mentioned MDI model - which we provide as a ready-to-go frame
application. During this tutorial you will get a clear insight on how it works and this will also make it much easier to understand the
document-view model as well - which is hard to understand even for advanced programmers. That will help you create other type of
applications, which use the document-view model even if they only contain one window and you wouldn't obviously see a need for it. But
let's just go inside it - you will see what's coming up on you and how easy it actually is.

The tutorial covers several steps:
<itemize>
<item>installing KDE 2 (libraries) and setting up KDevelop to create KDE 2 applications.
<item>understanding the basic concepts of MDI and document-view model.
<item>creating the generic framework for <em>KScribble</em> and explaining the concept of the framework.
<item>implementing the document class, who will provide the interface to read and write the document data as well as maintaining the
document.
<item>implementing the view class to visualize the data. This class also takes over the interaction with the user.
<item>adding dialogs to set the pen width and color of the pen to draw with, including their integration into the toolbar and menubar
<item>changing the view from the default <tt>QWidget</tt> inheritance to a scrollable view.
</itemize>

The tutorial example itself is based on the code found in the scribble example application that comes with the Qt library. The source
of the original example can also be found within the Qt documentation, section examples.

<chapt>Installing KDE 2
<p>
In this chapter we will first go through a couple of steps that will help you set up KDevelop for creating KDE 2 / Qt 2.x
applications. The requirements are:
<itemize>
<item>a current Qt-2.1 snapshot available at <htmlurl url="http://www.troll.no" name="http://www.troll.no">
<item>a current KDE 2 snapshot of the packages <tt>kdesupport</tt> and <tt>kdelibs</tt>
</itemize>

Both the Qt-2.1 and KDE 2 libraries are currently under development but are to be expected as final and changes to be expected for the
final versions are marginal and may not even affect your application. This means you're getting to know the newest libraries coming up-
and you're in charge of a valuable time-saving to create your application even before the libraries are completed.

The following sections describe what to do in detail within three steps:
<itemize>
<item>installing the Qt library
<item>installing the KDE libraries
<item>setting up KDevelop
</itemize>

Then you're ready to go and we'll proceed with creating the first step of the example program <em>KScribble</em> in the next chapter.


<sect>Setting up Qt-2.1
<p>
This first step will lead you to the minimum requirement to follow our example- which implies that there is a possibility to avoid
installing KDE 2 if you're only interested in creating Qt-only programs. As Qt-2.1 contains all needed classes and KDevelop providing a
project template for multiple document interface applications for Qt-2.1 as well based on the same framecode that is used in the KDE 2
template, you should have no problem at all following the example with a Qt-only application.

Now, to get the newest Qt library, get a recent version from the Troll Tech website at <htmlurl url="http://www.troll.no"
name="http://www.troll.no">, section download. Then change to root and copy the tarball to the directory where your currently used Qt
version is placed as well - on a SuSE Linux system this would be <tt>/usr/lib</tt>, where you should have a directory for either
qt-1.44 or qt-2.0.2, depending on the distribution version. Untar the library sources with

<tt>tar zxvf qtxxx.tar.gz</tt>

depending on the name of the tarball. Then set the environment variable <tt>QTDIR</tt> to point to the directory where your new Qt-2.1
library is placed with e.g. <tt>setenv QTDIR=/usr/lib/qt-2.1</tt>. Another solution would be to move the qt-1.44 directory, usually
just named qt, to qt-1.44 and create a symlink that for now has to point to qt-2.1, after the library is build, change it back to
point to the qt-1.44 directory.

Change to the Qt-2.1 directory and type:
<tscreen><verb>
./configure
make
</verb></tscreen>

You can change back your QTDIR variable to point to your qt-1.44 installation after successfully
compiling the Qt-2.1 library.

Now switch to the directory <tt>/usr/lib/qt-2.1/lib</tt> and copy the created libraries to <tt>/usr/lib</tt> <bf>exept</bf> the
symbolic link <tt>libqt.so</tt>.

Then you're done with Qt and you can proceed to the next step, setting up KDE 2 libraries. If you want to develop for Qt only, proceed
to section Setting up KDevelop.

<sect>Setting up KDE 2 Libraries
<p>

The second step leads you to install the needed KDE libraries. Download a recent snapshot of the library packages <tt>kdesupport</tt>
and <tt>kdelibs</tt> from <htmlurl url="http://www.kde.org" name="http://www.kde.org">. Then things will go a bit easier than for the
Qt library. Just untar the sources to your directory and change to the kdesupport directory first. There, type:

<tscreen><verb>
./configure --with-qt-dir=/usr/lib/qt-2.1 --prefix=/opt/kde2
make

and as root:

make install
</verb></tscreen>

This will install the kdesupport package to the directory given in the --prefix option and compile using the new build Qt-2.1 library,
to which you give the path to configure by the option --with-qt-dir.

The same applies to the kdelibs package, just change to the kdelibs directory and type the same as above for the kdesupport package.

Then you're done with setting up the requirements for the needed libraries to build a KDE 2 application.

As a note aside, the KDE library package contains support for automatic HTML documentation generation, which you can easily get by
installing KDoc, version 2.x. Then type <tt>makekdedoc</tt> in your kdelibs directory and KDoc will create the HTML documentation in a
subdirectory <tt>srcdoc</tt>. In KDevelop you can access the KDE library documentation online with setting the KDE library
documentation path in the KDevelop Setup dialog to point to <tt>kdelibs/srcdoc</tt>. On the same way set your Qt-Online documentation
path in KDevelop to point to <tt>/usr/lib/qt-2.1/html</tt>, so you can access the documentation right away from within KDevelop.

If you successfully installed the Qt-2.1 and KDE 2 libraries, you're just one step away from creating your first KDE 2 application, you
just need to give KDevelop the needed information where you installed the libraries - which we'll do in the next section.

<sect>Setting up KDevelop
<p>
This part is somewhat the easiest in the whole configuration process for KDE 2 development: Setting up KDevelop. Just open KDevelop,
then select "Options"->"KDevelop Setup" to access the KDevelop configuration. There, change to the last page, titled "Path". This page
contains two entry fields, one for the Qt library and one for the KDE 2 libraries. As you have successfully installed everything,
select <tt>/usr/lib/qt-2.1</tt> for the Qt-2.x library path and <tt>/opt/kde2</tt> for the KDE 2 library path. Press the "OK" button
and you're done.

Users that only want to develop for Qt-2.x (including the current Qt-2.0.2 version) just have to set the Qt-2.x library path.

Now we can proceed to the next chapter where we will create the first step of the <em>KScribble</em> example.


<chapt>Application Concepts
<p>
This chapter now introduces you into the ideas of the application models mentioned already: the MDI (Multiple Document Interface) and
the Document-View model. A basic introduction into the Document-View model and the generating of a project with KDevelop is already
given in <htmlurl url="../programming/index.html" name="The KDevelop Programming Handbook">, but based on a Single Document Interface
(SDI). In any case, you should be familiar with the basics of the KDE and Qt classes that are explained in <htmlurl
url="../kde_libref/index.html" name="The KDE Library Reference Guide">, there the base classes of the underlying libraries are
explained in detail and how to use them, with an additional description of the Qt signal-slot mechanism and event handling.

As a guideline, you should know already:
<itemize>
<item>that every KDE application needs one instance of <tt>KApplication</tt> (for a Qt application one instance of
<tt>QApplication</tt>)
<item>generally a main window is inherited from <tt>KTMainWindow</tt> for KDE (for a Qt application inherited from
<tt>QMainWindow</tt>)
<item>that events (e.g. keyboard presses or mouse movements) are sent to the application by the underlying window system
<item>that <tt>QWidget</tt> as the base class for all visible Graphical User Interface (GUI) components provides specialized event
handlers by virtual functions that filter out the according events by reimplementing <tt>QObject::event()</tt>
<item>that the Qt signal-slot mechanism means basically that a component can send out signals and a receiver can connect to those
signals to process some actions
<item>that this mechanism avoids inheriting classes for GUI components because the signals inform you about e.g. mouse presses  where
appropriate for a wiget
</itemize>

<sect>The Document-View Model
<p>
The Document-View Model is one of the most basic concepts in application design that rely on graphical user interfaces. Therefore, a
certain understanding of the why is needed to see that although the programmer has other possibilities, it makes sense to make use of
it. But first let's follow the usual design of a typical KDE / Qt application:

Your application instance provides the first connection to your application and is the starting point of the event handling for a
program. The program itself represents itself to the user by a Graphical User Interface which is most often called a main-window. The
main window then provides the appropriate functions for the user such as key accelerators, a menubar, toolbar and a statusbar. In the
center it contains a so-called "view-area" which means that this part is an instance of another class, usually called a "View". The
view instance is created when the main window gets constructed at program start and has to be set as the view area component with a
method provided by the main window: <tt>setView(your_view)</tt> for KDE applications using <tt>KTMainWindow</tt>,
<tt>setCentralWidget(your_view)</tt> for a Qt application using <tt>QMainWindow</tt>. Now, the view obviously is the area that is
responsible for interacting with the user to manipulate the data that it represents. As an example, you could use a
<tt>QMultiLineEdit</tt> as a view and you will have an editor. Then you can use the provided slots of the view for connections to
menubar or toolbar command like this:

While creating the menubar, you want to provide a method for the command "cut" in the "Edit" menu:
<tscreen><verb>
  pEditMenu->insertItem(BarIcon("editcut"), i18n("Cu&amp;t"),view, SLOT(cut()),KAccel::Cut, ID_EDIT_CUT);
</verb></tscreen>

This creates a menu item in the "Edit" menu, that, when activated, directly calls the slot <tt>cut()</tt> of the instance
<tt>view</tt>, whereby we suppose you have created this instance as a <tt>QMultiLineEdit</tt> and set as the view area. The
multilineedit's slot gets called and cuts out the selected text as a reaction, the functionality is already provided by the class
itself and so there is no need to inherit from <tt>QMultiLineEdit</tt> to create a view area that is capable of such actions. They are
ready to use and make application development very fast- you just need the application instance and the main window including the
connections to your view area and you're done ! That means, a simple editor can be written by creating one single class that defines
the main window behavoir and how to save and read files into the editor - just some basic slots your main view has to implement itself.

But here is the reason why we're now introducing this mysterious Document-View model: You have to provide methods by your own to read
and write the actual files you want to edit with the <tt>QMultiLineEdit</tt> view-area <bf>within</bf> the main window's interface.
Yes, this is obviously the easiest thing to do in this case, and the most logic. Now, if we have a look at the files and their contents
as a so-called "Document", which we can subscribe with the attribute of an "Object" in C++ terminology, the next step is just a little
one: If I have a document, a view and a main window- why don't I separate these three objects from each other ? We could easily create
a small class that is responsible for reading in a file into a text stream and then call the view to draw the text visible to the user.
The same applies to saving the file again- the document class should then provide a saving method that retrieves the text from the view
again and saves it as a file. In the example these two methods would be the only actions that are needed to be done by a document
class, because the edit-view already provides all methods basically needed for and editor by slots and you can manipulate the content
of the view by them directly.

Now, the main idea behind the need for this separation into three objects (document, view, main window) instead of the minimum of two,
the view and the main window, is the question: what if I want to give the user the possibility to work with a file by <bf>two</bf> or
even more views ? Such things can even be done within one main window by splitters or deviders containing two view instances which
shall both display <bf>one</bf> file. There it is: the solution can only be that if the user manipulates the file contents in one view,
the other view has to be notified about that and to actualize its contents. Otherwise a bad scenario will occur: if the user closes one
view where he added something at the end of the file which he cutted out at the beginning of the file <bf>in</bf> the other view, the
file will be saved later by still containing the cutted section, because if the second and last view did not recognize this, it still
contains the text without modification from the beginning plus the inserted one. This means that both views have to be synchronized by
their contents they are displaying and that can be done if all views get notified about each action that the user does, which view he
actually uses should be equal. That means that finally a document class is needed to be the one and only holder of the true contents of
the document and is providing the views the possibility to manipulate the contents.

I hope this has given some insight into this model, although in most cases it seems that the programmer can live without it - equally
to just using a provided class as the view area or writing a widget on his own to handle user interaction, as long as you represent
<bf>one</bf> document or file by <bf>one</bf> view area, the view can be responsible for the data as well and only provide methods to
retrieve or set the document contents for actions like reading a file or saving it. The next model to describe, the Multiple Document
Interface, will make a difference at this point- there you will see the actual need and the functionality the Document-View model
provides.

<sect>The Multiple Document Interface (MDI)
<p>
As the last section described the Document-View model, you will probably guess what MDI means. Users that come from other Operating
Systems than Unix/Linux are used to it as well as programmers developing for those platforms. While X-Window applications traditionally
are more targeting towards functionality and stability, Unix users are used to single windows that provide functionality, therefore
even the Document-View model is often not needed to create applications. With Qt as a multi-platform toolkit, developers are having
even more choice - developing for MS Windows(tm) as well as for Unix systems. While on Windows the lack of creating applications that
are capable of handling so-called child windows has been getting to some kind of standard, this is adressed by the Qt 2.1 library, but
on the other hand Unix users can profit from this architecture as well.

What is now the meaning of MDI ? An MDI application generally has the same concept of a usual application that has, as described above,
one application instance and a main window. The view area now make the difference: you don't directly use a view that represents data
and provides interaction to manipulate that data but a view that handles other windows looking like top-level windows. These windows
are now representing the former view area and the main difference is that the interaction chain changes from

<tscreen><verb>
application instance -> main window -> view

to

appliation instance -> main window -> view -> active child window
</verb></tscreen>

The view now is capable of several actions:
<itemize>
<item>creating as much child windows as the user requests
<item>providing methods to retrieve the currently active child window
<item>maintaining a list of open views
<item>managing the child window behavoir for maximize, minimize such as a window manager does for top-level windows
</itemize>

Now, you can use "complete" widgets like the <tt>QMultiLineEdit</tt> as child windows like for an application that only provides one
window and each child window is responsible for it's own data. That could be described as "Multiple Document Interface", whereby each
child window is equal to a single document. The application then manages the usual actions such as providing methods for the child
window interaction such as cut or copy. Extending this concept with the document-view model enhances the possibilities by far: imagine
that you can open as much windows as you like within the main window and that a new child window can be a new view of a document that
is already shown by another child window. The management for this requires a separation into the already described three objects model,
but doesn't limit the actual number of instances of the documents as well as the views.

Fortunately, Qt 2.1 contains the possibility to create such applications and KDevelop provides you with the according application
frameworks for both, Qt-only programs as well as KDE 2 applications with the same interface methods- so it is adequate wether you want
to develop for one of these. Using KDE 2 interfaces will offer you still more possibilites by library functions as well as
inter-process communication, but those are special aspects that are to cover by separate introductions to these techniques.

Now you are prepared for following the development for KDE 2 - just follow the next chapter to get a first look at the functionality
already provided by KDevelop when creating applications. There, we will generate the framework for our tutorial application
<em>KScribble</em> and describe the practical aspects of programming MDI applications.

<chapt>The MDI Framework
<p>
If you're already familiar with previous versions of KDevelop, you will know that your IDE uses so-called "frameworks" as a starting
point of application development. These frameworks by default contain a support for a generic document-view model, but were limited to
SDI (Single Document Interface, one window with one view area) model structures. From KDevelop 1.1 on, the application wizard is
capable of a lot more than the previous versions: it offers some new project types especially for those developers that want to stay
up-to-date with the upcoming KDE 2 as well as for Qt 2.1. One major extension are MDI application frameworks for both, KDE 2 and Qt
2.1. These frameworks differ only in the use of some library functions such as file dialogs or message boxes as well as the used
toolbar and statusbar classes - the KDE version uses KDE 2 methods, the Qt version the according Qt functions.

To create the fist step of this tutorial application <em>KScribble</em>, be sure that you have followed the instructions in chapter 2
of this tutorial handbook: setting up KDE 2. If that went all right, nothing can go wrong. If you couldn't set up the KDE 2 libraries,
be sure that you have Qt-2.1 installed and set up KDevelop for that at least. You can follow this tutorial by choosing the according Qt
framework as well (which has the differences as mentioned above: other method calls for dialogs and GUI components).

<sect>Creating an MDI Framework
<p>
Now we will start jumping into development by creating the frame application for <em>KScribble</em>. Start KDevelop and choose
"Project"-"New" from the menubar to invoke the application wizard. On the first page, you will be shown a tree of project types. These
contain KDE and Qt projects. There, select "KDE 2 MDI" from the KDE section. If you only have Qt 2.1 installed, choose "Qt 2.1 MDI"
from the Qt section. Then select "Next", enter "KScribble" as project name and "1.0" as version number. Add your name
and email address into the according fields and you're done. Click on the "Create" button and KDevelop will generate our first version
of <em>KScribble</em> while you can watch the output in the last page of the wizard. Finally, press "Exit" to return to KDevelop. In
the output window you will see an additional message showing that the messages file has been set up for your project, which will be
important to translate KScribble into other languages.

<sect>Overview
<p>
Now it is important to have an understanding where to find what in the generated sources and where your place as a programmer can be
found to make <em>KScribble</em> a unique KDE application.

First of all, in the Classviewer you will see three already created classes, <tt>KScribbleApp</tt>, <tt>KScribbleDoc</tt> and
<tt>KScribbleView</tt>. As explained above, each of them has a certain part within the application; the App class builds the main
window and coordinates user interaction, the Doc class maintains the documents that an application can manipulate; finally the View
class is responsible for user interaction with the child windows and communicates with the document connected to it. This has several
consequences: to make a good use of the provided functionality, the programmer is bound to use the given View class. By default, the
View inherits <tt>QWidget</tt> as a minimum requirement, but you're by far not limited to that. But inheriting from another class is
not too much work and finally there is also the possibility to use a <tt>QMainWindow</tt> or <tt>KTMainWindow</tt> for example as the
class to inherit and use another class that manages the view.

In the next chapter we'll continue with extending <em>KScribble</em> to manage it's documents. After that we'll implement the user
interaction and you will see the first functionality that is unique to our application: we can draw pictures, load and save them.


<chapt>Defining the Documents
<p>

The first step when creating an application based on the Document-View model should always be to think what kind of data the
application has to manage. This decides how the view class will look like but especially how the document clas will read and write data
to and from files and offer methods to manipulate the data. As <em>KScribble</em> will be a simple drawing application that operates on
graphical data, we will use the Qt class <tt>QPixmap</tt> for storing our paintings while it is edited. <tt>QPixmap</tt> also offers
simple methods to read and write pictures into files, so the serialization of the document data is done in just two lines, one for
reading and one for writing. Further, we need to define a pen that draws into a document, set it's width and color and make it
available for the view class to retrieve the pen - actually you want the view offering the drawing methods, but the document as the
central element for all views has to hold the pen originally, because two views of the same document would otherwise use different
pens!

Therefore to define how our document class should work, we will add one instance of <tt>QPixmap</tt>, one of <tt>QPen</tt> and edit the
methods <tt>newDocument()</tt>, <tt>openDocument()</tt> and <tt>saveDocument()</tt>.

<sect>Adding the Instances
<p>

Open the file <tt>kscribbledoc.h</tt> by selecting it in one of the fileviewers or by a click on the classviewer over the class
<tt>KScribbleDoc</tt>. Then add the lines marked with -> from the following code snippet:


<code>
->  #include <qpixmap.h>
->  #include <qpen.h>

    class KScribbleDoc
    {

->    	protected:

->        QPen currentPen(){ return pen;};	
    		
->    		int penWidth()
->    			{ return pen.width(); }

      public slots:
        void updateAllViews(KScribbleView *sender);
    	
    	protected:
    	
->    		QPixmap buffer;
     	
      private:
->    		QPen pen;
        /** the modified flag of the current document */
        bool modified;
</code>

As you see, we added pen and buffer as well as currentPen() and penWidth(). As pen is declared private, we offer a possibility to
retrive the pen as well as the pen width. As these are already implemented within the classdeclaration, we don't have to add them to
the implementation file, where we're turning to now.

<sect>Initialization of the Document
<p>

Select the method newDocument() in the KScribbleDoc class to jump to the method declaration. Here, we're only adding one line, marked
with the arrow:
<code>
  kscribbledoc.cpp

  bool KScribbleDoc::newDocument()
  {
    /////////////////////////////////////////////////
    // TODO: Add your document initialization code here
->  pen=QPen( Qt::black, 3 );
    /////////////////////////////////////////////////
    modified=false;
    return true;
  }
</code>

This initializes the pen with the color black and width of 3 pixels; the QPen class has some more constructors, but this one lasts our
needs here.

<sect>Implementing the Serialization
<p>

What is left to do is to define how to open and save our pictures. This is done in the according methods:

<code>
    bool KScribbleDoc::openDocument(const QString &amp;filename, const char *format /*=0*/)
    {

    	QFile f( filename );
->     //if ( !f.open( IO_ReadOnly ) )
->     //	return false;
     /////////////////////////////////////////////////
     // TODO: Add your document opening code here
->     if(!buffer.load( filename, "PNG" ))
->     	return false;
     /////////////////////////////////////////////////
->     //f.close();


    bool KScribbleDoc::saveDocument(const QString &amp;filename, const char *format /*=0*/)
    {
      QFile f( filename );
->     // if ( !f.open( IO_WriteOnly ) )
->     // 	return false;

      /////////////////////////////////////////////////
      // TODO: Add your document saving code here
->    	if(!buffer.save( filename, "PNG" ))
->    		return false;
      /////////////////////////////////////////////////

->      //f.close();

</code>

Add the lines marked with the arrow again to your code. What we did here is to comment out the passages where the file
<tt>filename</tt> is opened, because that is done automatically by the load and save methods of QPixmap, which we add instead. Other
documents may open a file and read in its contents such as text lines or whatever, so the QFile methods are already present in the
codeframe. As save() and load() return a boolean value if the operation was successful, we're returning false if not, so the rest of
the framework gets a return value and can give out warnings if the operation was not successful.
The load() and save() methods now are already provided in QPixmap. They require the filename and the format as argument; the source
framework on the other hand <bf>does not</bf> call the document methods with the format yet. If only one format is used, it lasts to
set the format here. other methods could detect the format for example- but we will turn to this later. For now, we're using "PNG" as
format; see QImageIO for more details about the image formats that can be opened.

Now we're already finished defining our document structure. The QPixmap buffer serves us as a buffer storing the original picture
contents while we're working on it, the pen is a valid pen for all views connected to the document. Note that the initialization of the
pen is done in newDocument(). This method is always called after the constructor within the framework internally, so you should add
document instances initializations there as we did with the pen.

In the next chapter we will turn to the view class to define how the view shall cooperate with the user as well as how it accesses the
document- and then we'll be ready to paint !

<chapt>Defining the View
<p>

<sect>Interactivity with the User
<p>

In this chapter we'll turn to the view class of KScribble to define how the child windows shall work. First of all, we notice that
KScribbleView is derived from QWidget by default. That is the minimum requirement for a child window, but it lasts already to fullfill
our needs. When it comes to defining a new widget's behavoir, we need to know how the user shall interact with the window. In our
example, this would be obviously the mouse. Therefore, we have to overwrite some virtual methods from QWidget that process mouse
events the widget receives. What we need is to know when the user presses a mouse button, because the drawing shall only take place
when the mouse is pressed. Then we need to know when the mouse is moved (to know where it moves to) as well as when it is released-to
finish the stroke the user has drawn. Further we want our picture to be painted on the window and resized if the user decides to resize
the window he draws into. As members we will also add a QPointArray polyline and a boolean value mousePressed. Add the code with the
arrow to your include file for the class KScribbleView:

<code>
   kscribbleview.h

->   #include <qpointarray.h>

    class KScribbleView
    {
    .
    .
     protected:
        virtual void closeEvent(QCloseEvent* );

->     	virtual void mousePressEvent( QMouseEvent * );
->     	virtual void mouseReleaseEvent( QMouseEvent * );
->     	virtual void mouseMoveEvent( QMouseEvent * );
->     	virtual void resizeEvent( QResizeEvent * );
->     	virtual void paintEvent( QPaintEvent * );
   	
   	  KScribbleDoc *doc;
     		
->     private:
->   		bool mousePressed;
->   		QPointArray polyline;

     }
</code>


<sect>Reimplementing Event Handlers
<p>

Now we're coming to the actual implementation of the event handlers. As explained in <htmlurl url="../kde_libref/index.html" name="The
KDE Library Reference Guide">, Qt has a good way of handling user events, especially when they target on to widgets. QWidget as a
baseclass preselects the events and provides basic event handlers which, as they are declared as virtual, we can overwrite to define
how our widget shall react on user actions. One is already overwritten: the closeEvent() method. This is needed, because our main
window, represented in the App class, already preselects closing child windows and handles this; therefore the default event handler,
which just accepts the closing, must be overwritten to prevent that and let the App class do the job.

First of all, we have to declare the widget default behavoir in the constructor by initializing members and setting predefined values:

<code>
    kscribbleview.cpp


    KScribbleView::KScribbleView(KScribbleDoc* pDoc, QWidget *parent, const char* name, int wflags)
     : QWidget(parent, name, wflags)
    {
        doc=pDoc;

->      setBackgroundMode( QWidget::NoBackground );
->      setCursor( Qt::crossCursor );
->    	mousePressed=false;
->      polyline=QPointArray(3);
    }
</code>

We're setting the background to NoBackground, a cursor (crossCursor) and initialize mousePressed and polyline. Then we'll start
implementing our first event handler, mousePressEvent(), to recognize when the user presses the mouse and where:

Note: the following implementations have to be inserted completely, so the lines to add are not marked with an arrow !

<code>
void KScribbleView::mousePressEvent( QMouseEvent *e )
{
  mousePressed = TRUE;
  polyline[2] = polyline[1] = polyline[0] = e->pos();
}
</code>

Here, we're setting mousePressed to true, so we have stored this event somehow. The second line is not so obvious: we're storing the
position where the mouse was pressed into our array's first three elements. As the array is a QPointArray, it can store values of the
type QPoint (which contain an x and y value themselves). What we will do with this array is to store positions of the mouse and create
the drawing routine from there in the mouseMoveEvent:

<code>
void KScribbleView::mouseMoveEvent( QMouseEvent *e )
{
  if ( mousePressed ) {
		
    QPainter painter;
    painter.begin( &amp;doc->buffer );
    painter.setPen( doc->currentPen() );
    polyline[2] = polyline[1];
    polyline[1] = polyline[0];
    polyline[0] = e->pos();
    painter.drawPolyline( polyline );
    painter.end();

    QRect r = polyline.boundingRect();
    r = r.normalize();
    r.setLeft( r.left() - doc->penWidth() );
    r.setTop( r.top() - doc->penWidth() );
    r.setRight( r.right() + doc->penWidth() );
    r.setBottom( r.bottom() + doc->penWidth() );

	  doc->setModified();
    bitBlt( this, r.x(), r.y(), &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
  }
}
</code>

This event handler is probably the most difficult, so we will do a step-by-step walkthrough to understand what's been done. First of
all, the event handler receives all mouse movements over the widget. But as we're only interested in the move if the mouse is pressed,
because that is the time to draw, we have to ask if mousePressed is true. That has been done by the mousePressEvent handler before, so
we don't have to take care for more. Now we're starting the painting action. First we create a QPainter and let it draw into the buffer
of the document. This is important, because the document's buffer contains the real contents, the view only acts as a communicator
between the document and the user. We get the pen from the document instance as well by calling currentPen(). The next three lines
assign the values inside the polyline QPoint array, setting point 2 to 1, 1 to 0 and 0 to the point to where the move went (this is the
contents of the event we're interested in). Assuming we've just pressed the mouse (so all three values of the array contain the
pressing position) and the first mouse move event appears that contains the first position to draw a line to; this value is moved into
the first position in the array again. You may wonder why we need three points in the array then, if we're only interested to draw a
line from one position to the next. The following lines explain that: after drawing into our buffer is finished (with drawPolyline()
and painter.end()), we create a rectangle r and use boundingRect() from QPointArray to get a QRect that contains all three points.
Therefore we need three values to have a most-complete rectangle. Then we use normalize() to have the leftmost and topmost values the
smallest (as coordinates are counted from top->bottom and left->right). The next thing to do is adapt the size of the rectangle by the
size of the pen, because the pen has a thickness we get with penWidth() and widen the rectangle by the width of the pen. (Imagine the
mouse movement was only two pixels away but the pen thickness is set to ten- then the rectangle wouldn't contain the whole painted
area).
Finally, we set the document modified and use the bitBlt() function to copy the rectangle out of the buffer into the widget. bitBlt
operates bitwise and is very fast, so that it is a good method to copy the painted area from the buffer on the widget instead of
repainting the whole window. It's arguments are: first the object to draw to (the destination), here it is our widget, so we have to
use the pointer <bf>this</bf>. The next two arguments give the destination topleft position to start copying to, then follows the
source to draw from with it's coordinates now including the width and height. As the pixmap coordinates are the same as the coordinates
that the widget uses (because our pixmap is drawn into the topleft corner), the coordinates for the source and destination topleft
point are the same. This is something to watch out for in some of the next step, so it may be mentioned here already.

Next comes what happens if we release the mouse button. Then the drawing has to stop when we move the mouse again, so we set
mousePressed to false here:

<code>
void KScribbleView::mouseReleaseEvent( QMouseEvent * ) {
	mousePressed = FALSE;
}
</code>

Now we have finished implementing the user interaction when it comes to the actual drawing operations. The example shows it's not too
complicated to use a document-view model. Just create your document instance so that it contains the contents and copy the contents to
your view.

<sect>Painting and Resizing the Document
<p>

What is left to do are two other virtual event handlers that need a reimplementation. First of all, we have to take care that our
picture gets painted into the window when something else happens: when you open another window that obscures the painting - then you
change to your painting again, but it won't be there, unless your paint event gets processed to redraw the picture:

<code>
void KScribbleView::paintEvent( QPaintEvent *e )
{
  QWidget::paintEvent( e );

  QRect r = e->rect();

  bitBlt( this, r.x(), r.y(), &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
}
</code>

This method also uses bitBlt() to draw the picture from the buffer into the widget. Here, we only need the rectangle that gets
repainted, so we retrieve the geometry from the event ( e->rect() ) and use the coordinates for bitBlt(), just as we did in the
mouseMoveEvent().

The only thing where we didn't do anything about is the size of the pixmap. We didn't set it anywhere - we did not even use the pixmap
in the document class except for loading and saving - but these methods aren't called when creating a new picture. So it seems our
pixmap doesn't have a size nor a predefined background at all (even if we would have set the size, the contents would be random colors
because it is uninitialized).
On the other hand we have the fact that the KScribbleView instances get resized when they show up- at least with the minimum size. This
is the point where we can add the initialization as well, because the user can change the size manually and the widget will receive a
resize event as well. For reasons of simplicity, we want to set the pixmap size the same size the widget has. All this is done in the
event handler resizeEvent():

<code>
void KScribbleView::resizeEvent( QResizeEvent *e )
{
  QWidget::resizeEvent( e );

  int w = width() > doc->buffer.width() ?
  width() : doc->buffer.width();
  int h = height() > doc->buffer.height() ?
  height() : doc->buffer.height();

  QPixmap tmp( doc->buffer );
  doc->buffer.resize( w, h );
  doc->buffer.fill( Qt::white );
  bitBlt( &amp;doc->buffer, 0, 0, &amp;tmp, 0, 0, tmp.width(), tmp.height() );
}
</code>
Here, we first call the resizeEvent handler or QWidget. Then we calculate the size of our picture - because we can resize a window to
make it smaller or bigger, we have to separate these two cases: if we resize to a smaller geometry, the picture shall still contain
it's contents. On the other hand, if we resize to a bigger widget, we have to resize the pixmap as well to that bigger size. The
calculated values are stored in w and h. But before the resize takes place, we create a copy of our pixmap in the document in tmp. Then
we resize the buffer (the document), fill it with white color and then copy back the contents from tmp into buffer. This resizes our
pixmap always syncronous with the widget that displays it but doesn't loose contents which is outside the visible area if the resizing
makes the widget smaller.

Now our first application has gained a step where we can test it's functionality. Just hit "Run" in KDevelop and after KScribble shows
up, you're ready to paint your first picture with it !



<chapt>Copyright <label id="Copyright"> <p>
<tscreen><verb>

KDevelop Copyright 1998,1999 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

</book>











