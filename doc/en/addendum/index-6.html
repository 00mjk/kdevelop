<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>The KDE 2 Developer's Guide: The KDE Daemon</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-7.html">Next</A>
 <A HREF="index-5.html">Previous</A>
 <A HREF="index.html#toc6">Table of Contents</A>
</P>
<H3><A NAME="KDEDAEMON"></A> <A NAME="s6">6. The KDE Daemon</A></H3>

<P>Simon Hausmann 
<A HREF="mailto:hausmann@kde.org">&lt;hausmann@kde.org></A><P>v1.0 26, June 1999
<EM>This documentation describes the KDE Daemon, the services it provides and
how to use it. So if you're dealing with CORBA servers in the KDE or if you're
interested in a smart way of accessing KService data in your application then
you might want to read this and use kded</EM>
<P>
<H3><A NAME="ss6.1">6.1 Introduction</A>
</H3>

<P>The KDE Daemon, herein simply named kded, is a central daemon in the KDE Desktop
Environment. It provides three services:
<P>
<UL>
<LI>The KDE Trader (KTrader) , which provides an easy-to-use but still extremly
powerful interface to the KDE Registry.</LI>
<LI>The KDE Activator (KActivator) , which makes accessing CORBA based services
in KDE the easiest thing of the world ;-) .</LI>
<LI>The KDE Naming Service (KNaming) , which provides a simple but useful
naming service for CORBA Objects.</LI>
</UL>
<P>
<H3><A NAME="ss6.2">6.2 Using The KDE Daemon In Your Application</A>
</H3>

<P>Before we can use any of kded's services, we have to know something about it's
"position" in the KDE and the way it itself and the services can be accessed.
<P>
<P>As kded uses CORBA to communicate with it's clients, your application (as client),
has to
<UL>
<LI>link to the kded library, libkded.</LI>
<LI>link to libmico</LI>
<LI>initialize the MICO ORB</LI>
</UL>
<P>
<P>The first two points are fixed for all clients, the third one depends on the
specific client. In general you have to choices:
<P>
<UL>
<LI>If your application already uses KOM, then you're fine with using
KOMApplication (as you need it anyway) .</LI>
<LI>If you don't want to use KOM, then you can initialize the ORBA "manually":
<PRE>
CORBA::ORB_ptr orb = CORBA::ORB_init( argc, argv, "mico-local-orb" );
</PRE>

Please note that when using this construct or similar ones, your application is
<B>not</B> able to act as CORBA server if you are using KDE/Qt classes at the
same time. This is due to the fact that the ORB needs it's own event loop, beside
the main Qt event loop. Currently only KOMApplication, as part of the KDE Object
Model, implements the needed functionality to combine both event loops and thus
making KDE apps able to serve CORBA Objects.</LI>
</UL>
<P>
<P>Although kded uses CORBA extensively, the API is kept simple and free from
complicated CORBA stuff. In fact when talking about kded and it's API not the
kded server is meant but the KDE Daemon library. This library contains the
interface to the server (for the clients) as well as the whole server functionality.
The reason for this is based on the idea that an application using kded should
not be forced to rely on an existing kded server binary nor a running server at
all. The following three situations may exist when a client app gets started:
<P>
<UL>
<LI>No kded is running and there's no kded server binary in the path. In this
situation libkded will automatically start a local instance of kded in
the application's process.</LI>
<LI>No kded is running but there's a kded server binary available. Here libkded
will start the kded executable and connect to it.</LI>
<LI>kded is already running :-) . The fact that a kded is running is indicated
by a special property on the X Root Window. kded publishes it's IOR
(Interoperable Object Reference) in this property. This also ensures that
a kded instance is specific to a X display and therefore to your KDE session.</LI>
</UL>
<P>To sum it up: libkded will always make sure that the services of kded are available
for your client application, no matter in what alien environment the app is
running :-) . And, although you don't have to care about this, you can optionally
control this behaviour of libkded by adding one of the following three commandline arguments
to your app:
<UL>
<LI>"-kdedlocal" , which will make libkded <B>always</B> start a process-local
instance of kded and it's services.</LI>
<LI>"-kdedremote" , which will make libkded try to look for a running kded
instance before starting a local one.</LI>
<LI>"-kdedior ior_here" , which will make libkded connect to the kded server
specified by the given IOR.</LI>
</UL>
<P>
<P>Your actual interface to kded and it's services is the <CODE>KdedInstance</CODE> class,
defined in kded_instance.h . So if you want to use kded (I guess that's why you're
reading this shit ;) ) then make sure to create <B>one</B> single instance
of it, preferably by adding the following line somewhere in the beginning of
your <CODE>main()</CODE> :
<PRE>
KdedInstance( argc, argv, _a_reference_to_the_orb_here_ );
</PRE>

If you're using KOMApplication as application object (make sure to create the
instance before this line) , then you're fine by specifying <CODE>komapp_orb</CODE> as
reference to the ORB.
<P>
<P>As there is always only one single instance of this class, you can simply access
it by the static <CODE>self()</CODE> method of the class from anywhere you want. No
need to pass KdedInstance arguments all around in your program ;-) .
<P>
<P>For further information about <CODE>KdedInstance</CODE> you might want to read
<CODE>kded_instance.h</CODE> , it's pretty good documented.
<P>
<H3><A NAME="ss6.3">6.3 KTrader</A>
</H3>

<P>As already mentioned in the introduction, KTrader gives you access to the registry.
"Now what the hell is the registry?" you might ask. As this is just a documentation
about kded/libkded, I can only respond: "Please consult the documentation of/in
<CODE>libkio</CODE> for more information" :-} . Just one thing about it here: KTrader loads
the whole and bloaty registry for you. Thanks to the magic of <CODE>libkio</CODE> the loaded
registry will always be in sync with the "real" registry, the .desktop files in
the following standard directories (both types, the system wide and the user ones) :
<UL>
<LI>applnk</LI>
<LI>mimelnk</LI>
<LI>services</LI>
<LI>servicetypes</LI>
</UL>
<P>
<P>Now over to KTrader and it's API. Similar to <CODE>KdedInstance</CODE> there can
be only one single instance. The difference is that you don't have to care
about allocating it, just simply get a reference to the KTrader by calling
the <CODE>ktrader()</CODE> method of <CODE>KdedInstance</CODE> . And: don't
even think about deleting the returned reference! Just simply use it and be
happy with it :-) . (hey, kded is designed to be easy to use, no need for difficult
stuff...)
<P>
<P>The KTrader API is even so simple that it contains only two methods ;-) . But
before I describe these methods you have to know something about the kind of
data KTrader returns. In simple words: You will always get a list of KService
objects. More detailed: The returned list is a <CODE>QValueList</CODE> and the
entries are <CODE>KSharedPtr</CODE>'s (FIXME: will soon be renamed to QSharedPtr,
as it will become part of Qt.... AFAIK) to <CODE>KService</CODE> objects. Please
read the corresponding Qt documentation about these two classes. The big advantage
of using these two template classes is that everything becomes easy for you
and that the memory consumption is kept at a minimum . You don't have to care
about pointers, freeing them and cleaning up the list, as long as you use
<CODE>KTrader::ServicePtr</CODE> variables to hold the KService objects and as
long as you use <CODE>KTrader::OfferList</CODE> to pass the list around in your
program. So: Remember to always use these two types when dealing with KTrader!
<P>Now over to the two methods.
<P>
<P><CODE>KTrader::listServices()</CODE> returns your a list of <B>all</B> available
services in the whole KDE. (no need for further explanations I think...)
<P><CODE>KTrader::query()</CODE> is the key method of this beast. It performs a lookup
in the registry database, given your information about what you want to have.
The first argument is the name of the servicetype which all returned services
must implement. If you're unsure about the word "servicetype" , then you can
replace it with "mimetype" , for most, but not all, cases.
<P>The second argument is an additional constraint expression, which has to be
fulfilled by a service.
<P>The third argument is a preference expression after which the returned services
will be sorted. The value of the expression has to be numeric.
<P>The syntax of these two expressions is equal with the language of the standard
CORBA Trader (this is due to the fact that the parsing code is from the COS
Trader of MICO) . The language is not very difficult and I don't want to bloat
this documentation with further explanations about it. Please consult your
CORBA literature for more information. Just one thing you have to know:
Comparisons are always done with the properties of the KService object,
which are the standard entries (Name, ServiceType, RepoIds, ...) plus
the ones specified in the servicetype declaration and read by KService.
<P>Well, after so much theoretical explanations it's time for some practical example
code:
<!--
KTrader::OfferList
-->

<PRE>
  ...
  //get a reference to the KTrader
  KTrader *trader = KdedInstance::self()->ktrader();

  ...
  //will return a list of all services which implement the servicetype
  //named "text/plain"
  KTrader::OfferList offers = trader->query( "text/plain" );


  ...
  //will return a list of all services which implement the servicetype
  //named "image/gif" and which have the AllowAsDefault property set true
  KTrader::OfferList offers = trader->query( "image/gif", "AllowAsDefault == TRUE" );

  ...
  //will return KSpread ;-)
  KTrader::OfferList offers = trader->query( "KOfficeDocument", "(Exec == 'kspread') and (Path != '/opt/gnome/bin')" );

  ...
  //will return a list of all services which implement the servicetype
  //named "BlahFoo" and which will be sorted (from lowest to highest) by
  //the value of the property "Price" , declared in the servicetype
  //declaration of BlahFoo.
  KTrader::OfferList offers = trader->query( "BlahFoo", QString::null, "min Price" );
</PRE>
<P>
<P>Please note that KTrader, since it queries <CODE>libkio</CODE> for services, will
always return services sorted by the user's preferences for the specific
servicetype. These preferences can be specified in the file "profilerc" .
<P>
<H4>KTraderServiceProvider</H4>

<P>This section requires to be familiar with <CODE>libkio</CODE> and it is meant for everybody who
wants to use KRun in his application.
<P>KRun requires a fully loaded registry in order to resolve mimetype &lt;-> application
bindings. A fully loaded registry means that you need a <CODE>KServiceTypeFactory</CODE> and
a KServiceFactory, which both load the appropriate <CODE>KServiceType</CODE><CODE>KService</CODE> objects.
Now the KServiceType information doesn't need that much memory, but the KService
object really eat loooots of it. And isn't it kind of stupid to load this information
if this is already done by kded? Yes, it is ;-) .
<P>
<P>What we would need is to make KRun query KTrader for KService data, instead of
directly using KServiceTypeProfile. Fortunately KRun is flexible enough for this,
we just need a re-implementation of the KServiceProvider, defined in <CODE>krun.h</CODE>
and used by KRun. Guess what, but KTrader provides you this re-implementation :-) .
Just have a look at the end of <CODE>ktrader.h</CODE>.
<P>
<P>To sum it up: The following line makes KRun query kded, in your application:
<PRE>
  ...
  //place this somewhere BEFORE the first usage of KRun, preferable somewhere
  //in main()
  KTraderServiceProvider serviceProvider;
  ...
</PRE>

That's all, except that you <B>must</B> have a KdedInstance in order to be
able to use it.
<P>
<H3><A NAME="ss6.4">6.4 KActivator</A>
</H3>

<P>One often mentioned problem, when talking about applications which provide
their services via CORBA, is how to start and access these services. Solutions
like making apps write the IOR of an object somewhere into a file in the
filesystem or similar approaches are just hacks ;-) . Better use KActivator,
since it can automatically, on demand, start servers for you or use already
running ones. This is accomplished with the help of the mediators for BOA/POA
and the IMR (Implementation Repository), both provided by MICO. Fortunately
you don't have to deal with IMR entries and the mediators.
<P>
<P>Before you can use KActivator to start a server for you, you have to register
the server's service. There are two possible ways, the last one is highly
recommended though:
<P>
<UL>
<LI>Register and unregister it manually, by using the two corresponding
methods of the KActivator.</LI>
<LI>Go the smart way and provide the necessary information in a .desktop file.
Fortunately KService supports the necessary properties, like repository
ids, activation mode and others.</LI>
</UL>
<P>
<P>For the second point it's important that the .desktop file is available for
KRegistry, by placing it in a directory which gets scanned by the registry.
If your application has already a .desktop file in the applnk tree for example,
then you're fine with adding the necessary fields in there. Otherwise the
directory named "services" (either system-wide or user-local) is the best place
for it. If you provide the CORBA service information this way, then KActivator
will automatically detect it and register it automatically at the IMR. This
means that it is immediately available for KActivator and thus to your client app.
And since KRegistry is such a cool thing :-) , you can do all this even at
run-time, when kded is running. Just place the .desktop file in one of the
right directories for it and KActivator will update the IMR on-the-fly. The
same applies obviously for just deleted or modified .desktop files, which will
make KActivator adjust the IMR. Now you might get the idea why this is the
preferred way :-)) .
<P>
<P>Now that you know how to register CORBA services you will want to know how
to "access" it. <CODE>activateService()</CODE> is your friend here. Simply pass
it the name of the service, the repository id of the server object and the
object's tag and it will return you a functional object reference. That's all :-)
<P>
<P>Depending on the service's activation mode, KActivator will either return a reference
to an already running server or it will start a new instance.
<P>
<P>One note about the returned object reference: This is a virtual reference,
which means that that server object is started when the first call is invoked
on this reference, thus making your server get started "lazy", only on-demand.
But that's just additional information, you don't have to deal and know about
it at all. Just be happy with your functional object reference :-) .
<P>
<P>Want some examples? Here we go:
<P>This is how a .desktop file could look like, assuming that the commandline
"--server" starts the app in CORBA server mode:
<PRE>
Name=MyApp
Exec=fooblah
CORBAExec=fooblah --server
X-KDE-RepoIds=IDL:Foo/Blah:1.0#MyFoo
X-KDE-ActivationMode=shared
</PRE>
<P>
<P>If KActivator "gets" this file, it will register the service and then you're
able to do something like this:
<PRE>
  ...
  KActivator *activator = KdedInstance::self()->kactivator();
  ...
  CORBA::Object_var obj = activator->activateServer( "MyApp", "IDL:Foo/Blah:1.0", "MyFoo );
  ...
</PRE>
<P>
<P>The above example will either start a new fooblah instance or connect to a running
one.
<P>For further information please have a look at the examples in kdelibs/corba/tutorials/kded .
The example application there registers the server manually via <CODE>registerService</CODE> .
<P>Please note: The server <B>has</B> to be started by kded in order to make KActivator
return a reference to a running one. Executing "fooblah" from somewhere else
will <B>not</B> make KActivator use it. This is a problem for persistent
servers like KDesktop for example. But there's a solution available, just read
the next chapter about the KDE Naming Service :-) .
<P>
<H3><A NAME="ss6.5">6.5 KNaming</A>
</H3>

<P>The KDE Naming Service, KNaming, is also a very simple service, but it's pretty
useful and in some cases a very nice solution to make a CORBA client connect to
a persistent CORBA server.
<P>
<P>With KNaming you can bind a freely chooseable name to a CORBA object. And since
kded is system (session) wide available, your object becomes available for any
client which is able to connect to kded.
<P>
<P>There's not much to explain here :-} , so I suggest having a look at the KNaming
API, in <CODE>knaming.h</CODE>.
<P>
<P>Example code can be, again, found in kdelibs/corba/tutorials/kded . Here's just
a short real example situation:
<P>
<P>Just think of KDesktop, that nice app providing your background desktop icons.
It provides some functionality via CORBA, just have a look at kdesktop.idl to
see what I'm talking about. Now the problem for KDesktop is: How can it provide
this service to other apps in the system? Writing an IOR into some file is no
clean solution IMHO, and using KActivator doesn't work because KDesktop does not
get started by kded but by the startkde script on KDE startup. So we find a better
way and make KDesktop register it's object at KNaming. This is done by the following
lines:
<PRE>
  ...
  KNaming *knaming = KdedInstance::self()->knaming();
  naming->bind( "KDesktop", kdesktop_object_here );
  ...
</PRE>

Well, I told you a lie ;) : KNaming does not really bind to "KDesktop" but
instead to "IDL:KDesktopIf:1.0" , but since there's no naming convention
for the naming I have choosen a more readable name, IMHO of course :-) (don't
mind me David :] ) . I personally prefer human readable names ;) , in contrary
to repository ids with tags.
<P>
<P>Back to KNaming and KDesktop: Now any client application, kfmclient for example,
can "connect" to KDesktop. Just like this:
<PRE>
  ..
  KNaming *knaming = KdedInstance::self()->knaming();
  ...
  CORBA::Object_var obj = knaming->resolve( "KDesktop" );
  KDesktopIf_var kdesky = KDesktopIf::_narrow( obj );
  kdesky->selectAll(); //let's confuse the user by selecting all icons ;-)
  ...
</PRE>
<P>
<P ALIGN="RIGHT">

<A HREF="index-7.html">Next</A>
 <A HREF="index-5.html">Previous</A>
 <A HREF="index.html#toc6">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
