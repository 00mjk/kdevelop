<!doctype linuxdoc system>
<book>
<title>The KDE 2 Developer's Guide
<subtitle>The information guide to KDE 2 development, I/O slaves and KOM/OpenParts
<author>Ralf Nolden, Kurt Granroth, Simon Hausmann, David Sweet, Preston Brown, Torben Weis and  Bern Wuebben
<date>Version 0.2, Jan, 19  2000
<abstract>
This Handbook is a collection of various documentation about KDE 2 development. Each chapter remains the copyright of the original
author mentioned at the beginnig of the chapters and in section <ref id="Copyright" name="Copyright">.</abstract>

<toc>

<chapt>Preface
<p>

This handbook has been assembled to provide KDE developers the information they will need when porting their applications to KDE 2,
currently under development. KDE 2 is based on the Qt 2.1 and KDE 1.1.x libraries, whereby the KDE libraries are ported to work with
the current Qt library. Further, the KDE libraries will introduce a component technology that will enable developers to make use of IPC and 
embedding for their applications. 

As KDE application developers not involved in implementing for the KDE core team will probably want to port their applications, they
will not only have to watch out for the changes in Qt, but also for KDE's improvements and additions. As KDE 1.x applications will not
only be binary incompatible but also sourcecode incompatible, we want to provide enough information that can be used by developers that
are using the currently stable KDE 1.x implementation for applications that are suitable for production use, so transitioning will be
made less complicated and further implementations in current projects can be reviewed for possible problems that will arise when
porting.

Therefore, this handbook tries to collect all recently available documentation for porting and developing under KDE 2, but doesn´t make 
any promises on correctness as the KDE and Qt libraries can change every day. You are yourself responsible for updating your libraries 
and prove that your application can still compile and run. KDevelop helps you by a great deal by the fact that KDE 2 and Qt 2 project 
templates are already available in KDevelop for KDE 1.x. The KDE Applications Tutorial Handbook contains a full description how to 
install KDE 2 and Qt 2 parallel to your current KDE 1.x installation and how to use KDevelop 1.x for application design for KDE 2/Qt 2.
 
I want to thank all authors that were willing to contribute their current documentation to this handbook and hope this collection will
be of good use to those who want to stay on the bleeding edge of KDE development.


Ralf Nolden


<chapt>The KDE Developer's mini-HOWTO<label id="mini-HOWTO">
<p>

David Sweet &lt;dsweet@chaos.umd.edu&gt;

August 14, 1999

<em>
To help develop KDE or a KDE application you need to know
how to

(i) find KDE information and code, (ii) use CVS, and (iii)
compile. This document aims to help to you do these things without
losing too much hair.
This HOWTO is geared toward new developers, occasional
developers, and anyone considering contributing the the most excellent
free software project that is KDE.  It addresses questions that I and
others have been asking on the <bf/kde-devel/ mailing list recently
along with some more general information.
You can find a current version of this document at the
<htmlurl url="http://www-chaos.umd.edu/~dsweet/KDE/DeveloperHOWTO"
name="KDE Developer's HOWTO homepage">.
To contribute, comment, or correct, please email me at
<htmlurl url="mailto:dsweet@chaos.umd.edu" name="dsweet@chaos.umd.edu">
</em>

<sect>Information and Source Code


<sect1>General Information
<p>
The K Desktop Environment is an open source Unix desktop created by volunteers from around the world.  There are many ways to 
contribute to the project.  You can write new code, improve old code, write documentation, translate to other languages, create 
artwork, sounds, & music, report bugs, and suggest new features.  If you would like to develop code, read on.  If you would like to 
contribute in another way, please visit the KDE web site (<htmlurl url="http://www.kde.org"> name="http://www.kde.org">) for more information.

KDE uses the Qt toolkit which is developed by Troll Tech (<htmlurl url="http://www.troll.no" name="http://www.troll.no">). The main 
components of the desktop are a file manager (kfm), window manager (kwm), and panel (kpanel).  There are many more utilities and 
applications which are included in the base distribution and available elsewhere. The primary programming language used for development  
is C++, although bindings are available for Python (pyKDE).  The KDE code consists of libraries containing classes for, for example: 
(libkdecore) an application base (KApplication), accessing configuration files (KConfig), launching external processs (KProcess); 
(libkdeui) widgets (KEdit, KFontDialog, KToolBar, etc.); and other utility classes like KFileDialog (a file dialog) and KSpell (a 
spellchecker).  

Various desktop, configuration, and system administration utilities are also included in the distribution.  These are 
some of the things KDE developers work on.  A more recent creation is KOffice, a productivity suite which includes a word processor, 
spreadsheet, and presentation tool The currently released version of KDE is 1.1.2.  

KDE 2.0, which is, perhaps, the main focus of development right now, will include rewrites or major updates of kfm, khtmlw (an HTML 
widget), kpanel, kmail, and maybe kwm, unicode support, Inter-Process-Communication protocols and much more.


<sect1>URLs
<p>
<list>
<item>The main KDE web site is at:  <htmlurl url="http://www.kde.org"
 name="http://www.kde.org">.
<item>The developer's library is at:   <htmlurl url="http://developer.kde.org"
 name="http://developer.kde.org">.
<item> Bug reports can be found at (and sent to):  <htmlurl url="http://bugs.kde.org" name="http://bugs.kde.org">.
<item> Troll Tech (makers of the Qt toolkit) main site:   <htmlurl url="http://www.troll.no" name="http://www.troll.no">.
<item> KDE Source Code and binaries:   <htmlurl url="ftp://ftp.kde.org" name="ftp://ftp.kde.org">  (or mirrors)
<item> Qt Source Code and binaries:  <htmlurl url="ftp://ftp.troll.no" name="ftp://ftp.troll.no">
</list>

<sect1>Mailing lists
<p>
The list <bf/kde-devel/ is for KDE developers in general.  The <bf/kde-koffice/ mailing list is for developers interested in koffice, 
and <bf/kfm-devel/ is for kfm (the file manager) developers.

Send a message to either <bf/kde-devel-request/ or <bf/koffice-request/ with the message "subscribe myid@myserver" (where myid@myserver 
stands for your email address).  Go to the KDE mail page a click on "Mailing Lists" for more information about other KDE mailing lists 
and the mailing list archive. 

Toll Tech provides a list for users of the Qt 2.1 snapshots (discussed below).  You may subscribe to this by sending an email to 
snapshot-users-request@troll.no with the <em/message/ "subscribe". 

As a KDE developer you may want or need a kde email address, like joedeveloper@kde.org.  To obtain one, send an email with a polite 
request to Martin Konold at konold@kde.org. 

To gain access to the KDE CVS respository (discussed below), you firsly need to have a good reason for wanting access.  For example, 
you may be maintaining a CVS module.  If you think you have a good reason, send a polite email request to Stephan Kulow 
&lt;coolo@kde.org&gt;. 

You'll also need to send him an encrypted password to get the account set up. To create your encrpyted password, type:
<tscreen><verb>
	perl -e print\ crypt\('passwd','sa'\)\.\"\\n\"
</verb></tscreen>
where <tt/passwd/ is your choice of password and <tt/sa/ is two random
characters from the set (a-zA-Z0-9./). The output is your encrypted
password.


<sect>KDE CVS

<sect1>Introduction
<p>
The KDE CVS (Concurrent Versions System) is the source code repository for the KDE project.  You can access it via (i) WWW: 
http://www., (ii) cvs utility, (iii) cvsup utility, or (iv) snapshots. You will need CVS access only for (ii); (i), (iii), and (iv) are 
read-only methods and available to the public.


The web page for method (i) explains its usage.  I haven't an explanation for method (iii), cvsup, yet.  Please see 
http://www.kde.org/cvsup.html  { -- Perhaps someone who uses it will contribute a short explanation of usage and information
on obtaining it. -- }

The snapshots, (iv), are .tar.bz2 files which contain a section of KDE code (called "modules"; ex, kdelibs, kdeutils) as it looked on 
some specified day (specified in the filename: ex, kdelibs990517.tar.bz2). The snapshots are posted daily 
in ftp://ftp.kde.org/pub/kde/unstable/CVS/snapshots. { (ii) is described below. }

The repository (or, just "CVS") stores all of the changes made to the source code by all of the contributors so that changes may be 
undone.  Each time a user makes a change (s)he includes a comment so that the devlopment of code can be more easily followed.  These 
comments are sent to the kde-cvs mailing list.  The CVS splits into _branches_ which may contain different versions of the KDE project. 
For example, the two branches being developed now are KDE_1_1_BRANCH and HEAD.  They both are derived from the same code (i.e., if you 
"undid" enough of the changes made to either branch you'd reveal identical source code) but used for different purposes.  Here are some 
branches and descriptions for your reference: 

<itemize>
<item> KDE_1_1_2_RELEASE - code that was considered stable, released,
and distributed as KDE 1.1.2

<item> HEAD - code which will become KDE 2.0.  It is based on Qt 2.1, has a new kwm, kpanel, etc.  LOTS of changes.
</itemize>

<sect1> Using <tt/cvs/
<p>
The cvs utility is probably on your system.  If not, you should visit <htmlurl url="http://www.cyclic.com/cyclic-pages/howget.html" 
name="http://www.cyclic.com/cyclic-pages/howget.html"> To learn to use it I would recommend reading the man page!  But, I've included 
explanations of some common functions below. 

Let's assume for this section that your username is <tt/joedeveloper/. As written below you should enter all of these commands from  
some base directory.  (KDE/CVS is not a bad choice!) 

Set the environment variable <tt/CVSROOT/ to

<tt>:pserver:joedeveloper@cvs.kde.org:/home/kde.</tt>

<bf/Listing CVS modules/ You can't do this directly unfortunately.  You can, however, view the contents of the file /home/kde/modules 
with 
<tscreen><verb>
cvs -z6 co -c
</verb></tscreen>

The <tt/-z6/ option tells the server to compress the code at "level 6" before sending it to you.  This may speed things up for you.  
(In this case, since the module listing is small, it may not matter.)

<bf/Checking out a module/, e.g. kdelibs from HEAD
<tscreen><verb>
cvs -z6 checkout -r HEAD kdelibs
cvs -z6 checkout kdelibs
</verb></tscreen>

The -r options tells cvs which branch you want to checkout from.  The
default is the HEAD branch.

<bf/Checking out a module/, ex. kdelibs, from KDE_1_1_2_RELEASE
<tscreen><verb>
cvs -z6 checkout -r KDE_1_1_2_RELEASE kdelibs
</verb></tscreen>

<em/Note/: you could use co as an abbreviation for checkout.

<bf/Checking out an application from within a module/ (ex kjots, which
is in the kdeutils module) from the HEAD branch
<tscreen><verb>
(1)	cvs -z6 co -l kdeutils
(2)	cvs -z6 co -l admin
(3)	cvs -z6 co -l kdeutils/kjots
(4)	cd kdeutils; ln -s ../admin
</verb></tscreen>

The <tt/-l/ in line (1) tells cvs not to recurse the subdirectories of kdeutils.  This means will get the configure script and its 
companions (discussed below), but none of the application source code. 

Line (2) gets the admin directory which contains support files for autoconf and friends.  (This directory is retrieved automatically 
when checking out an entire module.)

Line (3) gets the kjots source.

Line (4) makes a link to the admin directory.  (This is better than copying or moving the directory here.  If you leave admin where cvs
put if then you can easily update the admin directory with cvs.  You could also make links to admin from any other modules you check 
out this way and thus have only one, up-to-date copy of admin.)

<bf/Updating source code you've previously checked out/ (ex. kdeutils/kjots)
<tscreen><verb>
	cvs -z6 update -P -d kdeutils/kjots
</verb></tscreen>

The source code for kjots on your hard drive will be updated to match the code in the CVS.  You don't need to specify the branch here.  
The correct branch is stored in <tt>kdeutils/kjots/CVS/Tag</tt>.

<bf/Commiting changes/ (putting them into CVS) (ex. kdeutils/kjots)
<tscreen><verb>
cvs -z6 commit kdeutils/jots
</verb></tscreen>

You'll be prompted to edit a comment.  Enter a short one which desribes the changes you're making with this commmit.  (You can use
your editor of choice by setting the EDITOR or CVSEDITOR environment variable.)

<bf/Adding a file/ (ex. kdeutils/kmyapp/greatnewcode.cpp)
<tscreen><verb>
(create the file first!)
cd kdeutils/kmyapp
cvs add greatnewcode.cpp
cvs commit
</verb></tscreen>


<bf/Deleting a file/ (ex. kdeutils/kmyapp/badoldcode.cpp)
<tscreen><verb>
cd kdeutils/kmyapp
rm badoldcode.cpp
cvs remove badoldcode.cpp
cvs commit
</verb></tscreen>

<bf/Adding a directory/ (a module, like a new app) (ex. kdeutils/kmyapp, with the source file kmysource.cpp)
<tscreen><verb>
cd kdeutils
mkdir kmyapp
(create the kmyapp/kmysource.cpp file)
cvs add kmyapp
cvs add kmyapp/kmysource.cpp
cvs commit    (actually puts the directory and file in the CVS)
</verb></tscreen>

<em/Note/: You need to have files in a directory to commit it.
<bf/Removing a directory/ (a module, like a new app) (ex. kdeutils/kmyapp)
<tscreen><verb>
cd kdeutils/kmyapp
(delete all files, as described above in "Deleting a file")
cd ..
cvs -P update  (will remove the local kmyapp automatically)
</verb></tscreen>



<sect>Compiling and Safe Development Practices (with configure)
<p>
Before you start downloading and compiling the latest sources you should be aware that there's a good chance they won't work!  They are
in a state of constant development so they could very well have bugs.

Knowing this, you should find a way to compile and run new KDE stuff without interfering with your existing stable KDE setup.  Here's  
one way, using the HEAD branch as an example.  We, again, assume your login is joedeveloper.  We also assume that your home directory 
is in /home/joedeveloper.  (This would be the case for Red Hat systems.)

<sect1> Organizing
<p>
Make a directory called KDE in the home directory of your *user* account.  You should not be doing any of this as root!  Make another
called KDE/CVS-HEAD.  cd into that directory and get the KDE sources from the HEAD branch that you want.  The (minumum) modules needed 
to use an application are: kdesupport, kdelibs.  You should compile and install them in that order (see below for compiling).  Others 
you might want are: kdebase, kdeutils, kdegraphics, etc. Now, make a directory called KDE/kde-HEAD.  This is where you'll store the
compiled code from the HEAD branch -- as well as Qt 2.1!

<sect1> Compiling Qt 2.1
<p>
 Let's get Qt 2.1. Take the KDE copy of the current Qt library from the KDE CVS with

<tscreen><verb>
cvs -z6 co qt-copy
cd qt-copy
setenv QTDIR $PWD     (if you use csh/tcsh)
OR
export QTDIR=`pwd`    (if you use bash)
make -f Makefile.cvs (creates symlinks -without that, qt will not compile !)
./configure   (-gif optionally)
make
</verb></tscreen>


<sect1> Compiling KDE (HEAD)
<p>

Now, for the KDE code.  <tt/cd/ to KDE/CVS-HEAD/kdesupport.  Type

<tscreen><verb>
make -f Makefile.cvs
./configure --prefix=/home/joedeveloper/KDE/kde-HEAD
--with-qt-dir=/home/joedeveloper/KDE/kde-HEAD/qt-copy
--with-qt-libs=/home/joedeveloper/KDE/kde-HEAD/qt-copy/lib
make

If all goes well, then

make install

If not, try to fix things, then type

make install

Repeat this process for the other modules.  You should alter the
./configure line to read
	./configure --prefix=/home/joedeveloper/KDE/kde-HEAD
  --with-qt-dir=/home/joedeveloper/KDE/kde-HEAD/qt-copy
  --with-qt-libs=/home/joedeveloper/KDE/kde-HEAD/qt-copy/lib
</verb></tscreen>

<sect1> Compiling tips
<p>
<itemize>
<item> I usually put that long configure command into a file called <tt/conf/ and leave it in my CVS-HEAD directory.  Then I can do a 
<tt>../conf</tt> from any module and get a good configure. 
<item> It seems that you need to compile and install qimageio (part of Qt) separately.  Just 
<tt/cd/ to <tt>/$QTDIR/extensions/imageio/src</tt> and type <tt/make install/ 
</itemize> 

<sect>Documentation
<p>

It's important to document your application so that end-users can make the most of it.  You should be clear and concise.  Describe any
non-standard installation, usage and UI features.  There's no need to talk about how to use the <em/File/ menu, for example, unless 
you've put some special entry on it.  Include contact and bug-reporting information as well as a hyperlink to the application's home 
page. Writing documentation for KDE 2 should be done in docbook-sgml. Look at <htmlurl url="http://developer.kde.org" 
name="http://developer.kde.org"> for more details how to get the needed packages for installing the docbook tools. KDE extends these 
tools by the module kdesdk/ksgmltools. This module also contains information where to get the docbook tools, additional documentation 
as well as how to use docbook and KDE.
  
You should also document your widgets and other classes.  You can include comments in your header ( <tt>.h</tt>) files which describe
each <tt/public/ or <tt/protected/ method.  It you do this as you write the methods it will make the documentation proceSss seem 
easier. (It may also help you be certain about what function(s) that method is to perform.)  The script <tt/kdoc/ will turn your header 
files into beautiful class documentation.  You can see examples of <tt/kdoc/ output if you look at <htmlurl 
url="http://www.ph.unimelb.edu.au/~ssk/kde/srcdoc/kdecore/index-long.html"   
name="http://www.ph.unimelb.edu.au/~ssk/kde/srcdoc/kdecore/index-long.html">. This is the annotated list of the core KDE classes. 

You can find <tt/ksgmltools/ in the KDE SDK which is available in the kdesdk module of CVS, <tt/kdoc/ in the kdoc module.  (Methods for 
getting things from CVS are described above.)



<sect1> KDOC:  The KDE Class Documentation Tool for C++

<p>
It's called <tt/kdoc/ and is in the kdedoc subdirectory of the CVS
module kdesdk.

If you mark up your header files like this:
<tscreen><verb>
  /**
   * Short description of this class
   *
   * This is a longer description of my class.  It does the following
   * @li Some bulleted thing
   * @li Some other bulleted thing
   *  You should use it when ...  It's not appropriate for ...
   *
   * @author My Name <myemail@wherever.edu>
   * @version 0.0.1
   **/

class KMyClass
{
        .
  /**
   * Describe method.  It takes &lt;i&gt;argument&lt;/i&gt; to mean ...
   *
   * @return A pointer to another class
   * @see KOtherClass
   **/
   KOtherClass *method (int argument);
}
</verb></tscreen>

The text in the comments beginning with <tt>/**</tt> (two asterisks,
mind you!) will be taken by <tt/kdoc/ as class documentation and
formatted appropriately.  You can use some HTML tags (like the
&lt;i&gt; above).  The <tt/@author/ and other tags are meaningful
to <tt/kdoc/ and used for formatting.

To run <tt/kdoc/, use the following command
<tscreen><verb>
 kdoc -dhtml -L$KDEDIR/share/kdoc -a Title header1.h header2.h ...
</verb></tscreen>

This instructs <tt/kdoc/ to generate HTML output (the default) in the
<tt/html/ directory (by the <tt/-d/ option) from the specified header
files.  It uses <tt/Title/ as the title for the documentation. ( <tt/-a/
says to do work on all header files, even if they don't "ask for it".  I
haven't told you how to "ask for it."  The <tt/-L/ tells kdoc where
its libraries are.)  Type <tt>kdoc -h</tt> for more information.


<sect> Packaging and Submitting Code to KDE

<sect1> Packaging
<p>
'Packing' means putting your (in this case source) code into some
format that is
<itemize>
<item> easy for others to configure and install, and
<item> easy to transfer,
<item> can be indexed so that it is easy to find.
</itemize>

These three concepts are expanded upon in the next three subsections.

<sect2> GNU Configure
<p>
The standard KDE application (or other code) source code package includes the GNU <tt/configure/ script which determines some 
information about the user's system and provides it to your source code as <tt/#define/ statements in a header file called
<tt/config.h/.

To get started with this, get the kdesdk from CVS using a method described above.  Then prepare kexample, an example package, for your 
application 

<tscreen><verb>
   cd kdesdk
   cd kexample
   make -f Makefile.cvs
   cd ..; cp -r kexample ~/KDE/kmyapp-0.0.1
</verb></tscreen>

(That last directory is just an example.  Replace kmyapp with your application's (or widget's) name, and replace 0.0.1 with its version
number.)

Now, we'll put your source code into the example package.  Let's say your source code was in the directory ~/KDE/KMyApp:

<tscreen><verb>
   cd ~/KDE/kmyapp-0.0.1
   mkdir kmyapp
   cp ~/KDE/KMyApp/*.cpp kmyapp
   cp ~/KDE/KMyApp/*.h kmyapp
   (There may be other files to copy, but leave your old Makefile behind!)
</verb></tscreen>
Now, edit kmyapp-0.0.1/Makefile.am and change the line
<tscreen><verb>
   SUBDIRS = kexample
</verb></tscreen>
to
<tscreen><verb>
   SUBDIRS = kmyapp
</verb></tscreen>

<em/Note/:  kmyapp here refers to the subdirectory by that name.  You could include more subdirectories to be compiled.  For example:
<tscreen><verb>
   SUBDIRS = kmyapp kmysupportclass
</verb></tscreen>

Also edit the last line of configure.in to read

<tscreen><verb>
AC_OUTPUT(Makefile \
          kmyapp/Makefile \
          po/Makefile)
</verb></tscreen>

The <tt/po/ directory contains translations of strings that you used in your code (this is about i18n(), which is not covered in this
HOWTO). We'll get to that it a minute.

Now we want to set up the Makefile for the kmyapp subdirectory.  Edit <tt>kmyapp/Makefile.am</tt> according to the instructions given 
in the comments.  They should be clear enough.

Now <tt>cd ~/KDE/kmyapp</tt> and type
<tscreen><verb>
   ./configure
</verb></tscreen>
This should create:
<itemize>
<item> Makefile
<item> kmyapp/Makfile
<item> config.h
</itemize>

You can now include config.h in your source code with <tt>#include "../config.h"</tt> and have your code compile differently on  
different systems based on the <tt>#define</tt>s.  Eh?  Well, different systems have slightly differnent ideas about implementing  
standards and such, and your code my need take this into account to be portable, i.e. to work on various Unices.  Take a look inside 
<tt>config.h</tt> for descriptions of the <tt>#define</tt>s.


<bf>Shared Libraries!</bf>  If you are packaging a widget or other class you should be compiling a shared library.  Luckily, this is 
easy to do within the kexample packge.  You only need to change the Makefile.am that resides in your code's sudirectory.  Unluckily, 
now example for a shared-library Makefile.am is included. So, I've included one in the next section. <em/Note/:  If you distribute a 
widget, you should also distribute a small program which tests the widget.  Put  that program in the same package in another 
subdirectory and have it compile along with the widget. 

Next, make a compressed archive.  You can do it this way
<tscreen><verb>
   cd ~/KDE/kmyapp
   make dist
   OR
   tar -cvf kmyapp-0.1.1.tgz kmyapp-0.1.1
</verb></tscreen>
or however you like.  Just be sure that the archive expands to <em/one/ directory containing all of the files.  This is neater and 
easier for the user to deal with. 

<sect2> Example Makfile.am for a Shared Library
<p>
<tscreen><verb>
# Example Makefile.am for a shared library.  It makes a library
#  called "example" as libexample.so.2.1.2
# This Makefile.am was taken from the kdelibs distribution and modified
#  to serve as an example.
#
# David Sweet
#

INCLUDES=  $(all_includes)

lib_LTLIBRARIES  = libexample.la

# Note:  If you specify a:b:c as the version in the next line,
#  the library that is made has version (a-c).c.b.  In this
#  example, the version is 2.1.2.
libexample_la_LDFLAGS = -version-info 3:2:1 $(all_libraries)

include_HEADERS = header1.h header2.h\
                  header3.h

# Which headers shouldn't be installed when a   make install  is done?
noinst_HEADERS = version.h

libexample_la_SOURCES = code1.cpp code2.cpp
                        code3.cpp

#  AUTO is great.  This takes care of all of your  moc'ing
#   dependencies.
#  (You still need to include, for example, header1.moc in code1.cpp.)
libexample_la_METASOURCES = AUTO
</verb></tscreen>


<sect2> LSM file
<p>
Next, you need and LSM file.  You can keep a copy in kmyapp-0.1.1
for distribution.

Here's a sample <tt/.lsm/:

<tscreen><verb>

Begin3
Title:          KLab
Version:        0.1.0
Entered-date:   3/1/99
Description:    GUI and more for RLab
Keywords:       kde rlab math plot plotting
Author:         David Sweet &lt;dsweet@chaos.umd.edu&gt;
Maintained-by:  David Sweet &lt'dsweet@chaos.umd.edu&gt;
Home-page:      http://www.glue.umd.edu/~dsweet/KDE/KLab
Primary-site:   ftp://ftp.kde.org/pub/kde/unstable/apps/scientific
Alternate-site: http://www.glue.umd.edu/~dsweet/KDE/KLab/
Original-site:  ftp://upload.kde.org/pub/kde/Incoming
Platform:       unix
Copying-policy: GPL
End

</verb></tscreen>

You can copy and paste this text into a file called "kmyapp.lsm" and make the appropriate changes.

<sect1> Submitting
<p>
If you are hacking at CVS, you should follow the commit procedure outlined above.  If you want to submit changes to code
that you are not maintaining, you should first check with the maintainer of the application.  You can usually find his/her email 
address in the directory containing the source.  Also check the program's "About" box if it has one.  If no maintainer is specifically 
listed, you should contact the author.

If you are developing outside of CVS, you can submit your code (widgets, applications, etc.) via FTP to
<htmlurl url="ftp://upload.kde.org/pub/kde/Incoming" name="ftp://upload.kde.org/pub/kde/Incoming">

When you do this be sure to include an <tt/.lsm/ (Linux Software Map) file. This way your code can be automatically placed in the 
appropriate spot on ftp.kde.org and its mirrors and an announcement can be automatically sent to the kde-announce mailing list.

<em/Note/: The <tt/.lsm/ file should be uploaded separately from the source code (as a plain ASCII file).  The source code should be
packaged as a .tar.gz (or .tgz) or .tar.bz2.  This archive should expand to a single directory with all of your stuff in it.


<sect>Acknowledgements
<p>
I'd like to thank the following people for their suggestions (in no particular order): Roberto Alsina, Waldo Bastian, Harri Porten, 
Samuel Wuethrich, Richard Moore, Daniel Naber, Ralf Nolden, Martin Konold, and Pietro Iglio, Stephan Kulow, Junji Takagi.

<sect>About this document

<sect1> Finding
<p>
The current version of this document is available at <htmlurl url="http://www.chaos.umd.edu/~dsweet/KDE/MiniHOWTO"  
name="http://www.chaos.umd.edu/~dsweet/KDE/MiniHOWTO">. 

A Japanese language version is available at <htmlurl url="http://www.asahi-net.or.jp/~hc3j-tkg/kde-jp/DevelMiniHOWTO-jp.txt" 
name="http://www.asahi-net.or.jp/~hc3j-tkg/kde-jp/DevelMiniHOWTO-jp.txt"> thanks to Junji Takagi. 

This document is included in the KDE Developer's Web Site (<htmlurl url="http://developer.kde.org" name="http://developer.kde.org">) 
and is part of the KDevelop (<htmlurl url="http://www.kdevelop.org" name="http://www.kdevelop.org">) programming manuals.

<sect1> Changes
<p>
<sect2> Changes from version &lt;July 1, 1999&gt; to version &lt;March, 11, 2000&gt;:
<p>
 <itemize>
 <item> Added "About this document" section
 <item> Added more acknowledgements
 <item> Multiple formatting changes (thanks Ralf!)
 <item> Fixed instructions for getting CVS access
 <item> updated contents for current KDE 2 development state (March, 11, 2000)
 </itemize>

<chapt>Porting to KDE 2 and Qt 2.1
<p>
Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name="Ralf.Nolden@post.rwth-aachen.de">

<em>
This howto describes all currently known changes and gives advice how to change your KDE 1.x/ Qt 1.x application to the new libraries.
The KDE sections are assebled using the KDE2PORTING notes that can be found in your kdelibs package as well, so if something doesn´t 
run like described below, see that file for updated information. 
</em>

<sect>Porting used Qt Methods/Classes
<p>
At the time of writing, the Qt library is on its way to be shipped in version 2.1. Therefore, this section will refer to changes 
between the 1.44 version to the 2.1 version. A good start for porting used Qt methods/classes is the Qt online documentation. At the 
start page, you will find the following sections:

<itemize>
<item>Key Features in Qt-2.1 
<item>Detailed Changes Notes 
<item>Porting from Qt 1.x to Qt 2.0
</itemize>

Reading these documents will give you a first impression what has been done to make the Qt library even better and which problems may 
occur when porting your code. 

The Qt library also ships with two conversion scripts that may help you porting. Those are qtrename140 and qt20fix, which are placed in 
your qt-directory/bin. If you don´t have this directory in your path, you should do so before running the apps. qtrename140 can be run 
in your sourcecode directory directly, qt20fix has to be appended to your make-command and has to be re-run as long as it tells you. If 
your make supports the -k option, you should append that to speed things up. 
  
After using the scripts you should recompile your project to fix any other errors that occur. If you´re developing a Qt-only 
application, you should make use of Qt´s internationalization features introduced with Qt-2.0. For that, you have to use the tr() 
function on all strings visible to the user, such as menubar entries, tooltips, labels etc.

See the documentation for QApplication and your Qt online documentation about internationalization with Qt.
 
<sect>Porting to KDE 2: General Issues
<p>

We did our best to clean up the header files of kdelibs, so they do not include unnecessary bloat for your application. As a 
consequence, you may notice that some header files are missing from your source files as
they have been included before by kapp.h for example. There is a script in kdesdk/scripts called "fixheaders" that takes care of most 
of these cases. Just call "make -k 2>&1 | perl .../fixheaders" and it will try to look after the error messages and add includes as it 
recognize the errors.




<sect>KHTMLW
<p>

khtmlw has been replaced with khtml.
- KHTMLView has vanished. Just use KHTMLWidget, which does scrollbar
  managing for free.
- A lot of the API has changed. If you just want to open a file/URL,
  you just need to do:
	KHTMLWidget *w = new KHTMLWidget();
	w->openURL(myURL);
- khtml uses Qstring's instead of char *'s now. This means, that most
  of the api has changed. In all functions:
     const char * -> QString
     QStrList -> QStringList
  The only exception for the moment is KHTMLWidget::write(), which does
  also exist in a const char * version.
- you won't need the getKHTMLWiget function anymore. Just replace
	getKHTMLWidget->xxx() with xxx()
- xxx(QString) -> xxx(const QString &)
- consistent naming. All getXyz() functions are renamed to xyz()
- replaced/changed functions:
	KHTMLWidget::setDefaultFontBase() -> setFontSizes().
	x/yOffset()                       -> contentsX/Y()
	getSelectedText(QString &)        -> QString selectedText()
	findTextEnd() has vanished. just remove the call from your code
	gotoXY(x, y)                      -> setContentsPos( x, y)
	docWidth()			  -> contentsWidth()
	docHeight()			  -> contentsHeight()
	...
- Don't forget to change the link-flags! (-lkhtml -lkjava instead of -lkhtmlw)


<sect>KIntegerLine, KIntLineEdit
<p>
  KIntegerLine and KIntLineEdit  have been replaced by KIntNumInput.
  The new header file is called knuminput.h.

  The new KIntNumInput can have an optional slider attached, ensures
  that the entered value is in a given range (use MAX_INT or similar
  if you don't care about the range) and can maintain a descriptive
  label and also a unit for the edited value.

  The API is almost the same and it simplifies existing code a bit,
  so give it a try. If you need more functionality, please contact
  me (Dirk A. Mueller <mueller@kde.org>).

  The additional class KDoubleNumInput gives you the same look & feel,
  but allows you to edit floating point numbers.

  <sect>KLocale
  <p>

- i18n is no longer a macro

  KApplication::getApplication()->getLocale()->translate

  but a function on it's own. klocale is obsolete and replace every call
  to klocale->translate with i18n.

  The return value of i18n is also no longer a const char*,
  but a unicode qstring.

<sect>KApplication
<p>

  doesn't hold any longer a KLocale instance. With this getLocale()
  and isLocaleInstantiated are now replaced by KGlobal::locale()

  it also doesn't hold a KiconLoader instance. As this also getIconLoader()
  has been removed. Replace kapp->getIconLoader()->loadIcon() with
  BarIcon() or use KGlobal::iconLoader() instead of getIconLoader()

  kde_*dir() have been removed as they require a unique top level directory
  for all applications (KDEDIR). This concept doesn't exist in KDE 2.0
  any more.

  Replace code that uses kde_*dir() + filename with calls to
  locate(filetype, filename) where filetype is what * used to be
  in kde_*dir(). locate is defined as function in kstddirs.h to call
  KGlobal::dirs()->findResource

  generalFont() and fixedFont() are deprecated and will be removed soon.
  Please use KGlobal::generalFont() and KGlobal::fixedFont() instead.

  appName() is deprecated. Please use QApplication::name() or instanceName
  instead.

  The methods tempSaveName() and checkRecoverFile() return QString
  now. The returned values must _not_ be free()d.

  helpMenu() has been moved to KTMainWindow. aboutKDE(), aboutApp() and
  appHelpActivated() have all been removed See section for KTMainWindow
  for more info.

  The KApplication constructor has changed. Command line arguments and
  program name should no longer be passed to KApplication but to 
  KCmdLineArgs. KCmdLineArgs performs command line parsing and a command
  line help. See kdelibs/kdecore/kcmdlineargs for more info.

<sect>KCmdLineArgs
<p>

  KCmdLineArgs is a new class that handles command line parsing and
  command line help. It is now required that your application
  specifies at least:
  - It's name.
  - A short description what it does. (e.g. 1 line)
  - A version.
  - All command line options that it supports.

  KCmdLineArgs itself will add the command line options supported by Qt 
  and KApplication.

  You can also use the KAboutData class to specify name, description and 
  version.

  In return for this information you can query KCmdLineArgs whether an 
  certain option was specified on the command line and your application 
  now automatically supports --help and --version. It aborts with a
  usefull error message when the command line contains a syntax error.
  See kdelibs/kdecore/kcmdlineargs for more info.

<sect>Drag´n Drop
<p>
KDNDIcon, KDNDDropZone, KDNDWidget, kdecore/drag.h

KDE Drag and Drop is Dead.  Long live Qt Xdnd.

Xdnd is better anyway, because it has been adopted by all the other
major GUI toolkits still under active development (this precludes
Motif, but maybe we can convince the lesstif guys!).  Some changes
are necessary to convert your old KDND-based stuff to Qt DND.

- Remove drag.h from all of your sources / header files.
- Remove KDNDDropZone object creations.  Instead of creating an
  object of this type and then connecting it to some arbitrary slot
  to handle drops, call "setAcceptDrops(true)" in your widget
  constructor and then override the protected methods dragEnterEvent,
  dragMoveEvent, dragLeaveEvent, and dropEvent.
- You should be aware that to handle drops, you will either have to
  inherit a widget and then override the methods mentioned above,
  or install an event handler for the widget in that widget's parent,
  and then handle QEvent::DragMove or QEvent::Drop inside there (if
  you want to avoid inheritance).
- You can emulate the old DndURL drop-type behaviour with the Qt
  Drag Object type QUriList.
- You can start a drag from inside your widget's mouseMoveEvent
  method if you wish.
- Qt includes a Drag and Drop tutorial.  We suggest you read that
  now if you are confused.
- QMultiLineEdit has already a DnD interface that accepts text/*
  If you want to add support for other mimetypes, you need to
  re-implement all DnD-methods (also dragMoveEvent()) and pass
  QTextDrag's to the parent methods.
- QTextDrag also accepts text/uri-list, which means that you
  always need to check for QUriDrag first if you want to get
  both working.
- The mimetype for Uri's is now text/uri-list. If you've used
  the proprietary Qt 1.x url/url, you need to adjust that.

<sect>KConfigBase, KConfig, KSimpleConfig
<p>

  These classes have been largely re-implemented.  The external API
  remains mostly the same, with the single notable change that
  the groupIterator and entryIterator methods have been removed and
  instead replaced by groupList (which returns a QStringList of groups)
  and entryMap(const QString &group) (which returns a QMap of entries
  in the specified group).  This is due to internal changes in KConfig
  which would make providing iterators possibly rather difficult.

  Much more extensive documentation on the KConfig and friends API can
  be found in the kdoc generated documentation from the header files,
  and in kdecore/KCONFIG_DESIGN.

  To use the new iterator, you will probably want to do something like
  this:

  QMap<QString, QString> tmpMap = config->entryMap(myGroup);
  QMap<QString, QString>::Iterator aIt(tmpMap.begin());

  for (; aIt != tmpMap.end(); ++aIt) {
   // body here.  Access iterator key as aIt.key(),
   // data as *aIt.
  }

<sect>KFM
<p>
libkfm has disappeared.

  Lots of other functionalities have been taken out of kfm, some being
  now in libkio, some in libkonq.
  Replacement table :
  
<itemize>
<item>   KFM::download         -> KIONetAccess::download (kdelibs/kio/kio_netaccess.h)
<item>   KFM::removeTempFile   -> KIONetAccess::removeTempFile
<item>   refreshDesktop, sortDesktop, selectRootIcons : removed; kdesktop handles it
<item>   KFM::configure        -> see konqueror interface (IDL, soon DCOP)
<item>   KFM::openURL          -> "(void) new KRun (url)" (kdelibs/kio/krun.h)
<item>   KFM::refreshDirectory -> not needed anymore since konqy/kdesktop use KDirWatch
<item>   KFM::openProperties   -> "(void) new PropertiesDialog (url)" (kdebase/libkonq/kpropsdlg.h)
<item>   KFM::exec             -> "(void) new KRun (url)" (kdelibs/kio/krun.h)
<item>   KFM::copy, KFM::move  -> KIOJob (async, see kio_job.h)
                            or KIONetAccess (sync, see kio_netaccess.h)
<item>   DlgLocation           -> Use KLineEditDlg (kdeui/klineeditdlg.h) instead
</itemize>

<sect>KGlobal: access to KDE global objects.
<p>

KGlobal allows centralized access to KDE global objects without including
extraneous headers. object creation is deferred if possible.

All methods are static and headers for returned types are not included. You
must have created a KApplication object before the methods can be used.

<code>
	#include<kglobal.h>
	#include<kconfig.h>     // Needed to use KConfig
	#include<klocale.h>     // Needed to use KLocale
	#include<kiconloader.h> //

	...
        	KConfig *appcfg = KGlobal::config();
	        QString mystr	 = i18n( "This is a string" );


		KIconLoader *loader = KGlobal::iconLoader();
</code>
		
<sect>KIconLoader
<p>
KIconLoader in 1.1 used to mix icons for applications and for toolbars.
This has changed, so you may notice that your application doesn't find
the right icons. loadIcon (used by BarIcon) returns only toolbar icons.
If you need icons for applications, use loadApplicationIcon.
loadMiniIcon and loadApplicationMiniIcon have been removed, instead
loadApplicationIcon now takes a "size" argument where you can specify the
size of the icon (small, medium, large).
The other big change you may notice, is that ICON and Icon have been
removed as they caused big confusion for not loading application icons
(see above). For this we added BarIcon which does the same as ICON before.
The third change in this row is that loadIcon doesn't need the extension
anymore, but looks for standard extensions (png, xpm) itself. If you hard-
coded .xpm, loadIcon will issue a warning at runtime, but will still work
in stripping off the .xpm part


<sect>KDialog
<p>
KDialog is no longer defined in kwizard.h. Include kdialog.h instead.


<sect>KTMainWidget
<p>

view_* public variables do no longer exist. There is really no reason
for an app to use this information. If you do need it anyway, use
mainViewGeometry() instead.


<sect>automoc
<p>

automoc has been removed from the admin directory. It has been replaced
by am_edit which provides a lot of additional features.

<sect>kcharsets
<p>

The kcharsets class has been completely rewritten, and most of it has
vanished, since support for it moved to Qt.

Most applications will only need to replace kapp->getKCharsets() with
KGlobal::charsets().

For conversion of various input formats to QStrings, please have a
look at QTextCodec and classes derived from it.

Character entities are now  converted from and to QChars. The name has
changed from convertTag to fromEntity and toEntity.

To get a font, which can display a certain charset (if such a font
exists), you can use the KCharsets::setQFont methods. Input is a font and
a charset. Kcharsets tries to find an output font, which matches the
input font most closely, but can display the given charset.


<sect>KWizard, KNoteBook
<p>
KWizard is based on QWizard now. The API has changed. Consult Qt's
documentation and kdelibs/kdetest/kwizardtest.cpp for an example use.
KNoteBook (deeply entwined with the former KWizard) has been removed until
someone is willing to port it to work with the new wizard. If you want to
use it you'll find the necessary files in kdegraphics/kiconedit.


<sect>KSpinBox, KNumericSpinBox
<p>

These classes have been replaced by QSpinBox. API is almost the same
HINTS:
  - valueincreased()/valuedecreased -> valueChanged()
  - getValue() -> value()


<sect>KClipboard
<p>
KClipboard has been removed. In case you've been using KClipboard,
QClipboard is the way to go now, as it has all the functionality the K
version had, and more.

<sect>KPanner, KNewPanner
<p>
KPanner and KNewPanner have been removed.  QSplitter does everything
KPanner did and more. The api is similar, but not compatible.
Basically to set it up so that you have a vertical splitter between a
listbox, a listview and multi line editor, you would do something like
this:

    QSplitter *split = new QSplitter( parent );
    QListBox *lb = new QListBox( split );
    KListView *lv = new KListView( split );
    QMultiLineEdit *ed = new QMultiLineEdit( split );

As you can see you are not limited to two children.  Additionally, you
do not have to call activate when you are done, and opaque resizing is
possible if you call setOpaqueResize(true).

////////////////////////////////////////////////////////////////////////
// * KTreeList, KTreeListItem

Use KListView, QListViewItem instead. API is almost the same, you only
need to add a Column (KListView::addColum) before KListView is useable.

KListView has no addChild(), insertItem() and removeItem() calls. Inserting
a root item is done by constructing a QListViewItem with the KListView
passed as the parent widget. adding a child item is done by constructing
a QListViewItem with the parent item as parameter. removeItem() should
be replaced by delete <pointer to item>.

The root items are not shown in a tree fashion by default. to get this,
use KListView::setDecorativeRoot(true).

Expanding and collapsing can by done by using QListViewItem::setOpen(bool).


/////////////////////////////////////////////////////////////////////////
// * KMsgBox

KMsgBox has been superseded by QMessageBox. Which has been superseded
by KMessageBox.

- KMsgBox had return codes starting with 1 for the first button, 2 for
  the second, and so on.  KMessageBox defines an enum which you should
  use instead.
- Please note that you shouldn't add the name of your application
  to the caption argument. It is already added automatically.

////////////////////////////////////////////////////////////////////////
// * KCombo

KCombo has been removed.  Use QComboBox instead, it is completely
compatible with the old KCombo API.  The method that you may have problems
with is the old KCombo::setText.  This has been renamed to
KCombo::setEditText.

////////////////////////////////////////////////////////////////////////
// * KQuickHelp

KQuickHelp, the "super-tooltip" widget, has been replaced by QWhatsThis.
It provides a compatible API and almost the same look and feel, in addition
to some new functionality.

////////////////////////////////////////////////////////////////////////
// * KPixmap::gradientFill

Use

KPixmapEffect::gradient(KPixmap&, QColor, QColor, enum KPixmapEffect::GradientType, int)

instead. Hence:

pix.gradientFill(ca, cb, direction, ncols)

becomes, for direction == true :

KPixmapEffect::gradient(pix, ca, cb, KPixmapEffect::VerticalGradient, ncols)

There are now:

KPixmapEffect:: [Vertical,
                 Horizontal,
                 Diagonal,
                 CrossDiagonal,
                 Rectangle,
                 Pyramid,
                 PipeCross,
                 Elliptic]

Gradients. See kdelibs/kdetest/kgradienttest && kunbalancedgradienttest for
information on how they actually look.

The code in KPixmap::gradientFill() is replaced with warnings. It isn't
possible to make this old method call the new functionalities in kdeui because
we can't link-compile kdecore to kdeui.

////////////////////////////////////////////////////////////////////////
// * KTabListBox

This widget has been replaced by the almighty KListView. Everything said
about KTreeList could be repeated here. The good thing is, that you now
can combine TreeView's and normal Tablists without problems.

////////////////////////////////////////////////////////////////////////
// * KToolBarButton & KRadioGroup

If you need to do anything with KToolBarButton you now need to include
<ktoolbarbutton.h> KRadioGroup has been renamed to KToolBarRadioGroup and
requires you to include <ktoolbarradiogroup.h>

////////////////////////////////////////////////////////////////////////
// * KAccel

The functions keyToString() and stringToKey() which were previously
declared globally in kaccel.h are now static methods in KAccel.

////////////////////////////////////////////////////////////////////////
// * KIO

All of the UDS_XXX and ERR_XXX constants are now in the KIO class. This
class is just a namespace, so you can either inherit from it, or reference
the constants as KIO::UDS_XXX. The names of all of the classes have been
changed to start with a 'k', this prevents namespace pollution. This should
not cause too many problems as most of the KIO classes now inherit the
namespace. Finally you should not longer include userpaths.h, it has been
renamed to kuserpaths.h, the old include will work for a while, but you
will get a warning message. If you have any questions about the changes
then mail me (rich@kde.org).

Conversion table (new names on the left) :
KUDSAtom <- UDSAtom;
KIOProtocol <- IOProtocol;
KUDSEntry <- UDSEntry;
KIOConnection <- Connection;
KIOConnectionSignals <- ConnectionSignals;
KIOConnectionSlots <- ConnectionSlots;
KIOJobBase <- IOJob;
KIOSlave <- Slave;
KIOFilter <- Filter;

////////////////////////////////////////////////////////////////////////
// * kstring.h / KString

The KString class is obsolete and is not defined in
kstring.h anymore. The header file only existed for compatibility reasons.
The file has been removed completely, use QString instead. (mirko@kde.org)

////////////////////////////////////////////////////////////////////////
// * ktopwidget.h / KTopWidget

KTMainWindow replaces this class completly. In most cases, it should be
enough to simply replace the declaration of your former KTopWidget with
KTMainWindow, as it is source compatible. ktopwidget.h does not
exist in KDE 2. (mirko@kde.org)

////////////////////////////////////////////////////////////////////////
// * kbutton.h / KButton

Since Qt 2.0, the class QToolButton provides the functionality of
buttons that raise when the mouse is moved over them, so there is no
reason to have a class providing the same feature in KDE libs. All
occurrences of KButton in the KDE CVS have been replaced by QToolButtons,
but for applications not in the CVS it has to be done by the respective
developer. (mirko@kde.org)

////////////////////////////////////////////////////////////////////////
// * kcolorgroup.h / KColorGroup

KColorGroup was not used in sources in the KDE CVS, and its
functionality is provided by Qt. It has been removed. (mirko@kde.org)

////////////////////////////////////////////////////////////////////////
// * kcharsets.h / KCharsets

This functionality is removed from the KDE core and used from Qt, so it
has been removed. Use QStrings (unicode) for this
purpose. (mirko@kde.org)

////////////////////////////////////////////////////////////////////////
// * Methods for getting the value of a member object named
//   getXy*() are renamed to xy*()

If your code does not compile and complains about missing member
functions, you should check for methods that started with get...().
These methods have been renamed to xy*().

////////////////////////////////////////////////////////////////////////
// * kled.h, kledlamp.h / KLed, KLedLamp

There where two different classes for showing an LED lamp. Both are
merged to the KLed class, but THE USER INTERFACE IS DIFFERENT, as both
where more or less broken.
Please adjust your code accordingly.

////////////////////////////////////////////////////////////////////////
// * KTMainWindow

helpMenu() has been moved to KTMainWindow from KApplication (kapp).

Both the "About KDE" and the "About <Application>" dialog boxes
are now modeless. "About KDE" is a completely new widget.

If you used in the toplevel window (that is derived from KTMainWindow)
"kapp->helpMenu( bool, QString )" to get the help menu
you must now change this to "helpMenu( QString )". The QString defaults
to QString::null so it is sufficient to write helpMenu().

The old aboutKDE(), aboutApp() and appHelpActivated() of KApplication
have all been removed. If you need direct access to these or need
access to a help menu in a class that is not derived from
KTMainWindow then allocate an instance of the new class KHelpMenu.
See KDE 2.0 API reference or khelpmenu.h (kdeui) for additional info.

Espen Sand <espen@kde.org>

////////////////////////////////////////////////////////////////////////
// * KPixmap, KPixmapEffect

KPixmap::gradientFill, KPixmap::patternFill, KPixmap::tile and
KPixmap::mapFill have been moved to KPixmapEffect, which is now part
of libkdeui.

KPixmap::tile() has been renamed to KPixmapEffects::createTile().

Dirk A. Mueller <mueller@kde.org>


///////////////////////////////////////////////////////////////////////
// * KDE Control Center

The format for modules for the KDE Control Center has changed quite
a bit. If you want to port your module to the new schema, please
consult

kdebase/kcontrol/README

which explains what needs to be done.

Matthias Hoelzer-Kluepfel <hoelzer@kde.org>


///////////////////////////////////////////////////////////////////////
// * KWMModuleApplication libkdeui/kwmmapp.h

The KWMModuleApplication has been removed. Instead, use the class
KWinModule in libkdecore. The API is a bit cleaner but very similar,
so you will feel comfortable immediately. One of the advantages of
KWinModule is that it doesn't require a special KApplication
subclass. This lead to many problems and misunderstandings in the
past. KWinModule is now just an object that emits fancy signals (and
provides some useful lists, like the list of all managed windows).
(ettrich@kde.org)


///////////////////////////////////////////////////////////////////////
// * kDebug

Use the kDebug* functions to log debug output, warnings and errors in a
very flexible way. kdebug has been improved, and the API simplified.
kdebug.h provides a small script for automating the conversion.
Note that enabling/disabling debug output can now be done with kdebugdialog,
which can be found in kdebase. The hidden dialog on C+S+F12 has disappeared.
Also, consider using nana for assertions and debugger checks (see nana/*.h).
(faure@kde.org)


//////////////////////////////////////////////////////////////////////
// * KFileDialog - General Stuff

The new (rewritten) KFileDialog (KFD) is a lot more like the new QFileDialog
but still looks quite different. Normally you may want to use the static
methods provided for convenience (getOpenFileName and getSaveFileName).
If you need special features you can configure the dialog extensively. Just
create an object and use the different methods. 
Werner Trobin <wtrobin@carinthia.com>


//////////////////////////////////////////////////////////////////////
// * KFileDialog - Preview Mode

There is also a new preview mode which is quite different to the one we had in
the KDE 1.x KFD. There are no preview modules you have to register but there
is a single method you can use to set a preview widget. This widget has to
inherit QWidget and you have to implement a slot (showPreview(const KURL &)) 
in this class. This slot is called each time the selected file/dir changes.
In this slot you have to react appropriate (i.e. show the preview :). The
easiest way this can be done is to derive your class from QWidgetStack and 
add a Object (derived from QWidget) for each file type. In the showPreview
method you just raise the matching widget. If you can't find an appropriate
widget just hide() the widget stack.
If you need some "inspiration" on how that could be done, please have a look
at koffice/lib/kofficecore/koFilterManager.cc (PreviewStack).
Werner Trobin <wtrobin@carinthia.com>

<sect>XML GUI Creation
<p>

<sect>
<p>




<chapt>Using KDE I/O Slaves
<p>
Kurt Granroth <htmlurl url="mailto:granroth@kde.org" name="&lt;granroth@kde.org&gt;">

v0.1, 15, June 1999

<em>
 This HOWTO describes how the KDE I/O slaves (ioslaves) work.  It is
 intended for both ioslave implementers as well as users.  In this
 document, I will attempt to describe both how ioslaves work as well
 as how to use them.
</em>


<sect>Introduction

<sect1>What Are I/O Slaves?
<p>
 The K Desktop Environment (KDE) I/O slaves (ioslaves) are a series of
 small programs that have intimate knowledge on working with a very
 specific protocol.  For instance, the HTTP ioslave (<tt><cdx/kio_http/</tt>)
 knows all about sending and receiving data to and from a <idx/web server/.  It
 knows all about <idx/SSL/, encoding, and what all of the different header fields
 mean.  It knows this so that KDE developers won't have to -- if they want
 a web page, they merely have to use <tt><cdx/kio_http/</tt> for it and it will
 take care of everything for them.

 The ioslaves are based on the KIO library (<tt><cdx/libkio/</tt>).  This library
 implements a method of asynchronous communication between
 applications as well as provides a "protocol registry" of sorts.
 This has many advantages.  Two of the major ones are:

 <itemize>
 <item>
    The client does not need to know anything about the ioslave that
    it is calling.  It merely specifies the protocol and <tt>cdx/libkio/</tt> will
  	automatically determine the proper ioslave to use.
	
 <item>
    All communication is done asynchronously.  All <tt><cdx/libkio/</tt> calls will
    return immediately.  Whenever events occur, <tt><cdx/libkio/</tt> will send
  	signals altering the client to that fact.  This means that the
	  client does not have to engage in any "busy waiting."
 </itemize>

 Here is a fully working snippet of code to download a web page:<ncdx/KIOJob/<ncdx/sigData()/

 <verb>
 KIOJob *job = new KIOJob;
 connect(job, SIGNAL(sigData(int, const char*, int)),
         this, SIGNAL(slotData(int, const char*, int)));
 job->get("http://www.kde.org/news_dyn.html");
 </verb>

 That's it!  When the ioslave is done getting the KDE news page, it
 will call your application's slotData() function with the page.

<sect1>Copyright

<p>
 Copyright (c) 1999 Kurt Granroth, All rights reserved.  This is free
 documentware; you can redistribute it and/or modify it under the
 terms of version 2 or later of the
 <htmlurl url="http://www.gnu.org/copyleft/gpl.html" name="GNU General Public
 License">

<sect>Setting Up IOSlaves

 <p>
 Using the KDE ioslaves is very easy once the framework is in place.
 This section will describe getting the "back-end" stuff setup.

<sect1>The KIO Library

 <p>
 The first part that needs to be installed is the KDE IO library
 (<tt><cdx/libkio/</tt>).  This library is part of the KDE 2.x <tt><cdx/kdelibs/</tt>
 package.  It
 will be installed by default on all KDE 2.x systems when 2.x is
 finally released.  In the meantime, you will need to get it through
 either CVSUP or the snapshots.  See www.kde.org (or a later appendix
 when I get around to it later) for details on that.

 <tt><cdx/libkio/</tt> depends on the KDE UI library (<tt><cdx/libkdeui/</tt>), the KDE
 Core library (<tt><cdx/libkdecore/</tt>), and Qt (<tt><cdx/libqt/</tt>).  These are
 the "standard" KDE libraries so there shouldn't be any problems, there.

<sect1>The IOSlaves

 <p>
 There are ioslaves for <tt><cdx/http/</tt>, <tt><cdx/file/</tt>, <tt><cdx/gzip/</tt>,
 <tt><cdx/tar/</tt>, <tt><cdx/file/</tt>, <tt><cdx/smb/</tt>, <tt><cdx/pop3/</tt>, and
 <tt><cdx/imap4/</tt> as of the time of this writing.  They are all found in the
 <tt><cdx/kdebase/</tt> package under <tt><cdx/kioslaves/</tt>.  Again, these are
 available only from the KDE development CVS so you'll need to use CVSUP or
 the snapshots to retrieve them.

<sect>Using ioslaves in your Application

 <p>
 Now that you have the backend stuff all setup, you can start setting
 up your application to use them.  This requires adding the <tt><cdx/libkio/</tt>
 library to your linking and including the proper header files.

<sect1>Modifying your Makefile

 <p>
 If you are using the standard KDE automake/autoconf system for your
 application, then you are in luck!  Adding another library is
 trivial:

 <itemize>
 <item>
   Edit <idx/Makefile.am/
 <item>
   Change the line &lt;yourapp&gt;<cdx/_LDADD/ to look something like:

   <verb>
     myapp_LDADD = $(LIB_KIO)
   </verb>
 </itemize>

 That's it!  If you are not using the KDE setup, then just make sure
 that you are including the following in your link stage:

 <verb>
    -lkio -lkdeui -lkdecore -lqt
 </verb>

<sect1>Adding the Proper Headers

 <p>
 This is also simple:

 <verb>
   #include <kio_job.h>
 </verb>

 Will take care of everything.

<sect>Using IOSlaves via KIOJob
 <p>
 Now that your application is all prepped for using ioslaves, you can
 actually start using them!

 The only class you need to deal with at a client level is the KIOJob
 class.  You will use it to "call" the ioslaves and it will send you
 signals when it received events from them.

 The basic procedure is something like this:

 <itemize>
 <item>
    Create a <idx/KIOJob/ instance
 <item>
    Connect all of the signals (events) that you are interested in to
    some local slots (callbacks).
 <item>
    Send the actual request
 <item>
    Process the resulting response in your slots.
 </itemize>

 <sect1>Typical Example
 <p>
 An example looks like so:<ncdx/sigData()/<ncdx/sigError()/<ncdx/sigDataEnd()/<ncdx/sigFinished()/

 <verb>
 KIOJob *job = new KIOJob;
 connect(job, SIGNAL(sigData(int, const char*, int)),
         this, SLOT(slotData(int, const char*, int)));
 connect(job, SIGNAL(sigError(int, int, const char*)),
         this, SLOT(slotError(int, int, const char*)));
 connect(job, SIGNAL(sigDataEnd(int)),
         this, SLOT(slotDataEnd(int)));
 connect(job, SIGNAL(sigFinished(int)),
         this, SLOT(slotFinished(int)));
 job->get("http://www.pobox.com/~kurt_granroth/index.html");
 </verb>

 This will get the web page at the above URL.  When the ioslave is done
 receiving the page, it will send it to you with your <tt><cdx/slotData()/</tt>
 function.  If there was an error, then you receive it in
 <tt>slotError()</tt>.  If the page was large, then it will be sent in
 chunks.  You know that you are done receiving data when
 <tt>slotDataEnd()</tt> is called.  The <tt>slotFinished()</tt> function is
 called when the ioslave is completely done.

<sect>KIOJob Calls

 <p>
 There are numerous operations that you can do with KIOJob.  Some of them
 are: <tt><cdx/put/</tt>, <tt><cdx/get/</tt>, <tt><cdx/mkdir/</tt>, <tt><cdx/copy/</tt>,
 <tt><cdx/move/</tt>, <tt><cdx/del/</tt>, <tt><cdx/unmount/</tt>, and <tt><cdx/mount/</tt>.  I will
 refer only to <tt><cdx/put()/</tt> and <tt><cdx/get()/</tt> in this HOWTO.  The others
 follow similar patterns.

<sect1>get(const char* url)

 <p>
 This is probably the most common operation.  It tells the ioslave to
 "get" the resource described in the URL.  This may be a web page, a
 POP3 message, or a local file -- it all depends on your URL.

 This operation is not very interactive.  You tell the ioslave what
 you want and it gets it for you.  Period.

 Specifically, it will send back your data with the <tt><cdx/sigData(int id,
 char char* data, int length)/</tt> signal.

 Parameters:

 const char *url - The URL of the resource that you wish to get

<sect1>put(const char* url, int mode, bool overwrite, bool resume, int size)

 <p>
 This operation will start the process of "putting" or sending data to
 the location specified in the URL.  This is used, for instance, to
 send files to a remote FTP server or do do a PUT or POST request with
 HTTP.  It is not quite a straight-forward as a <tt><cdx/get()/</tt> operation.

 The basic procedure looks like:

 <itemize>
 <item>
    Connect <tt><cdx/sigReady(int)/</tt> to a local slot (e.g., <tt>slotReady(int)</tt>)
 <item>
    Send a <tt><cdx/KIOJob::put(..)/</tt> request
 <item>
    When <tt>slotReady(..)</tt> is called, you know that the ioslave is ready
    to relay your data to its final destination.
 <item>
    Send all of your data using the <tt><cdx/KIOJob::data(const char*, int)/</tt>
    operation.  When you are done, notify the ioslave of this by
	sending a <tt><cdx/KIOJob::dataEnd()/</tt>
 </itemize>

 Some sample code looks like so:

 <verb>
 KIOJob *job;
 char *data = "My message";
 Client::Client()
 {
 	job = new KIOJob;
	connect(job, SIGNAL(sigReady(int)), this, SLOT(slotReady(int)));
	connect(job, SIGNAL(sigData(int, const char*, int)),
	        this, SLOT(slotData(int, const char*, int)));
	connect(job, SIGNAL(sigDataEnd(int)),
	        this, SLOT(slotDataEnd(int)));
	job->put("http://server.com/cgi-bin/post.cgi", -1, true, false, strlen(data));
 }

 void Client::sigReady(int id)
 {
    job->data(data, strlen(data));
	job->dataEnd();
 }
 </verb>

 Parameters:

   const char* url - The end location for your data
   int mode        - Special permissions for your data.  This should be set
                     to -1 if there are no special permissions
   bool overwrite  - Instructs the ioslave to overwrite anything that
                     may already be there.
   bool resume     - Instructs the ioslave to resume a previously aborted
                     transaction.
   int size        - This is the size of the data that you will be sending


 Beyond that, everything else is identical to the 'get' method.

<sect1>data(void *data, int size)

 <p>
 This is used to send data to an ioslave.  It is used in conjunction with
 the <tt><cdx/KIOJob::put(..)/</tt> operation.  It is almost always called from
 your object's <tt>slotReady()</tt> slot as you must wait for the
 <tt><cdx/sigReady(int)/</tt> signal before sending any data.  If your data is
 greater than 2048 bytes, then you must break it up into many chunks and
 send each chunk individually.

 Parameters:

 void *data - Your data that needs to go to the ioslave.  This should be no
              more than 2048 bytes.
 int size   - The size of this data

<sect1>dataEnd()

 <p>
 This is used along with <tt><cdx/KIOJob::data(..)/</tt> and
 <tt><cdx/KIOJob::put(..)/</tt>.  It signals the ioslave that you are done
 sending it data.  If you do not send this signal, then the ioslave will
 essentially hang.  You do not need to use this if you are using
 <tt><cdx/KIOJob::get(..)/</tt>.

 Parameters:

 None

<sect>KIOJob Signals

 <p>
 All communication from the ioslaves come through KIOJob in the form of
 signals.  There are quite a few of them (see <tt><cdx/kio_job.h/</tt> for a complete
 listing), but I'll only discuss the "essential" ones.

<sect1>sigError(int id, int errid, const char* text)

 <p>
 This signal is emitted whenever an error occurs.  You should always connect a
 slot to this signal unless you really don't care if there is an error or not.

 Parameters:

 int id           - The job id
 int errid        - The error code.  This corresponds to the list of errors
                    defined in kio_interface.h
 const char* text - A textual description of the error

<sect1>sigReady(int id)

 <p><ncdx/sigReady()/
 This signal occurs when the ioslave is ready to accept data.  If you are
 using only <tt><cdx/get(..)/</tt> methods, then you should not have to connect to this
 signal.  If you are using a <tt><cdx/put(..)/</tt> method, then you must connect to this
 signal and begin sending data from there.

 Parameters:

 int id - The job id

<sect1>sigData(int id, const char *data, int size)

 <p><ncdx/sigData()/
 This signal happens whenever the ioslave is sending you data.  This is
 typically the data that it just downloaded.  It will never be more than 2048
 bytes, so plan on having it called several times.  You are responsible for
 collecting all of the data.  You will know that the ioslave is done sending
 you data when you get the <tt><cdx/sigDataEnd(int)/</tt> signal.

 Parameters:

 int id           - The job id
 const char *data - The data that the ioslave just downloaded
 int size         - The size of this data chunk

<sect1>sigDataEnd(int id)

 <p><ncdx/sigDataEnd()/
 This signal is sent to signify that the ioslave is done sending you data.
 You should use this signal as an assurance that you can use the data as
 <tt><cdx/sigData(..)/</tt> will never again be called.

 Parameters:

 int id - The job id

<sect1>sigFinished(int id)

 <p><ncdx/sigFinished()/
 This signal indicates the the ioslave is completely done.

 Parameters:

 int id - The job id

<!-- TODO: HOW KIOSLAVES ACTUALLY WORK FOR THE IMPLEMENTERS -->




<chapt>DCOP: Desktop COmmunications Protocol<label id="DCOP">
<p>
Preston Brown <htmlurl url="mailto:pbrown@kde.org" name="<pbrown@kde.org>">

Version 1.0, October 14, 1999

<em>
Howto for the KDE Desktop COmmunincations Protocol implementation
</em>

<sect>Motivation and Background
<p>
The motivation behind building a protocol like DCOP is simple.  For
the past year, we have been attempting to enable interprocess
communication between KDE applications. KDE already has an extremely
simple IPC mechanism called KWMcom, which is (was!) used for communicating
between the panel and the window manager for instance.  It is about as
simple as it gets, passing messages via X Atoms.  For this reason it
is limited in the size and complexity of the data that can be passed
(X atoms must be small to remain efficient) and it also makes it so
that X is required.  CORBA was thought to be a more effective IPC/RPC
solution.  However, after a year of attempting to make heavy use of
CORBA in KDE, we have realized that it is a bit slow and memory
intensive for simple use.  It also has no authentication available.

What we really needed was an extremely simple protocol with basic
authorization, along the lines of MIT-MAGIC-COOKIE, as used by X.  It
would not be able to do NEARLY what CORBA was able to do, but for the
simple tasks required it would be sufficient. Some examples of such
tasks might be an application sending a message to the panel saying,
"I have started, stop displaying the 'application starting' wait
state," or having a new application that starts query to see if any
other applications of the same name are running.  If they are, simply
call a function on the remote application to create a new window,
rather than starting a new process.

<sect>Implementation
<p>
DCOP is a simple IPC/RPC mechanism built to operate over sockets.
Either unix domain sockets or tcp/ip sockets are supported. DCOP is
built on top of the Inter Client Exchange (ICE) protocol, which comes
standard as a part of X11R6 and later. It also depends on Qt, but
beyond that it does not require any other libraries. Because of this,
it is extremely lightweight, enabling it to be linked into all KDE
applications with low overhead.

<sect1>Model
<p>
The model is simple.  Each application using DCOP is a client.  They
communicate to each other through a DCOP server, which functions like
a traffic director, dispatching messages/calls to the proper
destinations.  All clients are peers of each other.

Two types of actions are possible with DCOP: "send and forget"
messages, which do not block, and "calls," which block waiting for
some data to be returned.

Any data that will be sent is serialized (marshalled, for you CORBA
types) using the built-in QDataStream operators available in all of the
Qt classes.  This is fast and easy.  Currently, there is no
type checking or parameter checking available for RPC, but this may be
provided at some time in the future in the form of a simple IDL-like
compiler (NOTE: 5 days later the IDL compiler is already started;
look in dcopidl/).  Until that is available, you will have to code
some things by hand that normally the compiler or CORBA take care of
automatically, but it is not a lot of work.

<sect1>Establishing the Connection
<p>
KApplication has gained a method called "KApplication::dcopClient()"
which returns a pointer to a DCOPClient instance.  The first time this
method is called, the client class will be created.  DCOPClients have
unique identifiers attached to them which are based on what
KApplication::name() returns.  In fact, if there is only a single
instance of the program running, the appId will be equal to
KApplication::name().

To actually enable DCOP communication to begin, you must use
DCOPClient::attach().  This will attempt to attach to the DCOP server.
If no server is found or there is any other type of error, attach()
will return false.  Applications which are DCOP-enabled should
probably do something like this at startup time:

<code>
client = kApp->dcopClient();
if (!client->attach()) {
  QMessageBox::error(this, i18n("Error connecting to DCOP server"),
                     i18n("There was an error connecting to the Desktop\n"
                          "communications server.  Please make sure that\n"
                          "the 'dcopserver' process has been started, and\n"
                          "then try again.\n"));
  exit(1);
}
</code>

After connecting with the server via DCOPClient::attach(), you need to
register this appId with the server so it knows about you.  Otherwise,
you are communicating anonymously.  Use the
DCOPClient::registerAs(const QCString &amp;name) to do so.  In the simple
case:
<code>
/*
 * returns the appId that is actually registered, which _may_ be
 * different from what you passed
 */
appId = client->registerAs(kApp->name());
</code>

If you never retrieve the DCOPClient pointer from KApplication, the
object will not be created and thus there will be no memory overhead.

You may also detach from the server by calling DCOPClient::detach().
If you wish to attach again you will need to re-register as well.  If
you only wish to change the ID under which you are registered, simply
call DCOPClient::registerAs() with the new name.


<sect1>Sending Data to a Remote Application
<p>
To actually communicate, you have one of two choices.  You may either
call the "send" or the "call" method.  Both methods require three
identification parameters: an application identifier, a remote object,
a remote function. Sending is asynchronous (i.e. it returns immediately)
and may or may not result in your own application being sent a message at
some point in the future. Then "send" requires one and "call" requires
two data parameters.

The remote object must be specified as an object hierarchy.  That is,
if the toplevel object is called "fooObject" and has the child
"barObject", you would reference this object as "fooObject/barObject".
Functions must be described by a full function signature.  If the
remote function is called "doIt", and it takes an int, it would be
described as "doIt(int)".  Please note that the return type is not
specified here, as it is not part of the function signature (or at
least the C++ understanding of a function signature).  You will get
the return type of a function back as an extra parameter to
DCOPClient::call().  See the section on call() for more details.

In order to actually get the data to the remote client, it must be
"serialized" via a QDataStream operating on a QByteArray. This is how
the data parameter is "built". A few examples will make clear how this
works.

Say you want to call "doIt" as described above, and not block (or wait
for a response).  You will not receive the return value of the remotely
called function, but you will not hang while the RPC is processed either.
The return value of send() indicates whether DCOP communication succeeded
or not.

<code>
QByteArray params;
QDataStream stream(params, IO_WriteOnly);
params << 5;
if (!client->send("someAppId", "fooObject/barObject", "QString doIt(int)",
	          params))
  qDebug("there was some error using DCOP.");
</code>

OK, now let's say we wanted to get the data back from the remotely
called function.  You have to execute a call() instead of a send().
The returned value will then be available in the data parameter "reply".
The actual return value of call() is still whether or not DCOP
communication was successful.

<code>
QByteArray params, reply;
QCString replyType;
QDataStream stream(params, IO_WriteOnly);
params << 5;
if (!client->call("someAppId", "fooObject/barObject", "doIt(int)",
                  params, replyType, reply))
  qDebug("there was some error using DCOP.");
else {
  QDataStream stream2(reply, IO_ReadOnly);
  if (replyType == "QString") {
    QString result;
    stream2 >> result;
    print("the result is: %s",result.latin1());
  } else
    qDebug("doIt returned an unexpected type of reply!");
}

</code>

<sect1>Receiving Data via DCOP
<p>
Currently the only real way to receive data from DCOP is to multiply
inherit from the normal class that you are inheriting (usually some
sort of QWidget subclass or QObject) as well as the DCOPObject class.
DCOPObject provides one very important method: DCOPObject::process().
This is a pure virtual method that you must implement in order to
process DCOP messages that you receive.  It takes a function
signature, QByteArray of parameters, and a reference to a QByteArray
for the reply data that you must fill in.

Think of DCOPObject::process() as a sort of dispatch agent.  In the
future, there will probably be a precompiler for your sources to write
this method for you.  However, until that point you need to examine
the incoming function signature and take action accordingly.  Here is
an example implementation.

<code>
bool BarObject::process(const QCString &amp;fun, const QByteArray &amp;data,
		        QCString &amp;replyType, QByteArray &amp;replyData)
{
  if (fun == "doIt(int)") {
    QDataStream stream(data, IO_ReadOnly);
    int arg;
    QString res;
    stream >> arg;
    res = self->doIt(arg);
    QDataStream stream2(replyData, IO_WriteOnly);
    stream2 << res;
    replyType = "QString";
    return true;
  } else {
    qDebug("unknown function call to BarObject::process()");
    return false;
  }
}
</code>

<sect>Conclusion
<p>
Hopefully this document will get you well on your way into the world
of inter-process communication with KDE!  Please direct all comments
and/or suggestions to Preston Brown <htmlurl url="mailto:pbrown@kde.org" name="<pbrown@kde.org>">.


<sect1>Performance Tests
<p>
A few back-of-the-napkin tests folks:

Code:
<code>
#include <kapp.h>

int main(int argc, char **argv)
{
  KApplication *app;

  app = new KApplication(argc, argv, "testit");
  return app->exec();
}
</code>
Compiled with:

g++ -O2 -o testit testit.cpp -I$QTDIR/include -L$QTDIR/lib -lkdecore

on Linux yields the following memory use statistics:
<tscreen><verb>
VmSize:     8076 kB
VmLck:         0 kB
VmRSS:      4532 kB
VmData:      208 kB
VmStk:        20 kB
VmExe:         4 kB
VmLib:      6588 kB
</verb></tscreen>

If I create the KApplication's DCOPClient, and call attach() and
registerAs(), it changes to this:

<tscreen><verb>
VmSize:     8080 kB
VmLck:         0 kB
VmRSS:      4624 kB
VmData:      208 kB
VmStk:        20 kB
VmExe:         4 kB
VmLib:      6588 kB
</verb></tscreen>

Basically it appears that using DCOP causes 100k more memory to be
resident, but no more data or stack.  So this will be shared between all
processes, right?  100k to enable DCOP in all apps doesn't seem bad at
all. :)

OK now for some timings.  Just creating a KApplication and then exiting
(i.e. removing the call to KApplication::exec) takes this much time:

0.28user 0.02system 0:00.32elapsed 92%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (1084major+62minor)pagefaults 0swaps

I.e. about 1/3 of a second on my PII-233.  Now, if we create our DCOP
object and attach to the server, it takes this long:

0.27user 0.03system 0:00.34elapsed 87%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (1107major+65minor)pagefaults 0swaps

I.e. about 1/3 of a second.  Basically DCOPClient creation and attaching
gets lost in the statistical variation ("noise").  I was getting times
between .32 and .48 over several runs for both of the example programs, so
obviously system load is more relevant than the extra two calls to
DCOPClient::attach and DCOPClient::registerAs, as well as the actual
DCOPClient constructor time.

<chapt>Copyright<label id="Copyright">
<p>

Each chapter of this handbook contains the documentation of the according authors, therefore the copyright remains on the side of
those. This handbook has been assembled by agreement with each author about the usage of his documentation. Reprint is therefore only
allowed on agreement with the KDevelop Team and the authors of each chapter.

KDevelop is Copyright 1998,1999,2000 The KDevelop Team. This handbook itself is part of the KDevelop Intergrated Development
environment

<ref id="mini-HOWTO"name="The KDE Developer's mini-HOWTO"> is copyright of David Sweet.<htmlurl url="mailto:dsweet@chaos.umd.edu" name="<dsweet@chaos.umd.edu>">



<ref id="KOMOP" name="KDE KOM / OpenParts"> is copyright of Torben Weis <htmlurl url="mailto:weis@kde.org" name="<weis@kde.org>"> and
Bernd Wuebben <htmlurl url="mailto:wuebben@kde.org" name="<wuebben@kde.org>">


<ref id="KOMHOWTO" name="Using KDE KOM / OpenParts HOWTO"> and <ref id="KDEDAEMON" name="The KDE Daemon"> are copyright of Simon
Hausmann <htmlurl url="mailto:hausmann@kde.org" name="<hausmann@kde.org>">


<ref id="DCOP" name="DCOP: Desktop COmmunications Protocol"> is copyright of Preston Brown <htmlurl url="mailto:pbrown@kde.org"
name="<pbrown@kde.org>">


</book>








