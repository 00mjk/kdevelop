<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>KDE Alkalmazás Tankönyv: Alkalmazás alapelvek</TITLE>
 <LINK HREF="index-7.html" REL=next>
 <LINK HREF="index-5.html" REL=previous>
 <LINK HREF="index.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="index-7.html">Következõ</A>
<A HREF="index-5.html">Elõzõ</A>
<A HREF="index.html#toc6">Tartalom</A>
<HR>
<H2><A NAME="s6">6. Alkalmazás alapelvek</A></H2>

<P>Ez a fejezet, a már említett alkalmazás fajtákról nyújt áttekintést: az MDI (Multiple Document Interface - Többdokumentumos felület) és a Dokumentum-nézet formáról lesz szó. A Kdevelop-pal történõ projekt létrehozásának és a Dokumentumnézet formának az alpvetõ bemutatása már megtörténta 
<A HREF="../programming/index.html">The KDevelop Programming Handbook</A> címen, de csak egy SDI-n (Single Document Interface - Egydokumentumos felület) keresztül. Mindenképpen tisztában kell lennie a KDE és a Qt osztályok alapjaival, amelyek leírását a 
<A HREF="../kde_libref/index.html">The KDE Library Reference Guide</A> címen nézheti meg, ahol részletes magyarázat található a háttérkönyvtárak osztályairól és azok használatáról, valamint leírás a Qt jel-fogadó  machanizmusáról és eseménykezelésérõl.Áttekintés arról, amit már tud:
<UL>
<LI>Minden KDE alkalmazásnak szüksége van egy <CODE>KApplication</CODE> példányra (a Qt alkalmazásnak pedig egy <CODE>QApplication</CODE> példányra).</LI>
<LI>A KDE, egy fõ ablakot általában a <CODE>KTMainWindow</CODE>-tõl vesz át (a Qt alkalmazás pedig a <CODE>QMainWindow</CODE> -tõl).</LI>
<LI>Az esmények (pl. bilentyû leütés, egérmozgáspk) az ablakkezelõ rendszeren keresztül kerülnek az alkalmazáshoz.</LI>
<LI>A <CODE>QWidget</CODE> , mint minden látható Grafikus Felhasználói Felület (GUI) összetevõinek alaposztálya, a virtuális funkcók által külön eseménykezelõket biztosít, hogy a <CODE>QObject::event()</CODE> reimplementálásával határozza meg az eseményt.</LI>
<LI>A Qt jel-fogadó mechanizmusa alapvetõen azt jelenti, hogy egy összetevõ jeleket küldhet, és a fogadó ezeket fogadva hajt végre utasításokat.</LI>
<LI>Ezzel az eljárással elkerülhetõ az osztályok hátrahagyása a GUI összetevõk számára, mert jelek értesítenek pl. azokról az egérkattintásról, ahol egy widget-nek elsõbbsége van.</LI>
</UL>
<H2><A NAME="ss6.1">6.1 A Dokumentumnézet forma</A>
</H2>

<P>A Dokumentumforma, egyike a  legalapvetõbb fogalmaknak a Grafikus Felhasználói Felületen történõ alkalmazástervezésben. Ezért könnyû megérteni, hogy miért kell megismerni az okait annak, amiért a programozók mégis szívesen használják ezt más lehetõségek ellenére. Elõszõr azonben lássuk hogyan készül egy tipikus KDE/Qt alkalmazás:Az alkalmazás kérelme adja egy program eseménykezelõjének a kiindulópontot. A programmal magával a felhasználó egy Grafikus Felhasználó Felületen keresztül kerül kapcsolatba, amit leggyakrabban fõablaknak neveznek. A fõablak nyújtja aztán az olyan szolgáltatásokat, mint a gyorsbillentyûk, a menüsor, az eszköztár, és állapotsor. Ennek közepén van az úgy nevezett "nézet terület", egy olyan rész, amiben más osztályok meghívhatók. Ezt általában csak "Kilátó"-nak hivják. A "kilátó" akkor kerül meghívásra, amikor a "fõ ablak" egy programindításnál megnyílik és "kilátó terület" összetevõként kell hogy beállítódjon egy olyan eljárással, amit a "fõ ablak" biztosít: <CODE>setView(your_view)</CODE> a KDE alkalmazásokhoz a <CODE>KTMainWindow</CODE> -t használva, <CODE>setCentralWidget(your_view)</CODE> a Qt alkalmazásokhoz a <CODE>QMainWindow</CODE> -t használva. Így nyilvánvaló, hogy a "kilátó" az a terület, amelyik felel a felhasználóval való kapcsolatért,hogy az kezelhesse azokat az adatokat, amelyek ott feltünnek. Példaként: használhats egy <CODE>QMultiLineEdit</CODE>-t, "kilátóként", ami által egy szövegszerkesztõhöz jut. Aztán használhatja még a "kilátó" meglevõ "fogadóit", hogy kapcsolatot teremtsen a menüsor, vagy eszköztár parancshoz a következõképpen:Miközben a menüsort készítí, meg akar adni egy eljárást a "kivágás" parancsnak a "Szerkesztés" menüben: 
<BLOCKQUOTE><CODE>
<PRE>
 pEditMenu—>inseritem(BarIcon("editcut"), i18n("Cu&amp;t"),view, SLOT(cut()),KAccel::Cut, ID_EDIT_CUT);
</PRE>
</CODE></BLOCKQUOTE>
Ez létrehoz egy menüpontot a "Szerkesztés" menüben, amely aktiválódásakor közvetlenül hívja meg a <CODE>view</CODE> <CODE>cut()</CODE> "fogadó"-ját; tehát feltételezzük, hogy  egy <CODE>QMultiLineEdit</CODE> -ként hozta létre és mint "kilátó területet" állította be. A multilineedit "fogadó" meghívódik, és válaszképpen kivágja a kijelölt szöveget. A mûködõképességet már biztosította az osztály maga, így nincsen szükség a <CODE>QMultiLineEdit</CODE> -tõl átvenni azt, hogy létrejöjjön egy "nézet terület", amelyik képes az ilyesfajta feladatok elvégzésére. Hamar készen is állnak a az alkalmazásfejlesztés elkészítésére és használatára - már csak egy alkalmazásra és a fõablakra van szüksége, amelyek kapcsolatban állnak a nézet területtel, és el is készült. Ez azt jelenti, hogy egy kis szövegszerkesztõt létre lehet hozni egy egyszerû osztály megírásával, amelyik leírja a fõablak viselkedését, valamint az állományok mentésének és betöltésének mikéntjét a szerkesztõben. A fõ kilátónak magának, csak néhány alapvetõ fogadót kell lekezelnie.Lássuk az okot, amiért ezt a rejtélyes Dokumentumnézet formát bemutatjuk: önnek kell megadnia azokat az eljárásokat, amelyek olvassák és írják a szerkesztés alatt álló állományokat a <CODE>QMultiLineEdit</CODE> nézettel a <B>within</B> fõablak felületen. Ez a legjobb és a leglogikusabb, amit ebben az esetben tehet. Ha az állományok tartalmára, mint egy "dokumentumra" tekint, amit a C++ terminológiájával élve "objektum"-változóként is felfoghatunk, akkor a következõ lépés nagyon egyszerû. Ha van egy dokumentumunk, egy nézetünk és egy fõablakunk, akkor miért ne különíthetnénk el ezt a három objektumot egymásól? Könnyedén létrehozhat egy kis osztályt, ami egy állomány szövegablakba való beolvasásáért felel, azután pedig meghívja a nézetet a szöveg láthatóvá tételének érdekében. Az állomány ismételt elmentésének érdekében ugyanez megtehetõ - a dokumentum osztálynak ezután biztosítania kell egy mentési eljárást, mely a nézetbõl visszanyeri a szöveget az állomány számára. Példánkban csak ezt a két eljárást kell végrehajtania dokumentumosztálynak, mert a szerkesztés-nézet alapvetõen minden olyan eljárást biztosít a fogadók által, melyekre egy editornak szüksége van. Ezeken keresztül, ön közvetlenül kezelheti a nézet tartalmát is.A legalább kettõ (nézet, fõablak) helyett, három objektumra (dokumentum, nézet, fõablak) történõ elkülönítés alapötlete a következõ kérdés felvetésébõl származik: Mi van akkor, ha a felhasználónak meg akarjuk adni azt a lehetõséget, hogy egy állománnyal <B>két</B>, vagy több nézetben is dolgozhasson egyszerre? Ezt egy fõablakban is megtehetjük osztók, vagy elválasztók segítségével, amely igy két olyan nézetet is tartalmazhat, melyek külön külön megjelenítenek <B>egy</B> állományt. Itt azonban elõjön az aprobléma, hogy ez a megoldás csak akkor mûködik, ha a felhasználó megváltoztatja az állományt az egyik kilátóban, és a másik nézet is értesül errõl, hogy tartalma frissülhessen. Másképpen hiba léphet fel: ha a felhasználó bezárja azt a nézetet, amelyben hozzáadott valamit az állomány végéhez, amit a másik <B>in</B> nézetben szereplõ állomány elejérõl vágott ki, akkor az állomány úgy kerül elmentésre, hogy még mindig tartalmazza a kivágott részt. Hiszen ha a nézetek nem értesülnek az adott állomány változásairól, akkor az elmentés után tartalmazni fogják mind a kivágott, mind a beillesztett részt is. Ez azt jelenti, hogy a nézeteket összhangban kell tartani, hogy az állomány változásait érzékelhessék és egyformán megjeleníthessék, bármelyik nézetben is dolgozik a felhasználó. Ezek szerint, végül is egy dokumentum osztálynak kell felügyelnie a dokumentum valós állapotát, és biztosítania kell a nézeteknek, hogy változtathassanak tartalmukon.Remélem, hogy a fent taglaltak engedtek némi betekintést ebbe a szerkezetbe; habár legtöbb esetben úgy tûnik, hogy a programozó meg lehet nélküle egy meglévõ osztály nézetként való használatával, vagy egy widget megírásával, amit felhasználóval való kapcsolat kezelésére használ. Ameddig ön csak <B>egy</B> dokumentumot jelenít meg <B>egy</B> nézetben, addig a nézet képes követni az állomány változásait, és csak azokért az eljárásokért felel, amelyek beállítják, vagy visszanyerik a dokumentum tartalmát a beolvasás, vagy az elmentés során. A következõ forma amit leírunk, az Összetett dokumentumfelület lesz, ami különbözik az itt leírtaktól. Meg fogja látni, hogy miért szükséges a Dokumentum nézet forma, és hogy milyen lehetõségeket biztosít.
<H2><A NAME="ss6.2">6.2 A Többdokumentumos felület (MDI)</A>
</H2>

<P>Az elõzõ fejezetben leírtak alapján, talán már sejti is, hogy mit jelent az MDI. Azok a felhasználók, akik nem Unix/Linux rendszert használnak, hanem valamilyen más operációs rendszert, azok használják ezt, miként az azokra a platformokra fejlesztõ programozók is. Miközben az X-Window alkalmazások hagyományosan nagyobb hangsúlyt fektetnek a stabilitásra és a funkcionalitásra, addig a Unix felhasználók egyszerû ablakokat használnak a mûködést biztosítására, ezért még a Dokumentum-nézet formára sincs gyakran szükség egy alkalmazás létrehozásához. A Qt-val, mint többplatformos eszközzel, a fejlesztõknek lehetõségük van mind MS Windows (tm), mind Unix rendszerek alá fejleszteni. (Ezt a mondatot nem értem!!!!!!!!!!!!!!) Olyan alkalmazások a hiányában, amelyek képesek az u.n. "child window"-k kezelésére, a Windows szabványosodott, ez a Qt könyvtárnak köszönhetõ, de a Unix felhasználók is profitálnak ebbõl a felépítésbõl. !!!!!!!!!!!!!Mit is jelent az MDI? Egy MDI alkalmazásnak általában u.a. a koncepciója, mint egy szokásos alkalmazásnak -amint azt feljebb már leírtuk-,hogy tartalmaz egy alkalmazást és egy fõablakot. A nézet terület azonban egy kicsit más: nézetet közvetlenül nem használunk arra, hogy megjelenítse az adatokat, hogy dolgozzunk velük, hanem arra használjuk, hogy kezelje a többi ablakot, mint egy magas szintû fõablak. Ezek az ablakok alkotják most az elõbbi kilátó területet, valamint a fõ különbség az, hogy a kapcsolat láncolata megváltozik az
<BLOCKQUOTE><CODE>
<PRE>
alkalmazáshívás -> fõablak -> kilátó -ról azalkalmazáshívás -> fõablak -> kilátó -> aktív "child window" -ra
</PRE>
</CODE></BLOCKQUOTE>
A nézet így számos tevékenység elvégzésére képes:
<UL>
<LI>Annyi "child window" létrehozására, amennyit a felhasználó igényel</LI>
<LI>Eljárásokat biztosít az éppen aktív "child window" tartalmának kinyerésére</LI>
<LI>Tárolja a nyitva levõ kilátók listáját</LI>
<LI>Felügyeli a "child window" viselkedését annak aktivitása szempontjából, tehát úgy viselkedik, mint egy ablakkezelõ a magasszintû ablakoknál.</LI>
</UL>
Most, már "teljes" elemeket használunk -pl a <CODE>QMultiLineEdit</CODE>- "child windiws"-ként, mondjuk egy alkalmazáshoz, amelyik egy ablakkal rendelkezik és minden "child window" a saját adataiért felel. Ez nevezhetõ "Multiple Document Interface - Összetett dokumentumfelület"-nek, ahol minden "child window" olyan, mint egy dokumentum. Az alkalmazás biztosítja azokat az eljárásokat, amelyekre a "child window"-knak szükségük van, mint pl. a kivágás, másolás. Ennek a dokumentumnézet koncepciónak a kiterjesztésével további lehetõségekhez jutunk: képzeljük el, hogy a fõablakban annyi "child window"-t nyithatunk meg, amennyit szeretnénk, és hogy az új "child window"-k egészen új nézetét adhatják annak a dokumentumnak, amelyet egy másik "child window" már mutat. Ennek megszervezéséhez szükség van a már leírt három objektumos formába való elkülönítésre, de ez nem korlátozza a megnyitott dokumentum példányinak számát, ugyanúgy, ahogy nézetek számát sem.Szerencsére a Qt 2.1 rendelkezik azzal a lehetõséggel, hogy ilyen alkalmazásokat hozzunk létre, és a Kdevelop is biztosítja ezt keretalkalmazásaival, mind a csak Qt programoknál, mind a KDE 2 alkalmazásoknál ugyanazon a felületen; tehát szabadon megválasztható, hogy melyik típushoz szeretnénk fejleszteni. A KDE 2 felületek még több lehetõséget kínálnak a könyvtár-funkciók, és a végrehajtás közbeni kommunikáció által, de ezeknek a technikáknak a bemutatása egy újabb leírásnak képezhetik csak tárgyát.Most már felkészült a KDE 2-re való fejlesztésre - csak kövesse a következõ fejezetet, hogy megismerje a Kdevelop által, az alkalmazásfejlesztéshez biztosított funkciókat. Elõállítjuk majd a <EM>KScribble</EM> példaalkalmazásunk keretét és elolvashatja az MDI alkalmazások programozásának praktikus szempontjait.
<UL>
<LI>(Téma a KDevelop)</LI>
<LI></LI>
<LI>main-window = fõablak</LI>
<LI>view area = kilátó terület</LI>
<LI>"View" = nézet</LI>
<LI>Multiple Document Interface = Többdokumentumos felület</LI>
<LI>Single Documentum Interface = Egydokumentumos felület</LI>
<LI>Documentum View model = Dokumentumnézet forma</LI>
<LI>signal = jel</LI>
<LI>slot = fogadó  (Qt signal-slot mechanism = A Qt jel-fogadó mechanizmusa) </LI>
<LI>instance = hívás (meghívása egy alkalmazásnak), vagy példány</LI>
<LI>underlying libraries = háttérkönyvtárak</LI>
<LI>underlying window system = ablakkezelõ rendszer</LI>
<LI>event handler = eseménykezelõ</LI>
<LI>key acclerator = gyorsbillentyû (itt a gombokról van szó a képernyõn)</LI>
<LI>status bar = állapotsor</LI>
<LI>tool bar = eszköztár</LI>
<LI>menu bar = menüsor</LI>
<LI>widget = elem</LI>
<LI>child window =</LI>
<LI>top level window = magas szintû ablak</LI>
<LI>window manager = ablakkezelõ</LI>
</UL>
<HR>
<A HREF="index-7.html">Következõ</A>
<A HREF="index-5.html">Elõzõ</A>
<A HREF="index.html#toc6">Tartalom</A>
</BODY>
</HTML>
