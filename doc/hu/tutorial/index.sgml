<!doctype linuxdoc system>
<book>
<titlepag>
<title>KDE Alkalmazás Tankönyv
<subtitle>A KDE Példaalkalmazások Kézikönyve a KDevelop Integrált Fejlesztési Könyezet (KDevelop Integrated Development Environment) számára
<author>Ralf Nolden <htmlurl url="mailto:Ralf.Nolden@post.rwth-aachen.de" name = "<Ralf.Nolden@post.rwth-aachen.de>">
<inst>A KDevelop Csapat
<date>1.2-es verzió, 2000. április 6.
<abstract> A KDE Példaalkalmazások Kézikönyve a KDevelop Integrált Fejlesztési Könyezet (KDevelop Integrated Development Environment) számára egy példagyûjtemény arról, hogyan készítsünk KDE alkalmazásokat. Ez a kéziköny maga része a KDevelop Integrált Fejlesztési Könyezetnek, emiatt a GNU General Public Licence hatálya alá esik; lásd ott <ref id="Copyright" name="Copyright"> több információért.
</abstract>

<toc>
<chapt>Bevezetõ
<p>
Ahogy a KDE egyre több Unix rendszeren válik az alapvetõ grafikus felületté, egyre több és több programozó akar elõnyre szert tenni azzal, hogy ezt a KDE csomagban megtalálható, jól tervezett fejlesztõkörnyezetet használja. Ez a környezet lehetõvé teszi, a Qt/KDE osztályok egyszerû használatát, és grafikus felhasználói felület elkészítését egyaránt.
A KDevelop projekt éppen ezért, egy fejlesztõkörnyezetet szolgáltat, ami lehetõvé teszi a programozóknak, hogy gyorsan fejleszthessék KDE központú alkalmazásaikat, vagy átalakítsák az eddigieket.

Ez a kézikönyv a Qt -ben megtalálható példaprogramon keresztül próbál segítséget nyujtani abban, hogy mûködõ programot hozzunk létre a KDevelop segítségével. És segítséget ad, a kezdõknek mindíg problémát okozó, elsõ lépésekben.

Éppen ezért a következõ fejezet bemutatja önnek, hogyan kell létrehozni egy projektet a KDeveloppal, ami már önmagában is egy komplett alkalmazás. Aztán lépésrõl-lépésre végigmegyünk a Qt dokumentáción, ami példákat is tartalmaz, hogy bemutassa, hogyan kell használni a Qt függvénykönyvtárat.

Ezzel betekintést kap abba, hogyan kell használni a Qt függvénykönyvtár által nyújtott funkciókat, osztályokat. A Qt -vel kell kezdeni, mert az egész KDE erre a fügvénykönyvtárra épül, és az alkalmazások is széles körben kihasználják ezt.

Késõbb bemutatjuk, hogyan kell egy KDE alkalmazást létrehozni a KDevelop alkalmazás varázslóval. A minimális, automatikusan kapott szerkezetbõl fogunk egy mûködõ alkalmazást létrehozni, ami használja a KDE függvénnykönyvtárakat, és részletesen bemutatjuk a program  különbözõ részeit is.

A KDevelop Csapat sok sikert kíván önnek a KDE és Qt tanulásában, és reméli hogy ezen  kézikönyv által ön válhat a következõ KDE -t támogató programozóvá.


<sect>Amit már tudnia kellene
<p>
Ez a kézikönyv alapvetõ ismereteket igényel a C++ -ban való programozás terén. Csak így tudja megérteni a példában szereplõ programkódokat, azok mûködését. Feltételezi továbbá, hogy ön elolvasta a <htmlurl url="index.html" name="KDE Alkalmazás Tankönyv"> és a <htmlurl url="../../../default/kdevelop/programming/index.html" name="KDevelop Programozói Kézikönyv"> címû kézikönyveket, és tudja használni a KDevelop kezelõfelületét, és tudja mik azok a létrehozott projektek.

<chapt>Kezdõlépések
<p>
Getting Started- that means, you should have set up KDevelop to work correctly first. Ensure you have access to the Qt online reference
documentation by the "Help" menu or the according book in the documentation tree. When looking a the first page of the Ot
documentation, you will see that it contains a link to a section "Tutorials" and "Examples". Under "Tutorials", you will find a 14-step
introduction into using the Qt library to build applications. On the other hand, "Examples" will lead you to a list of example
programs that Qt includes and takes for example usage reference in certain classes. Now, if you are an absolute beginner, you should be
comfortable with the idea behind Qt- providing a library that offers:

<itemize>
<item>a base application class (<tt/QApplication/)
<item>a widget library for graphical user interfaces
<item>a set of additional helper classes for graphics, file and data handling
<item>the signal-slot mechanism for object communication
<item>event controlling by event loops and virtual methods
</itemize>

If that doesn't tell you anything right now, you should read about the Qt library in <htmlurl url="programming-2.html#ss2.1" name="The
KDevelop Programming Handbook"> where the basics for a Qt application are described in detail. There, you will also find and
introduction about the difference between a Qt and a KDE application, which is not much at the first level of the Qt tutorial step.

Now, to learn about Qt first would be a good start for programming KDE applications as well, so we will create a project that will
produce the tutorial applications after editing.

To do this, start with opening KDevelop and select "Project"-"New" from the menubar. The application wizard opens and you have to
select which type of project you want to build. For Qt applications, you would choose the Qt application, but we will use the mini-KDE
project to build our examples. The reason is simple: the Qt tutorials don't contain much code, and  by choosing the Qt application in
the application wizard, we would have to do a lot of changing on the provided code to create the "true" examples.

But as the mini-KDE application only consists of an empty main window but also checks for the Qt library and header files, it will fit
for our purposes and doesn't require much changes.

When entering the next wizard page, we have to enter the project-specific information. There, we can leave out any KDE-specific
additions such as a mini-icon and a main icon, documentation etc. We just fill in the information that will be useful for building a
suitable base for the tutorials. As the structure of the tutorial steps builds the next step on the previously created code, we can
start with <tt/MyWidget/ as the project name. This will already build us the base class that is needed in chapter 4, so we don't have
to care for that later. As we want to start with the first tutorial step, we will use '1' as the project number, which we can increase
later when moving to the next step.

Then, fill in the other required information such as your name, email address and project directory. That would be all we need and we
can flip to the next page. Insert your header for the project's header file here or use the given example. The same is done with the
4th page, where the same has to be set for the source files. Finally, the last page is entered, where you have to press "Create" to
build the project. If the button is not available, start at the first page again and make sure you didn't miss to insert any required
information.

If everything went OK, the project has been build and the messages window in the application wizard will have "READY" at it's last
line.  Select "Close" to finish the wizard.

When looking at the treeview on the left, you will see that the project alreay includes a class "MyWidget"- this is because we chose
this to be the application name. Further, when opening "Functions" in the classviewer's "Globals" folder, you will see that the
application already contains a <tt/main()/ function where the execution will start.

Now the application is already set up. You could do an "Execute" or "Make", but as we want to create the tutorial applications, we can
go ahead and change the code first to create our tutorial examples- which we'll do in the next step.


<chapt> A Qt tananyag lefordítása
<p>
<sect>Elsõ lépés: Helló világ!
<p>
Az elõzõ fejezet útmutatása alapján, létrehozott egy projektet, amit <tt/MyWidget/ hívnak; most, amikor a tananyag elsõ oldalát nézi a Qt 
leírásában, látni fogja, hogy az elsõ alkalmazás csak egy <tt/main()/ funkciót használ. Így elég megváltoztatnunk a megadott 
<tt/main/()/ funkciót a létrehozott projektben, hogy elindulhassunk a példafeladat elsõ részével. 

A <tt/main()/ funkció eléréséhez válassza ki azt az osztályböngészõ (classviewer) "Globals" elérési útjáról, ahol  a "Funkciók" pont található, 
ami az összes non-class fukciót kilistázza. Ez megnyitja a <tt/main/cpp/ állományt a "c/c++ állományok" ablakban, és a szerkesztõ kurzor már 
a <tt/main()/ elsõ sorában is áll.

<sect1> Min változtassunk elõszõr?
<p>
Kezdhetnénk az adott kód megváltoztatásával is, hogy eljussunk a kívánt változathoz, de az egész sokkal sokkal egyszerûbben is megoldható. Jelölje ki 
a <tt/main()/ funkció tartalmát az egérrel, vagy a Shift és a fel-le nyilak valamelyikének egyidejû lenyomásával. 
Ezután a "Szerkesztés" menübõl válassza a "Kivágás" pontot, vagy egyszerûen üsse le a "Del" billentyût a kijelölt kód törléséhez. Így kitörölte a main funkciót, 
ezért a nulláról kezdhetjük elsõ példafeladatunk összeállítását.

<sect1> A példafeladat kódjának bevitele
<p>
A kód példafeladatból való beillesztéséhez, elõszõr figyelmesen el kellene olvasnia azt, hogy megjegyezze melyik sor melyik kódot tartalmazza. Miután 
a példafeladatot sorról sorra elolvasta, példaként használhatja azt a saját gyakorlata megírásához.

Akik a könnyebb megoldást alkalmaznák, jelöljék ki a  kilistázott <tt/main()/ funkció tartalmát a dokumentum-böngészõben és nyomják meg 
a "Másolás" ikont az eszköztáron. Használhatja még az elõreugró menüt, vagy az idevágó parancsot a "Szerkesztés" menüben. Végül a kiválasztott rész a 
vágólapra kerül, és miután visszavált a forráskód ablakra, a "Beillesztés" paranccsal bemásolhatja az elõzöleg kijelölt részt (ugyanígy megteheti 
ezt a elõreugró menübõl, az eszköztár ikonnal vagy a "Szerkesztés" menü idevágó parancsával).

Végül a <tt/main()/ funkción kívül addja hozzá az idetartozó fejléc állományokat :

<tscreen><verb>
#include <qapplication.h>
#include <qpushbutton.h>
</verb></tscreen>

Ennyi az egész! Kész is van az elsõ példafeladat forráskódja.

<sect1>A Helló világ! elkészítése
<p>
Az elsõ példafeladat elkészítéséhez, válassza a "Make"-et a "Build" menübõl, vagy pedig nyomja meg az ennek megfelelõ ikont az eszköztáron. Tetszõlegesen választható még 
a "Végrehajt" parancs is, amely futtatja a kész alkalmazást, annak sikeres elkészítése után.

Amennyiben az összeállítás valamilyen hiba folytán leállna, bizonyosodjon meg róla, hogy a hiba a példafeladatban, vagy pedig önben van-e. Szomorú dolog lenne 
egy hibát keresgélni éppen akkor, amikor elhatározta, hogy a KDE-hez és/vagy Qt-hoz fog programozni, de ez mindenképpen jó alkalom a KDEvelop használatának gyakorlására. 
A hiba megtalálásához két lehetõség is a rendelkezésére áll: vagy válassza ki az odavágó hibaüzenetet a kimeneti ablakban, amely ahhoz a sorhoz visz, 
ahol a hiba van, vagy pedig nyomja meg az F4-es gombot. Tetszõlegesen a "Következõ Hiba" pontot is választhatja a "Nézet" menüben.

<sect1>Gyakorlatok
<p>
Most kérdezheti: "Gyakorlás? Eddig olyan egyszerû volt. Semmi szükségem gyakorlatokra!" Azonban meglátja, a dolgok kicsit bonyolódni fognak. Ez a 
lehetõ legegyszerûbb példa volt, de minél összetettebbek lesznek, annál több gondolkodást kívánnak majd öntõl, hogy megértse és követni tudja a 
tananyag lépéseit. A gyakorlatok képessé teszik önt arra, hogy megtanulja a KDEvelop mûködését, és megismerje tulajdonságait.

Hogy az elsõ alkalmazás által is tanuljon még egy kicsit, hajtsa végre a következõ változtatásokat a meglevõ kódon, és figyelje meg, hogy ezek 
hogyan befolyásolják az alkalmazás viselkedését.

<enum>a nyomógombot cserélje le a <tt>QLabel</tt> -re
<item>használja a <tt/setText()/ -et, a szöveg nyomógombkészítõben való közvetlen beállítása helyett
<item>használja <ttt/QPushButton::resize ( const Qsize & s )/ -t a magasság és szélesség közvetlen megadása helyett. Elõször hozzon létre egy <tt/QSize/ példányt, amely tartalmazza a méretet
<item>játszon el a mértettekkel, hogy lássa melyik a szélesség és melyik a magasság
</enum>

<sect>A 2. és 3. lépés: Kiterjesztések
<p>
A leírás 2. és 3. részében tovább tágulnak a tananyag 1. részében feltárult lehetõségek. Ugyanúgy hallani fog most a jelekrõl (signal) és a fogadókról (slot), mint az 
elemek (widget) közti gyermek-szülõ kapcsolatról.

Miért fontos tanulni mindezekrõl? A jelek és a fogadók alkotják azt a technológiát, amely 
megkülönbözteti a Qt könyvtárakat más  elemkönyvtáraktól. Ha bármikor is olyan problémába ütközne, hogy 
objektumok között szeretne kapcsolatot létrehozni, ez hihetetlenül lerövidíti a munkáját, és semmi végzetes nem történik, ha valami nem sikerül, még a 
hibás kapcsolódások sem vezetnek szegmentációs hibához. Ez a Qt könyvtár erõssége; 
és rugalmassasága miatt nem szívesen nélkülözné egyetlen KDE/Qt fejlesztõ sem. A jel/fogadó (signal/slot) mechanizmus megértése alapvetõ feltétele bármilyen KDE/Qt alkalmazás létrehozásának.

A másik dolog amire figyelnie kell az a tény, hogy a gomb bezárja a <tt/Qapplication/ példányt a <tt/quit()/ hívásával. 
Ismét találkozni fog a <tt/quit()/ -el, mikor a <tt/QApplication/ KDE-s megfelelõjével, a <tt/KApplication/ -al dolgozik majd.

<sect>Saját Elemek megírása
<p>
A  <tt/main()/ funkció sikeres módosítása és kibõvítése után elérte azt a pontot, hogy létrehozzon egy új, teljesen 
egyéni elemet, amelyet a 4. fejezet útmutatása alapján  létrehozott osztály segítségével fog megírni. Lényegében az 
alkalmazás varázsló már létrehozta az ön számára az osztályt, így nem marad sok hozzáírni való, csak be kell illesztenie a 4. lecke által 
a <tt/main.cpp/ állományba írt kódot, a <tt/MyWidget/ osztály fejlécébe és "implementation?" állományába. Szerencsére csak az "implementation?"-t 
kell hozzáadnia a "constructor?" kódjához

A megnyitáshoz válassza a "constructort?" a "classviewer?"-bõl. Ez automatikusan az "implementation?"-hoz visz, ahova 
be kell illesztenie a kódot. 

Itt csak arra kell figyelnie, hogy a <tt/qfont.h/- <tt/QFont/ tartalmát csak a <tt/MyWidget/ constructor kódja használja.
Tehát a <tt/#include &lt;qfont.h&gt;/ sort illessze be a <tt/mywidget.cpp/ állomány tetejére.

Az új alkalmazás futtatásához csak nyomja meg a "Végrehajt" gombot. Ez lefordítja a változásokat, miután elmentette õket.

<sect>Az Elemosztály kibõvítése
<p>
Az ötödik rész célja az elemosztály kibõvítése, ezért itt a virtuális funkciókról fog tanulni. 
A <tt/resizeEvent()/ itt reimplementálva található. Amit fontos megtanulnia (az osztály kibõvítésén belül) az az, hogy a Qt, 
virtuális funkciók által foglalkozik a felhasználói eseményekkel úgy, hogy egy bekövetkezett eseményt paraméternek vesz. 
Éppen emiatt kényelmesebben dolgozhat a Qt könyvtár következõ osztályit felhasználva:

<itemize>
<item>QEvent
<item>QChildEvent
<item>QCloseEvent
<item>QFocusEvent
<item>QKeyEvent
<item>QMouseEvent
<item>QMoveEvent
<item>QPaintEvent
<item>QResizeEvent
<item>QTimerEvent
</itemize>

Bármikor, amikor saját elemeket ír, különösen figyeljen arra az alkalmazások területén, hogy az alapértelmezett 
elemesemény-eljárás implementációját, önnek kell átírnia annak megfelelõen, hogy milyen eseményeknek kell végrehajtódnia. Ezek pl. lehetnek:

<tt/virtual void mousePressEvent (QmouseEvent * )/ amely azon egéresemény végrehajtásáért felel, amikor elõreugrik egy context menu. Az implementációba 
be kell illesztenie egy elõírt változót. A legtöbb fejlesztõ a <tt/event/ , vagy egyszerûen a <tt/e/ -t, használja mint változónevet.

Ezután végrehajtható az eseményre vonatkozó változó. Egy <tt/QMouseEvent/ -hez, rá kell kérdezni arra, hogy a középsõ, a bal- , vagy a 
jobboldali egérgomb váltotta-e ki az eseményt.

<sect>Új Osztály hozzáadása
<p>
A 6. leckében egy új osztályt kell hozzáadnia a megírt példaalkalmazáshoz. Most bizonyára azt gondolja, hogy "csak létrehozok egy 
fejléc- és egy implementációs állományt, aztán készen is vagyok." A KDevelop azonban még ennél is jobban megkönnyíti ezt az ön számára. 
Új osztály hozzáadásához használja az osztálygenerátort, ami elvégzi ön helyett a munka dandárját, így önnek csak az egyéni kódot kell beírnia.

Új osztály hozzáadásához az osztálygenerátorral, válassza a "Projekt"-"Új osztály" menüpontot, ami megjelenít egy párbeszédablakot, ahol beírhatja a 
hozzáadandó osztályhoz szükséges összes értéket. Az elsõ, amit be kell írnia, az osztály neve. A példafeladatban ez a <tt/LCDRange/, tehát ezt kell beírnia elõszõr. Ezután folytassa a baseclass-el. 
A baseclass az egyetlen olyan dolog, ami az új osztályba is átkerül. Ha megnézi a tananyagot (Qt 1.42), akkor látja, hogy ez a 
<tt/QWidget/ . Mint a legtöbb hozzáadandó GUI osztálynál, a <tt>QWidget</tt> kerülne át itt is, de az osztálygenerátor ezt leegyszerûsíti. Hagyja a baseclass cellát 
üresen és inkább jelölje be az "Additional Options"-ban a "QWidget child class"-et. Ez magától csatolja a szükséges 
<tt/Q_OBJECT/ makrót a fejlécállományhoz, hogy a fogadók és jelek késõbb hozzáadódjanak (ami a 7. fejezetben szükséges is lesz).

Az állománynevek maguktól bekerülnek, ezek miatt nem kell aggódnia. Az egyetlen dolog, amit javaslunk hozzáadni, az a 
leírás. Mindig jó egy részletezõ leírást mellékelni az osztályhoz, különösön akkor, ha annak neve ( <tt/LCDRange/ ) 
nem túlságosan beszédes.

<sect> A 7-14. lépés
<p>
Most már indent tud, ami a tananyag további lépéseihez szükséges, és kellõen felkészült, hogy végre tudja hajtani a szükséges teendõket.

Minden változtatás után indítson új szerkesztést és ellenõrizze, hogy a beírt kód nem hibás-e. Futtassa az alkalmazást és kísérje figyelemmel annak végrehajtódását. 
Ezenkívûl játszogathat még a KDevelop "Build" opcióival: hajtassa végre az alkalmazást olyan parancssori hibakeresõvel, mint pl. a 
KDbg a kellékek ablakban. Ezek után tudnia kell futtatni az alkalmazást azokkal a 
Qt példaprogramokkal, amiket a Qt-hoz mellékelnek. A következõ fejezetben megismeri a KDE 2-höz való fejlesztést  egy példaalkalmazás segítségével ( <em>KScribble</em> ). 
Ez egy kis rajzprogram, amelyiken keresztül megtanulhatja az alkalmazástervezés koncepcióját és a programozást egyedül.

<chapt>KDE alkalmazások létrehozása
<p>
Ebbõl a kézikönyvbõl megtudhatod, hogyan kell KDE/Qt alkalmazásokat készíteni - egy példaalkalmazás lépésenkénti elkészítése által. A fõ cél a grafikus felhasználói felület két fõ típusának és mûködésének megismerése: a dokumentumközpontú modell és a többdokumentumos felhasználói felület (MDI).

Kapsz egy jó elvi lehetõséget, amely már felbukkant a láthatáron: a KDE 2 és a Qt 2.1 könyvtárak, melyek új bõvítéseket és technológiát kínálnak a programozónak, az alkalmazások formájának fejlesztésével használható lehetõségek kibõvítésével kapcsolatban. Az olyan szívesen használt kulcsszavak, mint a ??céleszköz-anyagok??, a processzek közötti kommunikáció és a beágyazott alkalmazások, többet fognak lehetõvé tenni, mint amit most el tudsz képzelni.

Tehát, a KDevelop 1.1, amely még a KDE 1.1.x-re épül, gondoskodik a fejlesztõk számára a leginkább szükséges lehetõségekrõl: alkalmazások fejlesztése a KDE 2 számára, egy stabil asztali környezetben. Ez maga után vonja azt is, hogy ezek példák a Qt2.1-et használó KDE 2-n alapulnak, felajánlva a megoldást az említett MDI-modell számára - amit elkészítünk mint egy induló keretalkalmazást. A példák megismerése közben egy világos áttekintést fogsz kapni arról, hogyan mûködik, és ez sokkal egyszerûbbé teszi a dokumentum-nézõpontú modell megértését is - ami nehezen érthetõ még tapasztalt programozók számára is. Ez segíteni fog más típusú alkalmazások készítésében is, amelyek a dokumentum-nézõpontú modellt használják, még ha csak egy ablakot tartalmaznak is, és nem tûnik kézenfekvõnek a használata. De kezdjük - látni fogod, mi a következik és tulajdonképpen milyen könnyû is.

A példák további fejezetei a következõ néhány lépést tartalmazzák:
<itemize>
<item>a KDE 2 (könyvtárak) telepítése és a KDevelop felkészítése a KDE 2 alkalmazások készítésére.
<item>az MDI és a dokumentum-központú modell alapelveinek megértése
<item>egy általános keretprogram készítése a <em>KScribble</em> számára és a keret elvének elmagyarázása.
<item>a dokumentum osztálynak a bevezetése, amely a dokumentum adatainak írásához és olvasásához nyújt egy egységes felületet, valamint a dokumentum védelmét látja el.
<item>a nézet osztály bevezetése az adatok megjelenítéséhez. Az osztály ezen kívül a felhasználóval történõ kommunikációról gondoskodik.
<item>párbeszédablakok hozzáadása a toll szélességének és színének beállításához, beleértve a beépítésüket az eszköztárba és a menükbe.
<item>a nézet megváltoztatása az alapértelmezett <tt>QWidget</tt> öröklõdésrõl egy görgethetõ nézetre.
</itemize>

A példaprogram maga a Qt könyvtárban található firkálós példaprogram kódján alapszik. Az eredeti példa forrása megtalálható a Qt dokumentációban, a példák bekezdésben.
<chapt>A KDE 2 telepítése
<p>
Ebben a fejezetben néhány lépésen keresztül bemutatjuk, hogyan lehet a teljes KDE 2 installálása nélkül Qt 2.x/KDE 2
alkalmazásokat fejleszteni.
A szükségletek: <itemize>
<item>a legfrissebb Qt-2.1, ami megtalalható <htmlurl url="http://www.troll.no" name="http://www.troll.no">
<item>a legfrissebb KDE 2 csomagok közül a <tt>kdesupport</tt> és a <tt>kdelibs</tt> </itemize>

A Qt-2.1 és a KDE 2 függvénykönyvtárak pillanatnyilag fejlesztés alatt állnak, de várhatóan ez lesz a végsõ verzió. Változtatások
várhatóak a végsõ verzióban, de azok csekély mértéküek, így valószínûleg nem jelentkeznek az ön alkalmazásaiban. Ez azt jelenti,
hogy ön megismeri a legújabb függvénykönyvtárakat  és értekes idõt nyerhet azzal, hogy elõbb elkészítheti az alkalmazásait, mielõtt
a fügvenykönyvtárak véglegesen elkészülnének.

A következõ részekben részletesen leírjuk a teendõket három lépésben:
<itemize>
<item>Qt-2.1 függvénykönyvtárak installálása
<item>KDE 2 függvénykönyvtárak installálása
<item>A KDevelop beállítása
</itemize>
Ezután -ha készenáll a továbblépésre- folytathatjuk az elsõ lépések megtételével a <em>KScribble</em> példából, a következõ fejezetekben.

<sect>Qt-2.1 függvénykönyvtárak installálása
<p>
Az elsõ lépés bevezeti önt a minimális feltételekbe, hogy követhesse példánkat. Ez azt jelenti hogy nem szükséges a KDE 2
függvénykönyvtárak installálása, ha önt csak a Qt alkalmazások fejlesztése érdekli.
A Qt-2.1 tartalmazza a szükséges osztályokat és a KDevelop szolgáltatja a sablonokat az összetett kezelõfelületû Qt-2.1
alkalmazásokhoz, miközben ugyanazokon a keretkódokon alapszik amit a KDE 2 sablonokban használtak, így nem kellene
hogy gondot okozzon a példa követése, egy csak Qt alkalmazáson sem.

Most, hogy megszerezzük a legújabb Qt függvénykönyvtárat,  töltse le a legújabb verziót a Troll Tech honlapjáról
<htmlurl url="http://www.troll.no" name="http://www.troll.no">, a letöltés részrõl.

Aztán root -ként másolja a fáljt abba a könyvtárba, ahol a most használt Qt verzió talalható. SuSe Linux rendszeren az
 <tt>/usr/lib</tt> könyvtárban kellene lennie a qt-1.44 vagy qt-2.0.2 könyvtárnak, attól függõen, hogy milyen verziójú
rendszert használ.

Csomagolja ki a függvénykönyvtár forrást:

<tt>tar zxvf qtxxx.tar.gz</tt>

Ahol az xxx az éppen aktuális verziószám.
Ezután állítsa a <tt>QTDIR</tt> környezeti változót arra a könyvtárra, ahova az új Qt-2.1 függvénykönyvtár ki lett csomagolva.
pl.: <tt>setenv QTDIR=/usr/lib/qt-2.1</tt>. Másik lehetõség, ha átnevezi a qt-1.44 könyvtárat (rendszerint a neve csak qt)
qt-1.44 -re és létrehoz egy szimlinket, ami a qt-2.1 -re mutat. Miután a fordítással végzett, a szimlink mutasson újból
a qt-1.44 könyvtárra.
Lépjen a Qt-2.1 könytárba és gépelje be:
<tscreen><verb>
./configure
make
</verb></tscreen>

Miután sikeresen befejezõdött a Qt-2.1 függvénykönyvtár lefordítása, a  QTDIR környezeti változót visszaállíthatja az eredeti értékre.

Most lépjen át az /usr/lib/qt-2.1/lib könyvtárba és másolja a létrehozott  fájlokat az <tt>/usr/lib</tt> könyvtárba, <bf>kivéve</bf>
a <tt>libqt.so</tt> szimbolikus linket.

Így ön befejezte a Qt telepítését, folytathatja a KDE 2 függvénykönyvtárak beállításával. Ha ön csak Qt alkalmazásokat szeretne
fejleszteni, folytassa a KDevelop beállításával.

<sect>KDE 2 függvénykönyvtárak installálása
<p>
A második lépés segíti önt a szükséges KDE függvénykönyvtárak installálásában. Töltse le a legújabb  <tt>kdesupport</tt> és
<tt>kdelibs</tt> függvénykönyvtár csomagokat innen <htmlurl url="http://www.kde.org" name="http://www.kde.org">. Ezután a dolgok
kicsit könnyebben mennek majd, mint a Qt installálásánál. Csak csomagolja ki a forrást a saját könyvtárába, és lépjen elõször a
kdesupport könyvtárba. Ott gépelje be:

<tscreen><verb>
./configure --with-qt-dir=/usr/lib/qt-2.1 --prefix=/opt/kde2
make

majd root -ként:

make install
</verb></tscreen>

Így installálni fogja a kdesupport csomagot a  --prefix opcióban megadott könytárba, az újonnan fordított Qt-2.1 függvénykönyvtárat
használva, amit a  --with-qt-dir opcióban adott meg.

Ugyanez vonatkozik a kdelibs csomagra is, csak lépjen a kdelibs könyvtárba és gépelje be ugyanazt, amit feljebb a kdesupport csomagnál.

Most ön készen van  a szükséges függvénykönyvtárak beállításával, hogy létrehozhasson KDE 2 alkalmazásokat.

A KDE függvénykönyvtár csomag támogatja az automatikus HTML dokumentáció létrehozását,
amit könnyen elérhet a KDoc 2.x verziójának installalásával. Ezután gépelje be  <tt>makekdedoc</tt> parancsot az ön kdelibs
könytárában, és a KDoc létrehozza a HTML dokumentációt az <tt>srcdoc</tt> alkönyvtárba. A KDevelop -ban közvetlenül elérheti a
KDE függvénykönyvtár dokumentációját, ha beállítja a KDE függvénykönyvtár dokumentáció elérési utvonalát, a "KDevelop Beállítás"
ablakban, a <tt>kdelibs/srcdoc</tt> könyvtárra. Ugyanígy beállíthatja a Qt dokumentáció elérési útvonalát a KDevelop -ban az
<tt>/usr/lib/qt-2.1/html</tt> könyvtárra, így ön el tudja érni mindkét dokumentációt a KDevelop -on belül.

Ha ön sikeresen installálta a Qt-2.1 és a KDE 2 függvénykönyvtárakat, csak egy lépésre van az elsõ KDE 2 alkalmazás létrehozásától.
Önnek csak meg kell adnia a KDevelopnak, hogy hova installálta a  függvénykönyvtárakat, amit a következõ részben fogunk megtenni.

<sect> A KDevelop beállítása
<p>
Ez a rész a legegyszerûbb az egész KDE 2 konfigurálási folyamatból. Csak nyissa meg a KDevelop -ot, és válassza a
"Beállítások" -> "KDevelop Beállítás" menüpontot. Ott lépjen az utolsó, "Nyomvonal" címû lapra. Ez a lap két kitöltendõ mezõt tartalmaz,
az egyik a Qt függvénykönyvtár számára, a masik a KDE 2 függvénykönyvtár számára. Ahogy sikeresen installált mindent, állítsa
az <tt>/usr/lib/qt-2.1</tt> könyvtárat a Qt -hez, az <tt>/opt/kde2</tt> könyvtárat a KDE 2 -höz. Klikkeljen az "OK" gombra, és kész is van.

Azok a felhasználók akik csak Qt alkalmazásokat akarnak fejleszteni, csak a Qt-2.x függvénykönyvtár elérési útvonalát kell beállítaniuk.

Most folytathatjuk a következõ fejezetekkel, ahol megtesszük az elõ lépéseket a <em>KScribble</em> példából.<chapt>Alkalmazás alapelvek
<p>
Ez a fejezet, a már említett alkalmazás fajtákról nyújt áttekintést: az MDI (Multiple Document Interface - Többdokumentumos felület) és a 
Dokumentum-nézet formáról lesz szó. A Kdevelop-pal történõ projekt létrehozásának és a Dokumentumnézet formának az alpvetõ bemutatása már megtörtént
 a <htmlurl url="../programming/index.html" name="The KDevelop Programming Handbook"> címen, de csak egy 
SDI-n (Single Document Interface - Egydokumentumos felület) keresztül. Mindenképpen tisztában kell lennie a KDE és a Qt osztályok alapjaival, amelyek leírását a 
<htmlurl url="../kde_libref/index.html" name="The KDE Library Reference Guide"> címen nézheti meg, ahol részletes magyarázat található a háttérkönyvtárak osztályairól és azok használatáról, 
valamint leírás a Qt jel-fogadó  machanizmusáról és eseménykezelésérõl.

Áttekintés arról, amit már tud:
<itemize>
<item>Minden KDE alkalmazásnak szüksége van egy <tt>KApplication</tt> példányra (a Qt alkalmazásnak pedig egy 
<tt>QApplication</tt> példányra).
<item>A KDE, egy fõ ablakot általában a <tt>KTMainWindow</tt>-tõl vesz át (a Qt alkalmazás pedig a 
<tt>QMainWindow</tt> -tõl).
<item>Az esmények (pl. bilentyû leütés, egérmozgáspk) az ablakkezelõ rendszeren keresztül kerülnek az alkalmazáshoz.
<item>A <tt>QWidget</tt> , mint minden látható Grafikus Felhasználói Felület (GUI) összetevõinek alaposztálya, a virtuális funkcók által külön 
eseménykezelõket biztosít, hogy a <tt>QObject::event()</tt> reimplementálásával határozza meg az eseményt.
<item>A Qt jel-fogadó mechanizmusa alapvetõen azt jelenti, hogy egy összetevõ jeleket küldhet, és a fogadó ezeket 
fogadva hajt végre utasításokat.
<item>Ezzel az eljárással elkerülhetõ az osztályok hátrahagyása a GUI összetevõk számára, mert jelek értesítenek pl. azokról az egérkattintásról, 
ahol egy widget-nek elsõbbsége van.
</itemize>

<sect>A Dokumentumnézet forma
<p>
A Dokumentumforma, egyike a  legalapvetõbb fogalmaknak a Grafikus Felhasználói Felületen történõ alkalmazástervezésben. Ezért 
könnyû megérteni, hogy miért kell megismerni az okait annak, amiért a programozók mégis szívesen használják ezt más lehetõségek ellenére. 
Elõszõr azonben lássuk hogyan készül egy tipikus KDE/Qt alkalmazás:

Az alkalmazás kérelme adja egy program eseménykezelõjének a kiindulópontot. 
A programmal magával a felhasználó egy Grafikus Felhasználó Felületen keresztül kerül kapcsolatba, amit leggyakrabban 
fõablaknak neveznek. A fõablak nyújtja aztán az olyan szolgáltatásokat, mint a gyorsbillentyûk, a menüsor, az eszköztár, és állapotsor. 
Ennek közepén van az úgy nevezett "nézet terület", egy olyan rész, amiben más osztályok meghívhatók. 
Ezt általában csak "Kilátó"-nak hivják. A "kilátó" akkor kerül meghívásra, amikor a "fõ ablak" egy programindításnál megnyílik 
és "kilátó terület" összetevõként kell hogy beállítódjon egy olyan eljárással, amit a 
"fõ ablak" biztosít: <tt>setView(your_view)</tt> a KDE alkalmazásokhoz a <tt>KTMainWindow</tt> -t használva, <tt>setCentralWidget(your_view)</tt> a 
Qt alkalmazásokhoz a <tt>QMainWindow</tt> -t használva. Így nyilvánvaló, hogy a "kilátó" az a terület, amelyik felel a felhasználóval való kapcsolatért,
 hogy az kezelhesse azokat az adatokat, amelyek ott feltünnek. Példaként: használhats egy <tt>QMultiLineEdit</tt>-t, "kilátóként", 
ami által egy szövegszerkesztõhöz jut. Aztán használhatja még a "kilátó" meglevõ "fogadóit", hogy kapcsolatot teremtsen a menüsor, 
vagy eszköztár parancshoz a következõképpen:

Miközben a menüsort készítí, meg akar adni egy eljárást a "kivágás" parancsnak a "Szerkesztés" menüben: 
<tscreen><verb>
 pEditMenu>inseritem(BarIcon("editcut"), i18n("Cu&amp;t"),view, SLOT(cut()),KAccel::Cut, ID_EDIT_CUT);
</verb></tscreen>

Ez létrehoz egy menüpontot a "Szerkesztés" menüben, amely aktiválódásakor közvetlenül hívja meg a 
<tt>view</tt> <tt>cut()</tt> "fogadó"-ját; tehát feltételezzük, hogy  egy <tt>QMultiLineEdit</tt> -ként hozta létre és mint "kilátó területet" állította be. 
A multilineedit "fogadó" meghívódik, és válaszképpen kivágja a kijelölt szöveget. A mûködõképességet már biztosította az osztály maga, 
így nincsen szükség a <tt>QMultiLineEdit</tt> -tõl átvenni azt, hogy létrejöjjön egy "nézet terület", amelyik képes az ilyesfajta feladatok elvégzésére. 
Hamar készen is állnak a az alkalmazásfejlesztés elkészítésére és használatára - már csak egy alkalmazásra és a fõablakra van szüksége, 
amelyek kapcsolatban állnak a nézet területtel, és el is készült. Ez azt jelenti, hogy egy kis szövegszerkesztõt létre lehet hozni egy 
egyszerû osztály megírásával, amelyik leírja a fõablak viselkedését, valamint az állományok mentésének és betöltésének mikéntjét a szerkesztõben. 
A fõ kilátónak magának, csak néhány alapvetõ fogadót kell lekezelnie.

Lássuk az okot, amiért ezt a rejtélyes Dokumentumnézet formát bemutatjuk: önnek kell megadnia azokat az eljárásokat, amelyek olvassák 
és írják a szerkesztés alatt álló állományokat a <tt>QMultiLineEdit</tt> nézettel a <bf>within</bf> fõablak felületen. 
Ez a legjobb és a leglogikusabb, amit ebben az esetben tehet. Ha az állományok tartalmára, mint egy 
"dokumentumra" tekint, amit a C++ terminológiájával élve "objektum"-változóként is felfoghatunk, akkor a következõ lépés nagyon egyszerû. 
Ha van egy dokumentumunk, egy nézetünk és egy fõablakunk, akkor miért ne különíthetnénk el ezt a három objektumot egymásól? Könnyedén létrehozhat egy 
kis osztályt, ami egy állomány szövegablakba való beolvasásáért felel, azután pedig meghívja a nézetet a szöveg láthatóvá tételének érdekében. Az állomány ismételt elmentésének érdekében 
ugyanez megtehetõ - a dokumentum osztálynak ezután biztosítania kell egy mentési eljárást, mely a nézetbõl visszanyeri a szöveget az állomány számára. Példánkban csak ezt a két eljárást kell végrehajtania dokumentumosztálynak, 
mert a szerkesztés-nézet alapvetõen minden olyan eljárást biztosít a fogadók által, melyekre egy editornak szüksége van. 
Ezeken keresztül, ön közvetlenül kezelheti a nézet tartalmát is.

A legalább kettõ (nézet, fõablak) helyett, három objektumra (dokumentum, nézet, fõablak) történõ elkülönítés alapötlete a következõ 
kérdés felvetésébõl származik: Mi van akkor, ha a felhasználónak meg akarjuk adni azt a lehetõséget, hogy egy állománnyal <bf>két</bf>, vagy több nézetben is 
dolgozhasson egyszerre? Ezt egy fõablakban is megtehetjük osztók, vagy elválasztók segítségével, amely igy két olyan nézetet is tartalmazhat, melyek külön külön 
megjelenítenek <bf>egy</bf> állományt. Itt azonban elõjön az aprobléma, hogy ez a megoldás csak akkor mûködik, ha a felhasználó megváltoztatja az állományt az egyik kilátóban, 
és a másik nézet is értesül errõl, hogy tartalma frissülhessen. Másképpen hiba léphet fel: ha a felhasználó bezárja azt a nézetet, amelyben 
hozzáadott valamit az állomány végéhez, amit a másik <bf>in</bf> nézetben szereplõ állomány elejérõl vágott ki, akkor az állomány úgy kerül 
elmentésre, hogy még mindig tartalmazza a kivágott részt. Hiszen ha a nézetek nem 
értesülnek az adott állomány változásairól, akkor az elmentés után tartalmazni fogják mind a kivágott, mind a beillesztett részt is. 
Ez azt jelenti, hogy a nézeteket összhangban kell tartani, hogy az állomány változásait érzékelhessék és egyformán megjeleníthessék, 
bármelyik nézetben is dolgozik a felhasználó. Ezek szerint, végül is egy dokumentum osztálynak kell felügyelnie a dokumentum valós állapotát, 
és biztosítania kell a nézeteknek, hogy változtathassanak tartalmukon.

Remélem, hogy a fent taglaltak engedtek némi betekintést ebbe a szerkezetbe; habár legtöbb esetben úgy tûnik, hogy a programozó meg lehet nélküle egy meglévõ osztály nézetként 
való használatával, vagy egy widget megírásával, amit felhasználóval való kapcsolat kezelésére használ. Ameddig ön csak 
<bf>egy</bf> dokumentumot jelenít meg <bf>egy</bf> nézetben, addig a nézet képes követni az állomány változásait, és csak azokért az eljárásokért felel, amelyek beállítják, vagy 
visszanyerik a dokumentum tartalmát a beolvasás, vagy az elmentés során. A következõ forma amit leírunk, az Összetett 
dokumentumfelület lesz, ami különbözik az itt leírtaktól. Meg fogja látni, hogy miért szükséges a Dokumentum nézet forma, és hogy milyen lehetõségeket 
biztosít.

<sect>A Többdokumentumos felület (MDI)
<p>
Az elõzõ fejezetben leírtak alapján, talán már sejti is, hogy mit jelent az MDI. Azok a felhasználók, akik nem 
Unix/Linux rendszert használnak, hanem valamilyen más operációs rendszert, azok használják ezt, miként az azokra a platformokra fejlesztõ programozók is. Miközben az X-Window alkalmazások hagyományosan nagyobb hangsúlyt 
fektetnek a stabilitásra és a funkcionalitásra, addig a Unix felhasználók egyszerû ablakokat használnak a mûködést biztosítására, ezért még a 
Dokumentum-nézet formára sincs gyakran szükség egy alkalmazás létrehozásához. A Qt-val, mint többplatformos eszközzel, a fejlesztõknek 
lehetõségük van mind MS Windows (tm), mind Unix rendszerek alá fejleszteni. (Ezt a mondatot nem értem!!!!!!!!!!!!!!) Olyan alkalmazások a hiányában, 
amelyek képesek az u.n. "child window"-k kezelésére, a Windows szabványosodott, 
ez a Qt könyvtárnak köszönhetõ, de a Unix felhasználók is profitálnak ebbõl a felépítésbõl. !!!!!!!!!!!!!

Mit is jelent az MDI? Egy MDI alkalmazásnak általában u.a. a koncepciója, mint egy szokásos alkalmazásnak -amint azt feljebb már leírtuk-,hogy tartalmaz 
egy alkalmazást és egy fõablakot. A nézet terület azonban egy kicsit más: nézetet közvetlenül nem használunk arra, hogy megjelenítse az adatokat, hogy 
dolgozzunk velük, hanem arra használjuk, hogy kezelje a többi ablakot, mint egy magas szintû fõablak. Ezek az ablakok 
alkotják most az elõbbi kilátó területet, valamint a fõ különbség az, hogy a kapcsolat láncolata megváltozik az

<tscreen><verb>
alkalmazáshívás -> fõablak -> kilátó 

-ról az

alkalmazáshívás -> fõablak -> kilátó -> aktív "child window" 

-ra
</verb></tscreen>

A nézet így számos tevékenység elvégzésére képes:
<itemize>
<item>Annyi "child window" létrehozására, amennyit a felhasználó igényel
<item>Eljárásokat biztosít az éppen aktív "child window" tartalmának kinyerésére
<item>Tárolja a nyitva levõ kilátók listáját
<item>Felügyeli a "child window" viselkedését annak aktivitása szempontjából, tehát úgy viselkedik, mint egy ablakkezelõ a magasszintû ablakoknál.
</itemize>

Most, már "teljes" elemeket használunk -pl a <tt>QMultiLineEdit</tt>- "child windiws"-ként, mondjuk egy alkalmazáshoz, amelyik egy ablakkal rendelkezik és 
minden "child window" a saját adataiért felel. Ez nevezhetõ "Multiple Document Interface - Összetett dokumentumfelület"-nek, ahol 
minden "child window" olyan, mint egy dokumentum. Az alkalmazás biztosítja azokat az eljárásokat, amelyekre a "child window"-knak szükségük van, 
mint pl. a kivágás, másolás. Ennek a dokumentumnézet koncepciónak a kiterjesztésével további lehetõségekhez jutunk: képzeljük el, hogy a fõablakban 
annyi "child window"-t nyithatunk meg, amennyit szeretnénk, és hogy az új "child window"-k egészen új nézetét adhatják annak a dokumentumnak, 
amelyet egy másik "child window" már mutat. Ennek megszervezéséhez szükség van a már leírt három objektumos formába való elkülönítésre, 
de ez nem korlátozza a megnyitott dokumentum példányinak számát, ugyanúgy, ahogy nézetek számát sem.

Szerencsére a Qt 2.1 rendelkezik azzal a lehetõséggel, hogy ilyen alkalmazásokat hozzunk létre, és a Kdevelop is biztosítja ezt 
keretalkalmazásaival, mind a csak Qt programoknál, mind a KDE 2 alkalmazásoknál ugyanazon a felületen; tehát szabadon megválasztható, hogy melyik típushoz 
szeretnénk fejleszteni. A KDE 2 felületek még több lehetõséget kínálnak a könyvtár-funkciók, és a végrehajtás közbeni 
kommunikáció által, de ezeknek a technikáknak a bemutatása egy újabb leírásnak képezhetik csak tárgyát.

Most már felkészült a KDE 2-re való fejlesztésre - csak kövesse a következõ fejezetet, hogy megismerje a Kdevelop által, 
az alkalmazásfejlesztéshez biztosított funkciókat. Elõállítjuk majd a <em>KScribble</em> példaalkalmazásunk keretét 
és elolvashatja az MDI alkalmazások programozásának praktikus szempontjait.

<itemize>
<item>(Téma a KDevelop)
<item>
<item>main-window = fõablak
<item>view area = kilátó terület
<item>"View" = nézet
<item>Multiple Document Interface = Többdokumentumos felület
<item>Single Documentum Interface = Egydokumentumos felület
<item>Documentum View model = Dokumentumnézet forma
<item>signal = jel
<item>slot = fogadó  (Qt signal-slot mechanism = A Qt jel-fogadó mechanizmusa) 
<item>instance = hívás (meghívása egy alkalmazásnak), vagy példány
<item>underlying libraries = háttérkönyvtárak
<item>underlying window system = ablakkezelõ rendszer
<item>event handler = eseménykezelõ
<item>key acclerator = gyorsbillentyû (itt a gombokról van szó a képernyõn)
<item>status bar = állapotsor
<item>tool bar = eszköztár
<item>menu bar = menüsor
<item>widget = elem
<item>child window =
<item>top level window = magas szintû ablak
<item>window manager = ablakkezelõ
</itemize>
<chapt>Az MDI keretalkalmazás
<p>
If you're already familiar with previous versions of KDevelop, you will know that your IDE uses so-called "frameworks" as a starting
point of application development. These frameworks by default contain a support for a generic document-view model, but were limited to
SDI (Single Document Interface, one window with one view area) model structures. From KDevelop 1.1 on, the application wizard is
capable of a lot more than the previous versions: it offers some new project types especially for those developers that want to stay
up-to-date with the upcoming KDE 2 as well as for Qt 2.1. One major extension are MDI application frameworks for both, KDE 2 and Qt
2.1. These frameworks differ only in the use of some library functions such as file dialogs or message boxes as well as the used
toolbar and statusbar classes - the KDE version uses KDE 2 methods, the Qt version the according Qt functions.

To create the fist step of this tutorial application <em>KScribble</em>, be sure that you have followed the instructions in chapter 2
of this tutorial handbook: setting up KDE 2. If that went all right, nothing can go wrong. If you couldn't set up the KDE 2 libraries,
be sure that you have Qt-2.1 installed and set up KDevelop for that at least. You can follow this tutorial by choosing the according Qt
framework as well (which has the differences as mentioned above: other method calls for dialogs and GUI components).

<sect>Creating an MDI Framework
<p>
Now we will start jumping into development by creating the frame application for <em>KScribble</em>. Start KDevelop and choose
"Project"-"New" from the menubar to invoke the application wizard. On the first page, you will be shown a tree of project types. These
contain KDE and Qt projects. There, select "KDE 2 MDI" from the KDE section. If you only have Qt 2.1 installed, choose "Qt 2.1 MDI"
from the Qt section. Then select "Next", enter "KScribble" as project name and "1.0" as version number. Add your name
and email address into the according fields and you're done. Click on the "Create" button and KDevelop will generate our first version
of <em>KScribble</em> while you can watch the output in the last page of the wizard. Finally, press "Exit" to return to KDevelop. In
the output window you will see an additional message showing that the messages file has been set up for your project, which will be
important to translate <em>KScribble</em> into other languages.

<sect>Overview
<p>
Now it is important to have an understanding where to find what in the generated sources and where your place as a programmer can be
found to make <em>KScribble</em> a unique KDE application.

First of all, in the Classviewer you will see three already created classes, <tt>KScribbleApp</tt>, <tt>KScribbleDoc</tt> and
<tt>KScribbleView</tt>. As explained above, each of them has a certain part within the application; the App class builds the main
window and coordinates user interaction, the Doc class maintains the documents that an application can manipulate; finally the View
class is responsible for user interaction with the child windows and communicates with the document connected to it. This has several
consequences: to make a good use of the provided functionality, the programmer is bound to use the given View class. By default, the
View inherits <tt>QWidget</tt> as a minimum requirement, but you're by far not limited to that. But inheriting from another class is
not too much work and finally there is also the possibility to use a <tt>QMainWindow</tt> or <tt>KTMainWindow</tt> for example as the
class to inherit and use another class that manages the view.

In the next chapter we'll continue with extending <em>KScribble</em> to manage it's documents. After that we'll implement the user
interaction and you will see the first functionality that is unique to our application: we can draw pictures, load and save them.


<chapt>A dokumentumok definiálása
<p>

The first step when creating an application based on the Document-View model should always be to think what kind of data the
application has to manage. This decides how the view class will look like but especially how the document clas will read and write data
to and from files and offer methods to manipulate the data. As <em>KScribble</em> will be a simple drawing application that operates on
graphical data, we will use the Qt class <tt>QPixmap</tt> for storing our paintings while it is edited. <tt>QPixmap</tt> also offers
simple methods to read and write pictures into files, so the serialization of the document data is done in just two lines, one for
reading and one for writing. Further, we need to define a pen that draws into a document, set it's width and color and make it
available for the view class to retrieve the pen - actually you want the view offering the drawing methods, but the document as the
central element for all views has to hold the pen originally, because two views of the same document would otherwise use different
pens!

Therefore to define how our document class should work, we will add one instance of <tt>QPixmap</tt>, one of <tt>QPen</tt> and edit the
methods <tt>newDocument()</tt>, <tt>openDocument()</tt> and <tt>saveDocument()</tt>.

<sect>Adding the Instances
<p>

Open the file <tt>kscribbledoc.h</tt> by selecting it in one of the fileviewers or by a click on the classviewer over the class
<tt>KScribbleDoc</tt>. Then add the lines marked with -> from the following code snippet:


<code>
->  #include <qpixmap.h>
->  #include <qpen.h>

    class KScribbleDoc
    {

->    	protected:

->        QPen currentPen(){ return pen;};	
    		
->    		int penWidth()
->    			{ return pen.width(); }

      public slots:
        void updateAllViews(KScribbleView *sender);
    	
    	protected:
    	
->    		QPixmap buffer;
     	
      private:
->    		QPen pen;
        /** the modified flag of the current document */
        bool modified;
</code>

As you see, we added pen and buffer as well as <tt>currentPen()</tt> and <tt>penWidth()</tt>. As pen is declared private, we offer a
possibility to retrive the pen as well as the pen width. As these are already implemented within the classdeclaration, we don't have to
add them to the implementation file, where we're turning to now.

<sect>Initialization of the Document
<p>

Select the method <tt>newDocument()</tt> in the <tt>KScribbleDoc</tt> class to jump to the method declaration. Here, we're only adding
one line, marked with the arrow:
<code>
  kscribbledoc.cpp

  bool KScribbleDoc::newDocument()
  {
    /////////////////////////////////////////////////
    // TODO: Add your document initialization code here
->  pen=QPen( Qt::black, 3 );
    /////////////////////////////////////////////////
    modified=false;
    return true;
  }
</code>

This initializes the pen with the color black and width of 3 pixels; the <tt>QPen</tt> class has some more constructors, but this one lasts our
needs here.

<sect>Implementing the Serialization
<p>

What is left to do is to define how to open and save our pictures. This is done in the according methods:

<code>
    bool KScribbleDoc::openDocument(const QString &amp;filename, const char *format /*=0*/)
    {

    	QFile f( filename );
->     //if ( !f.open( IO_ReadOnly ) )
->     //	return false;
     /////////////////////////////////////////////////
     // TODO: Add your document opening code here
->     if(!buffer.load( filename, "PNG" ))
->     	return false;
     /////////////////////////////////////////////////
->     //f.close();


    bool KScribbleDoc::saveDocument(const QString &amp;filename, const char *format /*=0*/)
    {
      QFile f( filename );
->     // if ( !f.open( IO_WriteOnly ) )
->     // 	return false;

      /////////////////////////////////////////////////
      // TODO: Add your document saving code here
->    	if(!buffer.save( filename, "PNG" ))
->    		return false;
      /////////////////////////////////////////////////

->      //f.close();

</code>

Add the lines marked with the arrow again to your code. What we did here is to comment out the passages where the file
<tt>filename</tt> is opened, because that is done automatically by the load and save methods of <tt>QPixmap</tt>, which we add instead. Other
documents may open a file and read in its contents such as text lines or whatever, so the <tt>QFile</tt> methods are already present in the
codeframe. As <tt>save()</tt> and <tt>load()</tt> return a boolean value if the operation was successful, we're returning false if not,
so the rest of the framework gets a return value and can give out warnings if the operation was not successful.
The <tt>load()</tt> and <tt>save()</tt> methods now are already provided in <tt>QPixmap</tt>. They require the filename and the format as
argument; the source framework on the other hand <bf>does not</bf> call the document methods with the format yet. If only one format is
used, it lasts to set the format here. other methods could detect the format for example- but we will turn to this later. For now,
we're using "PNG" as format; see <tt>QImageIO</tt> for more details about the image formats that can be opened.

Now we're already finished defining our document structure. The <tt>QPixmap</tt> buffer serves us as a buffer storing the original picture
contents while we're working on it, the pen is a valid pen for all views connected to the document. Note that the initialization of the
pen is done in <tt>newDocument()</tt>. This method is always called after the constructor within the framework internally, so you
should add document instances initializations there as we did with the pen.

In the next chapter we will turn to the view class to define how the view shall cooperate with the user as well as how it accesses the
document- and then we'll be ready to paint !

<chapt>A nézet definiálása
<p>

<sect>Interactivity with the User
<p>

In this chapter we'll turn to the view class of <em>KScribble</em> to define how the child windows shall work. First of all, we notice that
KScribbleView is derived from <tt>QWidget</tt> by default. That is the minimum requirement for a child window, but it lasts already to fullfill
our needs. When it comes to defining a new widget's behavoir, we need to know how the user shall interact with the window. In our
example, this would be obviously the mouse. Therefore, we have to overwrite some virtual methods from <tt>QWidget</tt> that process mouse
events the widget receives. What we need is to know when the user presses a mouse button, because the drawing shall only take place
when the mouse is pressed. Then we need to know when the mouse is moved (to know where it moves to) as well as when it is released-to
finish the stroke the user has drawn. Further we want our picture to be painted on the window and resized if the user decides to resize
the window he draws into. As members we will also add a <tt>QPointArray</tt> polyline and a boolean value mousePressed. Add the code with the
arrow to your include file for the class KScribbleView:

<code>
   kscribbleview.h

->   #include <qpointarray.h>

    class KScribbleView
    {
    .
    .
     protected:
        virtual void closeEvent(QCloseEvent* );

->     	virtual void mousePressEvent( QMouseEvent * );
->     	virtual void mouseReleaseEvent( QMouseEvent * );
->     	virtual void mouseMoveEvent( QMouseEvent * );
->     	virtual void resizeEvent( QResizeEvent * );
->     	virtual void paintEvent( QPaintEvent * );
   	
   	  KScribbleDoc *doc;
     		
->     private:
->   		bool mousePressed;
->   		QPointArray polyline;

     }
</code>


<sect>Reimplementing Event Handlers
<p>

Now we're coming to the actual implementation of the event handlers. As explained in <htmlurl url="../kde_libref/index.html" name="The
KDE Library Reference Guide">, Qt has a good way of handling user events, especially when they target on to widgets. <tt>QWidget</tt> as a
baseclass preselects the events and provides basic event handlers which, as they are declared as virtual, we can overwrite to define
how our widget shall react on user actions. One is already overwritten: the <tt>closeEvent()</tt> method. This is needed, because our
main window, represented in the App class, already preselects closing child windows and handles this; therefore the default event
handler, which just accepts the closing, must be overwritten to prevent that and let the App class do the job.

First of all, we have to declare the widget default behavoir in the constructor by initializing members and setting predefined values:

<code>
    kscribbleview.cpp


    KScribbleView::KScribbleView(KScribbleDoc* pDoc, QWidget *parent, const char* name, int wflags)
     : QWidget(parent, name, wflags)
    {
        doc=pDoc;

->      setBackgroundMode( QWidget::NoBackground );
->      setCursor( Qt::crossCursor );
->    	mousePressed=false;
->      polyline=QPointArray(3);
    }
</code>

We're setting the background to NoBackground, a cursor (crossCursor) and initialize mousePressed and polyline. Then we'll start
implementing our first event handler, <tt>mousePressEvent()</tt>, to recognize when the user presses the mouse and where:

Note: the following implementations have to be inserted completely, so the lines to add are not marked with an arrow !

<code>
void KScribbleView::mousePressEvent( QMouseEvent *e )
{
  mousePressed = TRUE;
  polyline[2] = polyline[1] = polyline[0] = e->pos();
}
</code>

Here, we're setting mousePressed to true, so we have stored this event somehow. The second line is not so obvious: we're storing the
position where the mouse was pressed into our array's first three elements. As the array is a <tt>QPointArray</tt>, it can store values of the
type <tt>QPoint</tt> (which contain an x and y value themselves). What we will do with this array is to store positions of the mouse and create
the drawing routine from there in the mouseMoveEvent:

<code>
void KScribbleView::mouseMoveEvent( QMouseEvent *e )
{
  if ( mousePressed ) {
		
    QPainter painter;
    painter.begin( &amp;doc->buffer );
    painter.setPen( doc->currentPen() );
    polyline[2] = polyline[1];
    polyline[1] = polyline[0];
    polyline[0] = e->pos();
    painter.drawPolyline( polyline );
    painter.end();

    QRect r = polyline.boundingRect();
    r = r.normalize();
    r.setLeft( r.left() - doc->penWidth() );
    r.setTop( r.top() - doc->penWidth() );
    r.setRight( r.right() + doc->penWidth() );
    r.setBottom( r.bottom() + doc->penWidth() );

	  doc->setModified();
    bitBlt( this, r.x(), r.y(), &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
  }
}
</code>

This event handler is probably the most difficult, so we will do a step-by-step walkthrough to understand what's been done. First of
all, the event handler receives all mouse movements over the widget. But as we're only interested in the move if the mouse is pressed,
because that is the time to draw, we have to ask if mousePressed is true. That has been done by the <tt>mousePressEvent()</tt> event
handler before, so we don't have to take care for more. Now we're starting the painting action. First we create a <tt>QPainter</tt> and let it
draw into the buffer of the document. This is important, because the document's buffer contains the real contents, the view only acts
as a communicator between the document and the user. We get the pen from the document instance as well by calling
<tt>currentPen()</tt>. The next three lines assign the values inside the polyline <tt>QPoint</tt> array, setting point 2 to 1, 1 to 0 and 0 to
the point to where the move went (this is the contents of the event we're interested in). Assuming we've just pressed the mouse (so all
three values of the array contain the pressing position) and the first mouse move event appears that contains the first position to
draw a line to; this value is moved into the first position in the array again. You may wonder why we need three points in the array
then, if we're only interested to draw a line from one position to the next. The following lines explain that: after drawing into our
buffer is finished (with <tt>drawPolyline()</tt> and <tt>painter.end()</tt>), we create a rectangle r and use <tt>boundingRect()</tt>
from <tt>QPointArray</tt> to get a <tt>QRect</tt> that contains all three points. Therefore we need three values to have a most-complete rectangle. Then
we use <tt>normalize()</tt> to have the leftmost and topmost values the smallest (as coordinates are counted from top->bottom and
left->right). The next thing to do is adapt the size of the rectangle by the size of the pen, because the pen has a thickness we get
with <tt>penWidth()</tt> and widen the rectangle by the width of the pen. (Imagine the mouse movement was only two pixels away but the
pen thickness is set to ten- then the rectangle wouldn't contain the whole painted area).

Finally, we set the document modified and use the <tt>bitBlt()</tt> function to copy the rectangle out of the buffer into the widget.
bitBlt operates bitwise and is very fast, so that it is a good method to copy the painted area from the buffer on the widget instead of
repainting the whole window. It's arguments are: first the object to draw to (the destination), here it is our widget, so we have to
use the pointer <bf>this</bf>. The next two arguments give the destination topleft position to start copying to, then follows the
source to draw from with it's coordinates now including the width and height. As the pixmap coordinates are the same as the coordinates
that the widget uses (because our pixmap is drawn into the topleft corner), the coordinates for the source and destination topleft
point are the same. This is something to watch out for in some of the next step, so it may be mentioned here already.

Next comes what happens if we release the mouse button. Then the drawing has to stop when we move the mouse again, so we set
mousePressed to false here:

<code>
void KScribbleView::mouseReleaseEvent( QMouseEvent * ) {
	mousePressed = FALSE;
}
</code>

Now we have finished implementing the user interaction when it comes to the actual drawing operations. The example shows it's not too
complicated to use a document-view model. Just create your document instance so that it contains the contents and copy the contents to
your view.

<sect>Painting and Resizing the Document
<p>

What is left to do are two other virtual event handlers that need a reimplementation. First of all, we have to take care that our
picture gets painted into the window when something else happens: when you open another window that obscures the painting - then you
change to your painting again, but it won't be there, unless your paint event gets processed to redraw the picture:

<code>
void KScribbleView::paintEvent( QPaintEvent *e )
{
  QWidget::paintEvent( e );

  QRect r = e->rect();

  bitBlt( this, r.x(), r.y(), &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
}
</code>

This method also uses <tt>bitBlt()</tt> to draw the picture from the buffer into the widget. Here, we only need the rectangle that gets
repainted, so we retrieve the geometry from the event ( <tt>e->rect()</tt> ) and use the coordinates for <tt>bitBlt()</tt>, just as we
did in the <tt>mouseMoveEvent()</tt>.

The only thing where we didn't do anything about is the size of the pixmap. We didn't set it anywhere - we did not even use the pixmap
in the document class except for loading and saving - but these methods aren't called when creating a new picture. So it seems our
pixmap doesn't have a size nor a predefined background at all (even if we would have set the size, the contents would be random colors
because it is uninitialized).
On the other hand we have the fact that the KScribbleView instances get resized when they show up- at least with the minimum size. This
is the point where we can add the initialization as well, because the user can change the size manually and the widget will receive a
resize event as well. For reasons of simplicity, we want to set the pixmap size the same size the widget has. All this is done in the
event handler <tt>resizeEvent()</tt>:

<code>
void KScribbleView::resizeEvent( QResizeEvent *e )
{
  QWidget::resizeEvent( e );

  int w = width() > doc->buffer.width() ?
  width() : doc->buffer.width();
  int h = height() > doc->buffer.height() ?
  height() : doc->buffer.height();

  QPixmap tmp( doc->buffer );
  doc->buffer.resize( w, h );
  doc->buffer.fill( Qt::white );
  bitBlt( &amp;doc->buffer, 0, 0, &amp;tmp, 0, 0, tmp.width(), tmp.height() );
}
</code>
Here, we first call the resizeEvent handler or <tt>QWidget</tt>. Then we calculate the size of our picture - because we can resize a window to
make it smaller or bigger, we have to separate these two cases: if we resize to a smaller geometry, the picture shall still contain
it's contents. On the other hand, if we resize to a bigger widget, we have to resize the pixmap as well to that bigger size. The
calculated values are stored in w and h. But before the resize takes place, we create a copy of our pixmap in the document in tmp. Then
we resize the buffer (the document), fill it with white color and then copy back the contents from tmp into buffer. This resizes our
pixmap always syncronous with the widget that displays it but doesn't loose contents which is outside the visible area if the resizing
makes the widget smaller.

Now our first application has gained a step where we can test it's functionality. Just hit "Run" in KDevelop and after <em>KScribble</em> shows
up, you're ready to paint your first picture with it !

<chapt>A GUI bõvítése
<p>
As we have seen, we have already provided <em>KScribble</em> the ability to open and save pictures with the document class and enabled user
interaction by overwriting virtual methods in the view class and we gained the first functionaliy - we can draw pictures as well. But
when we created the <tt>QPen</tt> instance in the document class, we set some pre-defined values for the pen; the color is black and the pen
width set to 3 pixels. As you usually want to change these values in a drawing application, we have to enhance the main GUI by
providing ways to set these, according to the currently active window and document connected to it. This chapter will therefore
introduce you to:

<itemize>
<item>adding a new menu to the menubar
<item>extending the toolbar with icons for the actions defined in the menubar
<item>creating a new dialog with the KDevelop Dialogeditor
<item>connecting the new commands of the menubar and toolbar to calling the dialogs.
<item>enabling the document class to let us change the pen values
</itemize>

Further, we also add a method to delete the document contents at all with a menubar command.

<sect>Adding the "Pen" Menu
<p>

As the title of this section says, we will add a menu for setting the pen values of the documents here. Menus that are inserted into
the menubar are instances of <tt>QPopupMenu</tt>, and you can have a look at how the current menubar is created when you switch to the
<tt>KScribbleApp</tt> class, method <tt>initMenubar()</tt>. You will see that the menubar items are created in the order they appear on the
menubar - but this isn't necessary. There are two things important on how the menubar will look like:
<itemize>
<item>in the menus the order of the menuitems
<item>in the menubar the order of inserting the popup menus.
</itemize>

Last but not least you have to create menus first with calling the constructor. The class declaration already contains the pointers to
the popup menus, so we will have to add our "Pen" menu here first:

<code>
kscribbleapp.h

class KScribbleApp
{
.
.
  private:
    QPopupMenu* pPenMenu;

}
</code>

Now we are going to create the menu itself. Change to the implementation of the method <tt>KScribbleApp::initMenuBar()</tt> and add the
lines marked with an arrow:

<code>
void KScribbleApp::initMenuBar()
{
..

->  ///////////////////////////////////////////////////////////////////
->  // menuBar entry pen-Menu
->  pPenMenu = new QPopupMenu();
->  pPenMenu->insertItem(i18n("&amp;Color"), ID_PEN_COLOR);
->  pPenMenu->insertItem(i18n("&amp;Brush"), ID_PEN_BRUSH);

    menuBar()->insertItem(i18n("&amp;Edit"), pEditMenu);
->  menuBar()->insertItem(i18n("&amp;Pen"), pPenMenu);
    menuBar()->insertItem(i18n("&amp;View"), pViewMenu);


->  connect(pPenMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
->  connect(pPenMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));
}
</code>

You see that we first create the menu with <tt>new QPopupMenu()</tt>. Then we use the insertItem methods to add two menu entries, Color
and Brush. The visible commands are inserted with the method <tt>i18n()</tt>, which ensures that you can internationalize your
appliction. So as a general rule, you would declare all visual text that will appear later by the method <tt>i18n()</tt>. Qt-only
programs using Qt > 2.0 would use the according method <tt>tr()</tt> instead of <tt>i18n()</tt>, as Qt has it's own ways of
internationalizing applications. The second argument is a macro, the ID of the menubar item. This ID is a number that we have to set
using #define in the file resource.h, where you will see all other already used ID's declared. There are also other ways to insert
menus by directly connecting a slot to the inserted entry, but the application framework uses ID's to select which action has been
activated- and highlighted. Therefore each menu entry, independent of the popup menu it appears, has to be a unique number, and as we
can hardly remember numbers later, setting a #define for the ID is a nice solution. The popup menu is now inserted into the menubar
with <tt>insertItem()</tt> as well, and with the pointer to the menu as second argument.

Note that we inserted the popup menu after the "Edit" menu and before the "View" menu, so it will appear between those menus later in
the menubar. What is also important when creating menus is that they should be available to the user with shortcuts; ususally in menus
you will see underlined characters that the user can jump to directly by pressing ALT and the according underlined letter of the
menuitem. As a programmer, you have to set this character by a leading ampersand, so the "Pen" menu will later be accessible via the
keyboard by pressing ALT+P. Within the menu, the user can press another button to go directly to the command he wants to, so in the
menu all items should have this kind of shortcuts as well. Note that you should write item insertions together in groups that have the
same visible access, so you can keep a better overview of the characters you already used so that there are no menu accelerators used
twice. (this is also important for your translators: in other languages the used accelerator may not be available in the translated
word, so they have to set some accelerators again.)

In the last two lines we're connecting the pen menu with two slots: one for when the menu signals that it is activated and the action
should be executed, and one for when it is highlighted. That allows making a statusbar help message available for the user. You can
have a look at the methods the menu is connected to, they contain switch statements where the sent menu ID is compared and the
following action called.

What is left to do is to add the #define statements to the file resource.h:

<code>
resource.h

///////////////////////////////////////////////////////////////////
// Pen-menu entries
#define ID_PEN_COLOR                14010
#define ID_PEN_BRUSH                14020
</code>

You will see that the numbers are unique for these entries- you have to watch out not to set the same number for two entries- but if it
happens by accident, there's still the compiler that informs you about redefining.

This is currently all you have to do to add a new menu for your menubar. The actions they will execute are: "Color" will call a color
selection dialog, "Brush" will call a dialog (which we still have to create) to select the brush width.

But first we'll extend the toolbar as well by two icons for these actions in the next section.

<sect>Adding Toolbar Buttons
<p>

Whenever you think that some new commands should be made available by toolbar buttons as well because they are often used and you want
to offer additional functionality, you can easily do that by adding buttons in the framework's <tt>initToolBar()</tt> method of the
<tt>App</tt> class. Here, we decide to add a button for both menu entries in the Pen-menu, but those need icons - which you can either
find in the KDE directory /toolbar or, when you don't find an icon that matches your action, have to create yourself. KIconEdit is very
suitable to paint icons, so we will first create them. Choose "New" from the KDevelop "File" menu and select "Icon" as the filetype.
The first icon will be named "pencolor.xpm". Now we have to select where we want to have the icon created in our project directory.
Press the directory selection button and change to your project directory containing the <em>KScribble</em> sources. Then create a new
directory "toolbar". Change to that directory and press "OK". The new icon will then be created in the new directory "toolbar" and will
be opened by KIconEdit within KDevelop automatically. Paint something that will signalize the user what the button is intended to do,
save the pixmap and then switch to the RFV / LFV in KDevelop. Select the icon by a right mouse button press and select "Properties"
from the popup menu. You will see that the icon is included in the distribution, but for your program to find the icon again later, you
have to set the installation destination as well. Check the "install" option and enter into the line now active below:

<tt>$(kde_datadir)/kscribble/toolbar/pencolor.xpm</tt>

This will install the pixmap in the KDE file system hierarchy's data directory, where each application has its subdirectory containing
additional files needed by the application. Icons have to be installed into another subdirectory "toolbar", so the application's icon
loader can find the pixmaps for your program.

After you're finished, repeat all these above steps with the second icon for selecting the pen width. Name this pixmap "penwidth.xpm".

Now we only have to insert the buttons into the toolbar; add the lines marked with the arrow into your code:

<code>
void KScribbleApp::initToolBar()
{
..
    toolBar()->insertButton(BarIcon("editcopy"), ID_EDIT_COPY, true, i18n("Copy"));
    toolBar()->insertButton(BarIcon("editpaste"), ID_EDIT_PASTE, true, i18n("Paste"));
    toolBar()->insertSeparator();
->  toolBar()->insertButton(BarIcon("pencolor"), ID_PEN_COLOR, true, i18n("Color") );
->  toolBar()->insertButton(BarIcon("penwidth"), ID_PEN_BRUSH, true, i18n("Width") );
->  toolBar()->insertSeparator();
    toolBar()->insertButton(BarIcon("help"), ID_HELP_CONTENTS, SIGNAL(clicked()),
..
}
</code>
Here, we use the methods of KToolBar to insert buttons. The first argument, <tt>BarIcon()</tt>, tells the method to load the icon for
the button. What seems unusual is that we don't have to care for the file extension. The preferred format for KDE 2 is *.PNG, but it
works with xpm's as well. (You could use ImageMagick for that as well which can do that- or use <em>KScribble</em> in a later step to
convert your icons to PNG !)

The second argument is again the ID. The commands are then automatically activated, as the <tt>toolBar()</tt> is already connected to
the same methods as the menubar is for signal <tt>activated()</tt>. The third argument stands for "available" when true, "deactivated"
when false; as we want to have these available, we set this to true. At last, we add a tooltip for the the buttons, which we also
embrace with <tt>i18n()</tt> to allow internationalization.

Now you're done for now- the GUI is extended at least visually. You can compile and run <em>KScribble</em> again and see how it looks like- of
course the new items in the menubar and toolbar can't execute any action - that is what we're going to add in the next section.
You will also note that the toolbar icons we added are not displayed - which is because we didn't install <em>KScribble</em> and so they can't
be found. All other used icons are already shipped with the KDE libraries, so these are already visible.



<sect>Creating the Pen Width Dialog
<p>
As we´ve already created the according menubar and toolbar commands, we now have to build the first dialog to set the pen width. For
this, select "New" from the KDevelop "File" menu and select "Qt/KDE Dialog". Then enter the dialog file name as <tt>kpenbrushdlg</tt>,
the extension will be automatically added. Enter "OK" and the dialogeditor opens an empty widget that will be our dialog background.
When constructing a dialog, we have to think about what is really needed by the user; here, we need a label to display what will be
set; a spinbox with up and down buttons to set the pen width value and three buttons, one for resetting the pen width to the default
value, one to cancel the dialog and one for taking over the new value - the OK button. In this order we will add the items to the
dialog - which is important because the tab-focus follows the order by which the widgets are created. So if you´re starting with the OK
button, then the spinbox and then the cancel button, the input focus will change from the ok button to the spinbox and then to the
cancel button - which is not what the user expects. The tab focus should follow the widget´s items top-down from left to right, so we
have to construct the dialog in this order as well. To add items to the dialog, select the "Widgets" tab on the left pane. There you
have all available widgets present by icons to construct your dialog. Pressing a widget button will create the new item and place it at
the top-left corner of the widget. From there, you can place it with the mouse to the position you would like it to show up. Further,
when a widget item is selected, you can set the according values in the "Widget Properties" pane on the right.

<bf>The Label:</bf> press the "QLabel" button on the "Widgets" tab and place it at position x:50, y:20. Then select the "General"
section in the widget properties pane. Change the text in properity "Text" from "Label" to "Pen Width:". Adjust the width of the label
to a width that matches the label contents in x-direction; a width of 120 should last. You can do this either by using the mouse or set
the value in the "Geometry" section of the properties.

<bf>The Spinbox:</bf> press the "QSpinBox" button on the "Widgets" tab and place it at the right of the label we created in the last
step. Now set the variable name in section "C++Code" to "width_spbox". The minimum and maximum values are 1 and 100, which should last
for setting the brush width.

<bf>The Buttons:</bf> finally, we need the mentioned three buttons. The leftmost button will be the default button. Create a
<tt>QPushbutton</tt> and place it somewhere nicely on the bottom of the dialog, set the variable name to "default_btn" and the button text to
"Default". Proceed with the OK button with variable name "ok_btn" and the cancel button with variable name "cancel_btn" and set the
button text to "&amp;OK" and "&amp;Cancel".

If you´re fine with the layout of the dialog, choose "Generate complete sources" from the Build menu and set the classname to
"KPenBrushDlg", the inheritance to <tt>QDialog</tt>. After pressing "OK", the sources for the dialog are created and added to the project. Now
you can return to the editor view in KDevelop and we can add the code needed to give the dialog some execution purpose.

<sect>Connections and Setting Up
<p>
After we have created the GUI of the dialog, we have to add some functionality to the buttons and provide ways to set and retrieve the
selected value of the spinbox - because we want the dialog to display the current value when it gets called and to access the selected
value when the user pressed the OK button to quit the dialog.

In the generated class for the dialog, <tt>KPenBrushDlg</tt>, you can see one method besides the constructor and the destructor,
<tt>initDialog()</tt>. This method implements the whole GUI construction, so we don´t have to care for that anymore and we can go
directly to add the usual connections for the push buttons first. Add the lines marked by arrows to the constructor of the
dialog:

<code>
KPenBrushDlg::KPenBrushDlg(int curr, QWidget *parent, const char *name) : QDialog(parent,name,true){
	initDialog();

->	connect(default_btn, SIGNAL(clicked()), this, SLOT(slotDefault()));
->	connect(ok_btn, SIGNAL(clicked()), this, SLOT(accept()));
->	connect(cancel_btn, SIGNAL(clicked()), this, SLOT(reject()));
}
</code>

This provides the functionality for the buttons on the bottom of the dialog when the user clicks the button. First, we set the default
button to execute a slot called <tt>slotDefault()</tt>. This slot is still to be implemented below, where we will set the default value
of the spinbox directly.

The second <tt>connect()</tt> call connects the ok button to call the slot <tt>accept()</tt> provided by <tt>QDialog</tt>, as well as the cancel
button gets connected to <tt>QDialog</tt>´s slot <tt>reject()</tt>. This will both close the dialog and will set the result value which we will
use later when we implement the method that calls the dialog to determine if we want to use the value set or to ignore any changes.

Now we have to add two methods to set and retrieve the spinbox value:

<code>
void setCurrent(int curr){ width_spbox->setValue(curr); }
int width() { return width_spbox->value(); };
</code>

Add these methods to the class declaration with the modifier "public", as we want to set and retrieve the values when we call the
dialog to show up. The <tt>setCurrent()</tt> method will be used to set the current value the pen has, the <tt>width()</tt> method
returns us the selected with when the user presses OK and we want to know which value has been chosen.

Last but not least, we need to implement the <tt>slotDefault()</tt> method:

<code>
//kpenbrushdlg.h:
//method declaration:

public slots:
  void slotDefault();

//kpenbrushdlg.cpp:
//method implementation:

void KPenBrushDlg::slotDefault()
{
  width_spbox->setValue(3);
}
</code>

This will set the default value to 3 pixels for the pen.

Now we´re ready with our first dialog and we can turn to over to the other application classes to adapt some things and add the method
calls to invoke the dialog.

<sect>Calling the Dialogs
<p>
As you may guess, calling the dialogs means that we will not only implement calling our width selection dialog but also add the method
for selecting the pen color, but one after another. First, create a method <tt>slotPenBrush()</tt> in the class <tt>KScribbleApp</tt>:

<code>
void KScribbleApp::slotPenBrush()
{
  slotStatusMsg(i18n("Setting brush width..."));

  // get one window with document for a current pen width
  QWidgetList windows = pWorkspace->windowList();
  KScribbleView* m = (KScribbleView*)windows.at(0);
	KScribbleDoc* pDoc = m->getDocument();
  int curr_width=pDoc->penWidth();

  // create the dialog, get the new width and set the pen width for all documents
  KPenBrushDlg* dlg= new KPenBrushDlg(this);
  dlg->setCurrent(curr_width);
  if(dlg->exec()){
    int width=dlg->width();
  	for ( int i = 0; i < int(windows.count()); ++i )
  	{
    	m = (KScribbleView*)windows.at(i);
    	if ( m )
    	{
    		pDoc = m->getDocument();
        pDoc->setPenWidth(width);
    	}
  	}
  }
  slotStatusMsg(i18n("Ready."));
}
</code>
Here, we first have to access the window list and retrieve a pointer to a document - which can be a document of any window, because all
documents should have the same current pen width. Then we create an integer variable curr_width that stores the current pen width.

Now we can call the dialog by creating the dlg instance of KPenBrushDlg. Then we set the current pen width by calling
<tt>dlg->setCurrent()</tt>, which method we added to the dialog.
By calling <tt>dlg->exec()</tt> we invoke the dialog. The <tt>if()</tt> statement ensures that the following code is only executed when
the result code of the dialog has the accept flag set - which means, the code is executed if the user pressed the OK button on the
dialog.

Assuming the user changed the value and pressed OK, we have to set all documents to use the new pen width. For that we use the
<tt>for()</tt> loop and set every document´s pen width to the width variable we retrieved before with <tt>dlg->width()</tt>.

We don´t have implemented the method <tt>setPenWidth()</tt> in the document class, so we´ll do this right now:

<code>

kscribbledoc.h:

public:
  void setPenWidth( int w ){ pen.setWidth( w ); }
</code>

What is missing to execute any action is to add the methods that shall be called when the menu items are activated or the toolbar
buttons pressed. For this, we have to add the ID´s to the slot <tt>commandCallback()</tt>, which selects and executes the according
methods we want to call if a menu or toolbar item was chosen:

<code>
void KScribbleApp::commandCallback(int id_)
{
  switch (id_)
  {
    case ID_PEN_BRUSH:
      slotPenBrush();
      break;

    case ID_PEN_COLOR:
      slotPenColor();
      break;
....
  }
}
</code>

This addition also adds the <tt>slotPenColor()</tt> method to the execution list to set the pen color, which we will implement now:

<code>
void KScribbleApp::slotPenColor()
{
  slotStatusMsg(i18n("Selecting pen color..."));

  QColor myColor;
  int result = KColorDialog::getColor( myColor, this );
  if ( result == KColorDialog::Accepted )
  {
    QWidgetList windows = pWorkspace->windowList();
    KScribbleDoc* pDoc;
    KScribbleView* m;
    for ( int i = 0; i < int(windows.count()); ++i )
    {
      m = (KScribbleView*)windows.at(i);
      if ( m )
      {
        pDoc = m->getDocument();
        pDoc->setPenColor(myColor);
      }
    }
  }
  slotStatusMsg(i18n("Ready."));
}
</code>
When looking at the code, we see that we use another new method of <tt>KScribbleDoc</tt> to set the pen color. This one has to be implemented as
well:
<code>
kscribbledoc.h:

    /** sets the pen color */
    void setPenColor( const QColor &amp;c ){ pen.setColor( c ); }
</code>

Watch out for adding the declaration of the two new methods <tt>slotPenBrush()</tt> and <tt>slotPenColor()</tt> to the class
<tt>KScribbleApp</tt>, so our class knows about these methods.

Now you´re ready ! Let´s summarize what we´ve done in this chapter:
<itemize>
<item> we first added menubar and toolbar commands/items for two dialogs that we want to call;
<item> then we created the first dialog to set the pen width with the KDevelop dialogeditor
<item> after that we created the methods we want to call by the menubar/toolbar items which invoke the dialogs and set the poperties we
wanted to change
<item> finally, we added the needed set functions to the document so we are able to change the values after the dialogs get executed.
</itemize>

By this structure, you are provided the general way how to extend your application with more functionality and manipulating settings
that influence the behavoir of the document and view interaction.

<chapt>Bõvített nézetek
<p>

In this chapter we´re going to extend the functionality of our view widget by two enhancements: syncronized views and scrollviews.

<sect>Syncronizing Views
<p>
Let´s first explain what this will bring us and how we´re going to do it. While playing with <em>KScribble</em>, you may have noticed, that if
you open another view of a document by calling "Window"->"New Window", this new view works with the same data as the first view, and
does like any other view you create with that command. But when it comes to painting into the document, you can only do that in one
view - the other views are not displaying the document contents at the same time. If you obscure one view that doesn´t contain the
actual contents with another window and then bring it up to the front again, it will display the acutal contents. That comes because
after a widget has been obscured and then activated again, it receives a paint event from the window system, which will call
<tt>KScribbleView::paintEvent()</tt> again and that finally redraws the contents of the area that has been obscured. What we want to
achieve is that all views should paint syncronous with the one the user actually paints to. In fact, you will see that this enhancement
is a really easy task. The document class already provides us a method <tt>updateAllViews()</tt>, which calls the <tt>update()</tt>
method on each view in the document´s view list. This makes it very easy to syncronize the document contents - every time the contents
is changed, here by mouse movements (where we copy the changings to the buffer with <tt>bitBlt()</tt>), we just have to call
updateAllViews(this). The this pointer is needed, because the calling view doesn´t need a repaint and the <tt>update()</tt> method is
only executed if the sender view is not the same as it´s own.

What you´ve got to do here is only to call updateAllViews(this) at the end of the virtual methods <tt>mousePressEvent()</tt>,
<tt>mouseMoveEvent()</tt> and <tt>mouseReleaseEvent()</tt> - and you´re done !  Take this as a general rule in your applications: each
time the contents of the document is changed by a view, call <tt>updateAllViews()</tt>. How the update has to be executed has to be
implemented in the widget´s <tt>update()</tt> method; one may be content by setting e.g. the changed text in an editor, in our
application we just call <tt>repaint()</tt>, which generates a paint event and copies the contents of the document into the view again.

<sect>Scrolled Views
<p>

In this section we will add a functionality that is most often a thread to developers - if you can´t use an already implemented widget
that provides the scrolling already. What does scrolling mean ? In our context, the problem begins where we want to open a picture that
is bigger than a view can display. therefore, the result will be that you can only see as much as the view provides, beginning from the
topleft corner; the rest will be cut away from the user´s view. A scrollview on the other hand is a widget that provides a scrollbar on
the right side and on the bottom of the widget by which the user can "move" the contents. In fact, it shows the same size of the
document contents, but the view area can be moved within the document, so each part can be displayed if the user wants to by moving the
scrollbar sliders up and down, left and right. Fortunately, Qt provides a class <tt>QScrollView</tt> that itself inherits from
<tt>QWidget</tt> and offers the same base functionality as an ordinary widget but manages the contents by scrollbars automatically -
with the additional option that the programmer can either just use an instance of the <tt>QScrollView</tt>, create the child widgets
to manage with the scrollview as parent and add them to the scrollview with <tt>addChild()</tt> or create a view by inheriting
<tt>QScrollView</tt> and draw into the viewport, which is a defined area inside the scrollview, instead of directly to the widget. The
difference here is that <tt>QScrollView</tt> provides a set of event handlers similar to the <tt>QWidget</tt> event handlers especially for the
viewport. So what was formerly a <tt>mousePressEvent()</tt> in our view will become a viewportMousePressEvent, a <tt>paintEvent()</tt>
will become a viewportPaintEvent etc. The second possibility will suite our needs to make KScribbleView a scrollable widget and so we
will have to make the following modifications:

<itemize>
<item>first we have to make the document use a size of its contents. This can be done by getting the size for an opened picture, for a
new picture we have to define a default start size. In other painting applications, this size can be changed most often by a command
provided by the user interface, e.g. a dialog that asks for the new width and height as well as a method to shrink the picture
contents to fit into that new size.
<item>changing the inheritance of KScribbleView from <tt>QWidget</tt> to <tt>QScrollView</tt>
<item>renaming the virtual methods to the according viewport methods of <tt>QScrollView</tt>
<item>adapt the virtual event handlers to act on the geometry of the viewport. This means that the old implementation relies on the
geometries of <tt>QWidget</tt> starting at the topleft corner of a widget. If the view is scrolled and the topleft corner is not visible, we
have to ensure the positions retrieved from the <tt>QWidget</tt> coordinates are translated to viewport coordinates
</itemize>

<sect1>Sizing the Document Contents
<p>

As already mentioned, we have to set a size to the document contents as well as to initialize this size and provide a method to
retrieve the size by the views. For this, we add a variable <tt>QSize size</tt> to <tt>KScribbleDoc</tt> as well as the method
<tt>docSize()</tt>:

<code>
kscribbledoc.h:

#include <qsize.h>

...
public:
  const QSize docSize(){ return size;};

private:
  QSize size;

</code>

Now we have to modify all methods that deal with initializing and opening the document contents - <tt>newDocument()</tt> and
<tt>openDocument()</tt>:
<code>
  bool KScribbleDoc::newDocument()
  {
    /////////////////////////////////////////////////
    // TODO: Add your document initialization code here
->  size=QSize(300,200 );
   	pen=QPen( Qt::black, 3 );
->  buffer.resize(size);
->  buffer.fill( Qt::white );
    /////////////////////////////////////////////////
    modified=false;
    return true;
  }

  bool KScribbleDoc::openDocument(const QString &amp;filename, const char *format /*=0*/)
  {

  	QFile f( filename );
  //	if ( !f.open( IO_ReadOnly ) )
  //		return false;
    /////////////////////////////////////////////////
    // TODO: Add your document opening code here
  	if(!buffer.load( filename, format ))
  		return false;
->  size=buffer.size();
    /////////////////////////////////////////////////
  //	f.close();
  	
    modified=false;
    m_filename=filename;
  	m_title=QFileInfo(f).fileName();
    return true;
  }
</code>

In <tt>newDocument()</tt>, we initialize the size with a default value of 300 pixels wide and 200 pixels high. This is enough for a
small picture for now and we could add a dialog for resizing as well if we want.
When it comes to opening a picture, we have to set the size to the size of the picture. This can be done by calling
<tt>QPixmap::size()</tt>, which we used in <tt>openDocument()</tt>. Then we´re done with setting the sizes and we can move on to
reimplementing KScribbleView and make it a scrollview.

<sect>Adapting the View
<p>

As said above, we first have to change some things in the interface of KScribbleView. The following code shows these changings:

<code>
#include <qscrollview.h>

class KScribbleView : public QScrollView
{
  Q_OBJECT

  protected:
    /** changed from mousePressEvent() overwriting QScrollView method */
    virtual void viewportMousePressEvent( QMouseEvent* );
    /** changed from mouseReleaseEvent() overwriting QScrollView method */
    virtual void viewportMouseReleaseEvent( QMouseEvent* );
    /** changed from mouseMoveEvent() overwriting QScrollView method */
    virtual void viewportMouseMoveEvent( QMouseEvent* );

    /** commeted out because we have a document size defined */
//    resizeEvent( QResizeEvent* );

    /** changed from paintEvent() overwriting QScrollView method */
    virtual void viewportPaintEvent( QPaintEvent* );
}
</code>

Here, we changed the inheritance from <tt>QWidget</tt> to <tt>QScrollView</tt> first and added the according include file we need. Also we changed all
implemented event handlers that deal with interaction on the contents of the scrollview to the according methods <tt>QScrollView</tt> provides
for this purpose and commented out the resizeEvent. Now we can go over to the implementation of these methods and make use of the size
our picture has. As a view is always created after the document exists, we can resize the widget directly in the constructor to fit
this size and as well resize the contents (which is the viewport size):
<code>
#include <qsize.h>

KScribbleView::KScribbleView(KScribbleDoc* pDoc, QWidget *parent, const char* name, int wflags)
 : QScrollView(parent, name, wflags | WPaintClever | WNorthWestGravity | WRepaintNoErase)
{
    doc=pDoc;
		mousePressed=false;
    polyline=QPointArray(3);

->  setResizePolicy ( QScrollView::ResizeOne );
->  viewport()->setCursor( Qt::crossCursor );

->    QSize size=doc->docSize();
      // resize the viewport - this makes the resizeEvent obsolete
->    resizeContents(size.width(), size.height());
      // resize the widget to show up with the document size
->    resize(size);
}
</code>

Note that formerly, the <tt>resizeEvent()</tt> took care of resizing the drawing area to the same as the widget size. At the same time,
this changed the document size as well, so the document picture had always the same size as the widget. With the already initialized
size of the document (which we set in <tt>newDocument()</tt> and <tt>openDocument()</tt>), we just resize the contents by calling
<tt>resizeContents()</tt> provided by <tt>QScrollView</tt> with the size of the document. You may also notice that we changed the
cursor over the widget from the overall widget to the viewport widget, which we can retrieve with <tt>viewport()</tt>. Now we can
reimplement the event handlers. At first, we should take care for the paintEvent, as this is one of the most important ones, because it
gets called whenever the widget shows up or is resized.

<bf>Attention:</bf> take care to comment out the <tt>resizeEvent()</tt> implementation!

Now, the paint event will have to copy the pixmap in the buffer to the according position in the view. For this, we have to change the
destination of <tt>bitBlt()</tt> from this to <tt>viewport()</tt>, set the topleft position to 0,0 and set the target (the buffer) to
copy from the contentsX and contentsY position on into the viewport:
<code>
void KScribbleView::viewportPaintEvent( QPaintEvent *e )
{
  bitBlt( viewport(),0,0, &amp;doc->buffer,contentsX() ,contentsY() );
}
</code>
The <tt>contentsX()</tt> thereby is the position in x-direction of the scrollview´s contents - which goes to position 0 in the
viewport´s absolute position, which is the topleft point visible in the scrollview. The same applies to the y-direction. This part is
sometimes hard to understand and you may have to do a bit "try and error" when implementing your own scrollviews. The other possible
call of <tt>bitBlt()</tt> would be to switch the values of the positions and inverting the contents values:

bitBlt( viewport(), -contentsX(), -contentsY(), &amp;doc->buffer, 0, 0 );


The last changes we need to do are changing the mouse event handlers. First, the <tt>mouseMoveEvent()</tt>, which changes to
<tt>viewportMouseMoveEvent()</tt>, has a <tt>bitBlt()</tt> call as well. Here, we have to apply the same chages as in the paint event.
Further, in the <tt>mousePressEvent()</tt> and the <tt>mouseMoveEvent()</tt>, we have retrieved the position of the mouse events with
<tt>e->pos()</tt>. This position now will deliver us a widget position - not the contents position, so we have to translate this to
draw into the correct position of the document with <tt>viewportToContents()</tt>:
<code>
  void KScribbleView::viewportMousePressEvent( QMouseEvent *e )
  {
    mousePressed = TRUE;
->  doc->polyline[2] = doc->polyline[1] = doc->polyline[0] = viewportToContents(e->pos());
    doc->updateAllViews(this);
  }

  void KScribbleView::viewportMouseMoveEvent( QMouseEvent *e )
  {
    if ( mousePressed ) {
  ....
      doc->polyline[1] = doc->polyline[0];
->    doc->polyline[0] = viewportToContents(e->pos());
      painter.drawPolyline( doc->polyline );
  ....
      r.setBottom( r.bottom() + doc->penWidth() );

  	  doc->setModified();
->    bitBlt(viewport(), r.x()-contentsX(), r.y()-contentsY() ,
->            &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
  	  doc->updateAllViews(this);
    }
  }
</code>

In the <tt>viewportMouseMoveEvent()</tt>, we had to change the destination again from this to <tt>viewport()</tt> - and with that
translate the positions. This time, we used the second version of the call we used in <tt>viewportPaintEvent()</tt>, with subtracting
the contentsX and contentsY values to copy the rectangle containing the current painting into the correct position of the viewport.

At last, we will apply a small change in conjunction with the <tt>update()</tt> method: why should we repaint the whole widget every
time ? This will reduce performance most often and lead to a so-called "flicker" effect. This effect sometimes occurs with widgets, but
there are some ways to reduce this behavoir. Instead of calling <tt>repaint()</tt>, we could call <tt>repaint(false)</tt> as well. This
will not erase the widget contents before redrawing it. As we copy the document contents directly into the widget, we don´t need to
erase it anyway, because all the data will be overwritten anyway. In conjunction with <tt>QScrollView</tt>, we will reduce the painting
even more: we limit the update method to call <tt>repaint()</tt> on the viewport() widget, because that will call
<tt>viewportPaintEvent()</tt>. On the other hand, the painting area we use is the rectangle containing the document contents, which, when the
document size is smaller than the viewport size. So we can limit the paint event to the rectangle of the viewport where the document 
is displayed, whose visible width and height we can retrieve and compose to the rectangle. Additionally, we use the erase parameter with false,
so the document area doesn´t get erased:

<code>
void KScribbleView::update(KScribbleView* pSender){
  if(pSender != this)
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}
</code>

Now you´re ready !  This chapter has been one of the hardest to implement and understand - especially when it comes to the geometries
that change. But on the other hand, we gave our application a whole new functionality by the new scrollview and the syncronized views.

With that, we´re moving on to the last chapter of our tutorial. There, we will apply only a few changes by making use of some new
methods of the KDE2 libraries, but as usual, this will bring us some interesting functionality - <em>KScribble</em> will be able to open and
save a whole range of picture formats and thereby we will remove the restriction of operating only on the png file format.

<chapt>A KImageIO használata a KScribble-nél
<p>

When it comes to images, the Qt and KDE libraries offer a wide variety of operations. Besides actual drawing routines, the libraries
support a whole set of image formats which they can read and write - all without any cost on our view. The main class for these
operations is <tt>QImageIO</tt>, which has a support library by KDE: <tt>KImageIO</tt>. As a preparation before we can make use of these nice methods, we
have to add the according library to <em>KScribble</em>: libkimgio. Open "Project"->"Options" in KDevelop and add the line -lkimgio to the
additional libraries to link <em>KScribble</em> with.

<sect>Preparing the Document
<p>
Now we can go on and apply our changes. First, we have to remove the current restriction in the document class to only read and write
PNG files. Just replace "PNG" in the following methods with format, as given by the <tt>openDocument()</tt> and <tt>saveDocument()</tt>
methods:

In method <tt>KScribbleDoc::openDocument()</tt>:
 	
<tt>	if(!buffer.load( filename, format ))</tt>
	
In method <tt>KScribbleDoc:: saveDocument()</tt>:

<tt>	if(!buffer.save( filename, format ))</tt>

Then we have a default behavoir of these methods. Now, for now we don´t have all available file formats yet. This will be our next
task, together with adapting the slots in <em>KScribble</em> that deliver us filenames.

<sect>Registering File Formats
<p>
To use <tt>KImageIO</tt>, we have to initialize the library first. For this, we add a call for <tt>registerFormats()</tt> in our
<tt>main()</tt> function:
<code> 	
main.cpp:

............
  KApplication app;
  KImageIO::registerFormats();

  if (app.isRestored())
............
</code>
Note that this call is after the application is instanciated with KApplication app - without the application instance, our program will
not run, as <tt>KImageIO</tt> then doen´t know on which application to register the formats. The include file for this call will be added to
kscribble.h, as we´re going to use some of its methods in <tt>KScribbleApp</tt>:

kscribble.h:

#include &lt;kimgio.h&gt;


<sect>Opening Images
<p>

Now that we can make use of <tt>KImageIO</tt>, we have to apply the first change to the most important method of <tt>KScribbleApp</tt>:
<tt>openDocumentFile()</tt>. This method opens us any document until now only on the behalf of the filename. It just leaves out the
extension, as the format is not required by the document class by default. But as we have changed that, we just need a format - and
have to adapt the call for <tt>KScribbleDoc::openDocument()</tt> in the method <tt>openDocumentFile()</tt>:

<code>
kscribble.cpp:

  void KScribbleApp::openDocumentFile(const char* file)
  {
  	...........
  	
  	else
    {
->    QString format=KImageIO::type(file);
->	  if(!doc->openDocument(file,format))
    		KMessageBox::error (this,i18n("Could not open document !"), i18n("Error !"));
  		addRecentFile(file);
  	}
    ............
  }
</code>

Of course, this works the same as using <tt>QString format=QImageIO::imageFormat(file);</tt>. Here, <tt>KImageIO</tt> delivers us the format of
the image and we can call the document to open the file by filename and format. (Another possiblity would be to detect the format in
the document class as well).

<sect>Setting File Filters with KImageIO
<p>
Here, we´re finishing our tutorial with the last section - we will adapt the file dialogs of <em>KScribble</em> to make use of file filters.
For these, <tt>KImageIO</tt> provides nice methods to give us the needed strings for all image file formats that are available for opening and
saving. The following implementation replaces the default file filter (which is in fact none - you have to change your own
applications´ file filter to your mime type accordingly) with the <tt>pattern()</tt> method of <tt>KImageIO</tt>:

<code>
  void KScribbleApp::slotFileOpen()
  {
    slotStatusMsg(i18n("Opening file..."));
  	
->    QString fileToOpen=KFileDialog::getOpenFileName(QDir::currentDirPath(),
->              KImageIO::pattern(KImageIO::Reading), this, i18n("Open File..."));
    if(!fileToOpen.isEmpty())
    {
  		openDocumentFile(fileToOpen);		
    }

    slotStatusMsg(i18n("Ready."));
  }
</code>

Here, the mode in <tt>pattern()</tt> is set to Reading - which may differ from the patterns that are retrieved when set to writing. Now
we have finished opening files by its filename and format completely. What is missing to complete this structure, is setting the
patterns as well for saving a file. For that, the <tt>slotFileSaveAs()</tt> is called, which itself invokes the file dialog that
retrieves a file name. There, we will set the pattern mode to Writing:

<code>
void KScribbleApp::slotFileSaveAs()
{
  slotStatusMsg(i18n("Saving file with a new filename..."));

->  QString newName=KFileDialog::getSaveFileName(QDir::currentDirPath(),
->                               KImageIO::pattern(KImageIO::Writing), this, i18n("Save as..."));
  if(!newName.isEmpty())
  {
    KScribbleView* m = (KScribbleView*)pWorkspace->activeWindow();
    if( m )
    {
      KScribbleDoc* doc =	m->getDocument();
  	  QString format=QFileInfo(newName).extension();
  	  format=format.upper();
		  if(!doc->saveDocument(newName,format))
  	  {
  		  KMessageBox::error (this,i18n("Could not save the current document !"), i18n("I/O Error !"));
				return;
			}
      doc->changedViewList();
      setWndTitle(m);
    }
  }
  slotStatusMsg(i18n("Ready."));
}
</code>


<chapt>Nyomtatási funkciók hozzáadása
<p>

In this chapter we will show you how easy it is to implement printing functions using Qt. It´s actually just one line of code for us to
do here, but we will start understanding who is actually doing the printing job. When the user presses the print button in
<em>KScribble</em> or chooses "Print" from the "File" menu, the <tt>slotFilePrint()</tt> method is called in <tt>KScribbleApp</tt>.
This method detects which child window is currently activ and creates a printer instance of the class <tt>QPrinter</tt>. Then it calls
the widget´s printing method, <tt>KScribbleView::print()</tt>. Here, the framework already contains the base implementation - which
already shows you that for printing you just have to use <tt>QPainter</tt> which then draws on the printer. This method also calls the
printing dialog.

What we have to do here is to use <tt>QPainter</tt> methods to draw the pixmap of the document connected to the view. As
<tt>QPainter</tt> already offers a whole set of methods <tt>drawPixmap()</tt>, we will of course use one of them:

<code>
void KScribbleView::print(QPrinter *pPrinter)
{
  if (pPrinter->setup(this))
  {
    QPainter p;
    p.begin(pPrinter);
    	  	
    ///////////////////////////////
    // TODO: add your printing code here
->	p.drawPixmap(0,0,doc->buffer);
    ///////////////////////////////
    p.end();
  }
}
</code>

Here, we paint into the offset of the printer page at 0,0 with our buffer pixmap of the document. That´s all !

You can just go ahead and test it - now you can print any graphics that <em>KScribble</em> is able to open.

This is now the end of our trour through creating a KDE 2 application. You can find the source package of KScribble
completely with an extension that adds cut, copy, paste and undo functions as well as drag´n drop here:

<htmlurl
url="../../../../../apps/kdevelop/examples/kscribble-1.0.tar.gz"name="$(KDEDIR)/share/apps/kdevelop/examples/kscribble-1.0.tar.gz">   	
The example tarball is locally installed and can be downloaded to your home directory, where you can untar it and test it.
After untarring the tarball with <tt>tar zxvf kscribble-1.0.tar.gz</tt>, load the project and call "Automake and autoconf" from the
"Build" menu in KDevelop, then call "./configure" from the same menu. The configure options are those of my installtion of the KDE 2
and Qt 2.1, so you have to change them manually to match your installation path for these options.

The appendix also contains the complete sourcecode for this package to read through online.

<chapt>Copyright <label id="Copyright">
<p> <tscreen><verb>
KDevelop Copyright 1998,1999,2000 The KDevelop Team.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</verb></tscreen>

<appendix>
<chapt>KScribble-1.0 példa forráskód
<p>

<sect>Project Tarball
<p>
The example tarball is locally installed and can be downloaded to your home directory, where you can untar it and test it.
After untarring the tarball with <tt>tar zxvf kscribble-1.0.tar.gz</tt>, load the project and call "Automake and autoconf" from the
"Build" menu in KDevelop, then call "./configure" from the same menu. The configure options are those of my installtion of the KDE 2
and Qt 2.1, so you have to change them manually to match your installation path for these options.

<htmlurl
url="../../../../../apps/kdevelop/examples/kscribble-1.0.tar.gz"name="$(KDEDIR)/share/apps/kdevelop/examples/kscribble-1.0.tar.gz">   	

<sect>main.cpp
<p>

<code>
/***************************************************************************
                          main.cpp  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
#include <kcmdlineargs.h>
#include <kaboutdata.h>
#include <klocale.h>

#include "kscribble.h"

static const char *description =
   I18N_NOOP("KDE 2 example application");

static KCmdLineOptions options[] =
{
   {  "+[File]", I18N_NOOP("image file to open"), 0  },
   {  0, 0, 0  }
};


int main(int argc, char *argv[])
{
   KAboutData aboutData( "kscribble", I18N_NOOP("KScribble"),
      VERSION, description, KAboutData::License_GPL,
      "(c) 2000, Ralf Nolden");
   aboutData.addAuthor("Ralf Nolden",0, "rnolden@kdevelop.de");
   KCmdLineArgs::init( argc, argv, &amp;aboutData );
   KCmdLineArgs::addCmdLineOptions( options ); // Add our own options.

   KApplication app;
   KImageIO::registerFormats();

   if (app.isRestored())
   {
      RESTORE(KScribbleApp);
   }
   else
   {
      KScribbleApp *kscribble = new KScribbleApp();
      kscribble->show();

      KCmdLineArgs *args = KCmdLineArgs::parsedArgs();

      if (args->count())
        for(int i=0;i<args->count();i++)
          kscribble->openDocumentFile(args->arg(i));
      else
        kscribble->openDocumentFile();

      args->clear();
   }

   return app.exec();
}
</code>

<sect>kscribble.h
<p>
<code>
/***************************************************************************
                          kscribble.h  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef KSCRIBBLE_H
#define KSCRIBBLE_H


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

// include files for Qt
#include <qstrlist.h>
#include <qworkspace.h>

// include files for KDE
#include <kapp.h>
#include <ktmainwindow.h>
#include <kaccel.h>
#include <kimgio.h>

// forward declaration of the KScribble classes
class KScribbleDoc;
class KScribbleView;

/**
  * The base class for KScribble application windows. It sets up the main
  * window and reads the config file as well as providing a menubar, toolbar
  * and statusbar. In initView(), your main view is created as the MDI child window manager.
  * Child windows are created in createClient(), which gets a document instance as it's document to
  * display whereby one document can have several views.The MDI child is an instance of KScribbleView,
  * the document an instance of KScribbleDoc.
  * KScribbleApp reimplements the methods that KTMainWindow provides for main window handling and supports
  * full session management as well as keyboard accelerator configuration by using KAccel.
  * @see KTMainWindow
  * @see KApplication
  * @see KConfig
  * @see KAccel
  *
  * @author Source Framework Automatically Generated by KDevelop, (c) The KDevelop Team.
  * @version KDevelop version 1.1 code generation
  */
class KScribbleApp : public KTMainWindow
{
  Q_OBJECT

  public:
    /** construtor of KScribbleApp, calls all init functions to create the application.
     *  @see initMenuBar initToolBar
     */
    KScribbleApp();
    ~KScribbleApp();
    /** enables menuentries/toolbar items
     */
    void enableCommand(int id_);
    /** disables menuentries/toolbar items
     */
    void disableCommand(int id_);
    /** opens a file specified by commandline option
     */
    void openDocumentFile(const char *file=0);

  protected:
    /** queryClose is called by KTMainWindow on each closeEvent of a window. Against the
     *  default implementation (only returns true), this overridden function retrieves all modified documents
     *  from the open document list and asks the user to select which files to save before exiting the application.
     *  @see KTMainWindow#queryClose
     *  @see KTMainWindow#closeEvent
     */
    virtual bool queryClose();
    /** queryExit is called by KTMainWindow when the last window of the application is going to be closed
     *  during the closeEvent().
     *  Against the default implementation that just returns true, this calls saveOptions() to save the
     *  settings of the last window's properties.
     *  @see KTMainWindow#queryExit
     *  @see KTMainWindow#closeEvent
     */
    virtual bool queryExit();
    /** saves the window properties for each open window during session end to the session config file,
     *  including saving the currently opened file by a temporary filename provided by KApplication.
     *  @see KTMainWindow#saveProperties
     */
    virtual void saveProperties(KConfig *_cfg);
    /** reads the session config file and restores the application's state including the last
     *  opened files and documents by reading the temporary files saved by saveProperties()
     *  @see KTMainWindow#readProperties
     */
    virtual void readProperties(KConfig *_cfg);
    /** event filter to catch close events for MDI child windows and is installed in createClient() on every
      * child window. Closing a window calls the eventFilter first which removes the view from the connected
      * documents' view list. If the last view is going to be closed, the eventFilter() tests if the document
      * is modified; if yes, it asks the user to save the document. If the document title contains "Untitled",
      * slotFileSaveAs() gets called to get a save name and path.
      */
    virtual bool eventFilter(QObject* object, QEvent* event);
    /** creates a new child window. The document that will be connected to it
     *  has to be created before and the instances filled, with e.g. openDocument().
     *  Then call createClient() to get a new MDI child window.
     *  @see KScribbleDoc#addView
     *  @see KScribbleDoc#openDocument
     *  @param doc pointer to the document instance that the view will
     *  be connected to.
     */
    void createClient(KScribbleDoc* doc);
    /** accepts drag events for images */
    virtual void dragEnterEvent( QDragEnterEvent* );
    /** accepts drops and opens a new document
     *  for each drop */
    virtual void dropEvent( QDropEvent* );

  private slots:
    /** sets the main application window title each time the active MDI child window changes. */
    void setWndTitle(QWidget*);
    /** switch argument for slot selection by menu or toolbar ID */
    void commandCallback(int id_);
    /** switch argument for Statusbar help entries on slot selection. Add your ID's help
     *  here for toolbars and menubar entries. */
    void statusCallback(int id_);
    /** add a opened file to the recent file list and update recent file menu*/
    void addRecentFile(const QString &amp;file);
    /** clears the document in the actual view to reuse it as the new document */
    void slotFileNew();
    /** open a file and load it into the document*/
    void slotFileOpen();
    /** opens a file from the recent files menu */
    void slotFileOpenRecent(int id_);
    /** save a document */
    void slotFileSave();
    /** save a document by a new filename*/
    void slotFileSaveAs();
    /** asks for saving if the file is modified, then closes the actual file and window*/
    void slotFileClose();
    /** print the actual file */
    void slotFilePrint();
    /** closes all documents and quits the application.*/
    void slotFileQuit();
    /** reverts the last user action for the active window */
    void slotEditUndo();
    /** put the marked text/object into the clipboard and remove
     *  it from the document
     */
    void slotEditCut();
    /** put the marked text/object into the clipboard
     */
    void slotEditCopy();
    /** paste the clipboard into the document
     */
    void slotEditPaste();
    /** clears the current document */
    void slotEditClearAll();
    /** sets the pen width */
    void slotPenBrush();
    /** sets the pen color */
    void slotPenColor();
    /** toggles the toolbar
     */
    void slotViewToolBar();
    /** toggles the statusbar
     */
    void slotViewStatusBar();
    /** creates a new view for the document in the active child window and adds the new view to the
     * list of views the document maintains.
     */
    void slotWindowNewWindow();
    /** changes the statusbar contents for the standard label permanently, used to indicate current actions.
     * @param text the text that is displayed in the statusbar
     */
    void slotStatusMsg(const QString &amp;text);
    /** changes the status message of the whole statusbar for two seconds, then restores the last status.
     * This is used to display statusbar messages that give information about actions for
     * toolbar icons and menuentries.
     * @param text the text that is displayed in the statusbar
     */
    void slotStatusHelpMsg(const QString &amp;text);
    /** gets called when the window menu is activated; recreates the window menu with all opened window titles. */
    void windowMenuAboutToShow();
    /** activates the MDI child widget when it gets selected from the window menu. */
    void windowMenuActivated( int id );

  private:
    /** save general Options like all bar positions and status as well as the geometry and
     * the recent file list to the configuration file
     */   
    void saveOptions();
    /** read general Options again and initialize all variables like the recent file list
     */
    void readOptions();
    /** initKeyAccel creates the keyboard accelerator items for the available slots and changes the menu accelerators.
     * @see KAccel
     */
    void initKeyAccel();
    /** initMenuBar creates the menubar and inserts the menupopups as well as creating the helpMenu.
     */
    void initMenuBar();
    /** this creates the toolbars.
     */
    void initToolBar();
    /** sets up the statusbar for the main window by initialzing a statuslabel.
     */
    void initStatusBar();

    /** Creates the main view of the KTMainWindow instance and initializes the MDI view area including any needed
     *  connections.
     */
    void initView();

    /** contains the recently used filenames */
    QStrList recentFiles;

    /** the configuration object of the application */
    KConfig *config;
    /** the key accelerator container */
    KAccel *keyAccel;
    /** the recent file menu containing the last five opened files */
    QPopupMenu *pRecentFileMenu;
    /** the file menu */
    QPopupMenu* pFileMenu;
    /** the edit menu */
    QPopupMenu* pEditMenu;
    /** the pen menu */
    QPopupMenu* pPenMenu;    
    /** the view menu */
    QPopupMenu* pViewMenu;
    /** the window menu */
    QPopupMenu *pWindowMenu;
    /** pWorkspace is the MDI frame widget that handles MDI child widgets. Inititalized in
     * initView()
     */
    QWorkspace *pWorkspace;
    /** the printer instance */
    QPrinter *printer;
    /** a counter that gets increased each time the user creates a new document with "File"->"New" */
    int untitledCount;
    /** a list of all open documents. If the last window of a document gets closed, the installed eventFilter
     * removes this document from the list. The document list is checked for modified documents when the user
     * is about to close the application. */
    QList<KScribbleDoc> *pDocList;  

};

#endif // KSCRIBBLE_H
</code>

<sect>kscribble.cpp
<p>
<code>
/***************************************************************************
                          kscribble.cpp  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// include files for QT
#include <qdir.h>
#include <qprinter.h>
#include <qvbox.h>
#include <qwhatsthis.h>
#include <qtooltip.h>
#include <qtoolbutton.h>
#include <qimage.h>
#include <qdragobject.h>


// include files for KDE
#include <kiconloader.h>
#include <kmessagebox.h>
#include <kfiledialog.h>
#include <kcolordlg.h>
#include <kmenubar.h>
#include <klocale.h>
#include <kconfig.h>

// application specific includes
#include "kscribble.h"
#include "kscribbleview.h"
#include "kscribbledoc.h"
#include "resource.h"
#include "kpenbrushdlg.h"


KScribbleApp::KScribbleApp()
{
  config=kapp->config();
  printer = new QPrinter;
  untitledCount=0;
  pDocList = new QList<KScribbleDoc>();
  pDocList->setAutoDelete(true);
  setAcceptDrops(true);

  ///////////////////////////////////////////////////////////////////
  // call inits to invoke all other construction parts
  initMenuBar();
  initToolBar();
  initStatusBar();
  initKeyAccel();
  initView();
  
  readOptions();

  ///////////////////////////////////////////////////////////////////
  // disable menu and toolbar items at startup
  disableCommand(ID_EDIT_UNDO);
}

KScribbleApp::~KScribbleApp()
{
  delete printer;
}

void KScribbleApp::initKeyAccel()
{
  keyAccel = new KAccel(this);
  
  // fileMenu accelerators
  keyAccel->connectItem(KStdAccel::New, this, SLOT(slotFileNew()));
  keyAccel->connectItem(KStdAccel::Open, this, SLOT(slotFileOpen()));
  keyAccel->connectItem(KStdAccel::Save, this, SLOT(slotFileSave()));
  keyAccel->connectItem(KStdAccel::Close, this, SLOT(slotFileClose()));
  keyAccel->connectItem(KStdAccel::Print, this, SLOT(slotFilePrint()));
  keyAccel->connectItem(KStdAccel::Quit, this, SLOT(slotFileQuit()));
  // editMenu accelerators
  keyAccel->connectItem(KStdAccel::Cut, this, SLOT(slotEditCut()));
  keyAccel->connectItem(KStdAccel::Copy, this, SLOT(slotEditCopy()));
  keyAccel->connectItem(KStdAccel::Paste, this, SLOT(slotEditPaste()));

  keyAccel->connectItem(KStdAccel::Help, this, SLOT(appHelpActivated()));
      
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_NEW, KStdAccel::New);
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_OPEN, KStdAccel::Open);
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_SAVE, KStdAccel::Save);
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_CLOSE, KStdAccel::Close);
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_PRINT, KStdAccel::Print);
  keyAccel->changeMenuAccel(pFileMenu, ID_FILE_QUIT, KStdAccel::Quit);

  keyAccel->changeMenuAccel(pEditMenu, ID_EDIT_CUT, KStdAccel::Cut);
  keyAccel->changeMenuAccel(pEditMenu, ID_EDIT_COPY, KStdAccel::Copy);
  keyAccel->changeMenuAccel(pEditMenu, ID_EDIT_PASTE, KStdAccel::Paste);

  keyAccel->readSettings();  
}

void KScribbleApp::initMenuBar()
{
  ///////////////////////////////////////////////////////////////////
  // MENUBAR
  pRecentFileMenu = new QPopupMenu(this);
  connect(pRecentFileMenu, SIGNAL(activated(int)), SLOT(slotFileOpenRecent(int)));

  ///////////////////////////////////////////////////////////////////
  // menuBar entry file-Menu
  pFileMenu = new QPopupMenu(this);
  pFileMenu->insertItem(BarIcon("filenew"), i18n("&amp;New"), ID_FILE_NEW);
  pFileMenu->insertItem(BarIcon("fileopen"), i18n("&amp;Open..."), ID_FILE_OPEN);
  pFileMenu->insertItem(i18n("Open &amp;recent"), pRecentFileMenu, ID_FILE_OPEN_RECENT);

  pFileMenu->insertItem(i18n("&amp;Close"), ID_FILE_CLOSE);
  pFileMenu->insertSeparator();
  pFileMenu->insertItem(BarIcon("filefloppy") ,i18n("&amp;Save"), ID_FILE_SAVE);
  pFileMenu->insertItem(i18n("Save &amp;As..."), ID_FILE_SAVE_AS);
  pFileMenu->insertSeparator();
  pFileMenu->insertItem(BarIcon("fileprint"), i18n("&amp;Print..."), ID_FILE_PRINT);
  pFileMenu->insertSeparator();
  pFileMenu->insertItem(i18n("E&amp;xit"), ID_FILE_QUIT);
  
  ///////////////////////////////////////////////////////////////////
  // menuBar entry edit-Menu
  pEditMenu = new QPopupMenu(this);
  pEditMenu->insertItem(BarIcon("undo"), i18n("&amp;Undo"), ID_EDIT_UNDO);
  pEditMenu->insertSeparator();
  pEditMenu->insertItem(BarIcon("editcut"), i18n("Cu&amp;t"), ID_EDIT_CUT);
  pEditMenu->insertItem(BarIcon("editcopy"), i18n("&amp;Copy"), ID_EDIT_COPY);
  pEditMenu->insertItem(BarIcon("editpaste"), i18n("&amp;Paste"), ID_EDIT_PASTE);
  pEditMenu->insertItem(BarIcon("delete"),i18n("&amp;Clear All"), ID_EDIT_CLEAR_ALL);

  ///////////////////////////////////////////////////////////////////
  // menuBar entry pen-Menu
  pPenMenu = new QPopupMenu();
  pPenMenu->insertItem(i18n("&amp;Color"), ID_PEN_COLOR);
  pPenMenu->insertItem(i18n("&amp;Brush"), ID_PEN_BRUSH);

  ///////////////////////////////////////////////////////////////////
  // menuBar entry view-Menu
  pViewMenu = new QPopupMenu(this);
  pViewMenu->setCheckable(true);
  pViewMenu->insertItem(i18n("&amp;Toolbar"), ID_VIEW_TOOLBAR);
  pViewMenu->insertItem(i18n("&amp;Statusbar"), ID_VIEW_STATUSBAR);

  ///////////////////////////////////////////////////////////////////
  // menuBar entry window-Menu
  pWindowMenu = new QPopupMenu(this);
  pWindowMenu->setCheckable(true);


  ///////////////////////////////////////////////////////////////////
  // menuBar entry helpMenu
  QPopupMenu* pHelpMenu = helpMenu(i18n("KScribble" VERSION "\n\n(c) 2000 by\n"
                                  "Ralf Nolden\nRalf.Nolden@post.rwth-aachen.de"));

  ///////////////////////////////////////////////////////////////////
  // MENUBAR CONFIGURATION
  // insert your popup menus with the according menubar entries in the order
  // they will appear later from left to right
  menuBar()->insertItem(i18n("&amp;File"), pFileMenu);
  menuBar()->insertItem(i18n("&amp;Edit"), pEditMenu);
  menuBar()->insertItem(i18n("&amp;Pen"), pPenMenu);
  menuBar()->insertItem(i18n("&amp;View"), pViewMenu);
  menuBar()->insertItem(i18n("&amp;Window"), pWindowMenu );
  menuBar()->insertItem(i18n("&amp;Help"), pHelpMenu);

  ///////////////////////////////////////////////////////////////////
  // CONNECT THE MENU SLOTS WITH SIGNALS
  // for execution slots and statusbar messages
  connect(pFileMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
  connect(pFileMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));

  connect(pEditMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
  connect(pEditMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));

  connect(pPenMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
  connect(pPenMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));

  connect(pViewMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
  connect(pViewMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));

  connect(pWindowMenu, SIGNAL(aboutToShow() ), SLOT( windowMenuAboutToShow() ) );
  connect(pWindowMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
  connect(pWindowMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));

}

void KScribbleApp::initToolBar()
{

  ///////////////////////////////////////////////////////////////////
  // TOOLBAR
  toolBar()->insertButton(BarIcon("filenew"), ID_FILE_NEW, true, i18n("New File"));
  toolBar()->insertButton(BarIcon("fileopen"), ID_FILE_OPEN, true, i18n("Open File"));
  toolBar()->insertButton(BarIcon("filefloppy"), ID_FILE_SAVE, true, i18n("Save File"));
  toolBar()->insertButton(BarIcon("fileprint"), ID_FILE_PRINT, true, i18n("Print"));
  toolBar()->insertSeparator();
  toolBar()->insertButton(BarIcon("editcut"), ID_EDIT_CUT, true, i18n("Cut"));
  toolBar()->insertButton(BarIcon("editcopy"), ID_EDIT_COPY, true, i18n("Copy"));
  toolBar()->insertButton(BarIcon("editpaste"), ID_EDIT_PASTE, true, i18n("Paste"));
  toolBar()->insertSeparator();
  toolBar()->insertButton(BarIcon("pencolor"), ID_PEN_COLOR, true, i18n("Color") );
  toolBar()->insertButton(BarIcon("penwidth"), ID_PEN_BRUSH, true, i18n("Width") );
  toolBar()->insertSeparator();
  toolBar()->insertButton(BarIcon("help"), ID_HELP_CONTENTS, SIGNAL(clicked()),
          this, SLOT(appHelpActivated()), true,i18n("Help"));

  QToolButton *btnwhat = QWhatsThis::whatsThisButton(toolBar());
  QToolTip::add(btnwhat, i18n("What's this...?"));
  toolBar()->insertWidget(ID_HELP_WHATS_THIS, btnwhat->sizeHint().width(), btnwhat);

  ///////////////////////////////////////////////////////////////////
  // INSERT YOUR APPLICATION SPECIFIC TOOLBARS HERE WITH toolBar(n)


  ///////////////////////////////////////////////////////////////////
  // CONNECT THE TOOLBAR SLOTS WITH SIGNALS - add new created toolbars by their according number
  // connect for invoking the slot actions
  connect(toolBar(), SIGNAL(clicked(int)), SLOT(commandCallback(int)));
  // connect for the status help on holing icons pressed with the mouse button
  connect(toolBar(), SIGNAL(pressed(int)), SLOT(statusCallback(int)));

}

void KScribbleApp::initStatusBar()
{
  ///////////////////////////////////////////////////////////////////
  // STATUSBAR
  // TODO: add your own items you need for displaying current application status.
  statusBar()->insertItem(i18n("Ready."), ID_STATUS_MSG);
}


void KScribbleApp::initView()
{
  ////////////////////////////////////////////////////////////////////
  // here the main view of the KTMainWindow is created by a background box and
  // the QWorkspace instance for MDI view.
  QVBox* view_back = new QVBox( this );
  view_back->setFrameStyle( QFrame::StyledPanel | QFrame::Sunken );
  pWorkspace = new QWorkspace( view_back );
  connect(pWorkspace, SIGNAL(windowActivated(QWidget*)), this, SLOT(setWndTitle(QWidget*)));
  setView(view_back);
}

void KScribbleApp::setWndTitle(QWidget*){
  setCaption(pWorkspace->activeWindow()->caption());
}

void KScribbleApp::enableCommand(int id_)
{
  ///////////////////////////////////////////////////////////////////
  // enable menu and toolbar functions by their ID's
  menuBar()->setItemEnabled(id_, true);
  toolBar()->setItemEnabled(id_, true);
}

void KScribbleApp::disableCommand(int id_)
{
  ///////////////////////////////////////////////////////////////////
  // disable menu and toolbar functions by their ID's
  menuBar()->setItemEnabled(id_, false);
  toolBar()->setItemEnabled(id_, false);
}

void KScribbleApp::addRecentFile(const QString &amp;file)
{
  if(recentFiles.contains(file))
    return; // it's already there

  if( recentFiles.count() < 5)
    recentFiles.prepend(file);
  else{
    recentFiles.remove(recentFiles.last());
    recentFiles.prepend(file);
  }

  pRecentFileMenu->clear();

  for ( int i =0 ; i < (int)recentFiles.count(); i++){
    pRecentFileMenu->insertItem(recentFiles.at(i));
  }

}

void KScribbleApp::createClient(KScribbleDoc* doc)
{
  KScribbleView* w = new KScribbleView(doc, pWorkspace,0,WDestructiveClose);
  w->installEventFilter(this);
  doc->addView(w);
  w->setIcon(kapp->miniIcon());
  if ( pWorkspace->windowList().isEmpty() ) // show the very first window in maximized mode
    w->showMaximized();
  else
    w->show();
}

void KScribbleApp::openDocumentFile(const char* file)
{
  slotStatusMsg(i18n("Opening file..."));
  KScribbleDoc* doc;
  // check, if document already open. If yes, set the focus to the first view
  for(doc=pDocList->first(); doc > 0; doc=pDocList->next())
  {
    if(doc->pathName()==file)
    {
       KScribbleView* view=doc->firstView();  
       view->setFocus();
       return;
     }
  }
  doc = new KScribbleDoc();
  pDocList->append(doc);
  doc->newDocument();
  // Creates an untitled window if file is 0  
  if(!file)
  {
    untitledCount+=1;
    QString fileName=QString(i18n("Untitled%1")).arg(untitledCount);
    doc->setPathName(fileName);
    doc->setTitle(fileName);
  }
  // Open the file
  else
  {
    QString format=QImageIO::imageFormat(file);
    if(!doc->openDocument(file,format))
      KMessageBox::error (this,i18n("Could not open document !"), i18n("Error !"));
    addRecentFile(file);
  }
  // create the window
  createClient(doc);

  slotStatusMsg(i18n("Ready."));
}


void KScribbleApp::saveOptions()
{  
  config->setGroup("General Options");
  config->writeEntry("Geometry", size());
  config->writeEntry("Show Toolbar", toolBar()->isVisible());
  config->writeEntry("Show Statusbar",statusBar()->isVisible());
  config->writeEntry("ToolBarPos", (int) toolBar()->barPos());
  config->writeEntry("Recent Files", recentFiles);
}


void KScribbleApp::readOptions()
{
  
  config->setGroup("General Options");

  // bar status settings
  bool bViewToolbar = config->readBoolEntry("Show Toolbar", true);
  menuBar()->setItemChecked(ID_VIEW_TOOLBAR, bViewToolbar);
  if(!bViewToolbar)
  {
     enableToolBar(KToolBar::Hide);
  }
  
  bool bViewStatusbar = config->readBoolEntry("Show Statusbar", true);
  menuBar()->setItemChecked(ID_VIEW_STATUSBAR, bViewStatusbar);
  if(!bViewStatusbar)
  {
    enableStatusBar(KStatusBar::Hide);
  }

  // bar position settings
  KToolBar::BarPosition toolBarPos;
  toolBarPos=(KToolBar::BarPosition) config->readNumEntry("ToolBarPos", KToolBar::Top);
  toolBar()->setBarPos(toolBarPos);

  // initialize the recent file list
  config->readListEntry("Recent Files",recentFiles);

  for (int i=0; i < (int) recentFiles.count(); i++)
  {
    pRecentFileMenu->insertItem(recentFiles.at(i));
  }

  QSize size=config->readSizeEntry("Geometry");
  if(!size.isEmpty())
  {
    resize(size);
  }
  else
    resize(400,350);

}

void KScribbleApp::saveProperties(KConfig *_cfg)
{

}


void KScribbleApp::readProperties(KConfig* _cfg)
{
}    

bool KScribbleApp::queryClose()
{

  QStringList saveFiles;
  KScribbleDoc* doc;
  if(pDocList->isEmpty())
    return true;

  for(doc=pDocList->first(); doc!=0;doc=pDocList->next()){
    if(doc->isModified())
      saveFiles.append(doc->title());
  }
  if(saveFiles.isEmpty())
    return true;
        
  switch (KMessageBox::questionYesNoList(this,
      i18n("One or more documents have been modified.\nSave changes before exiting?"),saveFiles))     
  {
    case KMessageBox::Yes:
      for(doc=pDocList->first(); doc!=0;doc=pDocList->next()){
        if(doc->title().contains(i18n("Untitled")))
          slotFileSaveAs();
        else
        {
          if(!doc->saveDocument(doc->pathName())){
            KMessageBox::error (this,i18n("Could not save the current document !"), i18n("I/O Error !"));
            return false;
          }
        }
       }
      return true;
    case KMessageBox::No:
    default:
      return true;
  }
}

bool KScribbleApp::queryExit()
{
  saveOptions();
  return true;
}

bool KScribbleApp::eventFilter(QObject* object, QEvent* event){
  if(event->type() == QEvent::Close)
  {
    QCloseEvent* e=(QCloseEvent*)event;
    KScribbleView* pView=(KScribbleView*)object;
    KScribbleDoc* pDoc=pView->getDocument();
    if(pDoc->canCloseFrame(pView))
    {
       pDoc->removeView(pView);
       if(!pDoc->firstView())
         pDocList->remove(pDoc);
       
      e->accept();
      //////////////  
      if(pWorkspace->windowList().count()==1)
        setPlainCaption(kapp->caption());
      else
        setCaption(pWorkspace->activeWindow()->caption());      
      //////////////
    }
    else
      e->ignore();
  }
  return QWidget::eventFilter( object, event );    // standard event processing
}

/////////////////////////////////////////////////////////////////////
// SLOT IMPLEMENTATION
/////////////////////////////////////////////////////////////////////


void KScribbleApp::slotFileNew()
{
  slotStatusMsg(i18n("Creating new document..."));

  openDocumentFile();

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileOpen()
{
  slotStatusMsg(i18n("Opening file..."));
  
  QString fileToOpen=KFileDialog::getOpenFileName(QDir::currentDirPath(),
            KImageIO::pattern(KImageIO::Reading), this, i18n("Open File..."));
  if(!fileToOpen.isEmpty())
  {
    openDocumentFile(fileToOpen);    
  }

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileOpenRecent(int id_)
{
  slotStatusMsg(i18n("Opening file..."));
    
  openDocumentFile(pRecentFileMenu->text(id_));
  
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileSave()
{
  slotStatusMsg(i18n("Saving file..."));
  KScribbleView* m = (KScribbleView*)pWorkspace->activeWindow();
  if( m )
  {
    KScribbleDoc* doc =  m->getDocument();
    if(doc->title().contains(i18n("Untitled")))
     slotFileSaveAs();
    else
      if(!doc->saveDocument(doc->pathName()))
        KMessageBox::error (this,i18n("Could not save the current document !"), i18n("I/O Error !"));
  }
  

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileSaveAs()
{
  slotStatusMsg(i18n("Saving file with a new filename..."));

  QString newName=KFileDialog::getSaveFileName(QDir::currentDirPath(),
                               KImageIO::pattern(KImageIO::Writing), this, i18n("Save as..."));
  if(!newName.isEmpty())
  {
    KScribbleView* m = (KScribbleView*)pWorkspace->activeWindow();
    if( m )
    {
      KScribbleDoc* doc =  m->getDocument();
      QString format=QFileInfo(newName).extension();
      format=format.upper();
      if(!doc->saveDocument(newName,format))
      {
        KMessageBox::error (this,i18n("Could not save the current document !"), i18n("I/O Error !"));
        return;
      }
      doc->changedViewList();
      setWndTitle(m);
    }
    
  }

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileClose()
{
  slotStatusMsg(i18n("Closing file..."));
  
  KScribbleView* m = (KScribbleView*)pWorkspace->activeWindow();
  if( m )
  {
    KScribbleDoc* doc=m->getDocument();
    doc->closeDocument();
  }

  
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFilePrint()
{
  slotStatusMsg(i18n("Printing..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m )
    m->print( printer );

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotFileQuit()
{
  slotStatusMsg(i18n("Exiting..."));
  saveOptions();
  // close the first window, the list makes the next one the first again.
  // This ensures that queryClose() is called on each window to ask for closing
  KTMainWindow* w;
  if(memberList)
  {
    for(w=memberList->first(); w!=0; w=memberList->first())
    {
      // only close the window if the closeEvent is accepted. If the user
      // presses Cancel on the saveModified() dialog,
      // the window and the application stay open.
      if(!w->close())
      break;
    }
  }  
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotEditUndo()
{
  slotStatusMsg(i18n("Reverting last action..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m )
//    m->undo();

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotEditCut()
{
  slotStatusMsg(i18n("Cutting selection..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m )
    m->cutSelection();  

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotEditCopy()
{
  slotStatusMsg(i18n("Copying selection to clipboard..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m )
    m->copySelection();
    
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotEditPaste()
{
  slotStatusMsg(i18n("Inserting clipboard contents..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m )
    m->pasteSelection();
    
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotEditClearAll()
{
  slotStatusMsg(i18n("Clearing the document contents..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m ){
    KScribbleDoc* pDoc = m->getDocument();
    pDoc->editClearAll();
  }
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotPenBrush()
{
  slotStatusMsg(i18n("Setting brush width..."));

  // get one window with document for a current pen width
  QWidgetList windows = pWorkspace->windowList();
  KScribbleView* m = (KScribbleView*)windows.at(0);
  KScribbleDoc* pDoc = m->getDocument();
  int curr_width=pDoc->penWidth();

  // create the dialog, get the new width and set the pen width for all documents
  KPenBrushDlg* dlg= new KPenBrushDlg(curr_width,this);
  if(dlg->exec()){
    int width=dlg->width();
    for ( int i = 0; i < int(windows.count()); ++i )
    {
      m = (KScribbleView*)windows.at(i);
      if ( m )
      {
        pDoc = m->getDocument();
        pDoc->setPenWidth(width);
      }
    }
  }
  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotPenColor()
{
  slotStatusMsg(i18n("Selecting pen color..."));

  QColor myColor;
  int result = KColorDialog::getColor( myColor, this );
  if ( result == KColorDialog::Accepted )
  {
    QWidgetList windows = pWorkspace->windowList();
    KScribbleDoc* pDoc;
    KScribbleView* m;
    for ( int i = 0; i < int(windows.count()); ++i )
    {
      m = (KScribbleView*)windows.at(i);
      if ( m )
      {
        pDoc = m->getDocument();
        pDoc->setPenColor(myColor);
      }
    }
  }
  slotStatusMsg(i18n("Ready."));
}


void KScribbleApp::slotViewToolBar()
{
  slotStatusMsg(i18n("Toggle the toolbar..."));
  ///////////////////////////////////////////////////////////////////
  // turn Toolbar on or off
  if( menuBar()->isItemChecked(ID_VIEW_TOOLBAR))
  {
    menuBar()->setItemChecked(ID_VIEW_TOOLBAR, false);
    enableToolBar(KToolBar::Hide);
  }
  else
  {
    menuBar()->setItemChecked(ID_VIEW_TOOLBAR, true);
    enableToolBar(KToolBar::Show);
  }    

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotViewStatusBar()
{
  slotStatusMsg(i18n("Toggle the statusbar..."));
  ///////////////////////////////////////////////////////////////////
  //turn Statusbar on or off
  if( menuBar()->isItemChecked(ID_VIEW_STATUSBAR))
  {
    menuBar()->setItemChecked(ID_VIEW_STATUSBAR, false);
    enableStatusBar(KStatusBar::Hide);
  }
  else
  {
    menuBar()->setItemChecked(ID_VIEW_STATUSBAR, true);
    enableStatusBar(KStatusBar::Show);
  }

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotWindowNewWindow()
{
  slotStatusMsg(i18n("Opening a new application window..."));
  
  KScribbleView* m = (KScribbleView*) pWorkspace->activeWindow();
  if ( m ){
     KScribbleDoc* doc = m->getDocument();
    createClient(doc);
  }

  slotStatusMsg(i18n("Ready."));
}

void KScribbleApp::slotStatusMsg(const QString &amp;text)
{
  ///////////////////////////////////////////////////////////////////
  // change status message permanently
  statusBar()->clear();
  statusBar()->changeItem(text, ID_STATUS_MSG);
}


void KScribbleApp::slotStatusHelpMsg(const QString &amp;text)
{
  ///////////////////////////////////////////////////////////////////
  // change status message of whole statusbar temporary (text, msec)
  statusBar()->message(text, 2000);
}

void KScribbleApp::windowMenuAboutToShow()
{
  pWindowMenu->clear();
  
  pWindowMenu->insertItem(i18n("&amp;New Window"), ID_WINDOW_NEW_WINDOW);
  pWindowMenu->insertItem(i18n("&amp;Cascade"),
                          pWorkspace, SLOT(cascade() ),0 , ID_WINDOW_CASCADE );
  pWindowMenu->insertItem(i18n("&amp;Tile"),
                          pWorkspace, SLOT(tile() ),0 , ID_WINDOW_TILE );
  
  if ( pWorkspace->windowList().isEmpty() ) {
    disableCommand(ID_WINDOW_NEW_WINDOW);
    disableCommand(ID_WINDOW_CASCADE);
    disableCommand(ID_WINDOW_TILE);
  }
  
  pWindowMenu->insertSeparator();
  
  QWidgetList windows = pWorkspace->windowList();
  for ( int i = 0; i < int(windows.count()); ++i ) {
    int id = pWindowMenu->insertItem(QString("&amp;%1 ").arg(i+1)+windows.at(i)->caption(),
                                     this, SLOT( windowMenuActivated( int ) ) );
    pWindowMenu->setItemParameter( id, i );
    pWindowMenu->setItemChecked( id, pWorkspace->activeWindow() == windows.at(i) );
  }
}

void KScribbleApp::windowMenuActivated( int id )
{
  QWidget* w = pWorkspace->windowList().at( id );
  if ( w )
    w->setFocus();
}


void KScribbleApp::commandCallback(int id_)
{
  switch (id_)
  {
    case ID_FILE_NEW:
       slotFileNew();
         break;

    case ID_FILE_OPEN:
         slotFileOpen();
         break;

    case ID_FILE_SAVE:
         slotFileSave();
         break;

    case ID_FILE_SAVE_AS:
         slotFileSaveAs();
         break;

    case ID_FILE_CLOSE:
         slotFileClose();
         break;

    case ID_FILE_PRINT:
         slotFilePrint();
         break;

    case ID_FILE_QUIT:
         slotFileQuit();
         break;

    case ID_EDIT_CUT:
         slotEditCut();
         break;

    case ID_EDIT_COPY:
         slotEditCopy();
         break;

    case ID_EDIT_PASTE:
         slotEditPaste();
         break;

    case ID_EDIT_CLEAR_ALL:
         slotEditClearAll();
         break;

    case ID_PEN_BRUSH:
         slotPenBrush();
         break;

    case ID_PEN_COLOR:
         slotPenColor();
         break;

    case ID_VIEW_TOOLBAR:
         slotViewToolBar();
         break;

    case ID_VIEW_STATUSBAR:
         slotViewStatusBar();
         break;

    case ID_WINDOW_NEW_WINDOW:
         slotWindowNewWindow();
       break;

    default:
         break;
  }
}

void KScribbleApp::statusCallback(int id_)
{
  switch (id_)
  {
    case ID_FILE_NEW:
         slotStatusHelpMsg(i18n("Creates a new document"));
         break;

    case ID_FILE_OPEN:
         slotStatusHelpMsg(i18n("Opens an existing document"));
         break;

    case ID_FILE_OPEN_RECENT:
         slotStatusHelpMsg(i18n("Opens a recently used file"));
         break;

    case ID_FILE_SAVE:
         slotStatusHelpMsg(i18n("Saves the currently active document"));
         break;

    case ID_FILE_SAVE_AS:
         slotStatusHelpMsg(i18n("Saves the currently active document as under a new filename"));
         break;

    case ID_FILE_CLOSE:
         slotStatusHelpMsg(i18n("Closes the currently active document"));
         break;

    case ID_FILE_PRINT:
         slotStatusHelpMsg(i18n("Prints out the actual document"));
         break;

    case ID_FILE_QUIT:
         slotStatusHelpMsg(i18n("Quits the application"));
         break;

    case ID_EDIT_UNDO:
         slotStatusHelpMsg(i18n("Reverts the last editing action"));
         break;

    case ID_EDIT_CUT:
         slotStatusHelpMsg(i18n("Cuts the selected section and puts it to the clipboard"));
         break;

    case ID_EDIT_COPY:
         slotStatusHelpMsg(i18n("Copies the selected section to the clipboard"));
         break;

    case ID_EDIT_PASTE:
         slotStatusHelpMsg(i18n("Pastes the clipboard contents to actual position"));
         break;

    case ID_EDIT_CLEAR_ALL:
         slotStatusHelpMsg(i18n("Clears the document contents"));
         break;

    case ID_PEN_BRUSH:
         slotStatusHelpMsg(i18n("Sets the pen width"));
         break;

    case ID_PEN_COLOR:
         slotStatusHelpMsg(i18n("Sets the current pen color"));
         break;

    case ID_VIEW_TOOLBAR:
         slotStatusHelpMsg(i18n("Enables/disables the toolbar"));
         break;

    case ID_VIEW_STATUSBAR:
         slotStatusHelpMsg(i18n("Enables/disables the statusbar"));
         break;

    case ID_WINDOW_NEW_WINDOW:
         slotStatusHelpMsg(i18n("Opens a new view for the current document"));
         break;

    case ID_WINDOW_CASCADE:
         slotStatusHelpMsg(i18n("Cascades all windows"));
         break;

    case ID_WINDOW_TILE:
         slotStatusHelpMsg(i18n("Tiles all windows"));
         break;

    default:
         break;
  }
}
/** accepts drops and opens a new document
for each drop */
void KScribbleApp::dropEvent( QDropEvent* e){

  QImage img;
  if ( QImageDrag::decode(e, img) )
  {
    KScribbleDoc* doc = new KScribbleDoc();
    untitledCount+=1;
    QString fileName=QString(i18n("Untitled%1")).arg(untitledCount);
    doc->setPathName(fileName);
    doc->setTitle(fileName);
    doc->newDocument();
    pDocList->append(doc);
    KPixmap tmp;
    tmp.resize(img.size());
    tmp.convertFromImage(img);
    doc->setPixmap(tmp);
    doc->resizeDocument(tmp.size());
    doc->setModified();
    createClient(doc);
  }
}
/** accepts drag events for images */
void KScribbleApp::dragEnterEvent( QDragEnterEvent* e){
  e->accept(QImageDrag::canDecode(e));
}
</code>

<sect>kscribbledoc.h
<p>
<code>
/***************************************************************************
                          kscribbledoc.h  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef KSCRIBBLEDOC_H
#define KSCRIBBLEDOC_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

// include files for QT
#include <qobject.h>
#include <qstring.h>
#include <qlist.h>

#include <qsize.h>
#include <qpen.h>
#include <qpoint.h>
//#include <qpixmap.h>
#include <qpointarray.h>

#include <kpixmap.h>


// forward declaration of the KScribble classes
class KScribbleView;

/**  KScribbleDoc provides a document object for a document-view model.
  *
  * The KScribbleDoc class provides a document object that can be used in conjunction with the classes
  * KScribbleApp and KScribbleView to create a document-view model for MDI (Multiple Document Interface)
  * KDE 2 applications based on KApplication and KTMainWindow as main classes and QWorkspace as MDI manager widget.
  * Thereby, the document object is created by the KScribbleApp instance (and kept in a document list) and contains
  * the document structure with the according methods for manipulating the document
  * data by KScribbleView objects. Also, KScribbleDoc contains the methods for serialization of the document data
  * from and to files.
  * @author Source Framework Automatically Generated by KDevelop, (c) The KDevelop Team.   
  * @version KDevelop version 1.1 code generation
  */
class KScribbleDoc : public QObject
{
  Q_OBJECT

  friend KScribbleView;

  public:
    /** Constructor for the fileclass of the application */
    KScribbleDoc();
    /** Destructor for the fileclass of the application */
    ~KScribbleDoc();

    /** adds a view to the document which represents the document contents. Usually this is your main view. */
    void addView(KScribbleView *view);
    /** removes a view from the list of currently connected views */
    void removeView(KScribbleView *view);
    /** gets called if a view is removed or added */
    void changedViewList();
    /** returns the first view instance */
    KScribbleView* firstView(){ return pViewList->first(); };
    /** returns true, if the requested view is the last view of the document */
    bool isLastView();
    /** This method gets called when the user is about to close a frame window. It checks, if more than one view
     * is connected to the document (then the frame can be closed), if pFrame is the last view and the document is
     * modified, the user gets asked if he wants to save the document.
     */
    bool canCloseFrame(KScribbleView* pFrame);
    /** sets the modified flag for the document after a modifying action on the view connected to the document.*/
    void setModified(bool _m=true){ modified=_m; };
    /** returns if the document is modified or not. Use this to determine if your document needs
     * saving by the user on closing.
     */
    bool isModified(){ return modified; };
    /** deletes the document's contents */
    void deleteContents();
    /** initializes the document generally */
    bool newDocument();
    /** closes the acutal document */
    void closeDocument();
    /** loads the document by filename and format and emits the updateViews() signal */
    bool openDocument(const QString &amp;filename, const char *format=0);
    /** saves the document under filename and format.*/  
    bool saveDocument(const QString &amp;filename, const char *format=0);
    /** sets the path to the file connected with the document */
    void setPathName(const QString &amp;name);
    /** returns the pathname of the current document file*/
    const QString&amp; pathName() const;

    /** sets the filename of the document */
    void setTitle(const QString &amp;title);
    /** returns the title of the document */
    const QString&amp; title() const;
    /** get the current Pen */
    const QPen currentPen(){ return pen;};  
    /** returns the pen width */
    const int penWidth() { return pen.width(); }
    /** returns the pen color */
    const QColor penColor(){ return pen.color(); }
    /** sets the pen width */
    void setPenWidth( int w ){ pen.setWidth( w ); }
    /** sets the pen color */
    void setPenColor( const QColor &amp;c ){ pen.setColor( c ); }
    /** sets the pen style by a second toolbar */
    void setPenStyle( PenStyle s){ pen.setStyle(s);}
    /** clears the document contents */
    void editClearAll();

    /** get the document size */
    const QSize docSize(){ return size;};
    /** sets the pixmap contents. Used by KScribbleApp
    to create a new document by drop events */
    void setPixmap(KPixmap pix) { buffer=pix;};
    void resizeDocument(QSize m_size) { size=m_size; };
  public slots:
    /** calls repaint() on all views connected to the document object and is called by the view by
     * which the document has been changed.
     * As this view normally repaints itself, it is excluded from the paintEvent.
     */
    void updateAllViews(KScribbleView *sender);
  
  protected:
  
    QPen pen;
    QPointArray polyline;
    KPixmap buffer;
   
  private:
    /** the modified flag of the current document */
    bool modified;
    QString m_title;
    QString m_filename;
    /** the list of the views currently connected to the document */
    QList<KScribbleView> *pViewList;  
    QSize size;
};

#endif // KSCRIBBLEDOC_H

</code>

<sect>kscribbledoc.cpp
<p>
<code>
/***************************************************************************
                          kscribbledoc.cpp  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// include files for Qt
#include <qdir.h>
#include <qfileinfo.h>
#include <qwidget.h>

// include files for KDE
#include <klocale.h>
#include <kmessagebox.h>
#include <kfiledialog.h>

// application specific includes
#include "kscribbledoc.h"
#include "kscribble.h"
#include "kscribbleview.h"


KScribbleDoc::KScribbleDoc()
{
  pViewList = new QList<KScribbleView>;
  pViewList->setAutoDelete(false);
}

KScribbleDoc::~KScribbleDoc()
{
  delete pViewList;
}

void KScribbleDoc::addView(KScribbleView *view)
{
  pViewList->append(view);
  changedViewList();
}

void KScribbleDoc::removeView(KScribbleView *view)
{
    pViewList->remove(view);
    if(!pViewList->isEmpty())
      changedViewList();
    else
      deleteContents();
}

void KScribbleDoc::changedViewList(){  
  
  KScribbleView *w;
  if((int)pViewList->count() == 1){
    w=pViewList->first();
    w->setCaption(m_title);
  }
  else{  
    int i;
    for( i=1,w=pViewList->first(); w!=0; i++, w=pViewList->next())
      w->setCaption(QString(m_title+":%1").arg(i));  
  }
}

bool KScribbleDoc::isLastView() {
  return ((int) pViewList->count() == 1);
}


void KScribbleDoc::updateAllViews(KScribbleView *sender)
{
  KScribbleView *w;
  for(w=pViewList->first(); w!=0; w=pViewList->next())
  {
      w->update(sender);
  }

}

void KScribbleDoc::setPathName(const QString &amp;name)
{
  m_filename=name;
  m_title=QFileInfo(name).fileName();
}

const QString&amp; KScribbleDoc::pathName() const
{
  return m_filename;
}

void KScribbleDoc::setTitle(const QString &amp;title)
{
  m_title=title;
}

const QString &amp;KScribbleDoc::title() const
{
  return m_title;
}


void KScribbleDoc::closeDocument()
{
  KScribbleView *w;
  if(!isLastView())
  {
    for(w=pViewList->first(); w!=0; w=pViewList->next())
    {
        if(!w->close())
         break;
    }
  }
  if(isLastView())
  {
    w=pViewList->first();
    w->close();
  }
}

bool KScribbleDoc::newDocument()
{
  /////////////////////////////////////////////////
  // TODO: Add your document initialization code here
  size=QSize(300,200 );
  pen=QPen( Qt::black, 3 );
  polyline=QPointArray(3);
  buffer.resize(size);
  buffer.fill( Qt::white );
  /////////////////////////////////////////////////
  modified=false;
  return true;
}

bool KScribbleDoc::openDocument(const QString &amp;filename, const char *format /*=0*/)
{

  QFile f( filename );
//  if ( !f.open( IO_ReadOnly ) )
//    return false;
  /////////////////////////////////////////////////
  // TODO: Add your document opening code here
  if(!buffer.load( filename, format ))
    return false;
  size=buffer.size();
  /////////////////////////////////////////////////
//  f.close();
  
  modified=false;
  m_filename=filename;
  m_title=QFileInfo(f).fileName();
  return true;
}

bool KScribbleDoc::saveDocument(const QString &amp;filename, const char *format /*=0*/)
{
  QFile f( filename );
//  if ( !f.open( IO_WriteOnly ) )
//    return false;

  /////////////////////////////////////////////////
  // TODO: Add your document saving code here
  if(!buffer.save( filename, format ))
    return false;
  /////////////////////////////////////////////////

//  f.close();

  modified=false;
  m_filename=filename;
  m_title=QFileInfo(f).fileName();
  return true;
}

void KScribbleDoc::deleteContents()
{
  /////////////////////////////////////////////////
  // TODO: Add implementation to delete the document contents
  buffer.fill( Qt::white );
  /////////////////////////////////////////////////

}

bool KScribbleDoc::canCloseFrame(KScribbleView* pFrame)
{
  if(!isLastView())
    return true;
      
  bool ret=false;
  if(isModified())
  {
    QString saveName;
    switch(KMessageBox::warningYesNoCancel(pFrame, i18n("The current file has been modified.\n"
    "Do you want to save it?"),title()))
    {
    case KMessageBox::Yes:
      if(title().contains(i18n("Untitled")))
      {
        saveName=KFileDialog::getSaveFileName(QDir::currentDirPath(),
                             i18n("*|All files"), pFrame, i18n("Save as..."));
        if(saveName.isEmpty())
        return false;
      }
      else
       saveName=pathName();
          
      if(!saveDocument(saveName))
      {
        switch(KMessageBox::warningYesNo(pFrame,i18n("Could not save the current document !\n"
                          "Close anyway ?"), i18n("I/O Error !")))
        {
          case KMessageBox::Yes:
            ret=true;
          case KMessageBox::No:
            ret=false;
        }                
      }
      else
        ret=true;
        break;
    case KMessageBox::No:
      ret=true;
      break;
    case KMessageBox::Cancel:
    default:
      ret=false;         
      break;
    }
  }
  else
    ret=true;
    
  return ret;
}

void KScribbleDoc::editClearAll()
{
  deleteContents();
  setModified();
  updateAllViews(0);
}

</code>

<sect>kscribbleview.h
<p>
<code>
/***************************************************************************
                          kscribbleview.h  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef KSCRIBBLEVIEW_H
#define KSCRIBBLEVIEW_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

// include files for Qt
#include <qscrollview.h>
#include <kpixmap.h>

class KScribbleDoc;

/** The KScribbleView class provides the view widget for the document instance connected to it and is displayed
 * as a MDI child window in the main view area of the KScribbleApp class instance. The KScribbleApp
 * class also has an eventFilter()  method that gets installed on every KScribbleView instance to
 * control events of the type QEvent::Close.The document connected to the view instance keeps a list
 * of all view that represent the document contents as there can be more than one view. Views get created in
 * KScribbleApp::createClient() and automatically added to the list of views.
 * The KScribbleView class inherits QWidget as a base. Another possible inheritance besides specialized
 + widgets could be QMainWindow so that you can easily set up the main area of your view by setting another view
 * as main widget (QMainWindow::setMainWidget() ).
 * NOTE: The close event always has to be empty (DON`T CALL QWidget::closeEvent(e) in closeEvent())
 * because the installed event filter can only manage a forward implementation. If the QCloseEvent
 * is received by the KScribbleView, the overwritten event handler has to do nothing as the eventFilter
 * has set accept() or ignore() already. If QWidget::closeEvent() is called again, the default event
 * handler will accept the close event and the window gets destroyed even if the installed eventFilter
 * has set the event to be ignored.  
 * @author Source Framework Automatically Generated by KDevelop, (c) The KDevelop Team.
 * @version KDevelop version 1.1 code generation
 */
class KScribbleView : public QScrollView
{
  Q_OBJECT

  friend KScribbleDoc;

  public:
    /** Constructor for the view
      * @param pDoc  your document instance that the view represents. Create a document
      * before calling the constructor or connect an already existing document to a new MDI child widget.*/
    KScribbleView(KScribbleDoc* pDoc, QWidget* parent, const char *name, int wflags);
    /** Destructor for the main view */
    ~KScribbleView();
    /** returns a pointer to the document connected to the view*/
    KScribbleDoc *getDocument() const;
    /** gets called to redraw the document contents if it has been modified */
    void update(KScribbleView* pSender);
    /** contains the implementation for printing functionality and gets called by KScribbleApp::slotFilePrint() */
    void print(QPrinter *pPrinter);
    /** cuts out a selection */
    void cutSelection();
    /** copies a selection to the clipboard */
    void copySelection();
    /** pastes the clipboard contents to a selection that can be inserted into the picture */
    void pasteSelection();
        
  protected:
  
    /** overwritten QWidget::closeEvent() to catch closing views. Does nothing, as the closeEvents for
    * KScribbleView's are processed by KScribbleApp::eventFilter(), so this overwitten closeEvent is necessary
    * and has to be empty. Don't overwrite this method !
    */
    virtual void closeEvent(QCloseEvent* );
    /** overwritten to interpret key events for scrollbars */
    virtual void keyPressEvent( QKeyEvent* );
    /** changed from mousePressEvent() overwriting QScrollView method */
    virtual void viewportMousePressEvent( QMouseEvent* );
    /** changed from mouseReleaseEvent() overwriting QScrollView method */
    virtual void viewportMouseReleaseEvent( QMouseEvent* );
    /** On paste actions inserts the pasted clipboard contents */
    virtual void viewportMouseDoubleClickEvent(QMouseEvent* e);
    /** changed from mouseMoveEvent() overwriting QScrollView method */
    virtual void viewportMouseMoveEvent( QMouseEvent* );
    /** changed from resizeEvent() overwriting QScrollView method */
//    virtual void viewportResizeEvent( QResizeEvent* );
    /** changed from paintEvent() overwriting QScrollView method */
    virtual void viewportPaintEvent( QPaintEvent* );
      
    virtual void viewportDragEnterEvent ( QDragEnterEvent * );

    virtual void viewportDragMoveEvent ( QDragMoveEvent * );

    virtual void viewportDragLeaveEvent ( QDragLeaveEvent * );

    virtual void viewportDropEvent ( QDropEvent * );
  
    /** the document instance */
    KScribbleDoc *doc;
      
  private:
    KPixmap tmp;
    QRect select;
    QClipboard *cb;
    enum Action{IDLE=0, DRAW, SELECT, PASTE, DRAG} action;
};

#endif // KSCRIBBLEVIEW_H

</code>

<sect>kscribbleview.cpp
<p>
<code>
/***************************************************************************
                          kscribbleview.cpp  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
#include <iostream.h>

// include files for Qt
#include <qprinter.h>
#include <qpainter.h>
#include <qdir.h>
#include <qsize.h>
#include <qclipboard.h>
#include <qimage.h>
#include <qdragobject.h>

// include files for KDE
#include <kiconloader.h>

// application specific includes
#include "kscribbleview.h"
#include "kscribbledoc.h"
#include "kscribble.h"


KScribbleView::KScribbleView(KScribbleDoc* pDoc, QWidget *parent, const char* name, int wflags)
 : QScrollView(parent, name, wflags | WPaintClever | WNorthWestGravity | WRepaintNoErase)
{
  cb = QApplication::clipboard();
  viewport()->setAcceptDrops(true);
  setDragAutoScroll(true);
  doc=pDoc;
  action=IDLE;
  viewport()->setCursor( Qt::crossCursor );
  QSize size=doc->docSize();
  resizeContents(size.width(), size.height());
  resize(size);
}

KScribbleView::~KScribbleView()
{
}

KScribbleDoc *KScribbleView::getDocument() const
{
  return doc;
}

void KScribbleView::update(KScribbleView* pSender){
  if(pSender != this)
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}

void KScribbleView::print(QPrinter *pPrinter)
{
  if (pPrinter->setup(this))
  {
    QPainter p;
    p.begin(pPrinter);
          
    ///////////////////////////////
    // TODO: add your printing code here
    p.drawPixmap(0,0,doc->buffer);
    ///////////////////////////////
    p.end();
  }
}

/** cuts out a selection */
void KScribbleView::cutSelection(){
  select=select.normalize();
  QPixmap cb_pix;
  cb_pix.resize(select.size());
  // copy selection to cb_pix and copy to clipboard
  bitBlt(&amp;cb_pix, 0, 0,
         &amp;doc->buffer, select.x()+contentsX(),  select.y()+contentsY(), cb_pix.width(), cb_pix.height());
  cb->setPixmap(cb_pix);
  // fill cb_pix with white and copy to selection area
  cb_pix.fill(Qt::white);
  bitBlt(&amp;doc->buffer, select.x()+contentsX(), select.y()+contentsY(),
         &amp;cb_pix, 0, 0, cb_pix.width(), cb_pix.height());
  action = IDLE;
  doc->setModified();
  doc->updateAllViews(this);
  viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}
/** copies a selection to the clipboard */
void KScribbleView::copySelection(){
  select=select.normalize();
  QPixmap cb_pix;
  cb_pix.resize(select.size());
  // copy selection to cb_pix and copy to clipboard
  bitBlt(&amp;cb_pix, 0, 0,
         &amp;doc->buffer, select.x()+contentsX(),  select.y()+contentsY(),cb_pix.width(), cb_pix.height());
  cb->setPixmap(cb_pix);
  action = IDLE;
  viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}
/** pastes the clipboard contents to a selection that can be inserted into the picture */
void KScribbleView::pasteSelection(){
  select=cb->pixmap().rect();
  action = PASTE;
  viewport()->setCursor( Qt::sizeAllCursor );
}

void KScribbleView::closeEvent(QCloseEvent* e){

// DO NOT CALL QWidget::closeEvent(e) here !!
// This will accept the closing by QCloseEvent::accept() by default.
// The installed eventFilter() in KScribbleApp takes care for closing the widget
// or ignoring the close event
    
}

void KScribbleView::keyPressEvent( QKeyEvent *e )
{
  switch (e->key())
  {
    case Key_Right:
      scrollBy( 10, 0 );
      break;
    case Key_Left:
      scrollBy( -10,0);
      break;
    case Key_Up:
      scrollBy( 0, -10 );
      break;
    case Key_Down:
      scrollBy( 0, 10 );
      break;
    case Key_Home:
      setContentsPos(0,0);
      break;
    case Key_End:
      setContentsPos(0,viewport()->height()-viewport()->height());
      break;
    case Key_PageUp:
      scrollBy( 0, -viewport()->height() );
      break;
    case Key_PageDown:
      scrollBy( 0, viewport()->height() );
      break;
  }

}

void KScribbleView::viewportMousePressEvent( QMouseEvent *e )
{
  if ( e->button() == LeftButton &amp;&amp; action == IDLE)
  {
    action=DRAW;
    doc->polyline[2] = doc->polyline[1] = doc->polyline[0] = viewportToContents(e->pos());
    doc->updateAllViews(this);
  }
  else if ( e->button() == RightButton &amp;&amp; action == IDLE)
  {
    action = SELECT;
    QPoint pt=e->pos();
    int x = pt.x() > contentsWidth() ? contentsWidth() : pt.x();
    int y = pt.y() > contentsHeight() ? contentsHeight() : pt.y();
    select.setLeft(x-1);
    select.setTop(y-1);
    select.setRight(x-1);
    select.setBottom(y-1);
  }
  else if( action == SELECT )
  {
    action = IDLE;
    select=select.normalize();
    // drag
    if(select.contains(e->pos(), true)) // point inside the selection
    {
      tmp.resize(select.size());
      bitBlt(&amp;tmp, 0, 0,
             &amp;doc->buffer, select.x()+contentsX(),  select.y()+contentsY(), tmp.width(), tmp.height());
      QImage img =tmp.convertToImage();
      QDragObject *d = new QImageDrag( img, viewport() );
      d->setPixmap(BarIcon("filenew"));
      d->drag();
    }
    // remove selection
    else
      viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
  }
  else if( action == PASTE )
  {
    if ( e->button() == RightButton )
    {
      action = IDLE;
      viewport()->setCursor( Qt::crossCursor );
    }
    QPoint mv_pt (viewport()->height(), viewport()->width());
    if(QRect(0,0,mv_pt.x(),mv_pt.y()).contains(e->pos()))
      select.moveCenter(e->pos());
    else
    {
      select.moveBottomRight(mv_pt);
    }
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
  }
}

void KScribbleView::viewportMouseReleaseEvent( QMouseEvent *e )
{
  if ( action == DRAW )
  {
    action = IDLE;
    doc->updateAllViews(this);
  }
  if ( action == SELECT)
  {
    QPoint pt=e->pos();
    int x = pt.x() > 0 ? pt.x() : 0;
    int y = pt.y() > 0 ? pt.y() : 0;
    select.setRight(x);
    select.setBottom(y);
    QSize size=doc->docSize();
    select = select.intersect(QRect(0,0,size.width(), size.height()));  
  }
}

/** On paste actions inserts the pasted clipboard contents
 */
void KScribbleView::viewportMouseDoubleClickEvent(QMouseEvent* e)
{
  if( action == PASTE )
  {
    action = IDLE;
    select.moveCenter(e->pos());
    viewport()->setCursor( Qt::crossCursor );
    QPixmap cb_pix;
    cb_pix.resize(cb->pixmap().size());
    cb_pix=cb->pixmap();
    bitBlt( &amp;doc->buffer, contentsX()+select.x(), contentsY()+select.y(),
            &amp;cb_pix, 0,0 , select.width(),select.height() );
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
    doc->setModified();
    doc->updateAllViews(this);
  }

}

void KScribbleView::viewportMouseMoveEvent( QMouseEvent *e )
{
  if ( action == DRAW )
  {    
    QPainter painter;
    painter.begin( &amp;doc->buffer );
    painter.setPen( doc->currentPen() );
    doc->polyline[2] = doc->polyline[1];
    doc->polyline[1] = doc->polyline[0];
    doc->polyline[0] = viewportToContents(e->pos());
    painter.drawPolyline( doc->polyline );
    painter.end();

    QRect r = doc->polyline.boundingRect();
    r = r.normalize();
    r.setLeft( r.left() - doc->penWidth() );
    r.setTop( r.top() - doc->penWidth() );
    r.setRight( r.right() + doc->penWidth() );
    r.setBottom( r.bottom() + doc->penWidth() );

    bitBlt(viewport(), r.x()-contentsX(), r.y()-contentsY() ,
           &amp;doc->buffer, r.x(), r.y(), r.width(), r.height() );
    doc->setModified();
    doc->updateAllViews(this);
  }
  if ( action == SELECT )
  {
    QPoint pt=e->pos();
    select.setWidth(select.x()+pt.x());
    select.setHeight(select.y()+pt.y());
    select.setRight(pt.x());
    select.setBottom(pt.y());
    QSize size=doc->docSize();
    select = select.intersect(QRect(0,0,size.width(), size.height()));  
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
  }
  if( action == PASTE )
  {
    QPoint mv_pt (viewport()->height(), viewport()->width());
    if(QRect(0,0,mv_pt.x(),mv_pt.y()).contains(e->pos()))
      select.moveCenter(e->pos());
    else
    {
      select.moveBottomRight(mv_pt);
    }
    QRect pm_rect=cb->pixmap().rect();
    select.setWidth(pm_rect.width());
    select.setHeight(pm_rect.height());
    QSize size=doc->docSize();
    select = select.intersect(QRect(0,0,size.width(), size.height()));  
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
    doc->setModified();
    doc->updateAllViews(this);
  }
}

//void KScribbleView::viewportResizeEvent( QResizeEvent *e )
//{
//}

void KScribbleView::viewportPaintEvent( QPaintEvent *e )
{
  bitBlt( viewport(),0,0, &amp;doc->buffer,contentsX() ,contentsY() );

  if( action == PASTE )
  {
    tmp.resize(cb->pixmap().size());
    tmp=cb->pixmap();
  }
  if( action == PASTE || action == DRAG )
  {
    QSize size=doc->docSize();
    select = select.intersect(QRect(0,0,size.width(), size.height()));  
    if(select.intersects(e->rect()))
      bitBlt(viewport(), select.x(), select.y(), &amp;tmp, 0, 0, select.width(), select.height());
  }
  if( action == PASTE || action == DRAG || action == SELECT )
  {
//    if(select.intersects(e->rect()))
//    {
      QPainter paint_area;
      paint_area.begin(viewport());
      paint_area.setPen(QPen(Qt::black, 0, DashLine));
      paint_area.drawRect( select );
      paint_area.end();
//    }
  }
  QScrollView::viewportPaintEvent(e);
}

void  KScribbleView::viewportDragEnterEvent ( QDragEnterEvent * e)
{
  e->accept(QImageDrag::canDecode(e));
  action = DRAG;
}

void  KScribbleView::viewportDragMoveEvent ( QDragMoveEvent * e)
{
  QImage img;
  if ( QImageDrag::decode(e, img) ){
    tmp.resize(img.size());
    tmp.convertFromImage(img);
    select.setWidth(tmp.width());
    select.setHeight(tmp.height());
    select.moveCenter(e->pos());
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
  }
}

void  KScribbleView::viewportDragLeaveEvent ( QDragLeaveEvent * )
{
  action = IDLE;
  viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}

void  KScribbleView::viewportDropEvent ( QDropEvent * e)
{
  QImage img;
  if ( QImageDrag::decode(e, img) )
  {
    tmp.resize(img.size());
    tmp.convertFromImage(img);
    select.setWidth(tmp.width());
    select.setHeight(tmp.height());
    select.moveCenter(e->pos());
    bitBlt(&amp;doc->buffer, select.x()+contentsX(), select.y()+contentsY(),
           &amp;tmp, 0, 0, tmp.width(), tmp.height());
    doc->setModified();
    doc->updateAllViews(this);
  }
  action = IDLE;
    viewport()->repaint(0,0,visibleWidth(), visibleHeight(), false);
}

</code>

<sect>kpenbrushdlg.h
<p>
<code>
/***************************************************************************
                          kpenbrushdlg.h  -  description
                             -------------------
    begin                : Fri Jul 23 1999
    copyright            : (C) 1999 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#ifndef KPENBRUSHDLG_H
#define KPENBRUSHDLG_H

//Generated area. DO NOT EDIT!!!(begin)
#include <qwidget.h>
#include <qspinbox.h>
#include <qlabel.h>
#include <qpushbutton.h>
//Generated area. DO NOT EDIT!!!(end)

#include <qdialog.h>
#include <klocale.h>

/**
  *@author Ralf Nolden
  */

class KPenBrushDlg : public QDialog  {
   Q_OBJECT
public:
  KPenBrushDlg(int curr, QWidget *parent=0, const char *name=0);
  ~KPenBrushDlg();

  int width() { return width_spbox->value(); };
  
protected slots:
  void slotDefault();

protected:
  void initDialog();
  //Generated area. DO NOT EDIT!!!(begin)
  QSpinBox *width_spbox;
  QLabel *width_label;
  QPushButton *default_btn;
  QPushButton *ok_btn;
  QPushButton *cancel_btn;
  //Generated area. DO NOT EDIT!!!(end)

private:
};

#endif


</code>

<sect>kpenbrushdlg.cpp
<p>
<code>
/***************************************************************************
                          kpenbrushdlg.cpp  -  description
                             -------------------
    begin                : Fri Jul 23 1999
    copyright            : (C) 1999 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "kpenbrushdlg.h"
#include <qwhatsthis.h>
#include <kapp.h>

KPenBrushDlg::KPenBrushDlg(int curr, QWidget *parent, const char *name)
  : QDialog(parent,name,true,WStyle_ContextHelp)
{
  initDialog();
  QWhatsThis::add(width_spbox,i18n("Select brush width"));

  width_spbox->setValue(curr);
  connect(default_btn, SIGNAL(clicked()), this, SLOT(slotDefault()));
  connect(ok_btn, SIGNAL(clicked()), this, SLOT(accept()));
  connect(cancel_btn, SIGNAL(clicked()), this, SLOT(reject()));
}

KPenBrushDlg::~KPenBrushDlg(){
}

void KPenBrushDlg::slotDefault(){
  width_spbox->setValue(3);
}

</code>

<sect>kpenbrushdlgdata.cpp
<p>
<code>
/**********************************************************************
            --- KDevelop (KDlgEdit)  generated file ---

            Last generated: Fri Jul 23 10:43:10 1999

            DO NOT EDIT!!!  This file will be automatically
            regenerated by KDevelop.  All changes will be lost.

**********************************************************************/
#include <kapp.h>
#include "kpenbrushdlg.h"

void  KPenBrushDlg::initDialog(){
  this->resize(370,210);
  this->setMinimumSize(0,0);
  width_spbox= new QSpinBox(this,"width_spbox");
  width_spbox->setGeometry(150,50,100,25);
  width_spbox->setMinimumSize(0,0);
  width_spbox->setValue(1);
  width_spbox->setRange(1,99);

  width_label= new QLabel(this,"width_label");
  width_label->setGeometry(20,50,120,25);
  width_label->setMinimumSize(0,0);
  width_label->setText(i18n("Pen Width:"));

  default_btn= new QPushButton(this,"default");
  default_btn->setGeometry(30,160,100,30);
  default_btn->setMinimumSize(0,0);
  default_btn->setText(i18n("Default"));
  default_btn->setAutoDefault(true);

  ok_btn= new QPushButton(this,"ok");
  ok_btn->setGeometry(140,160,100,30);
  ok_btn->setMinimumSize(0,0);
  ok_btn->setText(i18n("OK"));
  ok_btn->setAutoDefault(true);

  cancel_btn= new QPushButton(this,"cancel");
  cancel_btn->setGeometry(250,160,100,30);
  cancel_btn->setMinimumSize(0,0);
  cancel_btn->setText(i18n("Cancel"));
  cancel_btn->setAutoDefault(true);

}
</code>

<sect>resource.h
<p>
<code>
/***************************************************************************
                          resource.h  -  description
                             -------------------
    begin                : Mon Jan 31 11:05:05 CET 2000
    copyright            : (C) 2000 by Ralf Nolden
    email                : Ralf.Nolden@post.rwth-aachen.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef RESOURCE_H
#define RESOURCE_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

///////////////////////////////////////////////////////////////////
// resource.h  -- contains macros used for commands


///////////////////////////////////////////////////////////////////
// COMMAND VALUES FOR MENUBAR AND TOOLBAR ENTRIES


///////////////////////////////////////////////////////////////////
// File-menu entries
#define ID_FILE_NEW                 10010
#define ID_FILE_OPEN                10020
#define ID_FILE_OPEN_RECENT         10030
#define ID_FILE_CLOSE               10040

#define ID_FILE_SAVE                10050
#define ID_FILE_SAVE_AS             10060

#define ID_FILE_PRINT               10070

#define ID_FILE_QUIT                10080

///////////////////////////////////////////////////////////////////
// Edit-menu entries
#define ID_EDIT_UNDO                11010
#define ID_EDIT_COPY                11020
#define ID_EDIT_CUT                 11030
#define ID_EDIT_PASTE               11040
#define ID_EDIT_CLEAR_ALL           11050

///////////////////////////////////////////////////////////////////
// Pen-menu entries
#define ID_PEN_COLOR                14010
#define ID_PEN_BRUSH                14020

///////////////////////////////////////////////////////////////////
// Draw-menu entries
#define ID_DRAW_FIND                15010
#define ID_DRAW_FREEHAND            15020
#define ID_DRAW_LINE                15030
#define ID_DRAW_RECT                15040
#define ID_DRAW_RECT_FILL           15050
#define ID_DRAW_CIRCLE              15060
#define ID_DRAW_CIRCLE_FILL         15070
#define ID_DRAW_ELLIPSE             15080
#define ID_DRAW_ELLIPSE_FILL        15090
#define ID_DRAW_SPRAY               15100
#define ID_DRAW_FILL                15110
#define ID_DRAW_ERASE               15120

///////////////////////////////////////////////////////////////////
// View-menu entries
#define ID_VIEW_TOOLBAR             12010
#define ID_VIEW_STATUSBAR           12020

///////////////////////////////////////////////////////////////////
// Window-menu entries
#define ID_WINDOW_NEW_WINDOW        13010
#define ID_WINDOW_CASCADE           13020
#define ID_WINDOW_TILE              13030

///////////////////////////////////////////////////////////////////
// Help-menu entries
#define ID_HELP_CONTENTS            1002
#define ID_HELP_WHATS_THIS          1003
///////////////////////////////////////////////////////////////////
// General application values
#define ID_STATUS_MSG               1001
#define TOOLS_TOOLBAR               1
#endif // RESOURCE_H

</code>

</book>
